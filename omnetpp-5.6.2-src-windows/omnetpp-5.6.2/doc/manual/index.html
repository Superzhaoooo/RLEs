<!doctype html public "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title>OMNeT++ - Simulation Manual</title>
  <meta name="copyright" content="OpenSim Ltd.">
  <meta name="author" content="Andras Varga">
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<style type="text/css">
  body { background-color: rgb(240, 240, 240); margin: 0 auto; }
  body,th,td,p,ul,ol,li,h1,h2,h3,h4 { font-family: arial,sans-serif; color: #000000}
  body,td,p,ul,ol,li { font-size: 12pt; }
  th,td { font-size: 11pt; }
  tt,code,pre { font-size: 11pt; }

  div.top {
    background-color: white; max-width: 750px; margin: 0 auto; padding-left: 100px; padding-right: 100px;
    box-shadow: 0 0 2px 2px #dddddd;
  }

  h1 { color: #196F93; margin-top: 50px; margin-bottom: 20px; }
  h2 { color: #196F93; margin-top: 40px; margin-bottom: 20px; }
  h3 { color: #196F93; margin-top: 30px; margin-bottom: 20px; }
  h4 { color: #196F93; margin-top: 30px; font-weight: bold; }

  hr.pgbr { color: #f5f5f5; margin-top: 40px; margin-bottom: 10px; }
  ul.dl { padding-left: 30px; text-indent: -30px; list-style: none; }
  pre { margin: 4px 8px 4px 2px; padding: 8px 10px; background:#fffff4; border: 1px solid #dddddd; }
  pre.ned { background:#f5fff5; border-left: 4px solid #ccffcc; }
  pre.msg { background:#f5fff5; border-left: 4px solid #ccffcc; }
  pre.cpp { background:#f5f5f5; border-left: 4px solid #ccccff; }
  pre.inifile { background:#fffff0; border-left: 4px solid #e5e533; }
  pre.filelisting { background:#f0f0f0; border-left: 4px solid #d9d9d9; }
  pre.commandline { background:#fffff0; border-left: 4px solid #606060; }
  table { background:#fffff4; margin: 0 auto; border-collapse:collapse; border: 2px solid; }
  td,th { text-align:left; vertical-align:top; border:1px solid; padding:3pt; border-color:#000000; }
  div.caption { margin-top: 10px; }
  a { color: #196F93; text-decoration: none; }
  a:visited { text-decoration: none; }
  # a:hover { text-decoration: underline; }

  table.matrix { display:inline-block; vertical-align: middle; position: relative; border: 0px; background:#ffffff; margin-left:8pt; margin-right:8pt; }
  table.matrix:before, table.matrix:after { content: ""; position: absolute; top: 0; border: 1px solid #000; width: 6px; height: 100%; }
  table.matrix:before { left: -6px; border-right: 0px; }
  table.matrix:after { right: -6px; border-left: 0px; }
  table.matrix td { padding: 5px; text-align: center; border: 0px; }

  a.headerlink { visibility: hidden; font-size: 0.8em; padding: 0 4px 0 4px; text-decoration: none; color: #82A3AF; }
  h1:hover > a.headerlink, h2:hover > a.headerlink, h3:hover > a.headerlink, h4:hover > a.headerlink { visibility: visible; }
</style>

<script type="text/javascript">
// ensure that URLs posted into various online forums remain usable after the 4.x -> 5.0 transition
function redirectOldLinks() {
    var anchorMap = {
        "sec100" : "cha:introduction",  // Introduction
        "sec101" : "sec:introduction:what-is-omnetpp",  // What Is OMNeT++?
        "sec102" : "sec:introduction:organization-of-this-manual",  // Organization of This Manual
        "sec103" : "cha:overview",  // Overview
        "sec104" : "sec:overview:modeling-concepts",  // Modeling Concepts
        "sec105" : "sec:overview:hierarchical-modules",  // Hierarchical Modules
        "sec106" : "sec:overview:module-types",  // Module Types
        "sec107" : "sec:overview:messages-gates-links",  // Messages, Gates, Links
        "sec108" : "sec:overview:modeling-of-packet-transmissions",  // Modeling of Packet Transmissions
        "sec109" : "sec:overview:parameters",  // Parameters
        "sec110" : "sec:overview:topology-description-method",  // Topology Description Method
        "sec111" : "sec:overview:programmable-using-cplusplus",  // Programming the Algorithms
        "sec112" : "sec:overview:using-omnetpp",  // Using OMNeT++
        "sec113" : "sec:overview:building-and-running-simulations",  // Building and Running Simulations
        "sec114" : "sec:overview:what-is-in-distribution",  // What Is in the Distribution
        "sec115" : "cha:ned-lang",  // The NED Language
        "sec116" : "sec:ned-lang:ned-overview",  // NED Overview
        "sec117" : "sec:ned-lang:warmup",  // NED Quickstart
        "sec118" : "sec:ned-lang:warmup:network",  // The Network
        "sec119" : "sec:ned-lang:warmup:introducing-a-channel",  // Introducing a Channel
        "sec120" : "sec:ned-lang:warmup:the-simple-modules",  // The App, Routing, and Queue Simple Modules
        "sec121" : "sec:warmup:ned-lang:node-compound-module",  // The Node Compound Module
        "sec122" : "sec:ned-lang:warmup:putting-it-together",  // Putting It Together
        "sec123" : "sec:ned-lang:simple-modules",  // Simple Modules
        "sec124" : "sec:ned-lang:compound-modules",  // Compound Modules
        "sec125" : "sec:ned-lang:channels",  // Channels
        "sec126" : "sec:ned-lang:parameters",  // Parameters
        "sec127" : "sec:ned-lang:gates",  // Gates
        "sec128" : "sec:ned-lang:submodules",  // Submodules
        "sec129" : "sec:ned-lang:connections",  // Connections
        "sec130" : "sec:ned-lang:multiple-connections",  // Multiple Connections
        "sec131" : "sec:ned-lang:connection-design-patterns",  // Connection Patterns
        "sec132" : "sec:ned-lang:parametric-submodule-and-connection-types",  // Parametric Submodule and Connection Types
        "sec133" : "sec:ned-lang:submodule-like",  // Parametric Submodule Types
        "sec134" : "sec:ned-lang:connection-like",  // Parametric Connection Types
        "sec135" : "sec:ned-lang:properties",  // Metadata Annotations (Properties)
        "sec136" : "sec:ned-lang:inheritance",  // Inheritance
        "sec137" : "sec:ned-lang:packages",  // Packages
        "sec138" : "cha:simple-modules",  // Simple Modules
        "sec139" : "sec:simple-modules:simulation-concepts",  // Simulation Concepts
        "sec140" : "sec:simple-modules:discrete-event-simulation",  // Discrete Event Simulation
        "sec141" : "sec:simple-modules:event-loop",  // The Event Loop
        "sec142" : "sec:simple-modules:events-in-opp",  // Events and Event Execution Order in OMNeT++
        "sec143" : "sec:simple-modules:simulation-time",  // Simulation Time
        "sec144" : "sec:simple-modules:fes-implementation",  // FES Implementation
        "sec145" : "sec:simple-modules:simple-modules-in-opp",  // Components, Simple Modules, Channels
        "sec146" : "sec:simple-modules:defining-simple-modules",  // Defining Simple Module Types
        "sec147" : "sec:simple-modules:defining:overview",  // Overview
        "sec148" : "sec:simple-modules:module-ctor",  // Constructor
        "sec149" : "sec:simple-modules:initialize-and-finish",  // Initialization and Finalization
        "sec150" : "sec:simple-modules:handlemessage-and-activity",  // Adding Functionality to cSimpleModule
        "sec151" : "sec:simple-modules:handlemessage",  // handleMessage()
        "sec152" : "sec:simple-modules:activity",  // activity()
        "sec153" : "sec:simple-modules:global-vars",  // How to Avoid Global Variables
        "sec154" : "sec:simple-modules:module-subclassing",  // Reusing Module Code via Subclassing
        "sec155" : "sec:simple-modules:parameters",  // Accessing Module Parameters
        "sec156" : "sec:simple-modules:volatile-parameters",  // Volatile and Non-Volatile Parameters
        "sec157" : "sec:simple-modules:setting-parameters",  // Changing a Parameters Value
        "sec158" : "sec:simple-modules:further-cpar-methods",  // Further cPar Methods
        "sec159" : "sec:simple-modules:emulating-parameter-arrays",  // Emulating Parameter Arrays
        "sec160" : "sec:simple-modules:handleparameterchange",  // handleParameterChange()
        "sec161" : "sec:simple-modules:gates",  // Accessing Gates and Connections
        "sec162" : "sec:simple-modules:gate-objects",  // Gate Objects
        "sec163" : "sec:simple-modules:connections",  // Connections
        "sec164" : "sec:simple-modules:connections-channel",  // The Connections Channel
        "sec165" : "sec:simple-modules:sending-and-receiving",  // Sending and Receiving Messages
        "sec166" : "sec:simple-modules:self-messages",  // Self-Messages
        "sec167" : "sec:simple-modules:sending-messages",  // Sending Messages
        "sec168" : "sec:simple-modules:broadcasts-and-retransmissions",  // Broadcasts and Retransmissions
        "sec169" : "sec:simple-modules:delayed-sending",  // Delayed Sending
        "sec170" : "sec:simple-modules:direct-sending",  // Direct Message Sending
        "sec171" : "sec:simple-modules:packet-transmission",  // Packet Transmissions
        "sec172" : "sec:simple-modules:receiving-with-activity",  // Receiving Messages with activity()
        "sec173" : "sec:simple-modules:channels",  // Channels
        "sec174" : "sec:simple-modules:channels-overview",  // Overview
        "sec175" : "sec:simple-modules:channel-api",  // The Channel API
        "sec176" : "sec:simple-modules:channel-examples",  // Channel Examples
        "sec177" : "sec:simple-modules:stopping",  // Stopping the Simulation
        "sec178" : "sec:simple-modules:endsimulation",  // Normal Termination
        "sec179" : "sec:simple-modules:raising-errors",  // Raising Errors
        "sec180" : "sec:simple-modules:fsm",  // Finite State Machines
        "sec181" : "sec:simple-modules:walking-module-hierarchy",  // Navigating the Module Hierarchy
        "sec182" : "sec:simple-modules:direct-method-calls",  // Direct Method Calls Between Modules
        "sec183" : "sec:simple-modules:creating-modules",  // Dynamic Module Creation
        "sec184" : "sec:simple-modules:dynamic-creation:when-to-use",  // When Do You Need Dynamic Module Creation
        "sec185" : "sec:simple-modules:dynamic-creation:overview",  // Overview
        "sec186" : "sec:simple-modules:dynamic-creation:api",  // Creating Modules
        "sec187" : "sec:simple-modules:deleting-modules",  // Deleting Modules
        "sec188" : "sec:simple-modules:module-deletion-and-finish",  // Module Deletion and finish()
        "sec189" : "sec:simple-modules:creating-connections",  // Creating Connections
        "sec190" : "sec:simple-modules:removing-connections",  // Removing Connections
        "sec191" : "sec:simple-modules:signals",  // Signals
        "sec192" : "sec:simple-modules:signals-design",  // Design Considerations and Rationale
        "sec193" : "sec:simple-modules:signals-api",  // The Signals Mechanism
        "sec194" : "sec:simple-modules:model-change",  // Listening to Model Changes
        "sec195" : "sec:simple-modules:signal-based-statistics",  // Signal-Based Statistics Recording
        "sec196" : "sec:simple-modules:signal-based-statistics-motivation",  // Motivation
        "sec197" : "sec:simple-modules:declaring-statistics",  // Declaring Statistics
        "sec198" : "sec:simple-modules:statistic-recording-dynamic-signals",  // Statistics Recording for Dynamically Registered Signals
        "sec199" : "sec:simple-modules:statistic-recording-programmatically",  // Adding Result Filters and Recorders Programmatically
        "sec200" : "sec:simple-modules:emitting-statistic-signals",  // Emitting Signals
        "sec201" : "sec:simple-modules:writing-result-filters",  // Writing Result Filters and Recorders
        "sec202" : "cha:messages",  // Messages and Packets
        "sec203" : "sec:msgs:overview",  // Overview
        "sec204" : "sec:msgs:cmessage",  // The cMessage Class
        "sec205" : "sec:messages:cmessage-basic-usage",  // Basic Usage
        "sec206" : "sec:messages:duplicating-messages",  // Duplicating Messages
        "sec207" : "sec:messages:message-ids",  // Message IDs
        "sec208" : "sec:messages:control-info",  // Control Info
        "sec209" : "sec:messages:information-about-last-arrival",  // Information About the Last Arrival
        "sec210" : "sec:messages:displaystring",  // Display String
        "sec211" : "sec:msgs:self-messages",  // Self-Messages
        "sec212" : "sec:messages:using-message-as-self-message",  // Using a Message as Self-Message
        "sec213" : "sec:messages:context-pointer",  // Context Pointer
        "sec214" : "sec:msgs:cpacket",  // The cPacket Class
        "sec215" : "sec:messages:cpacket-basic-usage",  // Basic Usage
        "sec216" : "sec:messages:identifying-protocol-of-packet",  // Identifying the Protocol
        "sec217" : "sec:messages:information-about-last-transmission",  // Information About the Last Transmission
        "sec218" : "sec:messages:encapsulating-packets",  // Encapsulating Packets
        "sec219" : "sec:messages:reference-counting",  // Reference Counting
        "sec220" : "sec:messages:encapsulating-several-packets",  // Encapsulating Several Packets
        "sec221" : "sec:msgs:attaching-objects",  // Attaching Parameters and Objects
        "sec222" : "sec:messages:attaching-objects",  // Attaching Objects
        "sec223" : "sec:messages:attaching-parameters",  // Attaching Parameters
        "sec224" : "cha:msg-def",  // Message Definitions
        "sec225" : "sec:msg-defs:intro",  // Introduction
        "sec226" : "sec:msg-defs:first-msg-class",  // The First Message Class
        "sec227" : "sec:msg-defs:messages-and-packets",  // Messages and Packets
        "sec228" : "sec:msg-defs:defining-messages-and-packets",  // Defining Messages and Packets
        "sec229" : "sec:msg-defs:field-data-types",  // Field Data Types
        "sec230" : "sec:msg-defs:initial-values",  // Initial Values
        "sec231" : "sec:msg-defs:enums",  // Enums
        "sec232" : "sec:msg-defs:fixed-size-arrays",  // Fixed-Size Arrays
        "sec233" : "sec:msg-defs:variable-size-arrays",  // Variable-Size Arrays
        "sec234" : "sec:msg-defs:other-types-as-fields",  // Classes and Structs as Fields
        "sec235" : "sec:msg-defs:pointers-fields",  // Pointer Fields
        "sec236" : "sec:msg-defs:inheritance",  // Inheritance
        "sec237" : "sec:msg-defs:assignment-of-inherited-fields",  // Assignment of Inherited Fields
        "sec238" : "sec:msg-defs:defining-classes",  // Classes
        "sec239" : "sec:msg-defs:defining-structs",  // Structs
        "sec240" : "sec:msg-defs:cplusplus-blocks",  // Literal C++ Blocks
        "sec241" : "sec:msg-defs:using-cpp-types",  // Using C++ Types
        "sec242" : "sec:msg-defs:announcing-types",  // Announcing Types to the Message Compiler
        "sec243" : "sec:msg-def:making-cpp-declarations-available",  // Making the C++ Declarations Available
        "sec244" : "sec:msg-def:putting-it-together",  // Putting it Together
        "sec245" : "sec:msg-defs:customizing-generated-class",  // Customizing the Generated Class
        "sec246" : "sec:msg-defs:customizing-method-names",  // Customizing Method Names
        "sec247" : "sec:msg-defs:customizing-via-inheritance",  // Customizing the Class via Inheritance
        "sec248" : "sec:msg-defs:abstract-fields",  // Abstract Fields
        "sec249" : "sec:msg-defs:using-stl",  // Using Standard Container Classes for Fields
        "sec250" : "sec:msg-def:typedefs",  // Typedefs
        "sec251" : "sec:msg-def:abstract-fields",  // Abstract Fields
        "sec252" : "sec:msg-defs:namespaces",  // Namespaces
        "sec253" : "sec:msg-defs:declaring-a-namespace",  // Declaring a Namespace
        "sec254" : "sec:msg-def:cpp-blocks-and-namespace",  // C++ Blocks and Namespace
        "sec255" : "sec:msg-def:type-announcements-and-namespace",  // Type Announcements and Namespace
        "sec256" : "sec:msg-defs:descriptor-classes",  // Descriptor Classes
        "sec257" : "sec:msg-defs:summary",  // Summary
        "sec258" : "cha:sim-lib",  // The Simulation Library
        "sec259" : "sec:sim-lib:using-omnetpp-library",  // Class Library Conventions
        "sec260" : "sec:sim-lib:cobject",  // Base Class
        "sec261" : "sec:sim-lib:cobject",  // Setting and Getting Attributes
        "sec262" : "sec:sim-lib:cobject",  // getClassName()
        "sec263" : "sec:sim-lib:cobject",  // Object Names
        "sec264" : "sec:sim-lib:cobject",  // Object Full Name and Full Path
        "sec265" : "sec:sim-lib:cobject",  // Copying and Duplicating Objects
        "sec266" : "sec:sim-lib:iterators",  // Iterators
        "sec267" : "sec:sim-lib:runtime-errors",  // Error Handling
        "sec268" : "sec:sim-lib:logging-from-modules",  // Logging from Modules
        "sec269" : "sec:simple-modules:simulation-time",  // Simulation Time Conversion
        "sec270" : "sec:sim-lib:random-variate-generation",  // Generating Random Numbers
        "sec271" : "sec:sim-lib:random-number-generators",  // Random Number Generators
        "sec272" : "sec:sim-lib:accessing-rngs",  // Random Number Streams, RNG Mapping
        "sec273" : "sec:sim-lib:accessing-rngs",  // Accessing The RNGs
        "sec274" : "sec:sim-lib:random-variate-generation",  // Random Variates
        "sec275" : "sec:sim-lib:random-numbers-from-histograms",  // Random Numbers from Histograms
        "sec276" : "sec:sim-lib:container-classes",  // Container Classes
        "sec277" : "sec:sim-lib:cqueue",  // Queue class: cQueue
        "sec278" : "sec:sim-lib:carray",  // Expandable Array: cArray
        "sec279" : "sec:sim-lib:ctopology",  // Routing Support: cTopology
        "sec280" : "sec:sim-lib:ctopology-overview",  // Overview
        "sec281" : "sec:sim-lib:ctopology-basic-usage",  // Basic Usage
        "sec282" : "sec:sim-lib:ctopology-shortest-paths",  // Shortest Paths
        "sec283" : "sec:sim-lib:pattern-matching",  // Pattern Matching
        "sec284" : "sec:sim-lib:cpatternmatcher",  // cPatternMatcher
        "sec285" : "sec:sim-lib:cmatchexpression",  // cMatchExpression
        "sec286" : "sec:sim-lib:statistics",  // Statistics and Distribution Estimation
        "sec287" : "sec:sim-lib:cstatistic-and-descendants",  // cStatistic and Descendants
        "sec288" : "sec:sim-lib:distribution-estimation-classes",  // Distribution Estimation
        "sec289" : "sec:sim-lib:ksplit-algorithm",  // The k-split Algorithm
        "sec290" : "sec:sim-lib:transient-detection-and-result-accuracy",  // Transient Detection and Result Accuracy
        "sec291" : "sec:sim-lib:result-recording",  // Recording Simulation Results
        "sec292" : "sec:sim-lib:coutvector",  // Output Vectors: cOutVector
        "sec293" : "sec:sim-lib:output-scalars",  // Output Scalars
        "sec294" : "sec:sim-lib:watches-and-snapshots",  // Watches and Snapshots
        "sec295" : "sec:sim-lib:basic-watches",  // Basic Watches
        "sec296" : "sec:sim-lib:read-write-watches",  // Read-write Watches
        "sec297" : "sec:sim-lib:structured-watches",  // Structured Watches
        "sec298" : "sec:sim-lib:stl-watches",  // STL Watches
        "sec299" : "sec:sim-lib:snapshots",  // Snapshots
        "sec300" : "sec:sim-lib:getting-coroutine-stack-usage",  // Getting Coroutine Stack Usage
        "sec301" : "sec:sim-lib:defining-ned-functions",  // Defining New NED Functions
        "sec302" : "sec:sim-lib:define-ned-function-macro",  // Define_NED_Function()
        "sec303" : "sec:sim-lib:define-ned-math-function",  // Define_NED_Math_Function()
        "sec304" : "sec:sim-lib:deriving-new-classes",  // Deriving New Classes
        "sec305" : "sec:sim-lib:cobject-or-not",  // cOwnedObject or Not?
        "sec306" : "sec:sim-lib:cobject-virtual-methods",  // cOwnedObject Virtual Methods
        "sec307" : "sec:sim-lib:class-registration",  // Class Registration
        "sec308" : "sec:sim-lib:subclassing-cobject-details",  // Details
        "sec309" : "sec:sim-lib:ownership-management",  // Object Ownership Management
        "sec310" : "sec:sim-lib:ownership-tree",  // The Ownership Tree
        "sec311" : "sec:sim-lib:managing-ownership",  // Managing Ownership
        "sec312" : "cha:build-sim-progs",  // Building Simulation Programs
        "sec313" : "sec:build-sim-progs:overview",  // Overview
        "sec314" : "sec:build-sim-progs:overview", // Using gcc
        "sec315" : "sec:build-sim-progs:opp-makemake",  // The opp_makemake Tool
        "sec316" : "sec:build-sim-progs:makemake-basic-use",  // Basic Use
        "sec317" : "sec:build-sim-progs:debug-and-release-builds",  // Debug and Release Builds
        "sec318" : "sec:build-sim-progs:debugging-makefile",  // Debugging the Makefile
        "sec319" : "sec:build-sim-progs:using-external-libraries",  // Using External C/C++ Libraries
        "sec320" : "sec:build-sim-progs:building-directory-trees",  // Building Directory Trees
        "sec321" : "sec:build-sim-progs:automatic-include-dirs",  // Automatic Include Dirs
        "sec322" : "sec:build-sim-progs:dependency-handling",  // Dependency Handling
        "sec323" : "sec:build-sim-progs:out-of-directory-build",  // Out-of-Directory Build
        "sec324" : "sec:build-sim-progs:building-shared-and-static-libraries",  // Building Shared and Static Libraries
        "sec325" : "sec:build-sim-progs:recursive-builds",  // Recursive Builds
        "sec326" : "sec:makefrag",  // Customizing the Makefile
        "sec327" : "sec:build-sim-progs:projects-with-multiple-source-trees",  // Projects with Multiple Source Trees
        "sec328" : "sec:build-sim-progs:multi-directory-example",  // A Multi-Directory Example
        "sec329" : "cha:config-sim",  // Configuring Simulations
        "sec330" : "sec:config-sim:config-file",  // The Configuration File
        "sec331" : "sec:config-sim:example-inifile",  // An Example
        "sec332" : "sec:config-sim:inifile-syntax",  // File Syntax
        "sec333" : "sec:config-sim:inifile-inclusion",  // File Inclusion
        "sec334" : "sec:config-sim:inifile-sections",  // Sections
        "sec335" : "sec:config-sim:general-section",  // The [General] Section
        "sec336" : "sec:config-sim:named-configurations",  // Named Configurations
        "sec337" : "sec:config-sim:section-inheritance",  // Section Inheritance
        "sec338" : "sec:config-sim:parameter-settings",  // Assigning Module Parameters
        "sec339" : "sec:config-sim:wildcards",  // Using Wildcard Patterns
        "sec340" : "sec:config-sim:using-default-values",  // Using the Default Values
        "sec341" : "sec:config-sim:parameter-studies",  // Parameter Studies
        "sec342" : "sec:config-sim:iterations",  // Iterations
        "sec343" : "sec:config-sim:named-iteration-variables",  // Named Iteration Variables
        "sec344" : "sec:config-sim:parallel-iteration",  // Parallel Iteration
        "sec345" : "sec:config-sim:predefined-variables",  // Predefined Variables, Run ID
        "sec346" : "sec:config-sim:constraint-expression",  // Constraint Expression
        "sec347" : "sec:config-sim:repeating-runs-with-different-seeds",  // Repeating Runs with Different Seeds
        "sec348" : "sec:config-sim:experiment-measurement-replication",  // Experiment-Measurement-Replication
        "sec349" : "sec:config-sim:rng-config",  // Configuring the Random Number Generators
        "sec350" : "sec:config-sim:number-of-rngs",  // Number of RNGs
        "sec351" : "sec:config-sim:rng-choice",  // RNG Choice
        "sec352" : "sec:config-sim:rng-mapping",  // RNG Mapping
        "sec353" : "sec:config-sim:automatic-seed-selection",  // Automatic Seed Selection
        "sec354" : "sec:config-sim:manual-seed-configuration",  // Manual Seed Configuration
        "sec355" : "cha:run-sim",  // Running Simulations
        "sec356" : "sec:run-sim:introduction",  // Introduction
        "sec357" : "sec:run-sim:running",  // Running a Simulation Executable
        "sec358" : "sec:run-sim:running-shared-lib",  // Running a Shared Library
        "sec359" : "sec:run-sim:controlling-the-run",  // Controlling the Run
        "sec360" : "sec:run-sim:cmdenv",  // Cmdenv: the Command-Line Interface
        "sec361" : "sec:run-sim:cmdenv-example-run",  // Example Run
        "sec362" : "sec:run-sim:cmdenv-command-line-options",  // Command-Line Options
        "sec363" : "sec:run-sim:cmdenv-section",  // Cmdenv Ini File Options
        "sec364" : "sec:run-sim:interpreting-cmdenv-output",  // Interpreting Cmdenv Output
        "sec365" : "sec:run-sim:tkenv",  // The Tkenv Graphical User Interface
        "sec366" : "sec:run-sim:tkenv-options",  // Command-Line and Configuration Options
        "sec367" : "sec:run-sim:batch-execution",  // Batch Execution
        "sec368" : "sec:run-sim:batches-using-cmdenv",  // Using Cmdenv
        "sec369" : "sec:run-sim:batches-using-shell-scripts",  // Using Shell Scripts
        "sec370" : "sec:run-sim:batches-using-opp-runall",  // Using opp_runall
        "sec371" : "sec:run-sim:akaroa",  // Akaroa Support: Multiple Replications in Parallel
        "sec372" : "sec:run-sim:akaroa-introduction",  // Introduction
        "sec373" : "sec:run-sim:what-is-akaroa",  // What Is Akaroa
        "sec374" : "sec:run-sim:using-akaroa",  // Using Akaroa with OMNeT++
        "sec375" : "sec:run-sim:troubleshooting",  // Troubleshooting
        "sec376" : "sec:run-sim:unrecognized-configuration-option",  // Unrecognized Configuration Option
        "sec377" : "sec:run-sim:stack-problems",  // Stack Problems
        "sec378" : "sec:run-sim:memory-leaks-and-crashes",  // Memory Leaks and Crashes
        "sec379" : "sec:run-sim:simulation-executes-slowly",  // Simulation Executes Slowly
        "sec380" : "cha:graphics",  // Network Graphics And Animation
        "sec381" : "sec:graphics:display-strings",  // Display Strings
        "sec382" : "sec:graphics:displaystring-syntax-and-placement",  // Display String Syntax
        "sec383" : "sec:graphics:displaystring-syntax-and-placement",  // Display String Placement
        "sec384" : "sec:graphics:displaystring-inheritance",  // Display String Inheritance
        "sec385" : "sec:graphics:submodule-displaystring-tags",  // Display String Tags Used in Submodule Context
        "sec386" : "sec:graphics:background-displaystring-tags",  // Display String Tags Used in Module Background Context
        "sec387" : "sec:graphics:connection-displaystrings",  // Connection Display Strings
        "sec388" : "sec:graphics:message-displaystrings",  // Message Display Strings
        "sec389" : "sec:graphics:displaystring-parameter-substitution",  // Parameter Substitution
        "sec390" : "sec:graphics:displaystring-colors",  // Colors
        "sec391" : "sec:graphics:displaystring-colors",  // Color Names
        "sec392" : "sec:graphics:displaystring-colors",  // Icon Colorization
        "sec393" : "sec:graphics:icon-library",  // Icons
        "sec394" : "sec:graphics:icon-library",  // The Image Path
        "sec395" : "sec:graphics:icon-library",  // Categorized Icons
        "sec396" : "sec:graphics:icon-library",  // Icon Size
        "sec397" : "sec:graphics:compound-module-layouting",  // Layouting
        "sec398" : "sec:graphics:changing-displaystrings-at-runtime", // Enhancing Animation
        "sec399" : "sec:graphics:changing-displaystrings-at-runtime",  // Changing Display Strings at Runtime
        "sec400" : "sec:graphics:bubbles",  // Bubbles
        "sec401" : "cha:ana-sim",  // Result Recording and Analysis
        "sec402" : "sec:ana-sim:result-recording",  // Result Recording
        "sec403" : "sec:ana-sim:signals-and-statistics",  // Using Signals and Declared Statistics
        "sec404" : "sec:ana-sim:direct-result-recording",  // Direct Result Recording
        "sec405" : "sec:ana-sim:config-results",  // Configuring Result Collection
        "sec406" : "sec:ana-sim:config-results", // Configuring Signal-Based Statistics Recording
        "sec407" : "sec:ana-sim:warmup-period",  // Warm-up Period
        "sec408" : "sec:ana-sim:result-file-names",  // Result File Names
        "sec409" : "sec:ana-sim:config-results",  // Configuring Scalar Results
        "sec410" : "sec:ana-sim:config-results",  // Configuring Output Vectors
        "sec411" : "sec:ana-sim:saving-parameters-as-scalars",  // Saving Parameters as Scalars
        "sec412" : "sec:ana-sim:outputfile-precision",  // Recording Precision
        "sec413" : "sec:ana-sim:result-file-formats",  // Overview of the Result File Formats
        "sec414" : "sec:ana-sim:output-vector-files",  // Output Vector Files
        "sec415" : "sec:ana-sim:scalar-result-files",  // Scalar Result Files
        "sec416" : "sec:ana-sim:analysis-tool",  // The Analysis Tool in the Simulation IDE
        "sec417" : "sec:ana-sim:scavetool",  // Scave Tool
        "sec418" : "sec:ana-sim:scavetool-filter-command",  // The filter Command
        "sec419" : "sec:ana-sim:scavetool-index-command",  // The index Command
        "sec420" : "sec:ana-sim:scavetool-summary-command",  // The summary Command
        "sec421" : "sec:ana-sim:alternative-tools",  // Alternative Statistical Analysis and Plotting Tools
        "sec422" : "sec:ana-sim:gnu-r",  // GNU R
        "sec423" : "sec:ana-sim:numpy-scipy-and-matplotlib",  // NumPy, SciPy and MatPlotLib
        "sec424" : "sec:ana-sim:matlab-or-octave",  // MATLAB or Octave
        "sec425" : "sec:ana-sim:gnuplot",  // Gnuplot
        "sec426" : "sec:ana-sim:root",  // ROOT
        "sec427" : "sec:ana-sim:grace",  // Grace
        "sec428" : "sec:ana-sim:spreadsheet-programs",  // Spreadsheet Programs
        "sec429" : "cha:eventlog",  // Eventlog
        "sec430" : "sec:eventlog:introduction",  // Introduction
        "sec431" : "sec:eventlog:configuration",  // Configuration
        "sec432" : "sec:eventlog:file-name",  // File Name
        "sec433" : "sec:eventlog:recording-intervals",  // Recording Intervals
        "sec434" : "sec:eventlog:recording-modules",  // Recording Modules
        "sec435" : "sec:eventlog:recording-messages",  // Recording Message Data
        "sec436" : "sec:eventlog:eventlog-tool",  // Eventlog Tool
        "sec437" : "sec:eventlog:filter",  // Filter
        "sec438" : "sec:eventlog:echo",  // Echo
        "sec439" : "cha:neddoc",  // Documenting NED and Messages
        "sec440" : "sec:neddoc:overview",  // Overview
        "sec441" : "sec:neddoc:documentation-comments",  // Documentation Comments
        "sec442" : "sec:neddoc:private-comments",  // Private Comments
        "sec443" : "sec:neddoc:comment-placement",  // More on Comment Placement
        "sec444" : "sec:neddoc:referring-to-other-ned-and-message-types",  // Referring to Other NED and Message Types
        "sec445" : "sec:neddoc:automatic-linking",  // Automatic Linking
        "sec446" : "sec:neddoc:tilde-linking",  // Tilde Linking
        "sec447" : "sec:neddoc:text-layout-and-formatting",  // Text Layout and Formatting
        "sec448" : "sec:neddoc:paragraphs-and-lists",  // Paragraphs and Lists
        "sec449" : "sec:neddoc:special-tags",  // Special Tags
        "sec450" : "sec:neddoc:text-formatting-using-html",  // Text Formatting Using HTML
        "sec451" : "sec:neddoc:escaping-html-tags",  // Escaping HTML Tags
        "sec452" : "sec:neddoc:customizing-and-adding-pages",  // Customizing and Adding Pages
        "sec453" : "sec:neddoc:adding-custom-title-page",  // Adding a Custom Title Page
        "sec454" : "sec:neddoc:adding-extra-pages",  // Adding Extra Pages
        "sec455" : "sec:neddoc:externally-created-pages",  // Incorporating Externally Created Pages
        "sec456" : "sec:neddoc:file-inclusion",  // File Inclusion
        "sec457" : "cha:testing",  // Testing
        "sec458" : "sec:testing:overview",  // Overview
        "sec459" : "sec:testing:verification-validation",  // Verification, validation
        "sec460" : "sec:testing:unit-testing-regression-testing",  // Unit testing, regression testing
        "sec461" : "sec:testing:opptest",  // The opp_test Tool
        "sec462" : "sec:testing:opptest:introduction",  // Introduction
        "sec463" : "sec:testing:opptest:terminology",  // Terminology
        "sec464" : "sec:testing:opptest:test-file-syntax",  // Test file syntax
        "sec465" : "sec:testing:opptest:test-description",  // Test description
        "sec466" : "sec:testing:opptest:test-code-generation",  // Test code generation
        "sec467" : "sec:testing:opptest:pass-criteria",  // PASS criteria
        "sec468" : "sec:testing:opptest:extra-processing-steps",  // Extra processing steps
        "sec469" : "sec:testing:opptest:unresolved",  // Unresolved
        "sec470" : "sec:testing:opptest:synopsys",  // opp_test synopsys
        "sec471" : "sec:testing:opptest:writing-control-script",  // Writing the control script
        "sec472" : "sec:testing:smoke-tests", // Implementing various types of tests
        "sec473" : "sec:testing:smoke-tests",  // Smoke tests
        "sec474" : "sec:testing:fingerprint-tests",  // Fingerprint tests
        "sec475" : "sec:testing:unit-tests",  // Unit tests
        "sec476" : "sec:testing:module-tests",  // Module tests
        "sec477" : "sec:testing:statistical-tests",  // Statistical tests
        "sec478" : "cha:parallel-exec",  // Parallel Distributed Simulation
        "sec479" : "sec:parallel-exec:introduction-to-pdes",  // Introduction to Parallel Discrete Event Simulation
        "sec480" : "sec:parallel-exec:assessing-available-parallelism",  // Assessing Available Parallelism in a Simulation Model
        "sec481" : "sec:parallel-exec:pdes-support-in-omnetpp",  // Parallel Distributed Simulation Support in OMNeT++
        "sec482" : "sec:parallel-exec:overview",  // Overview
        "sec483" : "sec:parallel-exec:parallel-simulation-example",  // Parallel Simulation Example
        "sec484" : "sec:parallel-exec:placeholder-modules-proxy-gates",  // Placeholder Modules, Proxy Gates
        "sec485" : "sec:parallel-exec:configuration",  // Configuration
        "sec486" : "sec:parallel-exec:design-of-pdes-support",  // Design of PDES Support in OMNeT++
        "sec487" : "cha:plugin-exts",  // Plug-in Extensions
        "sec488" : "sec:plugin-exts:overview",  // Overview
        "sec489" : "sec:plugin-exts:overview",  // Plug-in Descriptions
        "sec490" : "sec:plugin-exts:rng",  // Defining a New Random Number Generator
        "sec491" : "sec:plugin-exts:scheduler",  // Defining a New Scheduler
        "sec492" : "sec:plugin-exts:configuration-providers",  // Defining a New Configuration Provider
        "sec493" : "sec:plugin-exts:outputscalarmanager",  // Defining a New Output Scalar Manager
        "sec494" : "sec:plugin-exts:outputvectormanager",  // Defining a New Output Vector Manager
        "sec495" : "sec:plugin-exts:snapshotmanager",  // Defining a New Snapshot Manager
        "sec496" : "sec:plugin-exts:configoption:reading-values",  // Accessing the Configuration
        "sec497" : "sec:plugin-exts:configoption:registration",  // Defining New Configuration Options
        "sec498" : "sec:plugin-exts:configoption:reading-values",  // Reading Values from the Configuration
        "sec499" : "sec:plugin-exts:user-interface",  // Implementing a New User Interface
        "sec500" : "cha:embedding",  // Embedding the Simulation Kernel
        "sec501" : "sec:embedding:architecture",  // Architecture
        "sec502" : "sec:embedding:embedding",  // Embedding the OMNeT++ Simulation Kernel
        "sec503" : "sec:embedding:main-function",  // The main() Function
        "sec504" : "sec:embedding:simulate-function",  // The simulate() Function
        "sec505" : "sec:embedding:providing-an-environment-object",  // Providing an Environment Object
        "sec506" : "sec:embedding:providing-a-configuration-object",  // Providing a Configuration Object
        "sec507" : "sec:embedding:loading-ned-files",  // Loading NED Files
        "sec508" : "sec:embedding:eliminating-ned-files",  // How to Eliminate NED Files
        "sec509" : "sec:embedding:assigning-module-parameters",  // Assigning Module Parameters
        "sec510" : "sec:embedding:extracting-statistics",  // Extracting Statistics from the Model
        "sec511" : "sec:embedding:simulation-loop",  // The Simulation Loop
        "sec512" : "sec:embedding:multiple-coexisting-simulations",  // Multiple, Coexisting Simulations
        "sec513" : "sec:embedding:installing-a-custom-scheduler",  // Installing a Custom Scheduler
        "sec514" : "sec:embedding:multi-threaded-programs",  // Multi-Threaded Programs
        "sec515" : "cha:ned-ref",  // Appendix&#58; NED Reference
        "sec516" : "sec:ned-ref:syntax",  // Syntax
        "sec517" : "sec:ned-ref:ned-file-name-extension",  // NED File Name Extension
        "sec518" : "sec:ned-ref:ned-file-encoding",  // NED File Encoding
        "sec519" : "sec:ned-ref:reserved-words",  // Reserved Words
        "sec520" : "sec:ned-ref:identifiers",  // Identifiers
        "sec521" : "sec:ned-ref:case-sensitivity",  // Case Sensitivity
        "sec522" : "sec:ned-ref:literals",  // Literals
        "sec523" : "sec:ned-ref:comments",  // Comments
        "sec524" : "sec:ned-ref:grammar",  // Grammar
        "sec525" : "sec:ned-ref:built-in-defs",  // Built-in Definitions
        "sec526" : "sec:ned-ref:packages",  // Packages
        "sec527" : "sec:ned-ref:package-declaration",  // Package Declaration
        "sec528" : "sec:ned-ref:directory-structure",  // Directory Structure, package.ned
        "sec529" : "sec:ned-ref:components",  // Components
        "sec530" : "sec:ned-ref:simple-modules",  // Simple Modules
        "sec531" : "sec:ned-ref:compound-modules",  // Compound Modules
        "sec532" : "sec:ned-ref:networks",  // Networks
        "sec533" : "sec:ned-ref:channels",  // Channels
        "sec534" : "sec:ned-ref:module-interfaces",  // Module Interfaces
        "sec535" : "sec:ned-ref:channel-interfaces",  // Channel Interfaces
        "sec536" : "sec:ned-ref:resolving-cpp-class",  // Resolving the C++ Implementation Class
        "sec537" : "sec:ned-ref:properties",  // Properties
        "sec538" : "sec:ned-ref:parameters",  // Parameters
        "sec539" : "sec:ned-ref:pattern-assignments",  // Pattern Assignments
        "sec540" : "sec:ned-ref:gates",  // Gates
        "sec541" : "sec:ned-ref:submodules",  // Submodules
        "sec542" : "sec:ned-ref:connections",  // Connections
        "sec543" : "sec:ned-ref:connection-groups",  // Conditional and Loop Connections, Connection Groups
        "sec544" : "sec:ned-ref:inner-types",  // Inner Types
        "sec545" : "sec:ned-ref:name-uniqueness",  // Name Uniqueness
        "sec546" : "sec:ned-ref:param-assignment-order",  // Parameter Assignment Order
        "sec547" : "sec:ned-ref:type-name-resolution",  // Type Name Resolution
        "sec548" : "sec:ned-ref:parameteric-type-resolution",  // Resolution of Parametric Types
        "sec549" : "sec:ned-ref:implementing-an-interface",  // Implementing an Interface
        "sec550" : "sec:ned-ref:inheritance",  // Inheritance
        "sec551" : "sec:ned-ref:build-order",  // Network Build Order
        "sec552" : "sec:ned-ref:expressions",  // Expressions
        "sec553" : "sec:ned-ref:operators",  // Operators
        "sec554" : "sec:ned-ref:referencing-parameters-and-loop-variables",  // Referencing Parameters and Loop Variables
        "sec555" : "sec:ned-ref:index-operator",  // The index Operator
        "sec556" : "sec:ned-ref:sizeof-operator",  // The sizeof() Operator
        "sec557" : "sec:ned-ref:functions",  // Functions
        "sec558" : "sec:ned-ref:units",  // Units of Measurement
        "sec559" : "cha:ned-language-grammar",  // Appendix&#58; NED Language Grammar
        "sec560" : "cha:ned-xml-binding",  // Appendix&#58; NED XML Binding
        "sec561" : "cha:ned-functions",  // Appendix&#58; NED Functions
        "sec562" : "cha:msg-language-grammar",  // Appendix&#58; Message Definitions Grammar
        "sec563" : "cha:display-strings",  // Appendix&#58; Display String Tags
        "sec564" : "sec:display-strings:module-and-connection-display-strings",  // Module and Connection Display String Tags
        "sec565" : "sec:display-strings:message-display-strings",  // Message Display String Tags
        "sec566" : "cha:config-options",  // Appendix&#58; Configuration Options
        "sec567" : "sec:config-options:config-options",  // Configuration Options
        "sec568" : "sec:config-options:predefined-variables",  // Predefined Configuration Variables
        "sec569" : "cha:result-file-formats",  // Appendix&#58; Result File Formats
        "sec570" : "sec:result-file-formats:version",  // Version
        "sec571" : "sec:result-file-formats:run-declaration",  // Run Declaration
        "sec572" : "sec:result-file-formats:attributes",  // Attributes
        "sec573" : "sec:result-file-formats:module-parameters",  // Module Parameters
        "sec574" : "sec:result-file-formats:scalar-data",  // Scalar Data
        "sec575" : "sec:result-file-formats:vector-declaration",  // Vector Declaration
        "sec576" : "sec:result-file-formats:vector-data",  // Vector Data
        "sec577" : "sec:result-file-formats:index-header",  // Index Header
        "sec578" : "sec:result-file-formats:index-data",  // Index Data
        "sec579" : "sec:result-file-formats:statistics-object",  // Statistics Object
        "sec580" : "sec:result-file-formats:field",  // Field
        "sec581" : "sec:result-file-formats:histogram-bin",  // Histogram Bin
        "sec582" : "cha:eventlog-file-format",  // Appendix&#58; Eventlog File Format
        "sec583" : "sec:eventlog-file-format:entry-types",  // Supported Entry Types and Their Attributes
    }
    var key = self.location.hash.substr(1);
    if (key in anchorMap) {
        self.location.href = '#' + anchorMap[key];
    }
}
</script>

<body onload='redirectOldLinks()'>
<div class="top">


  <br>
  <img src='omnetpp.png' border='0'>
  <p style="color: #196F93; font-weight: bold; font-size: 32px; margin-top: 15px; margin-bottom: 5px">Simulation Manual</p>
  <p style="color: #196F93; font-weight: bold; font-size: 18px; margin-top: 5px; margin-bottom: 10px">OMNeT++ version 5.6.2</p>
  <p style="color: #196F93; font-weight: bold; font-size: 12px; margin-top: 5px; margin-bottom: 40px"><a href="http://omnetpp.org">http://omnetpp.org</a></p>
  <hr>


<h1>Chapters</h1>
<p>
<b><a href="#toc_1" class="toc">1 Introduction</a></b><br>
<b><a href="#toc_2" class="toc">2 Overview</a></b><br>
<b><a href="#toc_3" class="toc">3 The NED Language</a></b><br>
<b><a href="#toc_4" class="toc">4 Simple Modules</a></b><br>
<b><a href="#toc_5" class="toc">5 Messages and Packets</a></b><br>
<b><a href="#toc_6" class="toc">6 Message Definitions</a></b><br>
<b><a href="#toc_7" class="toc">7 The Simulation Library</a></b><br>
<b><a href="#toc_8" class="toc">8 Graphics and Visualization</a></b><br>
<b><a href="#toc_9" class="toc">9 Building Simulation Programs</a></b><br>
<b><a href="#toc_10" class="toc">10 Configuring Simulations</a></b><br>
<b><a href="#toc_11" class="toc">11 Running Simulations</a></b><br>
<b><a href="#toc_12" class="toc">12 Result Recording and Analysis</a></b><br>
<b><a href="#toc_13" class="toc">13 Eventlog</a></b><br>
<b><a href="#toc_14" class="toc">14 Documenting NED and Messages</a></b><br>
<b><a href="#toc_15" class="toc">15 Testing</a></b><br>
<b><a href="#toc_16" class="toc">16 Parallel Distributed Simulation</a></b><br>
<b><a href="#toc_17" class="toc">17 Customizing and Extending OMNeT++</a></b><br>
<b><a href="#toc_18" class="toc">18 Embedding the Simulation Kernel</a></b><br>
<b><a href="#toc_19" class="toc">19 Appendix A&#58; NED Reference</a></b><br>
<b><a href="#toc_20" class="toc">20 Appendix B&#58; NED Language Grammar</a></b><br>
<b><a href="#toc_21" class="toc">21 Appendix C&#58; NED XML Binding</a></b><br>
<b><a href="#toc_22" class="toc">22 Appendix D&#58; NED Functions</a></b><br>
<b><a href="#toc_23" class="toc">23 Appendix E&#58; Message Definitions Grammar</a></b><br>
<b><a href="#toc_24" class="toc">24 Appendix F&#58; Display String Tags</a></b><br>
<b><a href="#toc_25" class="toc">25 Appendix G&#58; Figure Definitions</a></b><br>
<b><a href="#toc_26" class="toc">26 Appendix H&#58; Configuration Options</a></b><br>
<b><a href="#toc_27" class="toc">27 Appendix I&#58; Result File Formats</a></b><br>
<b><a href="#toc_28" class="toc">28 Appendix J&#58; Eventlog File Format</a></b><br>
</p><h1>Table of Contents</h1>
<p>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_1"/><a href="#cha:introduction" class="toc">1 Introduction</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_1.1"/><a href="#sec:introduction:what-is-omnetpp" class="toc">1.1 What Is OMNeT++?</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_1.2"/><a href="#sec:introduction:organization-of-this-manual" class="toc">1.2 Organization of This Manual</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_2"/><a href="#cha:overview" class="toc">2 Overview</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1"/><a href="#sec:overview:modeling-concepts" class="toc">2.1 Modeling Concepts</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.1"/><a href="#sec:overview:hierarchical-modules" class="toc">2.1.1 Hierarchical Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.2"/><a href="#sec:overview:module-types" class="toc">2.1.2 Module Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.3"/><a href="#sec:overview:messages-gates-links" class="toc">2.1.3 Messages, Gates, Links</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.4"/><a href="#sec:overview:modeling-of-packet-transmissions" class="toc">2.1.4 Modeling of Packet Transmissions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.5"/><a href="#sec:overview:parameters" class="toc">2.1.5 Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.6"/><a href="#sec:overview:topology-description-method" class="toc">2.1.6 Topology Description Method</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.2"/><a href="#sec:overview:programmable-using-cplusplus" class="toc">2.2 Programming the Algorithms</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.3"/><a href="#sec:overview:using-omnetpp" class="toc">2.3 Using OMNeT++</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.3.1"/><a href="#sec:overview:building-and-running-simulations" class="toc">2.3.1 Building and Running Simulations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.3.2"/><a href="#sec:overview:what-is-in-distribution" class="toc">2.3.2 What Is in the Distribution</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_3"/><a href="#cha:ned-lang" class="toc">3 The NED Language</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.1"/><a href="#sec:ned-lang:ned-overview" class="toc">3.1 NED Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2"/><a href="#sec:ned-lang:warmup" class="toc">3.2 NED Quickstart</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.1"/><a href="#sec:ned-lang:warmup:network" class="toc">3.2.1 The Network</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.2"/><a href="#sec:ned-lang:warmup:introducing-a-channel" class="toc">3.2.2 Introducing a Channel</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.3"/><a href="#sec:ned-lang:warmup:the-simple-modules" class="toc">3.2.3 The App, Routing, and Queue Simple Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.4"/><a href="#sec:warmup:ned-lang:node-compound-module" class="toc">3.2.4 The Node Compound Module</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.5"/><a href="#sec:ned-lang:warmup:putting-it-together" class="toc">3.2.5 Putting It Together</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.3"/><a href="#sec:ned-lang:simple-modules" class="toc">3.3 Simple Modules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.4"/><a href="#sec:ned-lang:compound-modules" class="toc">3.4 Compound Modules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.5"/><a href="#sec:ned-lang:channels" class="toc">3.5 Channels</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.6"/><a href="#sec:ned-lang:parameters" class="toc">3.6 Parameters</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.6.1"/><a href="#sec:ned-lang:parameter-assignments" class="toc">3.6.1 Assigning a Value</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.6.2"/><a href="#sec:ned-lang:expressions" class="toc">3.6.2 Expressions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.6.3"/><a href="#sec:ned-lang:volatile" class="toc">3.6.3 volatile</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.6.4"/><a href="#sec:ned-lang:units" class="toc">3.6.4 Units</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.6.5"/><a href="#sec:ned-lang:xml-parameters" class="toc">3.6.5 XML Parameters</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.7"/><a href="#sec:ned-lang:gates" class="toc">3.7 Gates</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.8"/><a href="#sec:ned-lang:submodules" class="toc">3.8 Submodules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.9"/><a href="#sec:ned-lang:connections" class="toc">3.9 Connections</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.9.1"/><a href="#sec:ned-lang:channel-specification" class="toc">3.9.1 Channel Specification</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.9.2"/><a href="#sec:ned-lang:reconnecting-gates" class="toc">3.9.2 Reconnecting Gates</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.9.3"/><a href="#sec:ned-lang:channel-names" class="toc">3.9.3 Channel Names</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.10"/><a href="#sec:ned-lang:multiple-connections" class="toc">3.10 Multiple Connections</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.10.1"/><a href="#sec:ned-lang:multiple-connections-examples" class="toc">3.10.1 Examples</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.10.2"/><a href="#sec:ned-lang:connection-design-patterns" class="toc">3.10.2 Connection Patterns</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.11"/><a href="#sec:ned-lang:parametric-submodule-and-connection-types" class="toc">3.11 Parametric Submodule and Connection Types</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.11.1"/><a href="#sec:ned-lang:submodule-like" class="toc">3.11.1 Parametric Submodule Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.11.2"/><a href="#sec:ned-lang:conditional-parametric-submodules" class="toc">3.11.2 Conditional Parametric Submodules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.11.3"/><a href="#sec:ned-lang:connection-like" class="toc">3.11.3 Parametric Connection Types</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.12"/><a href="#sec:ned-lang:properties" class="toc">3.12 Metadata Annotations (Properties)</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.12.1"/><a href="#sec:ned-lang:property-indices" class="toc">3.12.1 Property Indices</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.12.2"/><a href="#sec:ned-lang:property-data-model" class="toc">3.12.2 Data Model</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.12.3"/><a href="#sec:ned-lang:overriding-and-extending-property-values" class="toc">3.12.3 Overriding and Extending Property Values</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.13"/><a href="#sec:ned-lang:inheritance" class="toc">3.13 Inheritance</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.14"/><a href="#sec:ned-lang:packages" class="toc">3.14 Packages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.14.1"/><a href="#sec:ned-lang:packages-overview" class="toc">3.14.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.14.2"/><a href="#sec:ned-lang:imports-and-name-resolution" class="toc">3.14.2 Name Resolution, Imports</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.14.3"/><a href="#sec:ned-lang:name-resolution-with-like" class="toc">3.14.3 Name Resolution With "like"</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.14.4"/><a href="#sec:ned-lang:default-package" class="toc">3.14.4 The Default Package</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_4"/><a href="#cha:simple-modules" class="toc">4 Simple Modules</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1"/><a href="#sec:simple-modules:simulation-concepts" class="toc">4.1 Simulation Concepts</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.1"/><a href="#sec:simple-modules:discrete-event-simulation" class="toc">4.1.1 Discrete Event Simulation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.2"/><a href="#sec:simple-modules:event-loop" class="toc">4.1.2 The Event Loop</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.3"/><a href="#sec:simple-modules:events-in-opp" class="toc">4.1.3 Events and Event Execution Order in OMNeT++</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.4"/><a href="#sec:simple-modules:simulation-time" class="toc">4.1.4 Simulation Time</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.5"/><a href="#sec:simple-modules:fes-implementation" class="toc">4.1.5 FES Implementation</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.2"/><a href="#sec:simple-modules:simple-modules-in-opp" class="toc">4.2 Components, Simple Modules, Channels</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.3"/><a href="#sec:simple-modules:defining-simple-modules" class="toc">4.3 Defining Simple Module Types</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.3.1"/><a href="#sec:simple-modules:defining:overview" class="toc">4.3.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.3.2"/><a href="#sec:simple-modules:module-ctor" class="toc">4.3.2 Constructor</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.3.3"/><a href="#sec:simple-modules:initialize-and-finish" class="toc">4.3.3 Initialization and Finalization</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4"/><a href="#sec:simple-modules:handlemessage-and-activity" class="toc">4.4 Adding Functionality to cSimpleModule</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4.1"/><a href="#sec:simple-modules:handlemessage" class="toc">4.4.1 handleMessage()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4.2"/><a href="#sec:simple-modules:activity" class="toc">4.4.2 activity()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4.3"/><a href="#sec:simple-modules:global-vars" class="toc">4.4.3 How to Avoid Global Variables</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4.4"/><a href="#sec:simple-modules:module-subclassing" class="toc">4.4.4 Reusing Module Code via Subclassing</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5"/><a href="#sec:simple-modules:parameters" class="toc">4.5 Accessing Module Parameters</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.1"/><a href="#sec:simple-modules:volatile-parameters" class="toc">4.5.1 Volatile and Non-Volatile Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.2"/><a href="#sec:simple-modules:setting-parameters" class="toc">4.5.2 Changing a Parameter's Value</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.3"/><a href="#sec:simple-modules:further-cpar-methods" class="toc">4.5.3 Further cPar Methods</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.4"/><a href="#sec:simple-modules:emulating-parameter-arrays" class="toc">4.5.4 Emulating Parameter Arrays</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.5"/><a href="#sec:simple-modules:handleparameterchange" class="toc">4.5.5 handleParameterChange()</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.6"/><a href="#sec:simple-modules:gates" class="toc">4.6 Accessing Gates and Connections</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.6.1"/><a href="#sec:simple-modules:gate-objects" class="toc">4.6.1 Gate Objects</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.6.2"/><a href="#sec:simple-modules:connections" class="toc">4.6.2 Connections</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.6.3"/><a href="#sec:simple-modules:connections-channel" class="toc">4.6.3 The Connection's Channel</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7"/><a href="#sec:simple-modules:sending-and-receiving" class="toc">4.7 Sending and Receiving Messages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.1"/><a href="#sec:simple-modules:self-messages" class="toc">4.7.1 Self-Messages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.2"/><a href="#sec:simple-modules:sending-messages" class="toc">4.7.2 Sending Messages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.3"/><a href="#sec:simple-modules:broadcasts-and-retransmissions" class="toc">4.7.3 Broadcasts and Retransmissions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.4"/><a href="#sec:simple-modules:delayed-sending" class="toc">4.7.4 Delayed Sending</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.5"/><a href="#sec:simple-modules:direct-sending" class="toc">4.7.5 Direct Message Sending</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.6"/><a href="#sec:simple-modules:packet-transmission" class="toc">4.7.6 Packet Transmissions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.7"/><a href="#sec:simple-modules:receiving-with-activity" class="toc">4.7.7 Receiving Messages with activity()</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.8"/><a href="#sec:simple-modules:channels" class="toc">4.8 Channels</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.8.1"/><a href="#sec:simple-modules:channels-overview" class="toc">4.8.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.8.2"/><a href="#sec:simple-modules:channel-api" class="toc">4.8.2 The Channel API</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.8.3"/><a href="#sec:simple-modules:channel-examples" class="toc">4.8.3 Channel Examples</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.9"/><a href="#sec:simple-modules:stopping" class="toc">4.9 Stopping the Simulation</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.9.1"/><a href="#sec:simple-modules:endsimulation" class="toc">4.9.1 Normal Termination</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.9.2"/><a href="#sec:simple-modules:raising-errors" class="toc">4.9.2 Raising Errors</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.10"/><a href="#sec:simple-modules:fsm" class="toc">4.10 Finite State Machines</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.10.1"/><a href="#sec:simple-modules:fsm-overview" class="toc">4.10.1 Overview</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.11"/><a href="#sec:simple-modules:walking-module-hierarchy" class="toc">4.11 Navigating the Module Hierarchy</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.11.1"/><a href="#sec:simple-modules:module-vectors" class="toc">4.11.1 Module Vectors</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.11.2"/><a href="#sec:simple-modules:module-ids" class="toc">4.11.2 Component IDs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.11.3"/><a href="#sec:simple-modules:walking-up-and-down-module-hierarchy" class="toc">4.11.3 Walking Up and Down the Module Hierarchy</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.11.4"/><a href="#sec:simple-modules:finding-modules-by-path" class="toc">4.11.4 Finding Modules by Path</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.11.5"/><a href="#sec:simple-modules:iterating-over-submodules" class="toc">4.11.5 Iterating over Submodules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.11.6"/><a href="#sec:simple-modules:navigating-connections" class="toc">4.11.6 Navigating Connections</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.12"/><a href="#sec:simple-modules:direct-method-calls" class="toc">4.12 Direct Method Calls Between Modules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13"/><a href="#sec:simple-modules:creating-modules" class="toc">4.13 Dynamic Module Creation</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.1"/><a href="#sec:simple-modules:dynamic-creation:when-to-use" class="toc">4.13.1 When To Use</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.2"/><a href="#sec:simple-modules:dynamic-creation:overview" class="toc">4.13.2 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.3"/><a href="#sec:simple-modules:dynamic-creation:api" class="toc">4.13.3 Creating Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.4"/><a href="#sec:simple-modules:deleting-modules" class="toc">4.13.4 Deleting Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.5"/><a href="#sec:simple-modules:module-deletion-and-finish" class="toc">4.13.5 Module Deletion and finish()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.6"/><a href="#sec:simple-modules:creating-connections" class="toc">4.13.6 Creating Connections</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.7"/><a href="#sec:simple-modules:removing-connections" class="toc">4.13.7 Removing Connections</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.14"/><a href="#sec:simple-modules:signals" class="toc">4.14 Signals</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.14.1"/><a href="#sec:simple-modules:signals-design" class="toc">4.14.1 Design Considerations and Rationale</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.14.2"/><a href="#sec:simple-modules:signals-api" class="toc">4.14.2 The Signals Mechanism</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.14.3"/><a href="#sec:simple-modules:model-change" class="toc">4.14.3 Listening to Model Changes</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15"/><a href="#sec:simple-modules:signal-based-statistics" class="toc">4.15 Signal-Based Statistics Recording</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.1"/><a href="#sec:simple-modules:signal-based-statistics-motivation" class="toc">4.15.1 Motivation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.2"/><a href="#sec:simple-modules:declaring-statistics" class="toc">4.15.2 Declaring Statistics</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.3"/><a href="#sec:simple-modules:statistic-recording-dynamic-signals" class="toc">4.15.3 Statistics Recording for Dynamically Registered Signals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.4"/><a href="#sec:simple-modules:statistic-recording-programmatically" class="toc">4.15.4 Adding Result Filters and Recorders Programmatically</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.5"/><a href="#sec:simple-modules:emitting-statistic-signals" class="toc">4.15.5 Emitting Signals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.6"/><a href="#sec:simple-modules:writing-result-filters" class="toc">4.15.6 Writing Result Filters and Recorders</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_5"/><a href="#cha:messages" class="toc">5 Messages and Packets</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.1"/><a href="#sec:msgs:overview" class="toc">5.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2"/><a href="#sec:msgs:cmessage" class="toc">5.2 The cMessage Class</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.1"/><a href="#sec:messages:cmessage-basic-usage" class="toc">5.2.1 Basic Usage</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.2"/><a href="#sec:messages:duplicating-messages" class="toc">5.2.2 Duplicating Messages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.3"/><a href="#sec:messages:message-ids" class="toc">5.2.3 Message IDs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.4"/><a href="#sec:messages:control-info" class="toc">5.2.4 Control Info</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.5"/><a href="#sec:messages:information-about-last-arrival" class="toc">5.2.5 Information About the Last Arrival</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.6"/><a href="#sec:messages:displaystring" class="toc">5.2.6 Display String</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.3"/><a href="#sec:msgs:self-messages" class="toc">5.3 Self-Messages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.3.1"/><a href="#sec:messages:using-message-as-self-message" class="toc">5.3.1 Using a Message as Self-Message</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.3.2"/><a href="#sec:messages:context-pointer" class="toc">5.3.2 Context Pointer</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4"/><a href="#sec:msgs:cpacket" class="toc">5.4 The cPacket Class</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.1"/><a href="#sec:messages:cpacket-basic-usage" class="toc">5.4.1 Basic Usage</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.2"/><a href="#sec:messages:identifying-protocol-of-packet" class="toc">5.4.2 Identifying the Protocol</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.3"/><a href="#sec:messages:information-about-last-transmission" class="toc">5.4.3 Information About the Last Transmission</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.4"/><a href="#sec:messages:encapsulating-packets" class="toc">5.4.4 Encapsulating Packets</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.5"/><a href="#sec:messages:reference-counting" class="toc">5.4.5 Reference Counting</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.6"/><a href="#sec:messages:encapsulating-several-packets" class="toc">5.4.6 Encapsulating Several Packets</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.5"/><a href="#sec:msgs:attaching-objects" class="toc">5.5 Attaching Objects To a Message</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.5.1"/><a href="#sec:messages:attaching-objects" class="toc">5.5.1 Attaching Objects</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.5.2"/><a href="#sec:messages:attaching-parameters" class="toc">5.5.2 Attaching Parameters</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_6"/><a href="#cha:msg-def" class="toc">6 Message Definitions</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.1"/><a href="#sec:msg-defs:intro" class="toc">6.1 Introduction</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.1.1"/><a href="#sec:msg-defs:first-msg-class" class="toc">6.1.1 The First Message Class</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2"/><a href="#sec:msg-defs:messages-and-packets" class="toc">6.2 Messages and Packets</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.1"/><a href="#sec:msg-defs:defining-messages-and-packets" class="toc">6.2.1 Defining Messages and Packets</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.2"/><a href="#sec:msg-defs:field-data-types" class="toc">6.2.2 Field Data Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.3"/><a href="#sec:msg-defs:initial-values" class="toc">6.2.3 Initial Values</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.4"/><a href="#sec:msg-defs:enums" class="toc">6.2.4 Enums</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.5"/><a href="#sec:msg-defs:fixed-size-arrays" class="toc">6.2.5 Fixed-Size Arrays</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.6"/><a href="#sec:msg-defs:variable-size-arrays" class="toc">6.2.6 Variable-Size Arrays</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.7"/><a href="#sec:msg-defs:other-types-as-fields" class="toc">6.2.7 Classes and Structs as Fields</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.8"/><a href="#sec:msg-defs:pointers-fields" class="toc">6.2.8 Pointer Fields</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.9"/><a href="#sec:msg-defs:inheritance" class="toc">6.2.9 Inheritance</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.10"/><a href="#sec:msg-defs:assignment-of-inherited-fields" class="toc">6.2.10 Assignment of Inherited Fields</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.3"/><a href="#sec:msg-defs:defining-classes" class="toc">6.3 Classes</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.4"/><a href="#sec:msg-defs:defining-structs" class="toc">6.4 Structs</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.5"/><a href="#sec:msg-defs:cplusplus-blocks" class="toc">6.5 Literal C++ Blocks</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.6"/><a href="#sec:msg-defs:using-cpp-types" class="toc">6.6 Using C++ Types</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.6.1"/><a href="#sec:msg-defs:announcing-types" class="toc">6.6.1 Announcing Types to the Message Compiler</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.6.2"/><a href="#sec:msg-def:making-cpp-declarations-available" class="toc">6.6.2 Making the C++ Declarations Available</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.6.3"/><a href="#sec:msg-def:putting-it-together" class="toc">6.6.3 Putting it Together</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.7"/><a href="#sec:msg-defs:customizing-generated-class" class="toc">6.7 Customizing the Generated Class</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.7.1"/><a href="#sec:msg-defs:customizing-method-names" class="toc">6.7.1 Customizing Method Names</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.7.2"/><a href="#sec:msg-defs:customizing-via-inheritance" class="toc">6.7.2 Customizing the Class via Inheritance</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.7.3"/><a href="#sec:msg-defs:abstract-fields" class="toc">6.7.3 Abstract Fields</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.8"/><a href="#sec:msg-defs:using-stl" class="toc">6.8 Using Standard Container Classes for Fields</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.8.1"/><a href="#sec:msg-def:typedefs" class="toc">6.8.1 Typedefs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.8.2"/><a href="#sec:msg-def:abstract-fields" class="toc">6.8.2 Abstract Fields</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.9"/><a href="#sec:msg-defs:namespaces" class="toc">6.9 Namespaces</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.9.1"/><a href="#sec:msg-defs:declaring-a-namespace" class="toc">6.9.1 Declaring a Namespace</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.9.2"/><a href="#sec:msg-def:cpp-blocks-and-namespace" class="toc">6.9.2 C++ Blocks and Namespace</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.9.3"/><a href="#sec:msg-def:type-announcements-and-namespace" class="toc">6.9.3 Type Announcements and Namespace</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.10"/><a href="#sec:msg-defs:descriptor-classes" class="toc">6.10 Descriptor Classes</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.11"/><a href="#sec:msg-defs:summary" class="toc">6.11 Summary</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_7"/><a href="#cha:sim-lib" class="toc">7 The Simulation Library</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1"/><a href="#sec:sim-lib:fundamentals" class="toc">7.1 Fundamentals</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.1"/><a href="#sec:sim-lib:using-omnetpp-library" class="toc">7.1.1 Using the Library</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.2"/><a href="#sec:sim-lib:cobject" class="toc">7.1.2 The cObject Base Class</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.3"/><a href="#sec:sim-lib:iterators" class="toc">7.1.3 Iterators</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.4"/><a href="#sec:sim-lib:runtime-errors" class="toc">7.1.4 Runtime Errors</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.2"/><a href="#sec:sim-lib:logging-from-modules" class="toc">7.2 Logging from Modules</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.2.1"/><a href="#sec:sim-lib:log-output" class="toc">7.2.1 Log Output</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.2.2"/><a href="#sec:sim-lib:log-levels" class="toc">7.2.2 Log Levels</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.2.3"/><a href="#sec:sim-lib:log-statements" class="toc">7.2.3 Log Statements</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.2.4"/><a href="#sec:sim-lib:log-categories" class="toc">7.2.4 Log Categories</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.2.5"/><a href="#sec:sim-lib:logging-composition-and-new-lines" class="toc">7.2.5 Composition and New lines</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.2.6"/><a href="#sec:sim-lib:logging-implementation" class="toc">7.2.6 Implementation</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.3"/><a href="#sec:sim-lib:random-number-generators" class="toc">7.3 Random Number Generators</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.3.1"/><a href="#sec:sim-lib:rngs" class="toc">7.3.1 RNG Implementations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.3.2"/><a href="#sec:sim-lib:global-and-component-local-rngs" class="toc">7.3.2 Global and Component-Local RNGs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.3.3"/><a href="#sec:sim-lib:accessing-rngs" class="toc">7.3.3 Accessing the RNGs</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4"/><a href="#sec:sim-lib:random-variate-generation" class="toc">7.4 Generating Random Variates</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.1"/><a href="#sec:sim-lib:random-variate-component-methods" class="toc">7.4.1 Component Methods</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.2"/><a href="#sec:sim-lib:random-number-stream-classes" class="toc">7.4.2 Random Number Stream Classes</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.3"/><a href="#sec:sim-lib:random-variate-generator-functions" class="toc">7.4.3 Generator Functions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.4"/><a href="#sec:sim-lib:random-numbers-from-histograms" class="toc">7.4.4 Random Numbers from Histograms</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.5"/><a href="#sec:sim-lib:adding-new-distributions" class="toc">7.4.5 Adding New Distributions</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.5"/><a href="#sec:sim-lib:container-classes" class="toc">7.5 Container Classes</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.5.1"/><a href="#sec:sim-lib:cqueue" class="toc">7.5.1 Queue class: cQueue</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.5.2"/><a href="#sec:sim-lib:carray" class="toc">7.5.2 Expandable Array: cArray</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6"/><a href="#sec:sim-lib:ctopology" class="toc">7.6 Routing Support: cTopology</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6.1"/><a href="#sec:sim-lib:ctopology-overview" class="toc">7.6.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6.2"/><a href="#sec:sim-lib:ctopology-basic-usage" class="toc">7.6.2 Basic Usage</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6.3"/><a href="#sec:sim-lib:ctopology-shortest-paths" class="toc">7.6.3 Shortest Paths</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6.4"/><a href="#sec:sim-lib:ctopology-manipulating" class="toc">7.6.4 Manipulating the graph</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.7"/><a href="#sec:sim-lib:pattern-matching" class="toc">7.7 Pattern Matching</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.7.1"/><a href="#sec:sim-lib:cpatternmatcher" class="toc">7.7.1 cPatternMatcher</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.7.2"/><a href="#sec:sim-lib:cmatchexpression" class="toc">7.7.2 cMatchExpression</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8"/><a href="#sec:sim-lib:statistics" class="toc">7.8 Collecting Summary Statistics and Histograms</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8.1"/><a href="#sec:sim-lib:cstatistic-and-descendants" class="toc">7.8.1 cStdDev</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8.2"/><a href="#sec:sim-lib:histograms" class="toc">7.8.2 cHistogram</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8.3"/><a href="#sec:sim-lib:psquare" class="toc">7.8.3 cPSquare</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8.4"/><a href="#sec:sim-lib:ksplit" class="toc">7.8.4 cKSplit</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.9"/><a href="#sec:sim-lib:result-recording" class="toc">7.9 Recording Simulation Results</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.9.1"/><a href="#sec:sim-lib:coutvector" class="toc">7.9.1 Output Vectors: cOutVector</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.9.2"/><a href="#sec:sim-lib:output-scalars" class="toc">7.9.2 Output Scalars</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10"/><a href="#sec:sim-lib:watches-and-snapshots" class="toc">7.10 Watches and Snapshots</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.1"/><a href="#sec:sim-lib:basic-watches" class="toc">7.10.1 Basic Watches</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.2"/><a href="#sec:sim-lib:read-write-watches" class="toc">7.10.2 Read-write Watches</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.3"/><a href="#sec:sim-lib:structured-watches" class="toc">7.10.3 Structured Watches</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.4"/><a href="#sec:sim-lib:stl-watches" class="toc">7.10.4 STL Watches</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.5"/><a href="#sec:sim-lib:snapshots" class="toc">7.10.5 Snapshots</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.6"/><a href="#sec:sim-lib:getting-coroutine-stack-usage" class="toc">7.10.6 Getting Coroutine Stack Usage</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.11"/><a href="#sec:sim-lib:defining-ned-functions" class="toc">7.11 Defining New NED Functions</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.11.1"/><a href="#sec:sim-lib:define-ned-function-macro" class="toc">7.11.1 Define_NED_Function()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.11.2"/><a href="#sec:sim-lib:define-ned-math-function" class="toc">7.11.2 Define_NED_Math_Function()</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12"/><a href="#sec:sim-lib:deriving-new-classes" class="toc">7.12 Deriving New Classes</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12.1"/><a href="#sec:sim-lib:cobject-or-not" class="toc">7.12.1 cObject or Not?</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12.2"/><a href="#sec:sim-lib:cobject-virtual-methods" class="toc">7.12.2 cObject Virtual Methods</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12.3"/><a href="#sec:sim-lib:class-registration" class="toc">7.12.3 Class Registration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12.4"/><a href="#sec:sim-lib:subclassing-cobject-details" class="toc">7.12.4 Details</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.13"/><a href="#sec:sim-lib:ownership-management" class="toc">7.13 Object Ownership Management</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.13.1"/><a href="#sec:sim-lib:ownership-tree" class="toc">7.13.1 The Ownership Tree</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.13.2"/><a href="#sec:sim-lib:managing-ownership" class="toc">7.13.2 Managing Ownership</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_8"/><a href="#cha:graphics" class="toc">8 Graphics and Visualization</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.1"/><a href="#sec:graphics:overview" class="toc">8.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2"/><a href="#sec:graphics:refreshdisplay" class="toc">8.2 Placement of Visualization Code</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.1"/><a href="#sec:graphics:refreshdisplay-usage-and-semantics" class="toc">8.2.1 The refreshDisplay() Method</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.2"/><a href="#sec:graphics:refreshdisplay-advantages" class="toc">8.2.2 Advantages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.3"/><a href="#sec:graphics:refreshdisplay-constness" class="toc">8.2.3 Why is <tt>refreshDisplay()</tt> const?</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.3"/><a href="#sec:graphics:smooth-animation" class="toc">8.3 Smooth Animation</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.3.1"/><a href="#sec:graphics:animation-concepts" class="toc">8.3.1 Concepts</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.3.2"/><a href="#sec:graphics:animation-modes" class="toc">8.3.2 Smooth vs. Traditional Animation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.3.3"/><a href="#sec:graphics:animation-speed" class="toc">8.3.3 The Choice of Animation Speed</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.3.4"/><a href="#sec:graphics:animation-hold" class="toc">8.3.4 Holds</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.3.5"/><a href="#sec:graphics:disabling-built-in-anims" class="toc">8.3.5 Disabling Built-In Animations</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4"/><a href="#sec:graphics:display-strings" class="toc">8.4 Display Strings</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.1"/><a href="#sec:graphics:displaystring-syntax-and-placement" class="toc">8.4.1 Syntax and Placement</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.2"/><a href="#sec:graphics:displaystring-inheritance" class="toc">8.4.2 Inheritance</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.3"/><a href="#sec:graphics:submodule-displaystring-tags" class="toc">8.4.3 Submodule Tags</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.4"/><a href="#sec:graphics:background-displaystring-tags" class="toc">8.4.4 Background Tags</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.5"/><a href="#sec:graphics:connection-displaystrings" class="toc">8.4.5 Connection Display Strings</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.6"/><a href="#sec:graphics:message-displaystrings" class="toc">8.4.6 Message Display Strings</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.7"/><a href="#sec:graphics:displaystring-parameter-substitution" class="toc">8.4.7 Parameter Substitution</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.8"/><a href="#sec:graphics:displaystring-colors" class="toc">8.4.8 Colors</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.9"/><a href="#sec:graphics:icon-library" class="toc">8.4.9 Icons</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.10"/><a href="#sec:graphics:compound-module-layouting" class="toc">8.4.10 Layouting</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.4.11"/><a href="#sec:graphics:changing-displaystrings-at-runtime" class="toc">8.4.11 Changing Display Strings at Runtime</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.5"/><a href="#sec:graphics:bubbles" class="toc">8.5 Bubbles</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6"/><a href="#sec:graphics:canvas" class="toc">8.6 The Canvas</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.1"/><a href="#sec:graphics:canvas-overview" class="toc">8.6.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.2"/><a href="#sec:graphics:creating-accessing-and-viewing-canvases" class="toc">8.6.2 Creating, Accessing and Viewing Canvases</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.3"/><a href="#sec:graphics:figure-classes" class="toc">8.6.3 Figure Classes</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.4"/><a href="#sec:graphics:figure-tree" class="toc">8.6.4 The Figure Tree</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.5"/><a href="#sec:graphics:creating-and-manipulating-figures" class="toc">8.6.5 Creating and Manipulating Figures from NED and C++</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.6"/><a href="#sec:graphics:canvas-stacking-order" class="toc">8.6.6 Stacking Order</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.7"/><a href="#sec:graphics:canvas-transforms" class="toc">8.6.7 Transforms</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.8"/><a href="#sec:graphics:showing-hiding-figures" class="toc">8.6.8 Showing/Hiding Figures</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.9"/><a href="#sec:graphics:figure-tooltip-associated-object" class="toc">8.6.9 Figure Tooltip, Associated Object</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.10"/><a href="#sec:graphics:figure-positions-colors-fonts-etc" class="toc">8.6.10 Specifying Positions, Colors, Fonts and Other Properties</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.11"/><a href="#sec:graphics:primitive-figures" class="toc">8.6.11 Primitive Figures</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.12"/><a href="#sec:graphics:compound-figures" class="toc">8.6.12 Compound Figures</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.13"/><a href="#sec:graphics:self-refreshing-figures" class="toc">8.6.13 Self-Refreshing Figures</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.6.14"/><a href="#sec:graphics:figures-with-custom-renderers" class="toc">8.6.14 Figures with Custom Renderers</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.7"/><a href="#sec:graphics:osg" class="toc">8.7 3D Visualization</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.7.1"/><a href="#sec:graphics:osg-introduction" class="toc">8.7.1 Introduction</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.7.2"/><a href="#sec:graphics:opp-api-for-osg" class="toc">8.7.2 The OMNeT++ API for OpenSceneGraph</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.7.3"/><a href="#sec:graphics:using-osg" class="toc">8.7.3 Using OSG</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.7.4"/><a href="#sec:graphics:using-osgearth" class="toc">8.7.4 Using osgEarth</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.7.5"/><a href="#sec:graphics:osg-osgearth-programming-resources" class="toc">8.7.5 OpenSceneGraph/osgEarth Programming Resources</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_9"/><a href="#cha:build-sim-progs" class="toc">9 Building Simulation Programs</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.1"/><a href="#sec:build-sim-progs:overview" class="toc">9.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2"/><a href="#sec:build-sim-progs:opp-makemake" class="toc">9.2 Using opp_makemake and Makefiles</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.1"/><a href="#sec:build-sim-progs:makemake-options" class="toc">9.2.1 Command-line Options</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.2"/><a href="#sec:build-sim-progs:makemake-basic-use" class="toc">9.2.2 Basic Use</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.3"/><a href="#sec:build-sim-progs:debug-and-release-builds" class="toc">9.2.3 Debug and Release Builds</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.4"/><a href="#sec:build-sim-progs:debugging-makefile" class="toc">9.2.4 Debugging the Makefile</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.5"/><a href="#sec:build-sim-progs:using-external-libraries" class="toc">9.2.5 Using External C/C++ Libraries</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.6"/><a href="#sec:build-sim-progs:building-directory-trees" class="toc">9.2.6 Building Directory Trees</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.7"/><a href="#sec:build-sim-progs:dependency-handling" class="toc">9.2.7 Dependency Handling</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.8"/><a href="#sec:build-sim-progs:out-of-directory-build" class="toc">9.2.8 Out-of-Directory Build</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.9"/><a href="#sec:build-sim-progs:building-shared-and-static-libraries" class="toc">9.2.9 Building Shared and Static Libraries</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.10"/><a href="#sec:build-sim-progs:recursive-builds" class="toc">9.2.10 Recursive Builds</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.11"/><a href="#sec:makefrag" class="toc">9.2.11 Customizing the Makefile</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.12"/><a href="#sec:build-sim-progs:projects-with-multiple-source-trees" class="toc">9.2.12 Projects with Multiple Source Trees</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.13"/><a href="#sec:build-sim-progs:multi-directory-example" class="toc">9.2.13 A Multi-Directory Example</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.3"/><a href="#sec:build-sim-progs:project-features" class="toc">9.3 Project Features</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.3.1"/><a href="#sec:build-sim-progs:project-feature" class="toc">9.3.1 What is a Project Feature</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.3.2"/><a href="#sec:build-sim-progs:opp-featuretool" class="toc">9.3.2 The opp_featuretool Program</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.3.3"/><a href="#sec:build-sim-progs:oppfeatures-file" class="toc">9.3.3 The .oppfeatures File</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.3.4"/><a href="#sec:build-sim-progs:introducing-project-features" class="toc">9.3.4 How to Introduce a Project Feature</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_10"/><a href="#cha:config-sim" class="toc">10 Configuring Simulations</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.1"/><a href="#sec:config-sim:config-file" class="toc">10.1 The Configuration File</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.1.1"/><a href="#sec:config-sim:example-inifile" class="toc">10.1.1 An Example</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.1.2"/><a href="#sec:config-sim:inifile-syntax" class="toc">10.1.2 File Syntax</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.1.3"/><a href="#sec:config-sim:inifile-inclusion" class="toc">10.1.3 File Inclusion</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2"/><a href="#sec:config-sim:sections" class="toc">10.2 Sections</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2.1"/><a href="#sec:config-sim:general-section" class="toc">10.2.1 The [General] Section</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2.2"/><a href="#sec:config-sim:named-configurations" class="toc">10.2.2 Named Configurations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2.3"/><a href="#sec:config-sim:section-inheritance" class="toc">10.2.3 Section Inheritance</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.3"/><a href="#sec:config-sim:parameter-settings" class="toc">10.3 Assigning Module Parameters</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.3.1"/><a href="#sec:config-sim:wildcards" class="toc">10.3.1 Using Wildcard Patterns</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.3.2"/><a href="#sec:config-sim:using-default-values" class="toc">10.3.2 Using the Default Values</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4"/><a href="#sec:config-sim:parameter-studies" class="toc">10.4 Parameter Studies</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.1"/><a href="#sec:config-sim:iterations" class="toc">10.4.1 Iterations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.2"/><a href="#sec:config-sim:named-iteration-variables" class="toc">10.4.2 Named Iteration Variables</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.3"/><a href="#sec:config-sim:parallel-iteration" class="toc">10.4.3 Parallel Iteration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.4"/><a href="#sec:config-sim:predefined-variables" class="toc">10.4.4 Predefined Variables, Run ID</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.5"/><a href="#sec:config-sim:constraint-expression" class="toc">10.4.5 Constraint Expression</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.6"/><a href="#sec:config-sim:repeating-runs-with-different-seeds" class="toc">10.4.6 Repeating Runs with Different Seeds</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.7"/><a href="#sec:config-sim:experiment-measurement-replication" class="toc">10.4.7 Experiment-Measurement-Replication</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5"/><a href="#sec:config-sim:rng-config" class="toc">10.5 Configuring the Random Number Generators</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5.1"/><a href="#sec:config-sim:number-of-rngs" class="toc">10.5.1 Number of RNGs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5.2"/><a href="#sec:config-sim:rng-choice" class="toc">10.5.2 RNG Choice</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5.3"/><a href="#sec:config-sim:rng-mapping" class="toc">10.5.3 RNG Mapping</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5.4"/><a href="#sec:config-sim:automatic-seed-selection" class="toc">10.5.4 Automatic Seed Selection</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5.5"/><a href="#sec:config-sim:manual-seed-configuration" class="toc">10.5.5 Manual Seed Configuration</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6"/><a href="#sec:config-sim:logging" class="toc">10.6 Logging</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.1"/><a href="#sec:config-sim:compile-time-log-filtering" class="toc">10.6.1 Compile-Time Filtering</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.2"/><a href="#sec:config-sim:runtime-log-filtering" class="toc">10.6.2 Runtime Filtering</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.3"/><a href="#sec:config-sim:log-prefix-format" class="toc">10.6.3 Log Prefix Format</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.4"/><a href="#sec:config-sim:configuring-cmdenv" class="toc">10.6.4 Configuring Cmdenv</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.5"/><a href="#sec:config-sim:configuring-tkenv-and-qtenv" class="toc">10.6.5 Configuring Tkenv and Qtenv</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_11"/><a href="#cha:run-sim" class="toc">11 Running Simulations</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1"/><a href="#cha:run-sim:intro" class="toc">11.1 Introduction</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.2"/><a href="#sec:run-sim:running" class="toc">11.2 Simulation Executables vs Libraries</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.3"/><a href="#sec:run-sim:command-line-options" class="toc">11.3 Command-Line Options</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.4"/><a href="#sec:run-sim:config-options-on-cmdline" class="toc">11.4 Configuration Options on the Command Line</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.5"/><a href="#sec:run-sim:specifying-ini-files" class="toc">11.5 Specifying Ini Files</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.6"/><a href="#sec:run-sim:specifying-ned-path" class="toc">11.6 Specifying the NED Path</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.7"/><a href="#sec:run-sim:selecting-user-interface" class="toc">11.7 Selecting a User Interface</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.8"/><a href="#sec:run-sim:selecting-configuration-and-runs" class="toc">11.8 Selecting Configurations and Runs</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.8.1"/><a href="#sec:run-sim:selecting-configuration-and-runs:syntax" class="toc">11.8.1 Run Filter Syntax</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.8.2"/><a href="#sec:run-sim:selecting-configuration-and-runs:queryoption" class="toc">11.8.2 The Query Option</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.9"/><a href="#sec:run-sim:loading-extra-libraries" class="toc">11.9 Loading Extra Libraries</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.10"/><a href="#sec:run-sim:stopping-condition" class="toc">11.10 Stopping Condition</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.11"/><a href="#sec:run-sim:output-control" class="toc">11.11 Controlling the Output</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.12"/><a href="#sec:run-sim:debugging-support" class="toc">11.12 Debugging</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.13"/><a href="#sec:run-sim:leaked-messages" class="toc">11.13 Debugging Leaked Messages</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.14"/><a href="#sec:run-sim:memory-leaks-and-crashes" class="toc">11.14 Debugging Other Memory Problems</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.15"/><a href="#sec:run-sim:profiling" class="toc">11.15 Profiling</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.16"/><a href="#sec:run-sim:checkpointing" class="toc">11.16 Checkpointing</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.17"/><a href="#sec:run-sim:cmdenv" class="toc">11.17 Using Cmdenv</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.17.1"/><a href="#sec:run-sim:cmdenv:sample-output" class="toc">11.17.1 Sample Output</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.17.2"/><a href="#sec:run-sim:cmdenv-config-options" class="toc">11.17.2 Selecting Runs, Batch Operation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.17.3"/><a href="#sec:run-sim:cmdenv:express-mode" class="toc">11.17.3 Express Mode</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.17.4"/><a href="#sec:run-sim:cmdenv:other-options" class="toc">11.17.4 Other Options</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.18"/><a href="#sec:run-sim:qtenv" class="toc">11.18 The Qtenv Graphical User Interface</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.18.1"/><a href="#sec:run-sim:qtenv-options" class="toc">11.18.1 Command-Line and Configuration Options</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.19"/><a href="#sec:run-sim:tkenv" class="toc">11.19 The Tkenv Graphical User Interface</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.19.1"/><a href="#sec:run-sim:tkenv-options" class="toc">11.19.1 Command-Line and Configuration Options</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.20"/><a href="#sec:run-sim:simulation-campaigns" class="toc">11.20 Running Simulation Campaigns</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.20.1"/><a href="#sec:run-sim:campaigns-naive-approach" class="toc">11.20.1 The Naive Approach</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.20.2"/><a href="#sec:run-sim:batches-using-opp-runall" class="toc">11.20.2 Using opp_runall</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.20.3"/><a href="#sec:run-sim:opp-runall:exploiting-clusters" class="toc">11.20.3 Exploiting Clusters</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.21"/><a href="#sec:run-sim:akaroa" class="toc">11.21 Akaroa Support: Multiple Replications in Parallel</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.21.1"/><a href="#sec:run-sim:akaroa-introduction" class="toc">11.21.1 Introduction</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.21.2"/><a href="#sec:run-sim:what-is-akaroa" class="toc">11.21.2 What Is Akaroa</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.21.3"/><a href="#sec:run-sim:using-akaroa" class="toc">11.21.3 Using Akaroa with OMNeT++</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_12"/><a href="#cha:ana-sim" class="toc">12 Result Recording and Analysis</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.1"/><a href="#sec:ana-sim:result-recording" class="toc">12.1 Result Recording</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.1.1"/><a href="#sec:ana-sim:signals-and-statistics" class="toc">12.1.1 Using Signals and Declared Statistics</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.1.2"/><a href="#sec:ana-sim:direct-result-recording" class="toc">12.1.2 Direct Result Recording</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2"/><a href="#sec:ana-sim:config-results" class="toc">12.2 Configuring Result Collection</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.1"/><a href="#sec:ana-sim:result-file-names" class="toc">12.2.1 Result File Names</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.2"/><a href="#sec:ana-sim:disabling-result-items" class="toc">12.2.2 Enabling/Disabling Result Items</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.3"/><a href="#sec:ana-sim:configuring-recording-modes" class="toc">12.2.3 Selecting Recording Modes for Signal-Based Statistics</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.4"/><a href="#sec:ana-sim:warmup-period" class="toc">12.2.4 Warm-up Period</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.5"/><a href="#sec:ana-sim:vector-recording-intervals" class="toc">12.2.5 Output Vectors Recording Intervals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.6"/><a href="#sec:ana-sim:vector-eventnum-recording" class="toc">12.2.6 Recording Event Numbers in Output Vectors</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.7"/><a href="#sec:ana-sim:saving-parameters-as-scalars" class="toc">12.2.7 Saving Parameters as Scalars</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.8"/><a href="#sec:ana-sim:outputfile-precision" class="toc">12.2.8 Recording Precision</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.3"/><a href="#sec:ana-sim:omnetpp-result-file-format" class="toc">12.3 The OMNeT++ Result File Format</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.3.1"/><a href="#sec:ana-sim:output-vector-files" class="toc">12.3.1 Output Vector Files</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.3.2"/><a href="#sec:ana-sim:scalar-result-files" class="toc">12.3.2 Scalar Result Files</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.4"/><a href="#sec:ana-sim:sqlite-result-files" class="toc">12.4 SQLite Result Files</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.5"/><a href="#sec:ana-sim:scavetool" class="toc">12.5 Scavetool</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.5.1"/><a href="#sec:ana-sim:scavetool:commands" class="toc">12.5.1 Commands</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.5.2"/><a href="#sec:ana-sim:scavetool:examples" class="toc">12.5.2 Examples</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6"/><a href="#sec:ana-sim:result-analysis" class="toc">12.6 Result Analysis</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.1"/><a href="#sec:ana-sim:analysis-tool" class="toc">12.6.1 The Analysis Tool in the Simulation IDE</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.2"/><a href="#sec:ana-sim:spreadsheet-programs" class="toc">12.6.2 Spreadsheets</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.3"/><a href="#sec:ana-sim:using-python" class="toc">12.6.3 Using Python for Result Analysis</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.4"/><a href="#sec:ana-sim:alternative-tools" class="toc">12.6.4 Using Other Software</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_13"/><a href="#cha:eventlog" class="toc">13 Eventlog</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.1"/><a href="#sec:eventlog:introduction" class="toc">13.1 Introduction</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2"/><a href="#sec:eventlog:configuration" class="toc">13.2 Configuration</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2.1"/><a href="#sec:eventlog:file-name" class="toc">13.2.1 File Name</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2.2"/><a href="#sec:eventlog:recording-intervals" class="toc">13.2.2 Recording Intervals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2.3"/><a href="#sec:eventlog:recording-modules" class="toc">13.2.3 Recording Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2.4"/><a href="#sec:eventlog:recording-messages" class="toc">13.2.4 Recording Message Data</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.3"/><a href="#sec:eventlog:eventlog-tool" class="toc">13.3 Eventlog Tool</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.3.1"/><a href="#sec:eventlog:filter" class="toc">13.3.1 Filter</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.3.2"/><a href="#sec:eventlog:echo" class="toc">13.3.2 Echo</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_14"/><a href="#cha:neddoc" class="toc">14 Documenting NED and Messages</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.1"/><a href="#sec:neddoc:overview" class="toc">14.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.2"/><a href="#sec:neddoc:documentation-comments" class="toc">14.2 Documentation Comments</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.2.1"/><a href="#sec:neddoc:private-comments" class="toc">14.2.1 Private Comments</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.2.2"/><a href="#sec:neddoc:comment-placement" class="toc">14.2.2 More on Comment Placement</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.3"/><a href="#sec:neddoc:referring-to-other-ned-and-message-types" class="toc">14.3 Referring to Other NED and Message Types</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.3.1"/><a href="#sec:neddoc:automatic-linking" class="toc">14.3.1 Automatic Linking</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.3.2"/><a href="#sec:neddoc:tilde-linking" class="toc">14.3.2 Tilde Linking</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4"/><a href="#sec:neddoc:text-layout-and-formatting" class="toc">14.4 Text Layout and Formatting</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4.1"/><a href="#sec:neddoc:paragraphs-and-lists" class="toc">14.4.1 Paragraphs and Lists</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4.2"/><a href="#sec:neddoc:special-tags" class="toc">14.4.2 Special Tags</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4.3"/><a href="#sec:neddoc:text-formatting-using-html" class="toc">14.4.3 Text Formatting Using HTML</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4.4"/><a href="#sec:neddoc:escaping-html-tags" class="toc">14.4.4 Escaping HTML Tags</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.5"/><a href="#sec:neddoc:customizing-and-adding-pages" class="toc">14.5 Customizing and Adding Pages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.5.1"/><a href="#sec:neddoc:adding-custom-title-page" class="toc">14.5.1 Adding a Custom Title Page</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.5.2"/><a href="#sec:neddoc:adding-extra-pages" class="toc">14.5.2 Adding Extra Pages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.5.3"/><a href="#sec:neddoc:externally-created-pages" class="toc">14.5.3 Incorporating Externally Created Pages</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.6"/><a href="#sec:neddoc:file-inclusion" class="toc">14.6 File Inclusion</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_15"/><a href="#cha:testing" class="toc">15 Testing</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.1"/><a href="#sec:testing:overview" class="toc">15.1 Overview</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.1.1"/><a href="#sec:testing:verification-validation" class="toc">15.1.1 Verification, Validation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.1.2"/><a href="#sec:testing:unit-testing-regression-testing" class="toc">15.1.2 Unit Testing, Regression Testing</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2"/><a href="#sec:testing:opptest" class="toc">15.2 The opp_test Tool</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.1"/><a href="#sec:testing:opptest:introduction" class="toc">15.2.1 Introduction</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.2"/><a href="#sec:testing:opptest:terminology" class="toc">15.2.2 Terminology</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.3"/><a href="#sec:testing:opptest:test-file-syntax" class="toc">15.2.3 Test File Syntax</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.4"/><a href="#sec:testing:opptest:test-description" class="toc">15.2.4 Test Description</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.5"/><a href="#sec:testing:opptest:test-code-generation" class="toc">15.2.5 Test Code Generation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.6"/><a href="#sec:testing:opptest:pass-criteria" class="toc">15.2.6 PASS Criteria</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.7"/><a href="#sec:testing:opptest:extra-processing-steps" class="toc">15.2.7 Extra Processing Steps</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.8"/><a href="#sec:testing:opptest:unresolved" class="toc">15.2.8 Unresolved</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.9"/><a href="#sec:testing:opptest:synopsys" class="toc">15.2.9 opp_test Synopsys</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.10"/><a href="#sec:testing:opptest:writing-control-script" class="toc">15.2.10 Writing the Control Script</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.3"/><a href="#sec:testing:smoke-tests" class="toc">15.3 Smoke Tests</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.4"/><a href="#sec:testing:fingerprint-tests" class="toc">15.4 Fingerprint Tests</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.4.1"/><a href="#sec:testing:fingerprint-computation" class="toc">15.4.1 Fingerprint Computation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.4.2"/><a href="#sec:testing:creating-fingerprint-tests" class="toc">15.4.2 Fingerprint Tests</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.5"/><a href="#sec:testing:unit-tests" class="toc">15.5 Unit Tests</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.6"/><a href="#sec:testing:module-tests" class="toc">15.6 Module Tests</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.7"/><a href="#sec:testing:statistical-tests" class="toc">15.7 Statistical Tests</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.7.1"/><a href="#sec:testing:validation-tests" class="toc">15.7.1 Validation Tests</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.7.2"/><a href="#sec:testing:statistical-regression-tests" class="toc">15.7.2 Statistical Regression Tests</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.7.3"/><a href="#sec:testing:statistical-tests-implementation" class="toc">15.7.3 Implementation</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_16"/><a href="#cha:parallel-exec" class="toc">16 Parallel Distributed Simulation</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.1"/><a href="#sec:parallel-exec:introduction-to-pdes" class="toc">16.1 Introduction to Parallel Discrete Event Simulation</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.2"/><a href="#sec:parallel-exec:assessing-available-parallelism" class="toc">16.2 Assessing Available Parallelism in a Simulation Model</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3"/><a href="#sec:parallel-exec:pdes-support-in-omnetpp" class="toc">16.3 Parallel Distributed Simulation Support in OMNeT++</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.1"/><a href="#sec:parallel-exec:overview" class="toc">16.3.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.2"/><a href="#sec:parallel-exec:parallel-simulation-example" class="toc">16.3.2 Parallel Simulation Example</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.3"/><a href="#sec:parallel-exec:placeholder-modules-proxy-gates" class="toc">16.3.3 Placeholder Modules, Proxy Gates</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.4"/><a href="#sec:parallel-exec:configuration" class="toc">16.3.4 Configuration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.5"/><a href="#sec:parallel-exec:design-of-pdes-support" class="toc">16.3.5 Design of PDES Support in OMNeT++</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_17"/><a href="#cha:plugin-exts" class="toc">17 Customizing and Extending OMNeT++</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.1"/><a href="#sec:plugin-exts:overview" class="toc">17.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2"/><a href="#sec:plugin-exts:configoption" class="toc">17.2 Adding a New Configuration Option</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2.1"/><a href="#sec:plugin-exts:configoption:registration" class="toc">17.2.1 Registration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2.2"/><a href="#sec:plugin-exts:configoption:reading-values" class="toc">17.2.2 Reading the Value</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.3"/><a href="#sec:plugin-exts:simulation-lifetime-listeners" class="toc">17.3 Simulation Lifetime Listeners</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.4"/><a href="#sec:plugin-exts:cevent" class="toc">17.4 cEvent</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.5"/><a href="#sec:plugin-exts:rng" class="toc">17.5 Defining a New Random Number Generator</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.6"/><a href="#sec:plugin-exts:scheduler" class="toc">17.6 Defining a New Event Scheduler</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.7"/><a href="#sec:plugin-exts:fes" class="toc">17.7 Defining a New FES Data Structure</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.8"/><a href="#sec:plugin-exts:fingerprint" class="toc">17.8 Defining a New Fingerprint Algorithm</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.9"/><a href="#sec:plugin-exts:outputscalarmanager" class="toc">17.9 Defining a New Output Scalar Manager</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.10"/><a href="#sec:plugin-exts:outputvectormanager" class="toc">17.10 Defining a New Output Vector Manager</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.11"/><a href="#sec:plugin-exts:eventlogmanager" class="toc">17.11 Defining a New Eventlog Manager</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.12"/><a href="#sec:plugin-exts:snapshotmanager" class="toc">17.12 Defining a New Snapshot Manager</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.13"/><a href="#sec:plugin-exts:configuration-providers" class="toc">17.13 Defining a New Configuration Provider</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.13.1"/><a href="#sec:plugin-exts:configprovider-overview" class="toc">17.13.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.13.2"/><a href="#sec:plugin-exts:configprovider-startup-sequence" class="toc">17.13.2 The Startup Sequence</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.13.3"/><a href="#sec:plugin-exts:configprovider:custom-class" class="toc">17.13.3 Providing a Custom Configuration Class</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.13.4"/><a href="#sec:plugin-exts:custom-reader-for-sectionbasedconfiguration" class="toc">17.13.4 Providing a Custom Reader for SectionBasedConfiguration</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.14"/><a href="#sec:plugin-exts:user-interface" class="toc">17.14 Implementing a New User Interface</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_18"/><a href="#cha:embedding" class="toc">18 Embedding the Simulation Kernel</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.1"/><a href="#sec:embedding:architecture" class="toc">18.1 Architecture</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2"/><a href="#sec:embedding:embedding" class="toc">18.2 Embedding the OMNeT++ Simulation Kernel</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.1"/><a href="#sec:embedding:main-function" class="toc">18.2.1 The main() Function</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.2"/><a href="#sec:embedding:simulate-function" class="toc">18.2.2 The simulate() Function</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.3"/><a href="#sec:embedding:providing-an-environment-object" class="toc">18.2.3 Providing an Environment Object</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.4"/><a href="#sec:embedding:providing-a-configuration-object" class="toc">18.2.4 Providing a Configuration Object</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.5"/><a href="#sec:embedding:loading-ned-files" class="toc">18.2.5 Loading NED Files</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.6"/><a href="#sec:embedding:eliminating-ned-files" class="toc">18.2.6 How to Eliminate NED Files</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.7"/><a href="#sec:embedding:assigning-module-parameters" class="toc">18.2.7 Assigning Module Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.8"/><a href="#sec:embedding:extracting-statistics" class="toc">18.2.8 Extracting Statistics from the Model</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.9"/><a href="#sec:embedding:simulation-loop" class="toc">18.2.9 The Simulation Loop</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.10"/><a href="#sec:embedding:multiple-coexisting-simulations" class="toc">18.2.10 Multiple, Coexisting Simulations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.11"/><a href="#sec:embedding:installing-a-custom-scheduler" class="toc">18.2.11 Installing a Custom Scheduler</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.12"/><a href="#sec:embedding:multi-threaded-programs" class="toc">18.2.12 Multi-Threaded Programs</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_19"/><a href="#cha:ned-ref" class="toc">19 Appendix A&#58; NED Reference</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1"/><a href="#sec:ned-ref:syntax" class="toc">19.1 Syntax</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.1"/><a href="#sec:ned-ref:ned-file-name-extension" class="toc">19.1.1 NED File Name Extension</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.2"/><a href="#sec:ned-ref:ned-file-encoding" class="toc">19.1.2 NED File Encoding</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.3"/><a href="#sec:ned-ref:reserved-words" class="toc">19.1.3 Reserved Words</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.4"/><a href="#sec:ned-ref:identifiers" class="toc">19.1.4 Identifiers</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.5"/><a href="#sec:ned-ref:case-sensitivity" class="toc">19.1.5 Case Sensitivity</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.6"/><a href="#sec:ned-ref:literals" class="toc">19.1.6 Literals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.7"/><a href="#sec:ned-ref:comments" class="toc">19.1.7 Comments</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.8"/><a href="#sec:ned-ref:grammar" class="toc">19.1.8 Grammar</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.2"/><a href="#sec:ned-ref:built-in-defs" class="toc">19.2 Built-in Definitions</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.3"/><a href="#sec:ned-ref:packages" class="toc">19.3 Packages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.3.1"/><a href="#sec:ned-ref:package-declaration" class="toc">19.3.1 Package Declaration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.3.2"/><a href="#sec:ned-ref:directory-structure" class="toc">19.3.2 Directory Structure, package.ned</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4"/><a href="#sec:ned-ref:components" class="toc">19.4 Components</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.1"/><a href="#sec:ned-ref:simple-modules" class="toc">19.4.1 Simple Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.2"/><a href="#sec:ned-ref:compound-modules" class="toc">19.4.2 Compound Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.3"/><a href="#sec:ned-ref:networks" class="toc">19.4.3 Networks</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.4"/><a href="#sec:ned-ref:channels" class="toc">19.4.4 Channels</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.5"/><a href="#sec:ned-ref:module-interfaces" class="toc">19.4.5 Module Interfaces</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.6"/><a href="#sec:ned-ref:channel-interfaces" class="toc">19.4.6 Channel Interfaces</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.7"/><a href="#sec:ned-ref:resolving-cpp-class" class="toc">19.4.7 Resolving the C++ Implementation Class</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.8"/><a href="#sec:ned-ref:properties" class="toc">19.4.8 Properties</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.9"/><a href="#sec:ned-ref:parameters" class="toc">19.4.9 Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.10"/><a href="#sec:ned-ref:pattern-assignments" class="toc">19.4.10 Pattern Assignments</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.11"/><a href="#sec:ned-ref:gates" class="toc">19.4.11 Gates</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.12"/><a href="#sec:ned-ref:submodules" class="toc">19.4.12 Submodules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.13"/><a href="#sec:ned-ref:connections" class="toc">19.4.13 Connections</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.14"/><a href="#sec:ned-ref:connection-groups" class="toc">19.4.14 Conditional and Loop Connections, Connection Groups</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.15"/><a href="#sec:ned-ref:inner-types" class="toc">19.4.15 Inner Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.16"/><a href="#sec:ned-ref:name-uniqueness" class="toc">19.4.16 Name Uniqueness</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.17"/><a href="#sec:ned-ref:param-assignment-order" class="toc">19.4.17 Parameter Assignment Order</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.18"/><a href="#sec:ned-ref:type-name-resolution" class="toc">19.4.18 Type Name Resolution</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.19"/><a href="#sec:ned-ref:parameteric-type-resolution" class="toc">19.4.19 Resolution of Parametric Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.20"/><a href="#sec:ned-ref:implementing-an-interface" class="toc">19.4.20 Implementing an Interface</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.21"/><a href="#sec:ned-ref:inheritance" class="toc">19.4.21 Inheritance</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.22"/><a href="#sec:ned-ref:build-order" class="toc">19.4.22 Network Build Order</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5"/><a href="#sec:ned-ref:expressions" class="toc">19.5 Expressions</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.1"/><a href="#sec:ned-ref:constants" class="toc">19.5.1 Constants</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.2"/><a href="#sec:ned-ref:operators" class="toc">19.5.2 Operators</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.3"/><a href="#sec:ned-ref:referencing-parameters-and-loop-variables" class="toc">19.5.3 Referencing Parameters and Loop Variables</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.4"/><a href="#sec:ned-ref:typename-operator" class="toc">19.5.4 The <b><tt>typename</tt></b> Operator</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.5"/><a href="#sec:ned-ref:index-operator" class="toc">19.5.5 The <b><tt>index</tt></b> Operator</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.6"/><a href="#sec:ned-ref:exists-operator" class="toc">19.5.6 The <b><tt>exists()</tt></b> Operator</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.7"/><a href="#sec:ned-ref:sizeof-operator" class="toc">19.5.7 The <b><tt>sizeof()</tt></b> Operator</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.8"/><a href="#sec:ned-ref:functions" class="toc">19.5.8 Functions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.9"/><a href="#sec:ned-ref:units" class="toc">19.5.9 Units of Measurement</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_20"/><a href="#cha:ned-language-grammar" class="toc">20 Appendix B&#58; NED Language Grammar</A></b></font><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_21"/><a href="#cha:ned-xml-binding" class="toc">21 Appendix C&#58; NED XML Binding</A></b></font><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_22"/><a href="#cha:ned-functions" class="toc">22 Appendix D&#58; NED Functions</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.1"/><a href="#sec:ned-functions:category-conversion" class="toc">22.1 Category "conversion":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.2"/><a href="#sec:ned-functions:category-math" class="toc">22.2 Category "math":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.3"/><a href="#sec:ned-functions:category-misc" class="toc">22.3 Category "misc":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.4"/><a href="#sec:ned-functions:category-ned" class="toc">22.4 Category "ned":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.5"/><a href="#sec:ned-functions:category-random-continuous" class="toc">22.5 Category "random/continuous":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.6"/><a href="#sec:ned-functions:category-random-discrete" class="toc">22.6 Category "random/discrete":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.7"/><a href="#sec:ned-functions:category-strings" class="toc">22.7 Category "strings":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.8"/><a href="#sec:ned-functions:category-units" class="toc">22.8 Category "units":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.9"/><a href="#sec:ned-functions:category-units-conversion" class="toc">22.9 Category "units/conversion":</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_22.10"/><a href="#sec:ned-functions:category-xml" class="toc">22.10 Category "xml":</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_23"/><a href="#cha:msg-language-grammar" class="toc">23 Appendix E&#58; Message Definitions Grammar</A></b></font><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_24"/><a href="#cha:display-strings" class="toc">24 Appendix F&#58; Display String Tags</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_24.1"/><a href="#sec:display-strings:module-and-connection-display-strings" class="toc">24.1 Module and Connection Display String Tags</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_24.2"/><a href="#sec:display-strings:message-display-strings" class="toc">24.2 Message Display String Tags</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_25"/><a href="#cha:figure-definitions" class="toc">25 Appendix G&#58; Figure Definitions</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_25.1"/><a href="#sec:figure-definitions:figure-types" class="toc">25.1 Built-in Figure Types</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_25.2"/><a href="#sec:figure-definitions:attribute-types" class="toc">25.2 Attribute Types</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_25.3"/><a href="#sec:figure-definitions:figure-attributes" class="toc">25.3 Figure Attributes</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_26"/><a href="#cha:config-options" class="toc">26 Appendix H&#58; Configuration Options</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.1"/><a href="#sec:config-options:config-options" class="toc">26.1 Configuration Options</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.2"/><a href="#sec:config-options:predefined-variables" class="toc">26.2 Predefined Variables</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_27"/><a href="#cha:result-file-formats" class="toc">27 Appendix I&#58; Result File Formats</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1"/><a href="#cha:result-file-formats:opp" class="toc">27.1 Native Result Files</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.1"/><a href="#sec:result-file-formats:opp:version" class="toc">27.1.1 Version</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.2"/><a href="#sec:result-file-formats:opp:run-declaration" class="toc">27.1.2 Run Declaration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.3"/><a href="#sec:result-file-formats:opp:attributes" class="toc">27.1.3 Attributes</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.4"/><a href="#sec:result-file-formats:opp:module-parameters" class="toc">27.1.4 Module Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.5"/><a href="#sec:result-file-formats:opp:scalar-data" class="toc">27.1.5 Scalar Data</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.6"/><a href="#sec:result-file-formats:opp:vector-declaration" class="toc">27.1.6 Vector Declaration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.7"/><a href="#sec:result-file-formats:opp:vector-data" class="toc">27.1.7 Vector Data</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.8"/><a href="#sec:result-file-formats:opp:index-header" class="toc">27.1.8 Index Header</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.9"/><a href="#sec:result-file-formats:opp:index-data" class="toc">27.1.9 Index Data</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.10"/><a href="#sec:result-file-formats:opp:statistics-object" class="toc">27.1.10 Statistics Object</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.11"/><a href="#sec:result-file-formats:opp:field" class="toc">27.1.11 Field</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1.12"/><a href="#sec:result-file-formats:opp:histogram-bin" class="toc">27.1.12 Histogram Bin</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.2"/><a href="#cha:result-file-formats:sqlite" class="toc">27.2 SQLite Result Files</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_28"/><a href="#cha:eventlog-file-format" class="toc">28 Appendix J&#58; Eventlog File Format</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_28.1"/><a href="#sec:eventlog-file-format:entry-types" class="toc">28.1 Supported Entry Types and Their Attributes</A></b><br>
</p><hr class='pgbr'><h1><a name="cha:introduction"/>1 Introduction<a class="headerlink" href="#cha:introduction" title="Permalink to this headline"></a></h1>

<p>
<h2><a name="sec:introduction:what-is-omnetpp"/>1.1 What Is OMNeT++?<a class="headerlink" href="#sec:introduction:what-is-omnetpp" title="Permalink to this headline"></a></h2>

<p>OMNeT++ is an object-oriented modular discrete event network simulation
framework. It has a generic architecture, so it can be (and has been)
used in various problem domains:

<p><ul>
  <li> modeling of wired and wireless communication networks
  <li> protocol modeling
  <li> modeling of queueing networks
  <li> modeling of multiprocessors and other distributed hardware systems
  <li> validating of hardware architectures
  <li> evaluating performance aspects of complex software systems
  <li> in general, modeling and simulation of any system where the
        discrete event approach is suitable, and can be conveniently
        mapped into entities communicating by exchanging messages.
</ul>

<p>OMNeT++ itself is not a simulator of anything concrete, but rather
provides infrastructure and tools for <i>writing</i> simulations. One of
the fundamental ingredients of this infrastructure is a component
architecture for simulation models. Models are assembled from reusable
components termed <i>modules</i>. Well-written modules are truly reusable,
and can be combined in various ways like LEGO blocks.

<p>Modules can be connected with each other via gates (other systems would
call them ports), and combined to form compound modules. The depth of
module nesting is not limited. Modules communicate through message passing,
where messages may carry arbitrary data structures. Modules can pass
messages along predefined paths via gates and connections, or directly to
their destination; the latter is useful for wireless simulations, for
example. Modules may have parameters that can be used to customize module
behavior and/or to parameterize the model's topology.
Modules at the lowest level of the module hierarchy are called
simple modules, and they encapsulate model behavior. Simple modules
are programmed in C++, and make use of the simulation library.

<p>OMNeT++ simulations can be run under various user interfaces.
Graphical, animating user interfaces are highly useful for
demonstration and debugging purposes, and command-line user
interfaces are best for batch execution.

<p>The simulator as well as user interfaces and tools are highly portable.
They are tested on the most common operating systems (Linux, Mac OS/X,
Windows), and they can be compiled out of the box or after trivial
modifications on most Unix-like operating systems.

<p>OMNeT++ also supports parallel distributed simulation. OMNeT++ can
use several mechanisms for communication between partitions of
a parallel distributed simulation, for example MPI or named pipes.
The parallel simulation algorithm can easily be extended, or new
ones can be plugged in. Models do not need any special instrumentation
to be run in parallel -- it is just a matter of configuration.
OMNeT++ can even be used for classroom presentation of parallel
simulation algorithms, because simulations can be run in parallel
even under the GUI that provides detailed feedback on what is going on.

<p>OMNEST is the commercially supported version of OMNeT++.
OMNeT++ is free only for academic and non-profit use;
for commercial purposes, one needs to obtain OMNEST licenses
from Simulcraft Inc.

<p>

<h2><a name="sec:introduction:organization-of-this-manual"/>1.2 Organization of This Manual<a class="headerlink" href="#sec:introduction:organization-of-this-manual" title="Permalink to this headline"></a></h2>

<p>The manual is organized as follows:

<p><ul>
  <li> The Chapters <a href="#cha:introduction">[1]</a> and <a href="#cha:overview">[2]</a>
    contain introductory material.
  <li> The second group of chapters, <a href="#cha:ned-lang">[3]</a>, <a href="#cha:simple-modules">[4]</a> and
    <a href="#cha:sim-lib">[7]</a> are the programming guide. They present the
    NED language<!--ned!language-->, describe the simulation concepts
    and their implementation in OMNeT++, explain how to write
    simple<!--module!simple--> modules, and describe the class library.
  <li> The chapters <a href="#cha:graphics">[8]</a> and <a href="#cha:neddoc">[14]</a>explain how to customize
    the network graphics and how to write NED source code comments
    from which documentation can be generated.
  <li> Chapters <a href="#cha:build-sim-progs">[9]</a>,
    <a href="#cha:config-sim">[10]</a>, <a href="#cha:run-sim">[11]</a> and <a href="#cha:ana-sim">[12]</a> deal with
    practical issues like building and running simulations and analyzing results, and
    describe the tools OMNeT++ provides to support these tasks.
  <li> Chapter <a href="#cha:parallel-exec">[16]</a> is devoted to the support
    of distributed execution.
  <li> Chapters <a href="#cha:plugin-exts">[17]</a> and <a href="#cha:embedding">[18]</a>
    explain the architecture and internals of OMNeT++, as well as
    ways to extend it and embed it into larger applications.
  <li> The appendices provide a reference on the NED language,
    configuration options, file formats, and other details.
</ul>

<p>


<p><a name="sec:introduction:history"></a>

<a name="sec:introduction:credits"></a>


<hr class='pgbr'><h1><a name="cha:overview"/>2 Overview<a class="headerlink" href="#cha:overview" title="Permalink to this headline"></a></h1>

<p>
<h2><a name="sec:overview:modeling-concepts"/>2.1 Modeling Concepts<a class="headerlink" href="#sec:overview:modeling-concepts" title="Permalink to this headline"></a></h2>

<p>An OMNeT++ model consists of modules that communicate with message passing.
The active modules are termed <i>simple modules</i>; they are written in C++,
using the simulation class library. Simple modules can be grouped into
<i>compound modules</i> and so forth; the number of hierarchy levels is
unlimited. The whole model, called network in OMNeT++, is itself a compound module.
Messages can be sent either via connections that span
modules or directly to other modules. The concept of simple and
compound modules is similar to DEVS atomic and coupled models.

<p>In Fig. <a href="#fig:ch-overview:modules">below</a>, boxes represent simple modules
(gray background) and compound modules.
Arrows connecting small boxes represent connections and gates.

<p>
  <center>
    <img src="over-modules.svg">
    <center><div class="caption"><i>Figure: Simple and compound modules</i></div></center>
    <a name="fig:ch-overview:modules"></a>
  </center>

<p>

<p>Modules communicate with messages that may contain arbitrary
data, in addition to usual attributes such as a timestamp.
Simple modules typically send messages via gates, but it is also
possible to send them directly to their destination modules. Gates are the
input and output interfaces of modules: messages are sent through
output gates and arrive through input gates. An input gate and output gate
can be linked by a connection. Connections are created within a single
level of module hierarchy; within a compound module, corresponding gates of
two submodules, or a gate of one submodule and a gate of the compound
module can be connected. Connections spanning hierarchy levels are
not permitted, as they would hinder model reuse. Because of the hierarchical
structure of the model, messages typically travel through a chain of
connections, starting and arriving in simple modules. Compound modules act like
"cardboard boxes" in the model, transparently relaying messages between
their inner realm and the outside world. Parameters such as propagation delay,
data rate and bit error rate, can be assigned to connections. One can also
define connection types with specific properties (termed channels) and
reuse them in several places. Modules can have parameters. Parameters are
used mainly to pass configuration data to simple modules, and to help
define model topology. Parameters can take string, numeric, or boolean
values. Because parameters are represented as objects in the program,
parameters -- in addition to holding constants -- may transparently act as
sources of random numbers, with the actual distributions provided with the
model configuration. They may interactively prompt the user for the value,
and they might also hold expressions referencing other parameters. Compound
modules may pass parameters or expressions of parameters to their
submodules.

<p>
OMNeT++ provides efficient tools for the user to describe the
structure of the actual system. Some of the main features are the following:
<ul>
<li> hierarchically nested modules
<li> modules are instances of module types
<li> modules communicate with messages through channels
<li> flexible module parameters
<li> topology description language
</ul>

<p><h3><a name="sec:overview:hierarchical-modules"/>2.1.1 Hierarchical Modules<a class="headerlink" href="#sec:overview:hierarchical-modules" title="Permalink to this headline"></a></h3>

<p>
An OMNeT++ model consists of hierarchically nested
modules<!--module!hierarchy--> that communicate by passing
messages to each other.
OMNeT++ models are often referred to as <i>networks</i>. The top
level module is the <i>system module</i>.  The system module
contains <i>submodules</i> that can also contain submodules
themselves (Fig. <a href="#fig:ch-overview:modules">below</a>). The depth of module
nesting is unlimited, allowing the user to reflect the logical
structure of the actual system in the model structure.

<p>Model structure is described in OMNeT++'s NED language.

<p>Modules that contain submodules are termed <i>compound
  modules</i><!--module!compound-->, as opposed to <i>simple
  modules</i><!--module!simple--> at the lowest level of the
module hierarchy. Simple modules contain the algorithms of the model.
The user implements the simple modules in C++, using the OMNeT++
simulation class library.

<p>
<h3><a name="sec:overview:module-types"/>2.1.2 Module Types<a class="headerlink" href="#sec:overview:module-types" title="Permalink to this headline"></a></h3>
<!--module!types-->

<p>Both simple and compound modules are instances of <i>module
  types</i>. In describing the model, the user defines module types;
instances of these module types serve as components for more complex
module types. Finally, the user creates the system module as an
instance of a previously defined module type; all modules of the
network are instantiated as submodules and sub-submodules of the
system module.

<p>When a module type is used as a building block, it makes no difference
whether it is a simple or compound module. This allows
the user to split a simple module into several
simple modules embedded into a compound<!--module!compound--> module,
or vice versa, to aggregate the functionality of a compound module into a
single simple module, without affecting existing users of the module
type.

<p>Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create <i>component libraries</i><!--module!libraries-->. This feature
will be discussed later, in chapter <a href="#cha:run-sim">[11]</a>.

<p>

<p><h3><a name="sec:overview:messages-gates-links"/>2.1.3 Messages, Gates, Links<a class="headerlink" href="#sec:overview:messages-gates-links" title="Permalink to this headline"></a></h3>

<p>Modules communicate by exchanging
<i>messages</i><!--message!exchanging-->. In an actual simulation,
messages can represent frames or packets in a computer network, jobs
or customers in a queuing network or other types of mobile entities.
Messages can contain arbitrarily complex data structures. Simple
modules can send messages either directly to their destination or
along a predefined path, through gates and connections.

<p>
The &#8220;local simulation time&#8221; of a module advances when the module
receives a message. The message can arrive from another module
or from the same module (<i>self-messages</i> are used to implement
timers).

<p>
<i>Gates</i><!--gate--> are the input and output interfaces of
modules; messages are sent out through output gates and arrive through
input gates.

<p>Each <i>connection</i><!--connection--> (also called
<i>link</i><!--link-->) is created within a single level of the
module hierarchy: within a compound module, one can connect the
corresponding gates of two submodules, or a gate of one submodule and
a gate of the compound module (Fig.
<a href="#fig:ch-overview:modules">below</a>).

<p>Because of the hierarchical structure of the model, messages typically
travel through a series of connections, starting and arriving in simple
modules. Compound modules act like &#8220;cardboard boxes&#8221; in the model,
transparently relaying messages between their inner realm and the
outside world.

<p>
<h3><a name="sec:overview:modeling-of-packet-transmissions"/>2.1.4 Modeling of Packet Transmissions<a class="headerlink" href="#sec:overview:modeling-of-packet-transmissions" title="Permalink to this headline"></a></h3>

<p>To facilitate the modeling of communication networks, connections
can be used to model physical links. Connections support
the following parameters: <i>data rate</i>, <i>propagation delay</i>,
<i>bit error rate</i> and <i>packet error rate</i>, and may be
disabled. These parameters and the underlying algorithms are encapsulated
into <i>channel</i> objects. The user can parameterize the channel
types provided by OMNeT++, and also create new ones.

<p>When data rates are in use, a packet object is by default delivered to the
target module at the simulation time that corresponds to the end of the
packet reception. Since this behavior is not suitable for the modeling of
some protocols (e.g. half-duplex Ethernet), OMNeT++ provides the possibility
for the target module to specify that it wants the packet object to be
delivered to it when the packet reception starts.

<p>
<h3><a name="sec:overview:parameters"/>2.1.5 Parameters<a class="headerlink" href="#sec:overview:parameters" title="Permalink to this headline"></a></h3>
<!--module!parameters-->
<!--parameters|seemodule parameters-->

<p>Modules can have parameters. Parameters can be assigned  in either
the NED files or the configuration file <tt>omnetpp.ini</tt>.

<p>Parameters can be used to customize simple module behavior,
and to parameterize the model topology.

<p>Parameters can take string, numeric or boolean values, or can
contain XML data trees. Numeric values include expressions using
other parameters and calling C functions, random variables from
different distributions, and values input interactively by the user.

<p>Numeric-valued parameters can be used to construct topologies in a
flexible way. Within a compound module, parameters can define the
number of submodules, number of gates, and the way the internal
connections are made.

<p>
<h3><a name="sec:overview:topology-description-method"/>2.1.6 Topology Description Method<a class="headerlink" href="#sec:overview:topology-description-method" title="Permalink to this headline"></a></h3>
<!--topology!description-->

<p>The user defines the structure of the model in NED language descriptions
(Network Description). The NED language will be discussed in detail
in chapter <a href="#cha:ned-lang">[3]</a>.

<p>
<h2><a name="sec:overview:programmable-using-cplusplus"/>2.2 Programming the Algorithms<a class="headerlink" href="#sec:overview:programmable-using-cplusplus" title="Permalink to this headline"></a></h2>

<p>The simple<!--module!simple--> modules of a model contain algorithms
as C++ functions.
The full flexibility and power of the programming language can
be used, supported by the OMNeT++ simulation class library.
The simulation programmer can choose between event-driven and process-style
description, and freely use object-oriented concepts
(inheritance, polymorphism etc) and design patterns to extend the
functionality of the simulator.

<p>Simulation objects (messages, modules, queues etc.) are represented
by C++ classes. They have been designed to work together efficiently,
creating a powerful simulation programming framework.
The following classes are part of the simulation class library:

<p><ul>
  <li> module, gate, parameter, channel
  <li> message, packet
  <li> container classes (e.g. queue, array)
  <li> data collection classes
  <li>statistic and distribution estimation classes (histograms, <i>P<sup>2</sup></i>
        algorithm for calculating quantiles etc.)
</ul>

<p>The classes are also specially instrumented, allowing one
to traverse objects of a running simulation and display information
about them such as name, class name, state variables or contents.
This feature makes it possible to create a simulation GUI where
all internals of the simulation are visible.

<p>


<p><h2><a name="sec:overview:using-omnetpp"/>2.3 Using OMNeT++<a class="headerlink" href="#sec:overview:using-omnetpp" title="Permalink to this headline"></a></h2>

<p>
<h3><a name="sec:overview:building-and-running-simulations"/>2.3.1 Building and Running Simulations<a class="headerlink" href="#sec:overview:building-and-running-simulations" title="Permalink to this headline"></a></h3>
<!--simulation!building-->
<!--simulation!running-->

<p>This section provides insights into working with OMNeT++ in practice.
Issues such as model files and compiling and running simulations are
discussed.

<p>An OMNeT++ model consists of the following parts:
<ul>
  <li>NED language topology description(s)<!--ned!files--> (<tt>.ned</tt> files)
    that describe the module structure with parameters, gates, etc.
    NED files can be written using any text editor, but the OMNeT++ IDE
    provides excellent support for two-way graphical and text editing.
  <li>Message definitions (<tt>.msg</tt> files) that let one define message
    types and add data fields to them. OMNeT++ will translate message definitions
    into full-fledged C++ classes.
  <li>Simple module sources. They are C++ files, with <tt>.h</tt>/<tt>.cc</tt> suffix.
</ul>

<p>The simulation system provides the following components:
<ul>
  <li>Simulation kernel<!--simulation!kernel-->. This contains the
    code that manages the simulation and the simulation class library.
    It is written in C++, compiled into a shared or static library.
  <li>User interfaces<!--simulation!user interface-->.
    <!--user interface--> OMNeT++ user interfaces
    are used in simulation execution, to facilitate debugging,
    demonstration, or batch execution of simulations. They are
    written in C++, compiled into libraries.
</ul>

<p>
Simulation programs are built from the above components. First,
<tt>.msg</tt> files are translated into C++ code using the <tt>opp_msgc</tt>.
program. Then all C++ sources are compiled and linked with the simulation
kernel and a user interface library to form a simulation executable or
shared library. NED files<!--ned!files--> are loaded dynamically in their original
text forms when the simulation program starts.

<p>
<h4><a name="sec:overview:running-simulation-and-analyzing-results"/>2.3.1.1 Running the Simulation and Analyzing the Results<a class="headerlink" href="#sec:overview:running-simulation-and-analyzing-results" title="Permalink to this headline"></a></h4>

<p>The simulation may be compiled as a standalone program executable,
or as a shared library to be run using OMNeT++'s <tt>opp_run</tt> utility.
When the program is started, it first reads the NED files<!--ned!files-->,
then the configuration file<!--simulation!configuration file--> usually called
<tt>omnetpp.ini</tt>. The configuration file contains settings that
control how the simulation is executed, values for model parameters, etc.
The configuration file can also prescribe several simulation runs; in
the simplest case, they will be executed by the simulation program one
after another.

<p>The output of the simulation is written into result files: output vector
files<!--output!vector file-->, output scalar files<!--output!scalar file-->,
and possibly the user's own output files.
OMNeT++ contains an Integrated Development Environment (IDE) that provides
rich environment for analyzing these files. Output files are line-oriented
text files which makes it possible to process them with a variety of tools
and programming languages as well, including Matlab, GNU R, Perl, Python,
and spreadsheet programs.

<p>
<h4><a name="sec:overview:user-interfaces"/>2.3.1.2 User Interfaces<a class="headerlink" href="#sec:overview:user-interfaces" title="Permalink to this headline"></a></h4>
<!--simulation!user interface-->

<p>The primary purpose of user interfaces is to make the internals
of the model visible to the user, to control simulation execution,
and possibly allow the user to intervene by changing variables/objects
inside the model. This is very important in the development/debugging
phase of the simulation project. Equally important, a hands-on
experience allows the user to get a feel of the model's
behavior. The graphical user interface can also be used to
demonstrate a model's operation.

<p>
The same simulation model can be executed with various user
interfaces, with no change in the model files themselves.
The user would typically test and debug the simulation with a powerful
graphical user interface, and finally run it with a simple,
fast user interface that supports batch execution.

<p>
<h4><a name="sec:overview:component-libraries"/>2.3.1.3 Component Libraries<a class="headerlink" href="#sec:overview:component-libraries" title="Permalink to this headline"></a></h4>
<!--module!libraries-->

<p>Module types can be stored in files separate from the place
of their actual use, enabling the user to group existing
module types and create component libraries.

<p>
<h4><a name="sec:overview:universal-standalone-simulation-programs"/>2.3.1.4 Universal Standalone Simulation Programs<a class="headerlink" href="#sec:overview:universal-standalone-simulation-programs" title="Permalink to this headline"></a></h4>

<p>
A simulation executable can store several independent models
that use the same set of simple modules. The user can specify
in the configuration file which model is to be run. This
allows one to build one large executable that contains several
simulation models, and distribute it as a standalone simulation
tool. The flexibility of the topology description language also
supports this approach.

<p>
<h3><a name="sec:overview:what-is-in-distribution"/>2.3.2 What Is in the Distribution<a class="headerlink" href="#sec:overview:what-is-in-distribution" title="Permalink to this headline"></a></h3>

<p>An OMNeT++ installation contains the following subdirectories. Depending
on the platform, there may also be additional directories present, containing
software bundled with OMNeT++.)

<p>The simulation system itself:

<p><pre class="verbatim">
  <b>omnetpp/</b>         OMNeT++ root directory
    <b>bin/</b>           OMNeT++ executables
    <b>include/</b>       header files for simulation models
    <b>lib/</b>           library files
    <b>images/</b>        icons and backgrounds for network graphics
    <b>doc/</b>           manuals, readme files, license, APIs, etc.
      <b>ide-customization-guide/</b> how to write new wizards for the IDE
      <b>ide-developersguide/</b> writing extensions for the IDE
      <b>manual/</b>      manual in HTML
      <b>ned2/</b>        DTD definition of the XML syntax for NED files
      <b>tictoc-tutorial/</b>  introduction into using OMNeT++
      <b>api/</b>         API reference in HTML
      <b>nedxml-api/</b>  API reference for the NEDXML library
      <b>parsim-api/</b>  API reference for the parallel simulation library
    <b>src/</b>           OMNeT++ sources
      <b>sim/</b>         simulation kernel
        <b>parsim/</b>    files for distributed execution
        <b>netbuilder/</b>files for dynamically reading NED files
      <b>envir/</b>       common code for user interfaces
      <b>cmdenv/</b>      command-line user interface
      <b>tkenv/</b>       Tcl/Tk-based user interface
      <b>qtenv/</b>       Qt-based user interface
      <b>nedxml/</b>      NEDXML library, nedtool, opp_msgc
      <b>scave/</b>       result analysis library
      <b>eventlog/</b>    eventlog processing library
      <b>layout/</b>      graph layouter for network graphics
      <b>common/</b>      common library
      <b>utils/</b>       opp_makemake, opp_test, etc.
    <b>test/</b>          regression test suite
      <b>core/</b>        tests for the simulation library
      <b>anim/</b>        tests for graphics and animation
      <b>dist/</b>        tests for the built-in distributions
      <b>makemake/</b>    tests for opp_makemake
      ...
</pre>

<p>The Eclipse-based Simulation IDE is in the <tt>ide</tt> directory.

<p><pre class="verbatim">
    <b>ide/</b>           Simulation IDE
      <b>features/</b>    Eclipse feature definitions
      <b>plugins/</b>     IDE plugins (extensions to the IDE can be dropped here)
      ...
</pre>

<p>The Windows version of OMNeT++ contains a redistribution of the MinGW
gcc compiler, together with a copy of MSYS that provides Unix tools
commonly used in Makefiles. The MSYS directory also contains various
3rd party open-source libraries needed to compile and run OMNeT++.

<p><pre class="verbatim">
    <b>tools/</b>       Platform specific tools and compilers (e.g. MinGW/MSYS on Windows)
</pre>

<p>Sample simulations are in the <tt>samples</tt> directory.

<p><pre class="verbatim">
    <b>samples/</b>     directories for sample simulations
      <b>aloha/</b>     models the Aloha protocol
      <b>cqn/</b>       Closed Queueing Network
      ...
</pre>

<p>The <tt>contrib</tt> directory contains material from the OMNeT++ community.

<p><pre class="verbatim">
    <b>contrib/</b>     directory for contributed material
      <b>akaroa/</b>    Patch to compile akaroa on newer gcc systems
      <b>topologyexport/</b>  Export the topology of a model in runtime
      ...
</pre>

<p>

<hr class='pgbr'><h1><a name="cha:ned-lang"/>3 The NED Language<a class="headerlink" href="#cha:ned-lang" title="Permalink to this headline"></a></h1>

<p>
<h2><a name="sec:ned-lang:ned-overview"/>3.1 NED Overview<a class="headerlink" href="#sec:ned-lang:ned-overview" title="Permalink to this headline"></a></h2>

<p>The user describes the structure of a simulation model in the NED language. NED
stands for Network Description. NED lets the user declare simple modules, and
connect and assemble them into compound modules. The user can label some compound
modules as <i>networks</i>; that is, self-contained simulation models. Channels are
another component type, whose instances can also be used in compound modules.

<p>The NED language has several features which let it scale well to large projects:

<p><ul class="dl">

<p><li><b>Hierarchical.</b>  The traditional way to deal with complexity is by
introducing hierarchies. In OMNeT++, any module which would be too complex as
a single entity can be broken down into smaller modules, and used as a
compound module.

<p><li><b>Component-Based.</b>  Simple modules and compound modules are inherently
reusable, which not only reduces code copying, but more importantly, allows
component libraries (like the INET Framework, MiXiM, Castalia, etc.) to
exist.

<p><li><b>Interfaces.</b>  Module and channel interfaces can be used as a
placeholder where normally a module or channel type would be used, and the
concrete module or channel type is determined at network setup time by a
parameter. Concrete module types have to &#8220;implement&#8221; the interface they
can substitute. For example, given a compound module type named
<tt>MobileHost</tt> contains a <tt>mobility</tt> submodule of the type
<tt>IMobility</tt> (where <tt>IMobility</tt> is a module interface), the actual
type of <tt>mobility</tt> may be chosen from the module types that implemented
<tt>IMobility</tt> (<tt>RandomWalkMobility</tt>, <tt>TurtleMobility</tt>, etc.)

<p><li><b>Inheritance.</b>  Modules and channels can be subclassed. Derived modules
and channels may add new parameters, gates, and (in the case of compound
modules) new submodules and connections. They may set existing parameters
to a specific value, and also set the gate size of a gate vector. This
makes it possible, for example, to take a <tt>GenericTCPClientApp</tt> module
and derive an <tt>FTPClientApp</tt> from it by setting certain parameters to a fixed
value; or to derive a <tt>WebClientHost</tt> compound module from a
<tt>BaseHost</tt> compound module by adding a <tt>WebClientApp</tt> submodule and
connecting it to the inherited <tt>TCP</tt> submodule.

<p><li><b>Packages.</b>  The NED language features a Java-like package structure,
to reduce the risk of name clashes between different models. <tt>NEDPATH</tt>
(similar to Java's <tt>CLASSPATH</tt>) has also been introduced to make it easier
to specify dependencies among simulation models.

<p><li><b>Inner types.</b>  Channel types and module types used locally by a
compound module can be defined within the compound module, in order to
reduce namespace pollution.

<p><li><b>Metadata annotations.</b>  It is possible to annotate module or channel
types, parameters, gates and submodules by adding properties. Metadata are
not used by the simulation kernel directly, but they can carry extra
information for various tools, the runtime environment, or even for other
modules in the model. For example, a module's graphical representation
(icon, etc)  or the prompt string and measurement unit (milliwatt, etc) of a
parameter are already specified as metadata annotations.

<p></ul>

<p><ul class="note"><b>NOTE</b><br>
    The NED language has changed significantly in the 4.0 version.
    Inheritance, interfaces, packages, inner types, metadata annotations, inout
    gates were all added in the 4.0 release, together with many other features.
    Since the basic syntax has changed as well, old NED files need to be
    converted to the new syntax. There are automated tools for this purpose, so
    manual editing is only needed to take advantage of new NED features.
</ul>

<p>The NED language has an equivalent tree representation which can be
serialized to XML; that is, NED files can be converted to XML and back
without loss of data, including comments. This lowers the barrier for
programmatic manipulation of NED files; for example extracting information,
refactoring and transforming NED, generating NED from information stored in
other systems like SQL databases, and so on.

<p><ul class="note"><b>NOTE</b><br>
    This chapter is going to explain the NED language gradually, via examples.
    A more formal and concise treatment can be found in Appendix <a href="#cha:ned-language-grammar">[20]</a>.
</ul>

<p>
<h2><a name="sec:ned-lang:warmup"/>3.2 NED Quickstart<a class="headerlink" href="#sec:ned-lang:warmup" title="Permalink to this headline"></a></h2>

<p>In this section we introduce the NED language via a complete and
reasonably real-life example: a communication network.

<p>Our hypothetical network consists of nodes. On each node there is an
application running which generates packets at random intervals.
The nodes are routers themselves as well. We assume that the application
uses datagram-based communication, so that we can leave out the
transport layer from the model.

<p>
<h3><a name="sec:ned-lang:warmup:network"/>3.2.1 The Network<a class="headerlink" href="#sec:ned-lang:warmup:network" title="Permalink to this headline"></a></h3>

<p>First we'll define the network, then in the next sections we'll continue
to define the network nodes.

<p>Let the network topology be as in Figure <a href="#fig:ned-routing-topology">below</a>.

<p>
  <center>
    <img src="ned-routing-network.png">
    <center><div class="caption"><i>Figure: The network</i></div></center>
    <a name="fig:ned-routing-topology"></a>
  </center>

<p>
The corresponding NED description would look like this:

<pre class="ned">
//
// A network
//
network Network
{
    submodules:
        node1: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>;
        node2: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>;
        node3: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>;
        ...
    connections:
        node1.port++ &lt;--&gt; {datarate=100Mbps;} &lt;--&gt; node2.port++;
        node2.port++ &lt;--&gt; {datarate=100Mbps;} &lt;--&gt; node4.port++;
        node4.port++ &lt;--&gt; {datarate=100Mbps;} &lt;--&gt; node6.port++;
        ...
}
</pre>
<p>
The above code defines a network type named <tt>Network</tt>. Note that the NED
language uses the familiar curly brace syntax, and &#8220;<tt>//</tt>&#8221; to denote
comments.

<p><ul class="note"><b>NOTE</b><br>
    Comments in NED not only make the source code more readable, but in the
    OMNeT++ IDE they also are displayed at various places (tooltips, content
    assist, etc), and become part of the documentation extracted from the NED
    files. The NED documentation system, not unlike <i>JavaDoc</i> or
    <i>Doxygen</i>, will be described in Chapter <a href="#cha:neddoc">[14]</a>.
</ul>

<p>The network contains several nodes, named <tt>node1</tt>, <tt>node2</tt>, etc.
from the NED module type <tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>. We'll define <tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> in the next
sections.

<p>The second half of the declaration defines how the nodes are to be
connected. The double arrow means bidirectional connection. The connection
points of modules are called gates, and the <tt>port++</tt> notation adds a
new gate to the <tt>port[]</tt> gate vector. Gates and connections will be
covered in more detail in sections <a href="#sec:ned-lang:gates">[3.7]</a> and
<a href="#sec:ned-lang:connections">[3.9]</a>. Nodes are connected with a channel that
has a data rate of 100Mbps.

<p><ul class="note"><b>NOTE</b><br>
    In many other systems, the equivalent of OMNeT++ gates are called
    <i>ports</i>. We have retained the term <i>gate</i> to reduce
    collisions with other uses of the otherwise overloaded word
    <i>port</i>: router port, TCP port, I/O port, etc.
</ul>

<p>The above code would be placed into a file named <tt>Net6.ned</tt>. It is
a convention to put every NED definition into its own file and to name the
file accordingly, but it is not mandatory to do so.

<p>One can define any number of networks in the NED files, and for every
simulation the user has to specify which network to set up.
The usual way of specifying the network is to put the <b><tt>network</tt></b>
option into the configuration (by default the <tt>omnetpp.ini</tt> file):

<pre class="inifile">
[General]
network = Network
</pre>
<p>

<p><h3><a name="sec:ned-lang:warmup:introducing-a-channel"/>3.2.2 Introducing a Channel<a class="headerlink" href="#sec:ned-lang:warmup:introducing-a-channel" title="Permalink to this headline"></a></h3>

<p>It is cumbersome to have to repeat the data rate for every connection.
Luckily, NED provides a convenient solution: one can create a new channel
type that encapsulates the data rate setting, and this channel type can
be defined inside the network so that it does not litter the global
namespace.

<p>The improved network will look like this:

<pre class="ned">
//
// A Network
//
network Network
{
    types:
        channel C extends ned.DatarateChannel {
            datarate = 100Mbps;
        }
    submodules:
        node1: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>;
        node2: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>;
        node3: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>;
        ...
    connections:
        node1.port++ &lt;--&gt; C &lt;--&gt; node2.port++;
        node2.port++ &lt;--&gt; C &lt;--&gt; node4.port++;
        node4.port++ &lt;--&gt; C &lt;--&gt; node6.port++;
        ...
}
</pre>
<p>
Later sections will cover the concepts used (inner types, channels, the
<tt>DatarateChannel</tt> built-in type, inheritance) in detail.

<p>
<h3><a name="sec:ned-lang:warmup:the-simple-modules"/>3.2.3 The App, Routing, and Queue Simple Modules<a class="headerlink" href="#sec:ned-lang:warmup:the-simple-modules" title="Permalink to this headline"></a></h3>

<p>Simple modules are the basic building blocks for other (compound) modules,
denoted by the <b><tt>simple</tt></b> keyword.
All active behavior in the model is encapsulated in <b><tt>simple</tt></b> modules.
Behavior is defined with a C++ class; NED files only declare the externally
visible interface of the module (gates, parameters).

<p>In our example, we could define <tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> as a simple module. However,
its functionality is quite complex (traffic generation, routing, etc),
so it is better to implement it with several smaller simple module types
which we are going to assemble into a compound module. We'll have
one simple module for traffic generation (<tt>App</tt>), one for routing
(<tt>Routing</tt>), and one for queueing up packets to be sent out (<tt>Queue</tt>).
For brevity, we omit the bodies of the latter two in the code below.

<pre class="ned">
simple App
{
    parameters:
        int destAddress;
        ...
        @display("i=block/browser");
    gates:
        input in;
        output out;
}

simple Routing
{
    ...
}

simple Queue
{
    ...
}
</pre>
<p>
By convention, the above simple module declarations go into the
<tt>App.ned</tt>, <tt>Routing.ned</tt> and <tt>Queue.ned</tt> files.

<p><ul class="note"><b>NOTE</b><br>
    Note that module type names (<tt>App</tt>, <tt>Routing</tt>, <tt>Queue</tt>)
    begin with a capital letter, and parameter and gate names begin with
    lowercase -- this is the recommended naming convention. Capitalization
    matters because the language is case sensitive.
</ul>

<p>Let us look at the first simple module type declaration. <tt>App</tt> has a
parameter called <tt>destAddress</tt> (others have been omitted for now),
and two gates named <tt>out</tt> and <tt>in</tt> for sending and receiving
application packets.

<p>The argument of <b><tt>@display()</tt></b> is called a <i>display string</i>,
and it defines the rendering of the module in graphical environments;
<tt>"i=..."</tt> defines the default icon.

<p>Generally, <tt>@</tt>-words like <tt>@display</tt> are called <i>properties</i>
in NED, and they are used to annotate various objects
with metadata. Properties can be attached to files, modules, parameters, gates,
connections, and other objects, and parameter values have a very flexible
syntax.

<p>
<h3><a name="sec:warmup:ned-lang:node-compound-module"/>3.2.4 The <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> Compound Module<a class="headerlink" href="#sec:warmup:ned-lang:node-compound-module" title="Permalink to this headline"></a></h3>

<p>Now we can assemble <tt>App</tt>, <tt>Routing</tt> and <tt>Queue</tt> into the
compound module <tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>. A compound module can be thought of as
a &#8220;cardboard box&#8221; that groups other modules into a larger unit,
which can further be used as a building block for other modules;
networks are also a kind of compound module.

<p>
  <center>
    <img src="ned-routing-node.png">
    <center><div class="caption"><i>Figure: The <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> compound module</i></div></center>
    <a name="fig:ned-routing-node"></a>
  </center>

<p>
<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
    parameters:
        int address;
        @display("i=misc/node_vs,gold");
    gates:
        inout port[];
    submodules:
        app: App;
        routing: Routing;
        queue[sizeof(port)]: Queue;
    connections:
        routing.localOut --&gt; app.in;
        routing.localIn &lt;-- app.out;
        for i=0..sizeof(port)-1 {
            routing.out[i] --&gt; queue[i].in;
            routing.in[i] &lt;-- queue[i].out;
            queue[i].line &lt;--&gt; port[i];
        }
}
</pre>

<p>Compound modules, like simple modules, may have parameters and gates.
Our <tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> module contains an <tt>address</tt> parameter, plus a
<i>gate vector</i> of unspecified size, named <tt>port</tt>.
The actual gate vector size will be determined implicitly by the number
of neighbours when we create a network from nodes of this type.
The type of <tt>port[]</tt> is <tt>inout</tt>, which allows bidirectional
connections.

<p>The modules that make up the compound module are listed under
<b><tt>submodules</tt></b>. Our <tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> compound module type has an <tt>app</tt> and
a <tt>routing</tt> <i>submodule</i>, plus a <tt>queue[]</tt> <i>submodule
vector</i> that contains one <tt>Queue</tt> module for each port, as specified by
<tt>[sizeof(port)]</tt>. (It is legal to refer to <tt>[sizeof(port)]</tt> because
the network is built in top-down order, and the node is already created and
connected at network level when its submodule structure is built out.)

<p>In the <b><tt>connections</tt></b> section, the submodules are connected to each
other and to the parent module. Single arrows are used to connect input and
output gates, and double arrows connect inout gates, and a <b><tt>for</tt></b> loop
is utilized to connect the <tt>routing</tt> module to each <tt>queue</tt> module, and
to connect the outgoing/incoming link (<tt>line</tt> gate) of each queue to the
corresponding port of the enclosing module.

<p>
<h3><a name="sec:ned-lang:warmup:putting-it-together"/>3.2.5 Putting It Together<a class="headerlink" href="#sec:ned-lang:warmup:putting-it-together" title="Permalink to this headline"></a></h3>

<p>We have created the NED definitions for this example, but how are they used by OMNeT++? When
the simulation program is started, it loads the NED files. The program
should already contain the C++ classes that implement the needed simple
modules, <tt>App</tt>, <tt>Routing</tt> and <tt>Queue</tt>; their C++ code is either
part of the executable or is loaded from a shared library. The simulation
program also loads the configuration (<tt>omnetpp.ini</tt>), and determines
from it that the simulation model to be run is the <tt>Network</tt> network.
Then the network is instantiated for simulation.

<p>The simulation model is built in a top-down preorder fashion. This means
that starting from an empty system module, all submodules are created,
their parameters and gate vector sizes are assigned, and they are fully connected
before the submodule internals are built.

<p><br><br>
<center>
* * *
</center>
<br><br>

<p>In the following sections we'll go through the elements of the NED
language and look at them in more detail.

<p>

<p><h2><a name="sec:ned-lang:simple-modules"/>3.3 Simple Modules<a class="headerlink" href="#sec:ned-lang:simple-modules" title="Permalink to this headline"></a></h2>

<p>Simple modules are the active components in the model.
Simple modules are defined with the <b><tt>simple</tt></b> keyword.

<p>An example simple module:

<pre class="ned">
simple Queue
{
    parameters:
        int capacity;
        @display("i=block/queue");
    gates:
        input in;
        output out;
}
</pre>
<p>
Both the <b><tt>parameters</tt></b> and <b><tt>gates</tt></b> sections are optional, that is,
they can be left out if there is no parameter or gate. In addition, the
<b><tt>parameters</tt></b> keyword itself is optional too; it can be left out
even if there are parameters or properties.

<p>Note that the NED definition doesn't contain any code to define the
operation of the module: that part is expressed in C++. By default, OMNeT++
looks for C++ classes of the same name as the NED type (so here, <tt>Queue</tt>).

<p>One can explicitly specify the C++ class with the <b><tt>@class</tt></b> property.
Classes with namespace qualifiers are also accepted, as shown in the following
example that uses the <tt>mylib::Queue</tt> class:

<pre class="ned">
simple Queue
{
    parameters:
        int capacity;
        @class(mylib::Queue);
        @display("i=block/queue");
    gates:
        input in;
        output out;
}
</pre>
<p>
If there are several modules whose C++ implementation classes are in the same
namespace, a better alternative to <b><tt>@class</tt></b> is the <b><tt>@namespace</tt></b> property.
The C++ namespace given with <b><tt>@namespace</tt></b> will be prepended to the normal
class name. In the following example, the C++ classes will be <tt>mylib::App</tt>,
<tt>mylib::Router</tt> and <tt>mylib::Queue</tt>:

<pre class="ned">
@namespace(mylib);

simple App {
   ...
}

simple Router {
   ...
}

simple Queue {
   ...
}
</pre>
<p>
The <b><tt>@namespace</tt></b> property may not only be specified at file level as
in the above example, but for packages as well. When placed in a file
called <tt>package.ned</tt>, the namespace will apply to all components in
that package and below.

<p>The implementation C++ classes need to be subclassed from the
<tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt> library class; chapter <a href="#cha:simple-modules">[4]</a> of
this manual describes in detail how to write them.

<p>Simple modules can be extended (or specialized) via subclassing. The
motivation for subclassing can be to set some open parameters or gate sizes
to a fixed value (see <a href="#sec:ned-lang:parameters">[3.6]</a> and
<a href="#sec:ned-lang:gates">[3.7]</a>), or to replace the C++ class with a different
one. Now, by default, the derived NED module type will <i>inherit</i> the
C++ class from its base, so it is important to remember that you need to
write out <b><tt>@class</tt></b> if you want it to use the new class.

<p>The following example shows how to specialize a module by setting a parameter
to a fixed value (and leaving the C++ class unchanged):

<pre class="ned">
simple Queue
{
   int capacity;
   ...
}

simple BoundedQueue extends Queue
{
   capacity = 10;
}
</pre>
<p>
In the next example, the author wrote a <tt>PriorityQueue</tt> C++ class, and
wants to have a corresponding NED type, derived from <tt>Queue</tt>. However,
it does not work as expected:

<pre class="ned">
simple PriorityQueue extends Queue // wrong! still uses the Queue C++ class
{
}
</pre>
<p>
The correct solution is to add a <b><tt>@class</tt></b> property to override the
inherited C++ class:

<pre class="ned">
simple PriorityQueue extends Queue
{
   @class(PriorityQueue);
}
</pre>
<p>
Inheritance in general will be discussed in section <a href="#sec:ned-lang:inheritance">[3.13]</a>.

<p>

<p><h2><a name="sec:ned-lang:compound-modules"/>3.4 Compound Modules<a class="headerlink" href="#sec:ned-lang:compound-modules" title="Permalink to this headline"></a></h2>

<p>A compound module groups other modules into a larger unit. A compound
module may have gates and parameters like a simple module, but no active
behavior is associated with it.<br><ul><font size=-1>[Although the C++ class
for a compound module can be overridden with the <b><tt>@class</tt></b> property,
this is a feature that should probably never be used. Encapsulate the code
into a simple module, and add it as a submodule.]</font></ul>

<p><ul class="note"><b>NOTE</b><br>
    When there is a temptation to add code to a compound module,
    then encapsulate the code into a simple module, and add it as
    a submodule.
</ul>

<p>A compound module declaration may contain several sections,
all of them optional:

<pre class="ned">
module Host
{
   types:
       ...
   parameters:
       ...
   gates:
       ...
   submodules:
       ...
   connections:
       ...
}
</pre>
<p>
Modules contained in a compound module are called submodules, and they are
listed in the <tt>submodules</tt> section. One can create arrays of submodules
(i.e. submodule vectors), and the submodule type may come from a parameter.

<p>Connections are listed under the <tt>connections</tt> section of the
declaration. One can create connections using simple programming constructs
(loop, conditional). Connection behaviour can be defined by associating a
channel with the connection; the channel type may also come from a
parameter.

<p>Module and channel types only used locally can be defined in the
<tt>types</tt> section as inner types, so that they do not pollute the
namespace.

<p>Compound modules may be extended via subclassing. Inheritance may add new
submodules and new connections as well, not only parameters and gates.
Also, one may refer to inherited submodules, to inherited types etc. What
is not possible is to "de-inherit" or modify submodules or connections.
<br><ul><font size=-1>[With one exception: Since OMNeT++ version 5.6, reconnecting
existing gates is possible using the <b><tt>reconnect</tt></b> property, see
<a href="#sec:ned-lang:reconnecting-gates">[3.9.2]</a>.]</font></ul>

<p>In the following example, we show how to assemble common protocols
into a "stub" for wireless hosts, and add user agents via
subclassing.<br><ul><font size=-1>[Module types, gate names, etc. used in this chapter's
code examples are entirely made-up, and not based on an actual
OMNeT++-based model framework]</font></ul>

<pre class="ned">
module WirelessHostBase
{
   gates:
       input radioIn;
   submodules:
       tcp: TCP;
       ip: IP;
       wlan: Ieee80211;
   connections:
       tcp.ipOut --&gt; ip.tcpIn;
       tcp.ipIn &lt;-- ip.tcpOut;
       ip.nicOut++ --&gt; wlan.ipIn;
       ip.nicIn++ &lt;-- wlan.ipOut;
       wlan.radioIn &lt;-- radioIn;
}

module WirelessHost extends WirelessHostBase
{
   submodules:
       webAgent: WebAgent;
   connections:
       webAgent.tcpOut --&gt; tcp.appIn++;
       webAgent.tcpIn &lt;-- tcp.appOut++;
}
</pre>
<p>
The <tt>WirelessHost</tt> compound module can further be extended,
for example with an Ethernet port:

<pre class="ned">
module DesktopHost extends WirelessHost
{
   gates:
       inout ethg;
   submodules:
       eth: EthernetNic;
   connections:
       ip.nicOut++ --&gt; eth.ipIn;
       ip.nicIn++ &lt;-- eth.ipOut;
       eth.phy &lt;--&gt; ethg;
}
</pre>
<p>

<p>
<h2><a name="sec:ned-lang:channels"/>3.5 Channels<a class="headerlink" href="#sec:ned-lang:channels" title="Permalink to this headline"></a></h2>

<p>Channels encapsulate parameters and behaviour associated with connections.
Channels are like simple modules, in the sense that there are C++ classes
behind them. The rules for finding the C++ class for a NED channel type is
the same as with simple modules: the default class name is the NED type
name unless there is a <b><tt>@class</tt></b> property (<b><tt>@namespace</tt></b> is also
recognized), and the C++ class is inherited when the channel is subclassed.

<p>Thus, the following channel type would expect a <tt>CustomChannel</tt> C++ class
to be present:

<pre class="ned">
channel CustomChannel  // requires a CustomChannel C++ class
{
}
</pre>
<p>
The practical difference compared to modules is that one rarely needs to write
custom channel C++ class because there are predefined channel types that one can
subclass from, inheriting their C++ code. The predefined types are:
<tt>ned.IdealChannel</tt>, <tt>ned.DelayChannel</tt> and <tt>ned.DatarateChannel</tt>.
(&#8220;<tt>ned</tt>&#8221; is the package name; one can get rid of it by importing the types
with the <tt>import ned.*</tt> directive. Packages and imports are described in
section <a href="#sec:ned-lang:packages">[3.14]</a>.)

<p><tt>IdealChannel</tt> has no parameters, and lets through all messages without
delay or any side effect. A connection without a channel object
and a connection with an <tt>IdealChannel</tt> behave in the same way.
Still, <tt>IdealChannel</tt> has its uses, for example when a channel object
is required so that it can carry a new property or parameter that is
going to be read by other parts of the simulation model.

<p><tt>DelayChannel</tt> has two parameters:

<p><ul>
    <li> <tt>delay</tt> is a <tt>double</tt> parameter which represents the
          propagation delay of the message. Values need to be specified
          together with a time unit (<tt>s</tt>, <tt>ms</tt>, <tt>us</tt>, etc.)
    <li> <tt>disabled</tt> is a boolean parameter that defaults to <tt>false</tt>;
          when set to <tt>true</tt>, the channel object will drop all messages.
</ul>

<p><tt>DatarateChannel</tt> has a few additional parameters compared to <tt>DelayChannel</tt>:

<p><ul>
    <li> <tt>datarate</tt> is a <tt>double</tt> parameter that represents the
          data rate of the channel. Values need to be specified
          in bits per second or its multiples as unit (<tt>bps</tt>,
          <tt>kbps</tt>, <tt>Mbps</tt>, <tt>Gbps</tt>, etc.) Zero is treated
          specially and results in zero transmission duration, i.e.
          it stands for infinite bandwidth. Zero is also the default.
          Data rate is used for calculating the transmission duration of
          packets.
    <li> <tt>ber</tt> and <tt>per</tt> stand for Bit Error Rate and Packet Error Rate,
          and allow basic error modelling. They expect a <tt>double</tt>
          in the <i>[0,1]</i> range. When the channel decides (based on random
          numbers) that an error occurred during transmission of a packet,
          it sets an error flag in the packet object. The receiver
          module is expected to check the flag, and discard the packet
          as corrupted if it is set. The default <tt>ber</tt> and <tt>per</tt>
          are zero.
</ul>

<p><ul class="note"><b>NOTE</b><br>
    There is no channel parameter that specifies whether the channel
    delivers the message object to the destination module at the end or
    at the start of the reception; that is decided by the C++ code
    of the target simple module. See the <tt>setDeliverOnReceptionStart()</tt>
    method of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>.
</ul>

<p>The following example shows how to create a new channel type by
specializing <tt>DatarateChannel</tt>:

<pre class="ned">
channel Ethernet100 extends ned.DatarateChannel
{
    datarate = 100Mbps;
    delay = 100us;
    ber = 1e-10;
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    The three built-in channel types are also used for connections where
    the channel type is not explicitly specified.
</ul>

<p>One may add parameters and properties to channels via subclassing, and
may modify existing ones. In the following example, we introduce distance-based
calculation of the propagation delay:

<pre class="ned">
channel DatarateChannel2 extends ned.DatarateChannel
{
    double distance @unit(m);
    delay = this.distance / 200000km * 1s;
}
</pre>
<p>
Parameters are primarily intended to be read by the underlying C++ class,
but new parameters may also be added as annotations to be used by other
parts of the model. For example, a <tt>cost</tt> parameter may be used for
routing decisions in routing module, as shown in the example below. The
example also shows annotation using properties (<b><tt>@backbone</tt></b>).

<pre class="ned">
channel Backbone extends ned.DatarateChannel
{
    @backbone;
    double cost = default(1);
}
</pre>
<p>

<p><h2><a name="sec:ned-lang:parameters"/>3.6 Parameters<a class="headerlink" href="#sec:ned-lang:parameters" title="Permalink to this headline"></a></h2>

<p>Parameters are variables that belong to a module. Parameters can be
used in building the topology (number of nodes, etc), and to supply
input to C++ code that implements simple modules and channels.

<p>Parameters can be of type <b><tt>double</tt></b>, <b><tt>int</tt></b>,
<b><tt>bool</tt></b>, <b><tt>string</tt></b> and <b><tt>xml</tt></b>; they can also
be declared <b><tt>volatile</tt></b>. For the numeric types, a unit of
measurement can also be specified (<b><tt>@unit</tt></b> property), to increase
type safety.

<p>Parameters can get their value from NED files or from the configuration
(<tt>omnetpp.ini</tt>). A default value can also be given (<tt>default(</tt>...<tt>)</tt>),
which is used if the parameter is not assigned otherwise.

<p>The following example shows a simple module that has five parameters, three
of which have default values:

<pre class="ned">
simple App
{
    parameters:
        string protocol;       // protocol to use: "UDP" / "IP" / "ICMP" / ...
        int destAddress;       // destination address
        volatile double sendInterval @unit(s) = default(exponential(1s));
                               // time between generating packets
        volatile int packetLength @unit(byte) = default(100B);
                               // length of one packet
        volatile int timeToLive = default(32);
                               // maximum number of network hops to survive
    gates:
        input in;
        output out;
}
</pre>
<p>

<p><h3><a name="sec:ned-lang:parameter-assignments"/>3.6.1 Assigning a Value<a class="headerlink" href="#sec:ned-lang:parameter-assignments" title="Permalink to this headline"></a></h3>

<p>Parameters may get their values in several ways: from NED code, from the
configuration (<tt>omnetpp.ini</tt>), or even, interactively from the
user. NED lets one assign parameters at several places: in subclasses via
inheritance; in submodule and connection definitions where the NED type is
instantiated; and in networks and compound modules that directly or
indirectly contain the corresponding submodule or connection.

<p>For instance, one could specialize the above <tt>App</tt> module type via
inheritance with the following definition:

<pre class="ned">
simple PingApp extends App
{
    parameters:
        protocol = "ICMP/ECHO"
        sendInterval = default(1s);
        packetLength = default(64byte);
}
</pre>
<p>
This definition sets the <tt>protocol</tt> parameter to a fixed value
(<tt>"ICMP/ECHO"</tt>), and changes the default values of the
<tt>sendInterval</tt> and <tt>packetLength</tt> parameters. <tt>protocol</tt> is now
locked down in <tt>PingApp</tt>, its value cannot be modified via further subclassing
or other ways. <tt>sendInterval</tt> and <tt>packetLength</tt> are still unassigned
here, only their default values have been overwritten.

<p>Now, let us see the definition of a <tt>Host</tt> compound module that uses
<tt>PingApp</tt> as submodule:

<pre class="ned">
module Host
{
    submodules:
        ping : PingApp {
            packetLength = 128B; // always ping with 128-byte packets
        }
        ...
}
</pre>
<p>
This definition sets the <tt>packetLength</tt> parameter to a fixed value. It
is now hardcoded that <tt>Host</tt>s send 128-byte ping packets; this
setting cannot be changed from NED or the configuration.

<p>It is not only possible to set a parameter from the compound module that
contains the submodule, but also from modules higher up in the module tree.
A network that employs several <tt>Host</tt> modules could be defined like
this:

<pre class="ned">
network Network
{
    submodules:
        host[100]: Host {
            ping.timeToLive = default(3);
            ping.destAddress = default(0);
        }
        ...
}
</pre>
<p>
Parameter assignment can also be placed into the <tt>parameters</tt> block of
the parent compound module, which provides additional flexibility. The
following definition sets up the hosts so that half of them pings host #50,
and the other half pings host #0:

<pre class="ned">
network Network
{
    parameters:
        host[*].ping.timeToLive = default(3);
        host[0..49].ping.destAddress = default(50);
        host[50..].ping.destAddress = default(0);

    submodules:
        host[100]: Host;
        ...
}
</pre>
<p>
Note the use of asterisk to match any index, and <tt>..</tt> to match index ranges.

<p>If there were a number of individual hosts instead of a submodule vector,
the network definition could look like this:

<pre class="ned">
network Network
{
    parameters:
        host*.ping.timeToLive = default(3);
        host{0..49}.ping.destAddress = default(50);
        host{50..}.ping.destAddress = default(0);

    submodules:
        host0: Host;
        host1: Host;
        host2: Host;
        ...
        host99: Host;
}
</pre>
<p>
An asterisk matches any substring not containing a dot, and a <tt>..</tt>
within a pair of curly braces matches a natural number embedded in a
string.

<p>In most assigments we have seen above, the left hand side of the equal sign
contained a dot and often a wildcard as well (asterisk or numeric range);
we call these assignments <i>pattern assignments</i> or <i>deep
assignments</i>.

<p>There is one more wildcard that can be used in pattern assignments, and
this is the double asterisk; it matches any sequence of characters
including dots, so it can match multiple path elements. An example:

<pre class="ned">
network Network
{
    parameters:
        **.timeToLive = default(3);
        **.destAddress = default(0);
    submodules:
        host0: Host;
        host1: Host;
        ...
}
</pre>
<p>
Note that some assignments in the above examples changed default values,
while others set parameters to fixed values. Parameters that received no
fixed value in the NED files can be assigned from the configuration
(<tt>omnetpp.ini</tt>).

<p><ul class="important"><b>IMPORTANT</b><br>
    A non-default value assigned from NED cannot be overwritten later in
    NED or from ini files; it becomes &#8220;hardcoded&#8221; as far as ini files
    and NED usage are concerned. In contrast, default values are possible
    to overwrite.
</ul>

<p>A parameter can be assigned in the configuration using a similar syntax as
NED pattern assignments (actually, it would be more historically accurate
to say it the other way round, that NED pattern assignments use a similar
syntax to ini files):

<p>
<pre class="inifile">
Network.host[*].ping.sendInterval = 500ms  # for the host[100] example
Network.host*.ping.sendInterval = 500ms    # for the host0,host1,... example
**.sendInterval = 500ms
</pre>

<p>One often uses the double asterisk to save typing. One can write

<pre class="inifile">
**.ping.sendInterval = 500ms
</pre>
<p>
Or if one is certain that only ping modules have <tt>sendInterval</tt> parameters,
the following will suffice:

<pre class="inifile">
**.sendInterval = 500ms
</pre>
<p>
Parameter assignments in the configuration are described in section
<a href="#sec:config-sim:parameter-settings">[10.3]</a>.

<p>One can also write expressions, including stochastic expressions, in
NED files and in ini files as well. For example, here's how one can
add jitter to the sending of ping packets:

<pre class="inifile">
**.sendInterval = 1s + normal(0s, 0.001s)  # or just: normal(1s, 0.001s)
</pre>
<p>
If there is no assignment for a parameter in NED or in the ini file, the
default value (given with <tt>=default(...)</tt> in NED) will be applied
implicitly. If there is no default value, the user will be asked, provided
the simulation program is allowed to do that; otherwise there will be an
error. (Interactive mode is typically disabled for batch executions where
it would do more harm than good.)

<p>It is also possible to explicitly apply the default (this can sometimes
be useful):

<pre class="inifile">
**.sendInterval = default
</pre>
<p>
Finally, one can explicitly ask the simulator to prompt the user interactively
for the value (again, provided that interactivity is enabled; otherwise
this will result in an error):

<pre class="inifile">
**.sendInterval = ask
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    How can one decide whether to assign a parameter from NED or from an ini
    file? The advantage of ini files is that they allow a cleaner separation of the <i>model</i>
    and <i>experiments</i>. NED files (together with C++ code) are considered
    to be part of the model, and to be more or less constant. Ini files, on
    the other hand, are for experimenting with the model by running it
    several times with different parameters. Thus, parameters that are expected
    to change (or make sense to be changed) during experimentation should be
    put into ini files.
</ul>

<p>
<h3><a name="sec:ned-lang:expressions"/>3.6.2 Expressions<a class="headerlink" href="#sec:ned-lang:expressions" title="Permalink to this headline"></a></h3>

<p>Parameter values may be given with expressions. NED language expressions
have a C-like syntax, with some variations on operator names: binary and
logical XOR are <tt>#</tt> and <tt>##</tt>, while <tt>^</tt> has been reassigned
to <i>power-of</i> instead. The <tt>+</tt> operator does string
concatenation as well as numeric addition. Expressions can use various
numeric, string, stochastic and other functions (<tt>fabs()</tt>, <tt>toUpper()</tt>,
<tt>uniform()</tt>, <tt>erlang_k()</tt>, etc.).

<p><ul class="note"><b>NOTE</b><br>
    The list of NED functions can be found in Appendix <a href="#cha:ned-functions">[22]</a>.
    The user can also extend NED with new functions.
</ul>

<p>
Expressions may refer to module parameters, gate vector and module vector sizes
(using the <b><tt>sizeof</tt></b> operator) and the index of the current module
in a submodule vector (<b><tt>index</tt></b>).

<p>
Expressions may refer to parameters of the compound module being defined,
of the current module (with the <tt>this.</tt> prefix), and to parameters
of already defined submodules, with the syntax <tt>submodule.parametername</tt>
(or <tt>submodule[index].parametername</tt>).

<p>


<p><h3><a name="sec:ned-lang:volatile"/>3.6.3 volatile<a class="headerlink" href="#sec:ned-lang:volatile" title="Permalink to this headline"></a></h3>

<p>The <b><tt>volatile</tt></b> modifier causes the parameter's value expression to
be evaluated every time the parameter is read. This has significance if the
expression is not constant, for example it involves numbers drawn from a
random number generator. In contrast, non-volatile parameters are evaluated
only once. (This practically means that they are evaluated and replaced
with the resulting constant at the start of the simulation.)

<p>To better understand <b><tt>volatile</tt></b>, let's suppose we have a
<tt>Queue</tt> simple module that has a <tt>volatile double</tt> parameter
named <tt>serviceTime</tt>.

<pre class="ned">
simple Queue
{
    parameters:
        volatile double serviceTime;
}
</pre>
<p>
Because of the <b><tt>volatile</tt></b> modifier, the queue module's C++
implementation is expected to re-read the <tt>serviceTime</tt> parameter
whenever a value is needed; that is, for every job serviced. Thus, if
<tt>serviceTime</tt> is assigned an expression like <tt>uniform(0.5s, 1.5s)</tt>,
every job will have a different, random service time. To highlight this
effect, here's how one can have a time-varying parameter by exploiting
the <tt>simTime()</tt> NED function that returns the current simulation time:

<pre class="inifile">
**.serviceTime = simTime()&lt;1000s ? 1s : 2s  # queue that slows down after 1000s
</pre>
<p>
In practice, a volatile parameters are typically used as a configurable
source of random numbers for modules.

<p><ul class="note"><b>NOTE</b><br>
    This does not mean that a non-volatile parameter could not be assigned a
    random value like <tt>uniform(0.5s, 1.5s)</tt>. It can, but that would
    have a totally different effect: the simulation would use a constant
    service time, say <tt>1.2975367s</tt>, chosen randomly at the beginning
    of the simulation.
</ul>

<p><h3><a name="sec:ned-lang:units"/>3.6.4 Units<a class="headerlink" href="#sec:ned-lang:units" title="Permalink to this headline"></a></h3>

<p>One can declare a parameter to have an associated unit of measurement,
by adding the <b><tt>@unit</tt></b> property. An example:

<pre class="ned">
simple App
{
    parameters:
        volatile double sendInterval @unit(s) = default(exponential(350ms));
        volatile int packetLength @unit(byte) = default(4KiB);
    ...
}
</pre>
<p>
The <tt>@unit(s)</tt> and <tt>@unit(byte)</tt> declarations specify the measurement unit
for the parameter. Values assigned to parameters must have the same or
compatible unit, i.e. <tt>@unit(s)</tt> accepts milliseconds, nanoseconds,
minutes, hours, etc., and <tt>@unit(byte)</tt> accepts kilobytes, megabytes,
etc. as well.

<p><ul class="note"><b>NOTE</b><br>
    The list of units accepted by OMNeT++ is listed in the Appendix, see
    <a href="#sec:ned-ref:units">[19.5.9]</a>. Unknown units (<tt>bogomips</tt>, etc.)
    can also be used, but there are no conversions for them,
    i.e. decimal prefixes will not be recognized.
</ul>

<p>The OMNeT++ runtime does a full and rigorous unit check on
parameters to ensure &#8220;unit safety&#8221; of models. Constants should
always include the measurement unit.

<p>The <b><tt>@unit</tt></b> property of a parameter cannot be added or overridden
in subclasses or in submodule declarations.

<p>
<h3><a name="sec:ned-lang:xml-parameters"/>3.6.5 XML Parameters<a class="headerlink" href="#sec:ned-lang:xml-parameters" title="Permalink to this headline"></a></h3>

<p>Sometimes modules need complex data structures as input, which is something
that cannot be done well with module parameters. One solution is to place
the input data into a custom configuration file, pass the file name to the
module in a string parameter, and let the module read and parse the file.

<p>It is somewhat easier if the configuration uses XML syntax, because OMNeT++
contains built-in support for XML files. Using an XML parser (LibXML2 or
Expat), OMNeT++ reads and DTD-validates the file (if the XML document
contains a DOCTYPE), caches the file (so that references to it from several
modules will result in the file being loaded only once), allows selection
of parts of the document using an XPath-subset notation, and presents the
contents in a DOM-like object tree.

<p>This capability can be accessed via the NED parameter type <b><tt>xml</tt></b>,
and the <b><tt>xmldoc()</tt></b> function. One can point <b><tt>xml</tt></b>-type
module parameters to a specific XML file (or to an element inside an XML
file) via the <b><tt>xmldoc()</tt></b> function. One can assign <b><tt>xml</tt></b>
parameters both from NED and from <tt>omnetpp.ini</tt>.

<p>The following example declares an <b><tt>xml</tt></b> parameter, and assigns an
XML file to it. The file name is understood as being relative to the working
directory.

<pre class="ned">
simple TrafGen {
    parameters:
        xml profile;
    gates:
        output out;
}

module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> {
    submodules:
        trafGen1 : TrafGen {
            profile = xmldoc("data.xml");
        }
        ...
}
</pre>
<p>
<b><tt>xmldoc()</tt></b> also lets one select an element <i>within</i> an XML
file. In case one has a model that contains numerous modules that need XML
input, this feature allows the user get rid of the countless small XML
files by aggregating them into a single XML file. For example, the
following XML file contains two profiles identified with the IDs
<i>gen1</i> and <i>gen2</i>:

<pre class="filelisting">
&lt;?xml&gt;
&lt;root&gt;
    &lt;profile id="gen1"&gt;
          &lt;param&gt;3&lt;/param&gt;
          &lt;param&gt;5&lt;/param&gt;
    &lt;/profile&gt;
    &lt;profile id="gen2"&gt;
          &lt;param&gt;9&lt;/param&gt;
    &lt;/profile&gt;
&lt;/root&gt;
</pre>
<p>
And one can assign each profile to a corresponding submodule using an XPath-like
expression:

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> {
    submodules:
        trafGen1 : TrafGen {
            profile = xmldoc("all.xml", "/root/profile[@id='gen1']");
        }
        trafGen2 : TrafGen {
            profile = xmldoc("all.xml", "/root/profile[@id='gen2']");
        }
}
</pre>
<p>
It is also possible to create an XML document from a string constant, using
the <b><tt>xml()</tt></b> function. This is especially useful for creating a
default value for <b><tt>xml</tt></b> parameters. An example:

<pre class="ned">
simple TrafGen {
    parameters:
        xml profile = xml("&lt;root/&gt;"); // empty document as default
        ...
}
</pre>
<p>
The <b><tt>xml()</tt></b> function, like <b><tt>xmldoc()</tt></b>, also supports an
optional second XPath parameter for selecting a subtree.

<p>

<p>
<h2><a name="sec:ned-lang:gates"/>3.7 Gates<a class="headerlink" href="#sec:ned-lang:gates" title="Permalink to this headline"></a></h2>

<p>Gates are the connection points of modules.  OMNeT++ has three types of
gates: <i>input</i>, <i>output</i> and <i>inout</i>, the latter being
essentially an input and an output gate glued together.

<p>A gate, whether input or output, can only be connected to one other
gate. (For compound module gates, this means one connection &#8220;outside&#8221; and
one &#8220;inside&#8221;.)  It is possible, though generally not recommended, to
connect the input and output sides of an inout gate separately (see section
<a href="#sec:ned-lang:connections">[3.9]</a>).

<p>One can create single gates and gate vectors. The size of a gate vector
can be given inside square brackets in the declaration, but it is also possible
to leave it open by just writing a pair of empty brackets (&#8220;<tt>[]</tt>&#8221;).

<p>When the gate vector size is left open, one can still specify it later,
when subclassing the module, or when using the module for a submodule in a
compound module. However, it does not need to be specified because
one can create connections with the <tt><i>gate</i>++</tt> operator that
automatically expands the gate vector.

<p>The gate size can be queried from various NED expressions with the
<tt>sizeof()</tt> operator.

<p>NED normally requires that all gates be connected. To relax this
requirement, one can annotate selected gates with the <b><tt>@loose</tt></b>
property, which turns off the connectivity check for that gate. Also, input
gates that solely exist so that the module can receive messages via
<tt>sendDirect()</tt> (see <a href="#sec:simple-modules:direct-sending">[4.7.5]</a>) should
be annotated with <b><tt>@directIn</tt></b>. It is also possible to turn off the connectivity
check for all gates within a compound module by specifying the
<b><tt>allowunconnected</tt></b> keyword in the module's connections section.

<p>Let us see some examples.

<p>In the following example, the <tt>Classifier</tt> module has one input for
receiving jobs, which it will send to one of the outputs. The number of
outputs is determined by a module parameter:

<pre class="ned">
simple Classifier {
    parameters:
        int numCategories;
    gates:
        input in;
        output out[numCategories];
}
</pre>
<p>
The following <tt>Sink</tt> module also has its <tt>in[]</tt> gate defined
as a vector, so that it can be connected to several modules:

<pre class="ned">
simple Sink {
    gates:
        input in[];
}
</pre>
<p>
The following lines define a node for building a square grid. Gates around
the edges of the grid are expected to remain unconnected, hence the
<b><tt>@loose</tt></b> annotation:

<pre class="ned">
simple GridNode {
    gates:
        inout neighbour[4] @loose;
}
</pre>
<p>
<tt>WirelessNode</tt> below is expected to receive messages (radio transmissions)
via direct sending, so its <tt>radioIn</tt> gate is marked with <b><tt>@directIn</tt></b>.

<pre class="ned">
simple WirelessNode {
    gates:
        input radioIn @directIn;
}
</pre>
<p>
In the following example, we define <tt>TreeNode</tt> as having gates to connect
any number of children, then subclass it to get a <tt>BinaryTreeNode</tt> to
set the gate size to two:

<pre class="ned">
simple TreeNode {
    gates:
        inout parent;
        inout children[];
}

simple BinaryTreeNode extends TreeNode {
    gates:
        children[2];
}
</pre>
<p>
An example for setting the gate vector size in a submodule, using the same
<tt>TreeNode</tt> module type as above:

<pre class="ned">
module BinaryTree {
    submodules:
        nodes[31]: TreeNode {
            gates:
                children[2];
        }
    connections:
        ...
}
</pre>
<p>

<p>
<h2><a name="sec:ned-lang:submodules"/>3.8 Submodules<a class="headerlink" href="#sec:ned-lang:submodules" title="Permalink to this headline"></a></h2>

<p>Modules that a compound module is composed of are called its submodules.
A submodule has a name, and it is an instance of a compound or simple
module type. In the NED definition of a submodule, this module type
is usually given statically, but it is also possible to specify the type
with a string expression. (The latter feature, <i>parametric submodule
types</i>, will be discussed in section <a href="#sec:ned-lang:submodule-like">[3.11.1]</a>.)

<p>NED supports submodule arrays (vectors) and conditional submodules as well.
Submodule vector size, unlike gate vector size, must always be specified
and cannot be left open as with gates.

<p>It is possible to add new submodules to an existing compound module via
subclassing; this has been described in the section
<a href="#sec:ned-lang:compound-modules">[3.4]</a>.

<p>The basic syntax of submodules is shown below:

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
    submodules:
        routing: Routing;   // a submodule
        queue[sizeof(port)]: Queue;  // submodule vector
        ...
}
</pre>
<p>
As already seen in previous code examples, a submodule may also have a
curly brace block as body, where one can assign parameters, set the size of
gate vectors, and add/modify properties like the display string
(<b><tt>@display</tt></b>). It is not possible to add new parameters and gates.

<p>Display strings specified here will be merged with the display string
from the type to get the effective display string. The merge algorithm is
described in chapter <a href="#cha:graphics">[8]</a>.

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
    gates:
        inout port[];
    submodules:
        routing: Routing {
            parameters:   // this keyword is optional
                routingTable = "routingtable.txt"; // assign parameter
            gates:
                in[sizeof(port)];  // set gate vector size
                out[sizeof(port)];
        }
        queue[sizeof(port)]: Queue {
            @display("t=queue id $id"); // modify display string
            id = 1000+index;  // use submodule index to generate different IDs
        }
    connections:
        ...
}
</pre>
<p>
An empty body may be omitted, that is,

<pre class="ned">
      queue: Queue;
</pre>
<p>
is the same as

<pre class="ned">
      queue: Queue {
      }
</pre>
<p>
A submodule or submodule vector can be conditional. The <b><tt>if</tt></b>
keyword and the condition itself goes after the submodule type, like in the
example below:

<pre class="ned">
module Host
{
    parameters:
        bool withTCP = default(true);
    submodules:
        tcp : TCP if withTCP;
        ...
}
</pre>
<p>
Note that with submodule vectors, setting zero vector size can be used as an
alternative to the <b><tt>if</tt></b> condition.

<p><h2><a name="sec:ned-lang:connections"/>3.9 Connections<a class="headerlink" href="#sec:ned-lang:connections" title="Permalink to this headline"></a></h2>

<p>Connections are defined in the <b><tt>connections</tt></b> section of compound
modules. Connections cannot span across hierarchy levels; one can connect
two submodule gates, a submodule gate and the "inside" of the parent
(compound) module's gates, or two gates of the parent module (though this
is rarely useful), but it is not possible to connect to any gate outside the
parent module, or inside compound submodules.

<p>Input and output gates are connected with a normal arrow, and inout gates
with a double-headed arrow &#8220;<tt>&lt;--&gt;</tt>&#8221;. To connect the two gates
with a channel, use two arrows and put the channel specification in between.
The same syntax is used to add properties such as <b><tt>@display</tt></b> to the
connection.

<p>Some examples have already been shown in the NED Quickstart section
(<a href="#sec:ned-lang:warmup">[3.2]</a>); let's see some more.

<p>

It has been mentioned that an inout gate is basically an input and an
output gate glued together. These sub-gates can also be addressed (and
connected) individually if needed, as <tt>port$i</tt> and <tt>port$o</tt> (or
for vector gates, as <tt>port$i[$k$]</tt> and <tt>port$o[<i>k</i>]</tt>).

<p>
Gates are specified as <i>modulespec.gatespec</i> (to connect a submodule),
or as <i>gatespec</i> (to connect the compound module). <i>modulespec</i>
is either a submodule name (for scalar submodules), or a submodule name plus
an index in square brackets (for submodule vectors). For scalar gates,
<i>gatespec</i> is the gate name; for gate vectors it is either the gate name
plus an index in square brackets, or <i>gatename</i><tt>++</tt>.

<p>The <i>gatename</i><tt>++</tt> notation causes the first unconnected gate index
to be used. If all gates of the given gate vector are connected, the behavior
is different for submodules and for the enclosing compound module.
For submodules, the gate vector expands by one. For a compound module,
after the last gate is connected, <tt>++</tt> will stop with an error.

<p><ul class="note"><b>NOTE</b><br>
    Why is it not possible to expand a gate vector of the compound
    module? The model structure is built in top-down order, so new gates
    would be left unconnected on the outside, as there is no way in NED to
    "go back" and connect them afterwards.
</ul>

<p>When the <tt>++</tt> operator is used with <tt>$i</tt> or <tt>$o</tt>
(e.g. <tt>g$i++</tt> or <tt>g$o++</tt>, see later), it will actually add
a gate pair (input+output) to maintain equal gate sizes for the two
directions.

<p>

<p><h3><a name="sec:ned-lang:channel-specification"/>3.9.1 Channel Specification<a class="headerlink" href="#sec:ned-lang:channel-specification" title="Permalink to this headline"></a></h3>

<p>Channel specifications (<tt>--&gt;<i>channelspec</i>--&gt;</tt> inside a connection)
are similar to submodules in many respect. Let's see some examples!

<p>The following connections use two user-defined channel types,
<tt>Ethernet100</tt> and <tt>Backbone</tt>. The code shows the syntax
for assigning parameters (<tt>cost</tt> and <tt>length</tt>) and specifying
a display string (and NED properties in general):

<pre class="ned">
a.g++ &lt;--&gt; Ethernet100 &lt;--&gt; b.g++;
a.g++ &lt;--&gt; Backbone {cost=100; length=52km; ber=1e-8;} &lt;--&gt; b.g++;
a.g++ &lt;--&gt; Backbone {@display("ls=green,2");} &lt;--&gt; b.g++;
</pre>
<p>
When using built-in channel types, the type name can be omitted; it
will be inferred from the parameter names.

<pre class="ned">
a.g++ &lt;--&gt; {delay=10ms;} &lt;--&gt; b.g++;
a.g++ &lt;--&gt; {delay=10ms; ber=1e-8;} &lt;--&gt; b.g++;
a.g++ &lt;--&gt; {@display("ls=red");} &lt;--&gt; b.g++;
</pre>
<p>
If <tt>datarate</tt>, <tt>ber</tt> or <tt>per</tt> is assigned,
<tt>ned.DatarateChannel</tt> will be chosen. Otherwise, if <tt>delay</tt> or
<tt>disabled</tt> is present, it will be <tt>ned.DelayChannel</tt>; otherwise it
is <tt>ned.IdealChannel</tt>. Naturally, if other parameter names are assigned
in a connection without an explicit channel type, it will be an error (with
<i>&#8220;ned.DelayChannel has no such parameter&#8221;</i> or similar message).

<p>Connection parameters, similarly to submodule parameters, can also
be assigned using pattern assignments, albeit the channel names
to be matched with patterns are a little more complicated and less
convenient to use. A channel can be identified with the name of its
source gate plus the channel name; the channel name is currently always
<tt>channel</tt>. It is illustrated by the following example:

<pre class="ned">
module Queueing
{
    parameters:
        source.out.channel.delay = 10ms;
        queue.out.channel.delay = 20ms;
    submodules:
        source: Source;
        queue: Queue;
        sink: Sink;
    connections:
        source.out --&gt; ned.DelayChannel --&gt; queue.in;
        queue.out --&gt; ned.DelayChannel &lt;--&gt; sink.in;
</pre>
<p>
Using bidirectional connections is a bit trickier, because both
directions must be covered separately:

<pre class="ned">
network Network
{
    parameters:
        hostA.g$o[0].channel.datarate = 100Mbps; // the A -&gt; B connection
        hostB.g$o[0].channel.datarate = 100Mbps; // the B -&gt; A connection
        hostA.g$o[1].channel.datarate = 1Gbps;   // the A -&gt; C connection
        hostC.g$o[0].channel.datarate = 1Gbps;   // the C -&gt; A connection
    submodules:
        hostA: Host;
        hostB: Host;
        hostC: Host;
    connections:
        hostA.g++ &lt;--&gt; ned.DatarateChannel &lt;--&gt; hostB.g++;
        hostA.g++ &lt;--&gt; ned.DatarateChannel &lt;--&gt; hostC.g++;
</pre>
<p>
Also, with the <tt>++</tt> syntax it is not always easy to figure out which
gate indices map to the connections one needs to configure. If connection
objects could be given names to override the default name
&#8220;<tt>channel</tt>&#8221;, that would make it easier to identify connections in
patterns. This feature is described in the next section.

<p>
<h3><a name="sec:ned-lang:reconnecting-gates"/>3.9.2 Reconnecting Gates<a class="headerlink" href="#sec:ned-lang:reconnecting-gates" title="Permalink to this headline"></a></h3>

<p>Normally, it is an error for NED connection to refer to a gate which is already
connected. This behavior can be overridden with the <b><tt>@reconnect</tt></b>
property. A syntax example:

<pre class="ned">
a.out --&gt; {@reconnect;} --&gt; b.in;
</pre>
<p>
When a connection with the <b><tt>@reconnect</tt></b> property is encountered by the
network builder, it first checks whether any of the involved gates are connected.
If they are, it will unconnect them before proceeding to create the new connection.

<p>The usefulness of <b><tt>@reconnect</tt></b> lies with inheritance, as it allows one
to modify connections in the base compound module. For example, it is possible
to insert a new submodule in the path between two connected submodules, which
eliminates the need for "hook" submodules in compound modules that are meant
to be very configurable. This is illustrated in the following example:

<p>
<pre class="ned">
module Base {
    submodules:
        a: A;
        b: B;
    connections:
        a.out --&gt; b.in;
}

module Derived extends Base {
    submodules:
        c: C; // inserted between a and b
    connections:
        a.out --&gt; {@reconnect;} --&gt; c.in;
        c.out --&gt; {@reconnect;} --&gt; b.in;
}
</pre>

<p>
<h3><a name="sec:ned-lang:channel-names"/>3.9.3 Channel Names<a class="headerlink" href="#sec:ned-lang:channel-names" title="Permalink to this headline"></a></h3>

<p>The default name given to channel objects is <tt>"channel"</tt>. Since OMNeT++ 4.3
it is possible to specify the name explicitly, and also to override
the default name per channel type. The purpose of custom channel names is to make
addressing easier when channel parameters are assigned from ini files.

<p>The syntax for naming a channel in a connection is similar to submodule syntax:
<i>name: type</i>. Since both <i>name</i> and <i>type</i> are optional,
the colon must be there after <i>name</i> even if <i>type</i> is missing,
in order to remove the ambiguity.

<p>Examples:

<pre class="ned">
r1.pppg++ &lt;--&gt; eth1: EthernetChannel &lt;--&gt; r2.pppg++;
a.out --&gt; foo: {delay=1ms;} --&gt; b.in;
a.out --&gt; bar: --&gt; b.in;
</pre>
<p>
In the absence of an explicit name, the channel name comes from the
<tt>@defaultname</tt> property of the channel type if that exists.

<pre class="ned">
channel Eth10G extends ned.DatarateChannel like IEth {
    @defaultname(eth10G);
}
</pre>
<p>
There's a catch with <tt>@defaultname</tt> though: if the channel type is
specified with a <tt>**.<i>channelname</i>.liketype=</tt> line in an ini file, then
the channel type's <tt>@defaultname</tt> cannot be used as <i>channelname</i>
in that configuration line, because the channel type would only be known as a
result of using that very configuration line. To illustrate the problem,
consider the above <tt>Eth10G</tt> channel, and a compound module containing the
following connection:

<pre class="ned">
r1.pppg++ &lt;--&gt; &lt;&gt; like IEth &lt;--&gt; r2.pppg++;
</pre>
<p>
Then consider the following inifile:

<pre class="inifile">
**.eth10G.typename = "Eth10G"   # Won't match! The eth10G name would come from
                                #   the Eth10G type - catch-22!
**.channel.typename = "Eth10G"  # OK, as lookup assumes the name "channel"
**.eth10G.datarate = 10.01Gbps  # OK, channel already exists with name "eth10G"
</pre>
<p>
The anomaly can be avoided by using an explicit channel name in the connection,
not using <tt>@defaultname</tt>, or by specifying the type via a module parameter
(e.g. writing <tt>&lt;param&gt; like ...</tt> instead of <tt>&lt;&gt; like ...</tt>).

<p>

<p><h2><a name="sec:ned-lang:multiple-connections"/>3.10 Multiple Connections<a class="headerlink" href="#sec:ned-lang:multiple-connections" title="Permalink to this headline"></a></h2>

<p>Simple programming constructs (loop, conditional) allow creating
multiple connections easily.

<p>
This will be shown in the following examples.

<p><h3><a name="sec:ned-lang:multiple-connections-examples"/>3.10.1 Examples<a class="headerlink" href="#sec:ned-lang:multiple-connections-examples" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:ned-lang:chain-example"/>3.10.1.1 Chain<a class="headerlink" href="#sec:ned-lang:chain-example" title="Permalink to this headline"></a></h4>

<p>One can create a chain<!--chain--> of modules like this:

<pre class="ned">
module Chain
    parameters:
        int count;
    submodules:
        node[count] : <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> {
            gates:
                port[2];
        }
    connections allowunconnected:
        for i = 0..count-2 {
            node[i].port[1] &lt;--&gt; node[i+1].port[0];
        }
}
</pre>
<p>

<p><h4><a name="sec:ned-lang:binary-tree-example"/>3.10.1.2 Binary Tree<a class="headerlink" href="#sec:ned-lang:binary-tree-example" title="Permalink to this headline"></a></h4>

<p>One can build a binary tree<!--binary tree--> in the following way:

<pre class="ned">
simple BinaryTreeNode {
    gates:
        inout left;
        inout right;
        inout parent;
}

module BinaryTree {
    parameters:
        int height;
    submodules:
        node[2^height-1]: BinaryTreeNode;
    connections allowunconnected:
        for i=0..2^(height-1)-2 {
            node[i].left &lt;--&gt; node[2*i+1].parent;
            node[i].right &lt;--&gt; node[2*i+2].parent;
        }
}
</pre>
<p>
Note that not every gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here with
the <b><tt>allowunconnected</tt></b> modifier.
Consequently, it is the simple modules' responsibility not to send
on an unconnected gate.

<p>

<p><h4><a name="sec:ned-lang:random-graph-example"/>3.10.1.3 Random Graph<a class="headerlink" href="#sec:ned-lang:random-graph-example" title="Permalink to this headline"></a></h4>

<p>Conditional connections can be used to generate random
topologies<!--topology!random-->, for example. The following code
generates a random subgraph of a full graph:

<pre class="ned">
module RandomGraph {
    parameters:
        int count;
        double connectedness; // 0.0&lt;x&lt;1.0
    submodules:
        node[count]: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> {
            gates:
                in[count];
                out[count];
        }
    connections allowunconnected:
        for i=0..count-1, for j=0..count-1 {
            node[i].out[j] --&gt; node[j].in[i]
                if i!=j && uniform(0,1)&lt;connectedness;
        }
}
</pre>
<p>
Note the use of the <b><tt>allowunconnected</tt></b> modifier
here too, to turn off error messages produced by the network setup code
for unconnected gates.

<p>
<h3><a name="sec:ned-lang:connection-design-patterns"/>3.10.2 Connection Patterns<a class="headerlink" href="#sec:ned-lang:connection-design-patterns" title="Permalink to this headline"></a></h3>

<p><!--module!compound!patterns-->
<!--topology!patterns-->

<p>Several approaches can be used for creating complex topologies that have a
regular structure; three of them are described below.

<p>
<h4><a name="sec:ned-lang:subgraph-of-full-graph"/>3.10.2.1 &#8220;Subgraph of a Full Graph&#8221;<a class="headerlink" href="#sec:ned-lang:subgraph-of-full-graph" title="Permalink to this headline"></a></h4>

<p>
This pattern takes a subset of the connections of a full graph.  A
condition is used to &#8220;carve out&#8221; the necessary interconnection from
the full graph:

<pre class="ned">
for i=0..N-1, for j=0..N-1 {
    node[i].out[...] --&gt; node[j].in[...] if condition(i,j);
}
</pre>
<p>
The RandomGraph compound module (presented earlier) is an example of
this pattern, but the pattern can generate any graph where an
appropriate <i>condition(i,j)</i> can be formulated. For example,
when generating a tree<!--topology!tree--> structure, the condition
would return whether node <i>j</i> is a child of node <i>i</i> or
vice versa.

<p>Though this pattern is very general, its usage can be prohibitive if
the number of nodes <i>N</i> is high and the graph is sparse (it has
much less than <i>N<sup>2</sup></i> connections). The following
two patterns do not suffer from this drawback.

<p>
<h4><a name="sec:ned-lang:connections-of-each-node"/>3.10.2.2 &#8220;Connections of Each <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>&#8221;<a class="headerlink" href="#sec:ned-lang:connections-of-each-node" title="Permalink to this headline"></a></h4>

<p>The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this:

<pre class="ned">
for i=0..Nnodes, for j=0..Nconns(i)-1 {
    node[i].out[j] --&gt; node[rightNodeIndex(i,j)].in[j];
}
</pre>
<p>
The Hypercube<!--topology!hypercube--> compound module (to be
presented later) is a clear example of this approach. BinaryTree can
also be regarded as an example of this pattern where the inner j loop
is unrolled.

<p>The applicability of this pattern depends on how easily the <i>rightNodeIndex(i,j)</i>
function can be formulated.

<p>
<h4><a name="sec:ned-lang:enumerate-all-connections"/>3.10.2.3 &#8220;Enumerate All Connections&#8221;<a class="headerlink" href="#sec:ned-lang:enumerate-all-connections" title="Permalink to this headline"></a></h4>

<p>
A third pattern is to list all connections within a loop:

<pre class="ned">
for i=0..Nconnections-1 {
    node[leftNodeIndex(i)].out[...] --&gt; node[rightNodeIndex(i)].in[...];
}
</pre>
<p>
This pattern can be used if <i>leftNodeIndex(i)</i> and <i>rightNodeIndex(i)</i>
mapping functions can be sufficiently formulated.

<p>The <tt>Chain</tt> module is an example of this approach where the mapping
functions are extremely simple: <i>leftNodeIndex(i)=i</i> and <i>rightNodeIndex(i) = i+1</i>.
The pattern can also be used to create a random subset of a full
graph with a fixed number of connections.

<p>In the case of irregular structures where none of the above patterns
can be employed, one can resort to listing all connections, like one
would do it in most existing simulators.

<p>

<p><h2><a name="sec:ned-lang:parametric-submodule-and-connection-types"/>3.11 Parametric Submodule and Connection Types<a class="headerlink" href="#sec:ned-lang:parametric-submodule-and-connection-types" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:ned-lang:submodule-like"/>3.11.1 Parametric Submodule Types<a class="headerlink" href="#sec:ned-lang:submodule-like" title="Permalink to this headline"></a></h3>

<p>A submodule type may be specified with a module parameter of the type
<b><tt>string</tt></b>, or in general, with any string-typed expression.
The syntax uses the <b><tt>like</tt></b> keyword.

<p>Let us begin with an example:

<pre class="ned">
network Net6
{
    parameters:
        string nodeType;
    submodules:
        node[6]: &lt;nodeType&gt; like INode {
            address = index;
        }
    connections:
        ...
}
</pre>
<p>
It creates a submodule vector whose module type will come from the
<tt>nodeType</tt> parameter. For example, if <tt>nodeType</tt> is set to <tt>"SensorNode"</tt>,
then the module vector will consist of sensor nodes, provided such module
type exists and it qualifies. What this means is that the <tt>INode</tt> must be
an existing <i>module interface</i>, which the <tt>SensorNode</tt>
module type must implement (more about this later).

<p>As already mentioned, one can write an expression between the angle
brackets. The expression may use the parameters of the parent module and of
previously defined submodules, and has to yield a string value. For
example, the following code is also valid:

<pre class="ned">
network Net6
{
    parameters:
        string nodeTypePrefix;
        int variant;
    submodules:
        node[6]: &lt;nodeTypePrefix + "<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>" + string(variant)&gt; like INode {
           ...
}
</pre>
<p>
The corresponding NED declarations:

<pre class="ned">
moduleinterface INode
{
    parameters:
        int address;
    gates:
        inout port[];
}

module SensorNode like INode
{
    parameters:
        int address;
        ...
    gates:
        inout port[];
        ...
}
</pre>
<p>
The &#8220;<tt>&lt;nodeType&gt; like INode</tt>&#8221; syntax has an issue when used
with submodule vectors: does not allow one to specify different types
for different indices. The following syntax is better suited for
submodule vectors:

<p>The expression between the angle brackets may be left out altogether,
leaving a pair of empty angle brackets, <tt>&lt;&gt;</tt>:

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
    submodules:
        nic: &lt;&gt; like INic;  // type name expression left unspecified
        ...
}
</pre>
<p>
Now the submodule type name is expected to be defined via typename pattern
assignments. Typename pattern assignments look like pattern assignments for
the submodule's parameters, only the parameter name is replaced by the
<b><tt>typename</tt></b> keyword. Typename pattern assignments may also be
written in the configuration file. In a network that uses the above
<tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> NED type, typename pattern assignments would look like this:

<pre class="ned">
network Network
{
    parameters:
        node[*].nic.typename = "Ieee80211g";
    submodules:
        node: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>[100];
}
</pre>
<p>
A default value may also be specified between the angle brackets;
it will be used if there is no typename assignment for the
module:

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
    submodules:
        nic: &lt;default("Ieee80211b")&gt; like INic;
        ...
}
</pre>
<p>
There must be exactly one module type that goes by the simple name <tt>Ieee80211b</tt>
and also implements the module interface <tt>INic</tt>, otherwise an error message
will be issued. (The imports in <tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>'s the NED file play no role in the
type resolution.)  If there are two or more such types, one can remove the ambiguity
by specifying the fully qualified module type name, i.e. one that also includes
the package name:

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
    submodules:
        nic: &lt;default("acme.wireless.Ieee80211b")&gt; like INic; // made-up name
        ...
}
</pre>
<p>
<h3><a name="sec:ned-lang:conditional-parametric-submodules"/>3.11.2 Conditional Parametric Submodules<a class="headerlink" href="#sec:ned-lang:conditional-parametric-submodules" title="Permalink to this headline"></a></h3>

<p>When creating reusable compound modules, it is often useful to be able to make a
parametric submodule also optional. One solution is to let the user define the
submodule type with a string parameter, and not create the module when the
parameter is set to the empty string. Like this:

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
    parameters:
        string tcpType = default("Tcp");
    submodules:
        tcp: &lt;tcpType&gt; like ITcp if tcpType!="";
}
</pre>
<p>
However, this pattern, when used extensively, can lead to a large number of
string parameters. Luckily, it is also possible to achieve the same effect
with <b><tt>typename</tt></b>, without using extra parameters:

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
    submodules:
        tcp: &lt;default("Tcp")&gt; like ITcp if typename!="";
}
</pre>
<p>
The <b><tt>typename</tt></b> operator in a submodule's <b><tt>if</tt></b> condition
evaluates to the would-be type of the submodule. By using the <tt>typename!=""</tt>
condition, we can let the user eliminate the <tt>tcp</tt> submodule by setting its
typename to the empty string. For example, in a network that uses the above NED
type, typename pattern assignments could look like this:

<pre class="ned">
network Network
{
    parameters:
        node1.tcp.typename = "TcpExt"; // let node1 use a custom TCP
        node2.tcp.typename = ""; // no TCP in node2
    submodules:
        node1: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>;
        node2: <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>;
}
</pre>
<p>
Note that this trick does not work with submodule vectors. The reason is that
the condition applies to the vector as a whole, while type is per-element.

<p>It is often also useful to be able to check, e.g. in the connections section,
whether a conditional submodule has been created or not. This can be done with
the <b><tt>exists()</tt></b> operator. An example:

<pre class="ned">
module <a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>
{
        ...
    connections:
        ip.tcpOut --&gt; tcp.ipIn if exists(ip) && exists(tcp);
}
</pre>
<p>
Limitation: <b><tt>exists()</tt></b> may only be used <i>after</i> the submodule's
occurrence in the compound module.

<p>

<p>
<h3><a name="sec:ned-lang:connection-like"/>3.11.3 Parametric Connection Types<a class="headerlink" href="#sec:ned-lang:connection-like" title="Permalink to this headline"></a></h3>

<p>Parametric connection types work similarly to parametric submodule types,
and the syntax is similar as well. A basic example that uses a parameter of
the parent module:

<pre class="ned">
a.g++ &lt;--&gt; &lt;channelType&gt; like IMyChannel &lt;--&gt; b.g++;
a.g++ &lt;--&gt; &lt;channelType&gt; like IMyChannel {@display("ls=red");} &lt;--&gt; b.g++;
</pre>
<p>
The expression may use loop variables, parameters of the parent module
and also parameters of submodules (e.g. <tt>host[2].channelType</tt>).

<p>The type expression may also be absent, and then the type is expected to be
specified using typename pattern assignments:

<pre class="ned">
a.g++ &lt;--&gt; &lt;&gt; like IMyChannel &lt;--&gt; b.g++;
a.g++ &lt;--&gt; &lt;&gt; like IMyChannel {@display("ls=red");} &lt;--&gt; b.g++;
</pre>
<p>
A default value may also be given:

<pre class="ned">
a.g++ &lt;--&gt; &lt;default("Ethernet100")&gt; like IMyChannel &lt;--&gt; b.g++;
a.g++ &lt;--&gt; &lt;default(channelType)&gt; like IMyChannel &lt;--&gt; b.g++;
</pre>
<p>
The corresponding type pattern assignments:

<pre class="ned">
a.g$o[0].channel.typename = "Ethernet1000";  // A -&gt; B channel
b.g$o[0].channel.typename = "Ethernet1000";  // B -&gt; A channel
</pre>
<p>

<p><h2><a name="sec:ned-lang:properties"/>3.12 Metadata Annotations (Properties)<a class="headerlink" href="#sec:ned-lang:properties" title="Permalink to this headline"></a></h2>

<p>NED properties are metadata annotations that can be added to modules, parameters,
gates, connections, NED files, packages, and virtually anything in NED.
<tt>@display</tt>, <tt>@class</tt>, <tt>@namespace</tt>, <tt>@unit</tt>, <tt>@prompt</tt>,
<tt>@loose</tt>, <tt>@directIn</tt> are all properties that have been mentioned in
previous sections, but those examples only scratch the surface of what
properties are used for.

<p>
Using properties, one can attach extra information to NED elements. Some
properties are interpreted by NED, by the simulation kernel; other
properties may be read and used from within the simulation model, or
provide hints for NED editing tools.

<p>Properties are attached to the type, so one cannot have different
properties defined per-instance. All instances of modules, connections,
parameters, etc. created from any particular location in the NED files have
identical properties.

<p>The following example shows the syntax for annotating various NED elements:

<pre class="ned">
@namespace(foo);  // file property

module Example
{
    parameters:
       @node;   // module property
       @display("i=device/pc");   // module property
       int a @unit(s) = default(1); // parameter property
    gates:
       output out @loose @labels(pk);  // gate properties
    submodules:
       src: Source {
           parameters:
              @display("p=150,100");  // submodule property
              count @prompt("Enter count:"); // adding a property to a parameter
           gates:
              out[] @loose;  // adding a property to a gate
       }
       ...
    connections:
       src.out++ --&gt; { @display("ls=green,2"); } --&gt; sink1.in; // connection prop.
       src.out++ --&gt; Channel { @display("ls=green,2"); } --&gt; sink2.in;
}
</pre>
<p>

<p><h3><a name="sec:ned-lang:property-indices"/>3.12.1 Property Indices<a class="headerlink" href="#sec:ned-lang:property-indices" title="Permalink to this headline"></a></h3>

<p>Sometimes it is useful to have multiple properties with the same name,
for example for declaring multiple statistics produced by a simple module.
<i>Property indices</i> make this possible.

<p>A property index is an identifier or a number in square brackets after the
property name, such as <tt>eed</tt> and <tt>jitter</tt> in the following example:

<pre class="ned">
simple App {
    @statistic[eed](title="end-to-end delay of received packets";unit=s);
    @statistic[jitter](title="jitter of received packets");
}
</pre>
<p>
This example declares two statistics as <tt>@statistic</tt> properties,
<tt>@statistic[eed]</tt> and <tt>@statistic[jitter]</tt>. Property values within
the parentheses are used to supply additional info, like a more
descriptive name (<tt>title="..."</tt> or a unit (<tt>unit=s</tt>).
Property indices can be conveniently accessed from the C++ API as
well; for example it is possible to ask what indices exist for the
<tt>"statistic"</tt> property, and it will return a list containing
<tt>"eed"</tt> and <tt>"jitter"</tt>).

<p>In the <tt>@statistic</tt> example the index was textual and meaningful,
but neither is actually required. The following dummy example
shows the use of numeric indices which may be ignored altogether
by the code that interprets the properties:

<pre class="ned">
simple Dummy {
    @foo[1](what="apples";amount=2);
    @foo[2](what="oranges";amount=5);
}
</pre>
<p>
Note that without the index, the lines would actually define the
same <tt>@foo</tt> property, and would overwrite each other's values.

<p>Indices also make it possible to override entries via inheritance:

<pre class="ned">
simple DummyExt extends Dummy {
    @foo[2](what="grapefruits"); // 5 grapefruits instead of 5 oranges
}
</pre>
<p>

<p><h3><a name="sec:ned-lang:property-data-model"/>3.12.2 Data Model<a class="headerlink" href="#sec:ned-lang:property-data-model" title="Permalink to this headline"></a></h3>

<p>Properties may contain data, given in parentheses; the data model is quite
flexible. To begin with, properties may contain no value or a single
value:

<pre class="ned">
@node;
@node(); // same as @node
@class(FtpApp2);
</pre>
<p>
Properties may contain lists:

<pre class="ned">
@foo(Sneezy,Sleepy,Dopey,Doc,Happy,Bashful,Grumpy);
</pre>
<p>
They may contain key-value pairs, separated by semicolons:

<pre class="ned">
@foo(x=10.31; y=30.2; unit=km);
</pre>
<p>
In key-value pairs, each value can be a (comma-separated) list:

<pre class="ned">
@foo(coords=47.549,19.034;labels=vehicle,router,critical);
</pre>
<p>
The above examples are special cases of the general data model. According
to the data model, properties contain <i>key-valuelist</i> pairs,
separated by semicolons. Items in <i>valuelist</i> are separated by
commas. Wherever <i>key</i> is missing, values go on the valuelist of the
<i>default key</i>, the empty string.

<p>Value items may contain words, numbers, string constants and some other
characters, but not arbitrary strings. Whenever the syntax does not permit
some value, it should be enclosed in quotes. This quoting does not affect
the value because the parser automatically drops one layer of quotes; thus,
<tt>@class(TCP)</tt> and <tt>@class("TCP")</tt> are exactly the same. If the
quotes themselves need to be part of the value, an extra layer of quotes
and escaping are the solution: <tt>@foo("\"some
string\"")</tt>.

<p>There are also some conventions. One can use properties to tag NED
elements; for example, a <b><tt>@host</tt></b> property could be used to mark all
module types that represent various hosts. This property could be
recognized e.g. by editing tools, by topology discovery code inside the
simulation model, etc.

<p>The convention for such a &#8220;marker&#8221; property is that any extra data in it
(i.e. within parens) is ignored, except a single word <tt>false</tt>, which has
the special meaning of &#8220;turning off&#8221; the property. Thus, any simulation model
or tool that interprets properties should handle all the following forms as
equivalent to <tt>@host</tt>: <tt>@host()</tt>, <tt>@host(true)</tt>,
<tt>@host(anything-but-false)</tt>, <tt>@host(a=1;b=2)</tt>; and
<tt>@host(false)</tt> should be interpreted as the lack of the <tt>@host</tt>
tag.

<p>
<h3><a name="sec:ned-lang:overriding-and-extending-property-values"/>3.12.3 Overriding and Extending Property Values<a class="headerlink" href="#sec:ned-lang:overriding-and-extending-property-values" title="Permalink to this headline"></a></h3>

<p>Properties defined on a module or channel type may be updated both by
subclassing and when using type as a submodule or connection channel.
One can add new properties, and also modify existing ones.

<p>When modifying a property, the new property is merged with the old one. The
rules of merging are fairly simple. New keys simply get added. If a key already
exists in the old property, items in its valuelist overwrite items on
the same position in the old property. A single hyphen ($-$) as
valuelist item serves as &#8220;antivalue&#8221;, it removes the item at the
corresponding position.

<p>Some examples:

<p><table>
<TR> <TD align=left> <i>base</i>   </TD> <TD align=left> <tt>@prop</tt>  </TD></TR>
<TR> <TD align=left> <i>new</i>    </TD> <TD align=left> <tt>@prop(a)</tt>  </TD></TR>
<TR> <TD align=left>
<i>result</i> </TD> <TD align=left> <tt>@prop(a)</tt>
</table>

<p><table>
<TR> <TD align=left> <i>base</i>   </TD> <TD align=left> <tt>@prop(a,b,c)</tt>  </TD></TR>
<TR> <TD align=left> <i>new</i>    </TD> <TD align=left> <tt>@prop(,-)</tt>  </TD></TR>
<TR> <TD align=left>
<i>result</i> </TD> <TD align=left> <tt>@prop(a,,c)</tt>
</table>

<p><table>
<TR> <TD align=left> <i>base</i>   </TD> <TD align=left> <tt>@prop(foo=a,b)</tt>  </TD></TR>
<TR> <TD align=left> <i>new</i>    </TD> <TD align=left> <tt>@prop(foo=A,,c;bar=1,2)</tt>  </TD></TR>
<TR> <TD align=left>
<i>result</i> </TD> <TD align=left> <tt>@prop(foo=A,b,c;bar=1,2)</tt>
</table>

<p><ul class="note"><b>NOTE</b><br>
    The above merge rules are part of NED, but the code that interprets
    properties may have special rules for certain properties. For example,
    the <tt>@unit</tt> property of parameters is not allowed to be overridden,
    and <tt>@display</tt> is merged with special although similar rules
    (see Chapter <a href="#cha:graphics">[8]</a>).
</ul>

<p>

<p>
<h2><a name="sec:ned-lang:inheritance"/>3.13 Inheritance<a class="headerlink" href="#sec:ned-lang:inheritance" title="Permalink to this headline"></a></h2>

<p>Inheritance support in the NED language is only described briefly here,
because several details and examples have been already presented in
previous sections.

<p>In NED, a type may only extend (<b><tt>extends</tt></b> keyword) an element of
the same component type: a simple module may extend a simple module, a
channel may extend a channel, a module interface may extend a module
interface, and so on. There is one irregularity, however: A compound module
may extend a simple module (and inherits its C++ class), but not vica
versa.

<p>Single inheritance is supported for modules and channels, and multiple inheritance
is supported for module interfaces and channel interfaces. A network is a
shorthand for a compound module with the <b><tt>@isNetwork</tt></b> property set, so
the same rules apply to it as to compound modules.

<p>However, a simple or compound module type may implement (<b><tt>like</tt></b>
keyword) several module interfaces; likewise, a channel type may implement
several channel interfaces.

<p><ul class="important"><b>IMPORTANT</b><br>
    When you extend a simple module type both in NED and in C++, you must
    use the <b><tt>@class</tt></b> property to tell NED to use the new C++ class --
    otherwise the new module type inherits the C++ class of the base!
</ul>

<p>Inheritance may:
<ul>
    <li> add new properties, parameters, gates, inner types, submodules,
          connections, as long as names do not conflict with inherited names
    <li> modify inherited properties, and properties of inherited parameters and
          gates
    <li> it may not modify inherited submodules, connections and inner types
</ul>

<p>For details and examples, see the corresponding sections of this chapter
(simple modules <a href="#sec:ned-lang:simple-modules">[3.3]</a>,
compound modules <a href="#sec:ned-lang:compound-modules">[3.4]</a>,
channels <a href="#sec:ned-lang:channels">[3.5]</a>,
parameters <a href="#sec:ned-lang:parameters">[3.6]</a>,
gates <a href="#sec:ned-lang:gates">[3.7]</a>,
submodules <a href="#sec:ned-lang:submodules">[3.8]</a>,
connections <a href="#sec:ned-lang:connections">[3.9]</a>,
module interfaces and channel interfaces <a href="#sec:ned-lang:submodule-like">[3.11.1]</a>).

<p>

<p><h2><a name="sec:ned-lang:packages"/>3.14 Packages<a class="headerlink" href="#sec:ned-lang:packages" title="Permalink to this headline"></a></h2>

<p>Having all NED files in a single directory is fine for small simulation projects.
When a project grows, however, it sooner or later becomes
necessary to introduce a directory structure, and sort the NED files into
them. NED natively supports directory trees with NED files, and calls
directories <i>packages</i>. Packages are also useful for reducing
name conflicts, because names can be qualified with the package name.

<p><ul class="note"><b>NOTE</b><br>
    NED packages are based on the Java package concept, with minor
    enhancements. If you are familiar with Java, you'll find little
    surprise in this section.
</ul>

<p><h3><a name="sec:ned-lang:packages-overview"/>3.14.1 Overview<a class="headerlink" href="#sec:ned-lang:packages-overview" title="Permalink to this headline"></a></h3>

<p>When a simulation is run, one must tell the simulation kernel the
directory which is the root of the package tree; let's call it
<i>NED source folder</i>. The simulation kernel will traverse
the whole directory tree, and load all NED files from every directory.
One can have several NED directory trees, and their roots (the NED source
folders) should be given to the simulation kernel in the <i>NED path</i>
variable. The NED path can be specified in several ways: as an environment
variable (<tt>NEDPATH</tt>), as a configuration option (<b><tt>ned-path</tt></b>),
or as a command-line option to the simulation runtime (<tt>-n</tt>). <tt>NEDPATH</tt> is
described in detail in chapter <a href="#cha:run-sim">[11]</a>.

<p>Directories in a NED source tree correspond to packages. If NED files are
in the <tt>&lt;root&gt;/a/b/c</tt> directory (where <tt>&lt;root&gt;</tt> is listed in NED
path), then the package name is <tt>a.b.c</tt>. The package name has to be
explicitly declared at the top of the NED files as well, like this:

<pre class="ned">
package a.b.c;
</pre>
<p>
The package name that follows from the directory name and the declared
package must match; it is an error if they don't. (The only exception
is the root <tt>package.ned</tt> file, as described below.)

<p>By convention, package names are all lowercase, and begin with either
the project name (<tt>myproject</tt>), or the reversed domain name plus the
project name (<tt>org.example.myproject</tt>). The latter convention
would cause the directory tree to begin with a few levels of empty
directories, but this can be eliminated with a toplevel <tt>package.ned</tt>.

<p>NED files called <tt>package.ned</tt> have a special role, as they are meant
to represent the whole package. For example, comments in
<tt>package.ned</tt> are treated as documentation of the package. Also, a
<b><tt>@namespace</tt></b> property in a <tt>package.ned</tt> file affects all NED
files in that directory and all directories below.

<p>The toplevel <tt>package.ned</tt> file can be used to designate the root
package, which is useful for eliminating a few levels of empty directories
resulting from the package naming convention. For example, given a project
where all NED types are under the <tt>org.acme.foosim</tt> package, one can
eliminate the empty directory levels <tt>org</tt>, <tt>acme</tt> and <tt>foosim</tt> by
creating a <tt>package.ned</tt> file in the source root directory with
the package declaration <tt>org.example.myproject</tt>. This will cause a
directory <tt>foo</tt> under the root to be interpreted as package
<tt>org.example.myproject.foo</tt>, and NED files in them must contain that as
package declaration. Only the root <tt>package.ned</tt> can define the
package, <tt>package.ned</tt> files in subdirectories must follow it.

<p>Let's look at the INET Framework as example, which contains hundreds of NED
files in several dozen packages. The directory structure looks like this:

<p><pre class="verbatim">
INET/
    src/
        base/
        transport/
            tcp/
            udp/
            ...
        networklayer/
        linklayer/
        ...
    examples/
        adhoc/
        ethernet/
        ...
</pre>

<p>The <tt>src</tt> and <tt>examples</tt> subdirectories are denoted as NED source
folders, so <tt>NEDPATH</tt> is the following (provided INET was unpacked in
<tt>/home/joe</tt>):

<pre class="filelisting">
/home/joe/INET/src;/home/joe/INET/examples
</pre>
<p>
Both <tt>src</tt> and <tt>examples</tt> contain <tt>package.ned</tt> files to
define the root package:

<pre class="ned">
// INET/src/package.ned:
package inet;
</pre>
<p>
<pre class="ned">
// INET/examples/package.ned:
package inet.examples;
</pre>

<p>And other NED files follow the package defined in <tt>package.ned</tt>:

<pre class="ned">
// INET/src/transport/tcp/TCP.ned:
package inet.transport.tcp;
</pre>
<p>

<p><h3><a name="sec:ned-lang:imports-and-name-resolution"/>3.14.2 Name Resolution, Imports<a class="headerlink" href="#sec:ned-lang:imports-and-name-resolution" title="Permalink to this headline"></a></h3>

<p>We already mentioned that packages can be used to distinguish
similarly named NED types. The name that includes the package name
(<tt>a.b.c.Queue</tt> for a <tt>Queue</tt> module in the <tt>a.b.c</tt>
package) is called <i>fully qualified name</i>; without the package
name (<tt>Queue</tt>) it is called <i>simple name</i>.

<p>Simple names alone are not enough to unambiguously identify a type.
Here is how one can refer to an existing type:

<p><ol>
  <li> By fully qualified name. This is often cumbersome though,
        as names tend to be too long;
  <li> Import the type, then the simple name will be enough;
  <li> If the type is in the same package, then it doesn't need to be
        imported; it can be referred to by simple name
</ol>

<p>Types can be imported with the <b><tt>import</tt></b> keyword by either
fully qualified name, or by a wildcard pattern. In wildcard patterns,
one asterisk ("<tt>*</tt>") stands for "any character sequence not containing
period", and two asterisks ("<tt>**</tt>") mean "any character sequence which may
contain period".

<p>So, any of the following lines can be used to import a type called
<tt>inet.protocols.networklayer.ip.RoutingTable</tt>:

<pre class="ned">
import inet.protocols.networklayer.ip.RoutingTable;
import inet.protocols.networklayer.ip.*;
import inet.protocols.networklayer.ip.Ro*Ta*;
import inet.protocols.*.ip.*;
import inet.**.RoutingTable;
</pre>
<p>
If an import explicitly names a type with its exact fully qualified name,
then that type must exist, otherwise it is an error. Imports containing
wildcards are more permissive, it is allowed for them not to match any
existing NED type (although that might generate a warning.)

<p>Inner types may not be referred to outside their enclosing types, so they
cannot be imported either.

<p>
<h3><a name="sec:ned-lang:name-resolution-with-like"/>3.14.3 Name Resolution With "like"<a class="headerlink" href="#sec:ned-lang:name-resolution-with-like" title="Permalink to this headline"></a></h3>

<p>The situation is a little different for submodule and connection channel
specifications using the <b><tt>like</tt></b> keyword, when the type name comes
from a string-valued expression (see section
<a href="#sec:ned-lang:submodule-like">[3.11.1]</a> about submodule and channel types as
parameters). Imports are not much use here: at the time of writing the NED
file it is not yet known what NED types will be suitable for being "plugged
in" there, so they cannot be imported in advance.

<p>There is no problem with fully qualified names, but simple names need
to be resolved differently. What NED does is this: it determines which
interface the module or channel type must implement (i.e. <tt>... like INode</tt>),
and then collects the types that have the given simple name AND implement
the given interface. There must be exactly one such type, which is then used.
If there is none or there are more than one, it will be reported as an error.

<p>Let us see the following example:

<pre class="ned">
module MobileHost
{
    parameters:
        string mobilityType;
    submodules:
        mobility: &lt;mobilityType&gt; like IMobility;
        ...
}
</pre>
<p>
and suppose that the following modules implement the <tt>IMobility</tt> module
interface: <tt>inet.mobility.RandomWalk</tt>, <tt>inet.adhoc.RandomWalk</tt>,
<tt>inet.mobility.MassMobility</tt>. Also suppose that there is a type
called <tt>inet.examples.adhoc.MassMobility</tt> but it does not implement the
interface.

<p>So if <tt>mobilityType="MassMobility"</tt>, then
<tt>inet.mobility.MassMobility</tt> will be selected; the other
<tt>MassMobility</tt> doesn't interfere. However, if
<tt>mobilityType="RandomWalk"</tt>, then it is an error because there are two
matching <tt>RandomWalk</tt> types. Both <tt>RandomWalk</tt>'s can still be used,
but one must explicitly choose one of them by providing a package name:
<tt>mobilityType="inet.adhoc.RandomWalk"</tt>.

<p>
<h3><a name="sec:ned-lang:default-package"/>3.14.4 The Default Package<a class="headerlink" href="#sec:ned-lang:default-package" title="Permalink to this headline"></a></h3>

<p>It is not mandatory to make use of packages: if all NED files are in a
single directory listed on the NEDPATH, then package declarations (and
imports) can be omitted. Those files are said to be in the <i>default
package</i>.

<p>



<p>
<hr class='pgbr'><h1><a name="cha:simple-modules"/>4 Simple Modules<a class="headerlink" href="#cha:simple-modules" title="Permalink to this headline"></a></h1>
<!--module!simple-->

<p>
<i>Simple modules</i> are the active components in the model.
Simple modules are programmed in C++, using the OMNeT++ class
library. The following sections contain a short introduction
to discrete event simulation in general, explain how its concepts are
implemented in OMNeT++, and give an overview and practical advice
on how to design and code simple modules.

<p>
<h2><a name="sec:simple-modules:simulation-concepts"/>4.1 Simulation Concepts<a class="headerlink" href="#sec:simple-modules:simulation-concepts" title="Permalink to this headline"></a></h2>

<p>This section contains a very brief introduction into how discrete
event simulation (DES) works, in order to introduce terms we'll use
when explaining OMNeT++ concepts<!--simulation!concepts--> and
implementation.

<p>
<h3><a name="sec:simple-modules:discrete-event-simulation"/>4.1.1 Discrete Event Simulation<a class="headerlink" href="#sec:simple-modules:discrete-event-simulation" title="Permalink to this headline"></a></h3>

<p>A <i>discrete event system</i> is a system where state changes
(events<!--events-->) happen at discrete instances in time, and events take zero time
to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change takes
place in the system between the events. This is in contrast to
<i>continuous</i> systems where state changes are continuous.
Systems that can be viewed as discrete event systems can be modeled
using discrete event simulation<!--discrete event simulation-->, DES.

<p>For example, computer networks are usually viewed as discrete
event systems. Some of the events are:

<p><ul>
  <li> start of a packet transmission
  <li> end of a packet transmission
  <li> expiry of a retransmission timeout
</ul>

<p>This implies that between two events such as <i>start of a packet
transmission</i> and <i>end of a packet transmission</i>, nothing
interesting happens. That is, the packet's state remains <i>being
transmitted</i>. Note that the definition of &#8220;interesting&#8221; events and states always
depends on the intent and purposes of the modeler.
If we were interested in the transmission of individual bits, we would
have included something like <i>start of bit transmission</i> and
<i>end of bit transmission</i> among our events.

<p>
The time when events occur is often called <i>event timestamp</i>;
<!--event timestamp--> with OMNeT++ we use the term
<i>arrival time</i><!--arrival time--> (because in the class
library, the word &#8220;timestamp&#8221; is reserved for a user-settable
attribute in the event class). Time within the model is often called
<i>simulation time</i><!--simulation time-->, <i>model time</i>
<!--model!time--> or <i>virtual time</i><!--virtual time-->
as opposed to real time<!--real time--> or CPU time<!--CPU time-->
which refer to how long the simulation program has been running and
how much CPU time it has consumed.

<p>

<p><h3><a name="sec:simple-modules:event-loop"/>4.1.2 The Event Loop<a class="headerlink" href="#sec:simple-modules:event-loop" title="Permalink to this headline"></a></h3>

<p>Discrete event simulation maintains the set of future
events<!--future events--> in a data structure often called
FES<!--FES--> (Future Event Set) or FEL<!--FEL--> (Future Event List).
Such simulators usually work according to the following pseudocode:

<p><pre class="verbatim">
<i>initialize -- this includes building the model and</i>
              <i>inserting initial events to FES</i>

<i>while (FES not empty and simulation not yet complete)</i>
<i>{</i>
    <i>retrieve first event from FES</i>
    <i>t:= timestamp of this event</i>
    <b><i>process event</i></b>
    <i>(processing may insert new events in FES or delete existing ones)</i>
<i>}</i>
<i>finish simulation (write statistical results, etc.)</i>
</pre>

<p>
The initialization step usually builds the data structures
representing the simulation model, calls any user-defined
initialization code, and inserts initial events<!--initial events-->
into the FES<!--FES--> to ensure that the simulation can start. Initialization
strategies can differ considerably from one simulator to another.

<p>
The subsequent loop consumes events from the FES<!--FES--> and processes
them. Events are processed in strict timestamp order
to maintain causality, that is, to ensure that no current event may have
an effect on earlier events.

<p>Processing an event involves calls to user-supplied code. For example,
using the computer network simulation example, processing a &#8220;timeout
expired&#8221; event may consist of re-sending a copy of the network
packet, updating the retry count, scheduling another &#8220;timeout&#8221;
event, and so on. The user code may also remove events from the FES<!--FES-->,
for example when canceling timeouts.

<p>The simulation stops when there are no events left (this rarely happens
in practice), or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the user
will typically want to record statistics into output files.

<p>
<h3><a name="sec:simple-modules:events-in-opp"/>4.1.3 Events and Event Execution Order in OMNeT++<a class="headerlink" href="#sec:simple-modules:events-in-opp" title="Permalink to this headline"></a></h3>

<p>OMNeT++ uses messages<!--message--> to represent
events<!--events-->.<br><ul><font size=-1>[For all practical purposes. Note that there
is a class called <tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt> that <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> subclasses from,
but it is only used internal to the simulation kernel.]</font></ul>
Messages are represented by instances of the <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> class
and its subclasses. Messages are sent from one module to another -- this
means that the place where the &#8220;event will occur&#8221; is the
<i>message's destination module</i>, and the model time when the
event occurs is the <i>arrival time</i><!--arrival time--> of the
message. Events like &#8220;timeout expired&#8221; are implemented by the
module sending a message to itself.

<p>Events are consumed from the FES<!--FES--> in arrival time order, to
maintain causality. More precisely, given two messages, the following
rules apply:

<p><ol>
<li> The message with the <b>earlier arrival time</b> is executed
    first. If arrival times are equal,
<li> the one with the <b>higher scheduling priority</b> (smaller
    numeric value) is executed first. If priorities are the same,
<li> the one <b>scheduled/sent earlier</b> is executed first.
</ol>

<p><i>Scheduling priority</i><!--message!priority--> is a user-assigned integer
attribute of messages.

<p>

<p><h3><a name="sec:simple-modules:simulation-time"/>4.1.4 Simulation Time<a class="headerlink" href="#sec:simple-modules:simulation-time" title="Permalink to this headline"></a></h3>

<p>The current simulation time can be obtained with the <tt>simTime()</tt> function.

<p>Simulation time in OMNeT++ is represented by the C++ type <tt>simtime_t</tt>,
which is by default a typedef to the <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> class.
<tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> class stores simulation time in a 64-bit integer,
using decimal fixed-point representation. The resolution is controlled
by the <i>scale exponent</i> global configuration variable; that is,
<tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> instances have the same resolution. The exponent can be
chosen between -18 (attosecond resolution) and 0 (seconds).
Some exponents with the ranges they provide are shown in the following table.

<p><center>
  <table border>
<TR> <TD align=right>
    Exponent </TD> <TD align=right> Resolution </TD> <TD align=center> Approx. Range </TD></TR>
<TR> <TD align=right>      -18 </TD> <TD align=right> <i>10<sup>-18</sup></i>s (1as) </TD> <TD align=center> <i>+/- 9.22</i>s </TD></TR>
<TR> <TD align=right>      -15 </TD> <TD align=right> <i>10<sup>-15</sup></i>s (1fs) </TD> <TD align=center> <i>+/- 153.72</i> minutes </TD></TR>
<TR> <TD align=right>      -12 </TD> <TD align=right> <i>10<sup>-12</sup></i>s (1ps) </TD> <TD align=center> <i>+/- 106.75</i> days </TD></TR>
<TR> <TD align=right>      -9  </TD> <TD align=right> <i>10<sup>-9</sup></i>s (1ns)  </TD> <TD align=center> <i>+/- 292.27</i> years </TD></TR>
<TR> <TD align=right>      -6  </TD> <TD align=right> <i>10<sup>-6</sup></i>s (1us)  </TD> <TD align=center> <i>+/- 292271</i> years </TD></TR>
<TR> <TD align=right>      -3  </TD> <TD align=right> <i>10<sup>-3</sup></i>s (1ms)  </TD> <TD align=center> <i>+/- 2.9227e8</i> years </TD></TR>
<TR> <TD align=right>      0   </TD> <TD align=right> 1s                </TD> <TD align=center> <i>+/- 2.9227e11</i> years </TD></TR>
  </table>
</center>

<p>Note that although simulation time cannot be negative, it is still useful to
be able to represent negative numbers, because they often arise
during the evaluation of arithmetic expressions.

<p>There is no implicit conversion from <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> to <tt>double</tt>, mostly
because it would conflict with overloaded arithmetic operations of <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt>;
use the <tt>dbl()</tt> method of <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> or the <tt>SIMTIME_DBL()</tt> macro
to convert. To reduce the need for <tt>dbl()</tt>, several functions and methods
have overloaded variants that directly accept <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt>, for example
<tt>fabs()</tt>, <tt>fmod()</tt>, <tt>div()</tt>, <tt>ceil()</tt>, <tt>floor()</tt>,
<tt>uniform()</tt>, <tt>exponential()</tt>, and <tt>normal()</tt>.

<p>Other useful methods of <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> include <tt>str()</tt>,
which returns the value as a string; <tt>parse()</tt>, which converts a
string to <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt>; <tt>raw()</tt>, which returns the
underlying 64-bit integer; <tt>getScaleExp()</tt>, which returns the
global scale exponent; <tt>isZero()</tt>, which tests whether the
simulation time is 0; and <tt>getMaxTime()</tt>, which returns the maximum
simulation time that can be represented at the current scale exponent.
Zero and the maximum simulation time are also accessible
via the <tt>SIMTIME_ZERO</tt> and <tt>SIMTIME_MAX</tt> macros.

<pre class="cpp">
// 340 microseconds in the future, truncated to millisecond boundary
simtime_t timeout = (simTime() + <a href="../api/classomnetpp_1_1SimTime.html">SimTime</a>(340, SIMTIME_US)).trunc(SIMTIME_MS);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
   Converting a <tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a></tt> to <tt>double</tt> may lose precision, because
   <tt>double</tt> only has a 52-bit mantissa.
   Earlier versions of OMNeT++ used <tt>double</tt> for the simulation
   time, but that caused problems in long simulations that relied on fine-grained timing,
   for example MAC protocols. Other problems were the accumulation of
   rounding errors, and non-associativity (often <i>(x+y)+z != x+(y+z)</i>, see
   ~[<a href="#bib-Goldberg91what">Goldberg91what</a>]) which meant that two <tt>double</tt> simulation
   times could not be reliably compared for equality.
</ul>

<p>
<h3><a name="sec:simple-modules:fes-implementation"/>4.1.5 FES Implementation<a class="headerlink" href="#sec:simple-modules:fes-implementation" title="Permalink to this headline"></a></h3>

<p>The implementation of the FES<!--FES--> is a crucial factor in the
performance of a discrete event simulator. In OMNeT++, the FES is
replaceable, and the default FES implementation uses <i>binary
heap</i><!--binary heap--> as data structure. Binary heap is generally
considered to be the best FES algorithm for discrete event simulation, as
it provides a good, balanced performance for most workloads. (Exotic data
structures like <i>skiplist</i><!--skiplist--> may perform better than
heap in some cases.)

<p>
<h2><a name="sec:simple-modules:simple-modules-in-opp"/>4.2 Components, Simple Modules, Channels<a class="headerlink" href="#sec:simple-modules:simple-modules-in-opp" title="Permalink to this headline"></a></h2>

<p>OMNeT++ simulation models are composed of modules and connections. Modules
may be simple (atomic) modules or compound modules; simple modules are the
active components in a model, and their behaviour is defined by the user as
C++ code. Connections may have associated channel objects. Channel objects
encapsulate channel behavior: propagation and transmission time modeling,
error modeling, and possibly others. Channels are also programmable in C++
by the user.

<p>Modules and channels are represented with the <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>
classes, respectively. <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt> are both
derived from the <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt> class.

<p>The user defines simple module types by subclassing <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>.
Compound modules are instantiated with <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>, although
the user can override it with <b><tt>@class</tt></b> in the NED file, and can even
use a simple module C++ class (i.e. one derived from <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>)
for a compound module.

<p>The <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>'s subclasses include the three built-in channel
types: <tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt>, <tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> and
<tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt>. The user can create new channel types
by subclassing <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt> or any other channel class.

<p>The following inheritance diagram illustrates the relationship
of the classes mentioned above.

<p>
  <center>
    <img src="component-inheritance.svg">
    <center><div class="caption"><i>Figure: Inheritance of component, module and channel classes</i></div></center>
  </center>

<p>
Simple modules and channels can be programmed by redefining certain
member functions, and providing your own code in them. Some of those
member functions are declared on <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>, the common base
class of channels and modules.

<p><tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt> has the following member functions meant for
redefining in subclasses:

<p><ul>
  <li> <tt>initialize()</tt>. This method is invoked after OMNeT++ has
    set up the network (i.e. created modules and connected them according
    to the definitions), and provides a place for initialization code;
  <li> <tt>finish()</tt> is called when the simulation has terminated
    successfully, and its recommended use is the recording of summary
    statistics.
</ul>

<p><tt>initialize()</tt> and <tt>finish()</tt>, together with <tt>initialize()</tt>'s
variants for multi-stage initialization, will be covered in detail in
section <a href="#sec:simple-modules:initialize-and-finish">[4.3.3]</a>.

<p>In OMNeT++, events occur inside simple modules<!--module!simple-->.
Simple modules encapsulate C++ code that generates events and reacts to events,
implementing the behaviour of the module.

<p>To define the dynamic behavior of a simple module, one of the following
member functions need to be overridden:

<p><ul>
  <li> <tt>handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)</tt>. It
     is invoked with the message as parameter whenever the
     module receives a message. <tt>handleMessage()</tt> is
     expected to <i>process</i> the message, and then return.
     Simulation time never elapses inside <tt>handleMessage()</tt>
     calls, only between them.
  <li> <tt>activity()</tt> is started as a coroutine<br><ul><font size=-1>[Cooperatively
     scheduled thread, explained later.]</font></ul> at the beginning of the simulation, and
     it runs until the end of simulation (or until the function
     returns or otherwise terminates). Messages are obtained with
     <tt>receive()</tt> calls. Simulation time elapses inside
     <tt>receive()</tt> calls.
</ul>

<p>Modules written with <tt>activity()</tt> and <tt>handleMessage()</tt> can be
freely mixed within a simulation model. Generally, <tt>handleMessage()</tt>
should be preferred to <tt>activity()</tt>, due to scalability and other
practical reasons. The two functions will be described in detail in sections
<a href="#sec:simple-modules:handlemessage">[4.4.1]</a> and <a href="#sec:simple-modules:activity">[4.4.2]</a>,
including their advantages and disadvantages.

<p>The behavior of channels can also be modified by redefining member functions.
However, the channel API is slightly more complicated than that of simple
modules, so we'll describe it in a later section (<a href="#sec:simple-modules:channels">[4.8]</a>).

<p>Last, let us mention <tt>refreshDisplay()</tt>, which is related to updating
the visual appearance of the simulation when run under a graphical user
interface. <tt>refreshDisplay()</tt> is covered in the chapter that deals
with simulation visualization (<a href="#sec:graphics:refreshdisplay">[8.2]</a>).

<p><ul class="note"><b>NOTE</b><br>
    <tt>refreshDisplay()</tt> has been added in OMNeT++ 5.0. Until then,
    visualization-related tasks were usually implemented as part of
    <tt>handleMessage()</tt>. <tt>refreshDisplay()</tt> provides
    a far superior and more efficient solution.
</ul>

<p>
<h2><a name="sec:simple-modules:defining-simple-modules"/>4.3 Defining Simple Module Types<a class="headerlink" href="#sec:simple-modules:defining-simple-modules" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:simple-modules:defining:overview"/>4.3.1 Overview<a class="headerlink" href="#sec:simple-modules:defining:overview" title="Permalink to this headline"></a></h3>

<p>As mentioned before, a simple module<!--module!simple--> is nothing more
than a C++ class which has to be subclassed from <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>,
with one or more virtual member functions redefined to define its behavior.

<p>The class has to be registered with OMNeT++ via the <tt>Define_Module()</tt> macro.
The <tt>Define_Module()</tt> line should always be put into <tt>.cc</tt> or <tt>.cpp</tt>
files and not header file (<tt>.h</tt>), because the compiler generates code from it.

<p>The following <tt>HelloModule</tt> is about the simplest simple module one could write.
(We could have left out the <tt>initialize()</tt> method as well to make it even smaller,
but how would it say Hello then?) Note <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt> as base class,
and the <tt>Define_Module()</tt> line.

<pre class="cpp">
// file: HelloModule.cc
#include &lt;omnetpp.h&gt;
using namespace omnetpp;

class HelloModule : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

// register module class with OMNeT++
Define_Module(HelloModule);

void HelloModule::initialize()
{
    EV &lt;&lt; "Hello World!\n";
}

void HelloModule::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    delete msg; // just discard everything we receive
}
</pre>
<p>
In order to be able to refer to this simple<!--module!simple--> module type
in NED files, we also need an associated NED declaration which might
look like this:

<pre class="ned">
// file: HelloModule.ned
simple HelloModule
{
    gates:
        input in;
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:module-ctor"/>4.3.2 Constructor<a class="headerlink" href="#sec:simple-modules:module-ctor" title="Permalink to this headline"></a></h3>

<p>Simple modules are never instantiated by the user directly, but rather by
the simulation kernel. This implies that one cannot write arbitrary
constructors: the signature must be what is expected by the simulation kernel.
Luckily, this contract is very simple: the constructor must be public, and must take
no arguments:

<pre class="cpp">
  public:
    HelloModule();  // constructor takes no arguments
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt> itself has two constructors:
<ol>
  <li> <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>()</tt> -- one without arguments
  <li> <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>(size_t stacksize)</tt> -- one that accepts the coroutine
        stack size<!--module!stack size--><!--stack!size-->
</ol>

<p>The first version should be used with <tt>handleMessage()</tt> simple modules,
and the second one with <tt>activity()</tt> modules.
(With the latter, the <tt>activity()</tt> method of the module class
runs as a coroutine<!--coroutine--> which needs a separate CPU stack,
usually of 16..32K. This will be discussed in detail later.)
Passing zero stack size to the latter constructor also selects <tt>handleMessage()</tt>.

<p>Thus, the following constructor definitions are all OK, and select
<tt>handleMessage()</tt> to be used with the module:

<pre class="cpp">
HelloModule::HelloModule() {...}
HelloModule::HelloModule() : <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>() {...}
</pre>
<p>
It is also OK to omit the constructor altogether, because the
compiler-generated one is suitable too.

<p>The following constructor definition selects <tt>activity()</tt> to be used
with the module, with 16K of coroutine stack:

<pre class="cpp">
HelloModule::HelloModule() : <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>(16384) {...}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    The <tt>Module_Class_Members()</tt> macro, already deprecated in OMNeT++ 3.2,
    has been removed in the 4.0 version. When porting older simulation models,
    occurrences of this macro can simply be removed from the source code.
</ul>

<p>
<h3><a name="sec:simple-modules:initialize-and-finish"/>4.3.3 Initialization and Finalization<a class="headerlink" href="#sec:simple-modules:initialize-and-finish" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:simple-modules:init-finish:basic-usage"/>4.3.3.1 Basic Usage<a class="headerlink" href="#sec:simple-modules:init-finish:basic-usage" title="Permalink to this headline"></a></h4>

<p>The <tt>initialize()</tt> and <tt>finish()</tt> methods are declared
as part of <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>, and provide the user the opportunity
of running code at the beginning and at successful termination of the
simulation.

<p>The reason <tt>initialize()</tt> exists is that usually you cannot put
simulation-related code into the simple module
constructor<!--module!constructor-->, because the simulation model is still
being setup when the constructor runs, and many required objects are not yet
available. In contrast, <tt>initialize()</tt> is called just before the
simulation starts executing, when everything else has been set up
already.

<p><tt>finish()</tt> is for recording statistics, and it only gets called
when the simulation has terminated normally. It does not get called when
the simulations stops with an error message. The destructor always
gets called at the end, no matter how the simulation stopped, but
at that time it is fair to assume that the simulation model has been
halfway demolished already.

<p>Based on the above considerations, the following usage conventions exist
for these four methods:

<p><ul class="dl">

<p><li> Constructor:

<p>Set pointer members of the module class to <tt>nullptr</tt>; postpone all other
initialization tasks to <tt>initialize()</tt>.

<p><li> <tt>initialize()</tt>:

<p>Perform all initialization tasks: read module parameters, initialize
class variables, allocate dynamic data structures with <tt>new</tt>;
also allocate and initialize self-messages (timers) if needed.

<p><li> <tt>finish()</tt>:

<p>Record statistics. Do <b>not</b> <tt>delete</tt> anything or cancel timers --
all cleanup must be done in the destructor.

<p><li> Destructor:

<p>Delete everything which was allocated by <tt>new</tt> and is still held
by the module class. With self-messages (timers), use the
<tt>cancelAndDelete(msg)</tt> function! It is almost always wrong
to just delete a self-message from the destructor, because it might be
in the scheduled events list. The <tt>cancelAndDelete(msg)</tt> function
checks for that first, and cancels the message before deletion if necessary.

<p></ul>

<p>OMNeT++ prints the list of unreleased objects at the end of the simulation.
When a simulation model dumps <i>"undisposed object ..."</i> messages, this indicates
that the corresponding module destructors should be fixed. As a temporary measure, these
messages may be hidden by setting <tt>print-undisposed=false</tt> in the
configuration.

<p><ul class="note"><b>NOTE</b><br>
    The <tt>perform-gc</tt> configuration option has been removed in OMNeT++ 4.0.
    Automatic garbage collection cannot be implemented reliably, due to the
    limitations of the C++ language.
</ul>

<p>
<h4><a name="sec:simple-modules:init-finish:invocation-order"/>4.3.3.2 Invocation Order<a class="headerlink" href="#sec:simple-modules:init-finish:invocation-order" title="Permalink to this headline"></a></h4>

<p>The <tt>initialize()</tt> functions of the modules are invoked <i>before</i>
the first event is processed, but <i>after</i> the initial events (starter
messages<!--starter messages-->) have been placed into the FES<!--FES--> by
the simulation kernel.

<p>Both simple and compound modules have <tt>initialize()</tt> functions. A
compound module's <tt>initialize()</tt> function runs <i>before</i> that of
its submodules.

<p>The <tt>finish()</tt> functions are called when the event loop<!--event loop-->
has terminated, and only if it terminated normally.

<p><ul class="note"><b>NOTE</b><br>
<tt>finish()</tt> is not called if the simulation has terminated
with a runtime error.
</ul>

<p>The calling order for <tt>finish()</tt> is the reverse of the order of
<tt>initialize()</tt>: first submodules, then the encompassing compound module.
  <br><ul><font size=-1>[The way you can provide an <tt>initialize()</tt> function
  for a compound module is to subclass <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>, and tell
  OMNeT++ to use the new class for the compound module. The latter is done
  by adding the <tt>@class(&lt;classname&gt;)</tt> property into the NED declaration.]</font></ul>

<p>This is summarized in the following pseudocode:

<p>
<pre class="verbatim">
<i>perform simulation run:</i>
    build network
      (i.e. the system module and its submodules recursively)
    insert starter messages for all submodules using activity()
    do callInitialize() on system module
        <i>enter event loop // (described earlier)</i>
    if (event loop terminated normally) // i.e. no errors
        do callFinish() on system module
    clean up

callInitialize()
{
    call to user-defined initialize() function
    if (module is compound)
        for (each submodule)
            do callInitialize() on submodule
}

callFinish()
{
    if (module is compound)
        for (each submodule)
            do callFinish() on submodule
    call to user-defined finish() function
}
</pre>

<p>Keep in mind that <tt>finish()</tt> is not always called, so it isn't a
good place for cleanup code which should run every time the module is
deleted. <tt>finish()</tt> is only a good place for writing statistics,
result post-processing and other operations  which are supposed to run only on
successful completion. Cleanup code should go into the
destructor<!--module!destructor-->.

<p>
<h4><a name="sec:simple-modules:multi-stage-init"/>4.3.3.3 Multi-Stage Initialization<a class="headerlink" href="#sec:simple-modules:multi-stage-init" title="Permalink to this headline"></a></h4>

<p>In simulation models where one-stage
initialization<!--initialization--> provided by <tt>initialize()</tt>
is not sufficient, one can use multi-stage
initialization<!--initialization!multi-stage-->.  Modules have two
functions which can be redefined by the user:

<pre class="cpp">
virtual void initialize(int stage);
virtual int numInitStages() const;
</pre>
<p>
At the beginning of the simulation, <tt>initialize(0)</tt>
is called for <i>all</i> modules, then <tt>initialize(1)</tt>,
<tt>initialize(2)</tt>, etc. You can think of it like
initialization takes place in several &#8220;waves&#8221;. For each module,
<tt>numInitStages()</tt> must be redefined to return the number of init
stages required, e.g. for a two-stage init, <tt>numInitStages()</tt>
should return 2, and <tt>initialize(int stage)</tt> must be implemented to
handle the <i>stage=0</i> and <i>stage=1</i> cases.
  <br><ul><font size=-1>[Note the <tt>const</tt> in the <tt>numInitStages()</tt> declaration.
  If you forget it, by C++ rules you create a <i>different</i> function
  instead of redefining the existing one in the base class, thus the
  existing one will remain in effect and return 1.]</font></ul>

<p>The <tt>callInitialize()</tt> function performs the full multi-stage initialization
for that module and all its submodules.

<p>If you do not redefine the multi-stage initialization functions, the
default behavior is single-stage initialization: the default
<tt>numInitStages()</tt> returns 1, and the default <tt>initialize(int stage)</tt>
simply calls <tt>initialize()</tt>.

<p>
<h4><a name="sec:simple-modules:end-of-simulation-event"/>4.3.3.4 &#8220;End-of-Simulation&#8221; Event<a class="headerlink" href="#sec:simple-modules:end-of-simulation-event" title="Permalink to this headline"></a></h4>

<p>The task of <tt>finish()</tt> is implemented in several other simulators
by introducing a special <i>end-of-simulation</i><!--end-of-simulation--> event.
This is not a very good practice because the simulation programmer has to
code the models (often represented as FSMs) so that they can <i>always</i>
properly respond to end-of-simulation events, in whichever state they are. This
often makes program code unnecessarily complicated.
 For this reason OMNeT++ does not use the end of simulation event.

<p>This can also be witnessed in the design of the PARSEC<!--PARSEC-->
simulation language (UCLA). Its predecessor Maisie used
end-of-simulation events, but -- as documented in the PARSEC manual --
this has led to awkward programming in many cases, so for PARSEC
end-of-simulation events were dropped in favour of <tt>finish()</tt>
(called <tt>finalize()</tt> in PARSEC).

<p>
<h2><a name="sec:simple-modules:handlemessage-and-activity"/>4.4 Adding Functionality to <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a><a class="headerlink" href="#sec:simple-modules:handlemessage-and-activity" title="Permalink to this headline"></a></h2>

<p>This section discusses <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>'s previously mentioned
<tt>handleMessage()</tt> and <tt>activity()</tt> member functions, intended
to be redefined by the user.

<p>
<h3><a name="sec:simple-modules:handlemessage"/>4.4.1 handleMessage()<a class="headerlink" href="#sec:simple-modules:handlemessage" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:simple-modules:handlemessage:overview"/>4.4.1.1 Function Called for Each Event<a class="headerlink" href="#sec:simple-modules:handlemessage:overview" title="Permalink to this headline"></a></h4>

<p>The idea is that at each event<!--event--> (message arrival) we
simply call a user-defined function. This function,
<tt>handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)</tt> is a
virtual member function of <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt> which does
nothing by default -- the user has to redefine it in subclasses
and add the message processing code.

<p>The <tt>handleMessage()</tt> function will be called for every message
that arrives at the module. The function should process the message
and return immediately after that. The simulation time is potentially
different in each call. No simulation time elapses within a call
to <tt>handleMessage()</tt>.

<p>The event loop inside the simulator handles both <tt>activity()</tt>
and <tt>handleMessage()</tt> simple modules, and it corresponds
to the following pseudocode:

<p><pre class="verbatim">
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    m:= module containing this event
    if (m works with handleMessage())
        <b>m-&gt;handleMessage( event )</b>
    else // m works with activity()
        transferTo( m )
}
</pre>

<p>Modules with <tt>handleMessage()</tt> are NOT started automatically:
the simulation kernel creates starter messages<!--starter messages-->
only for modules with <tt>activity()</tt>. This means that you have to
schedule self-messages<!--self-message--> from the
<tt>initialize()</tt> function if you want a <tt>handleMessage()</tt>
simple module to start working &#8220;by itself&#8221;, without first receiving
a message from other modules.

<p>
<h4><a name="sec:simple-modules:handlemessage:programming"/>4.4.1.2 Programming with handleMessage()<a class="headerlink" href="#sec:simple-modules:handlemessage:programming" title="Permalink to this headline"></a></h4>

<p>To use the <tt>handleMessage()</tt> mechanism in a simple module, you must
specify <i>zero stack size</i><!--zero stack size--> for the module.
This is important, because this tells OMNeT++ that you want to use
<tt>handleMessage()</tt> and not <tt>activity()</tt>.

<p>Message/event related functions you can use in <tt>handleMessage()</tt>:

<p><ul>
  <li> <tt>send()</tt> family of functions -- to send messages to other modules
  <li> <tt>scheduleAt()</tt> -- to schedule an event (the module &#8220;sends a message to itself&#8221;)
  <li> <tt>cancelEvent()</tt> -- to delete an event scheduled with <tt>scheduleAt()</tt>
</ul>

<p>The <tt>receive()</tt> and <tt>wait()</tt> functions cannot be used in
<tt>handleMessage()</tt>, because they are coroutine-based by nature, as
explained in the section about <tt>activity()</tt>.

<p>You have to add data members to the module class for every piece
of information you want to preserve. This information cannot
be stored in local variables of <tt>handleMessage()</tt> because they
are destroyed when the function returns. Also, they cannot be
stored in static variables in the function (or the class), because
they would be shared between all instances of the class.

<p>Data members to be added to the module class will typically include
things like:

<p><ul>
  <li> state (e.g. IDLE/BUSY, CONN_DOWN/CONN_ALIVE/...)
  <li> other variables which belong to the state of the module: retry
    counts, packet queues, etc.
  <li> values retrieved/computed once and then stored: values of module
    parameters, gate indices, routing information, etc.
  <li> pointers of message objects created once and then reused for
    timers, timeouts, etc.
  <li> variables/objects for statistics collection
</ul>

<p>These variables are often initialized from the <tt>initialize()</tt>
method, because the information needed to obtain the initial value
(e.g. module parameters) may not yet be available at the time the
module constructor runs.

<p>Another task to be done in <tt>initialize()</tt> is to schedule
initial event(s)<!--events!initial--> which trigger the first call(s)
to <tt>handleMessage()</tt>.  After the first call,
<tt>handleMessage()</tt> must take care to schedule further events for
itself so that the &#8220;chain&#8221; is not broken. Scheduling events is not
necessary if your module only has to react to messages coming from
other modules.

<p><tt>finish()</tt> is normally used to record statistics information
accumulated in data members of the class at the end of the simulation.

<p>
<h4><a name="sec:simple-modules:handlemessage:application-area"/>4.4.1.3 Application Area<a class="headerlink" href="#sec:simple-modules:handlemessage:application-area" title="Permalink to this headline"></a></h4>

<p><tt>handleMessage()</tt> is in most cases a better choice than <tt>activity()</tt>:

<p><ol>
  <li> When you expect the module to be used in large simulations,
      involving several thousand modules. In such cases, the module stacks
      required by <tt>activity()</tt> would simply consume too much memory.
  <li> For modules which maintain little or no state information,
      such as packet sinks, <tt>handleMessage()</tt> is more convenient to program.
  <li> Other good candidates are modules with a large state space and
      many arbitrary state transition possibilities (i.e. where there
      are many possible subsequent states for any state). Such algorithms
      are difficult to program with <tt>activity()</tt>, and
      better suited for <tt>handleMessage()</tt> (see rule of thumb
      below). This is the case for most communication protocols.
</ol>

<p>
<h4><a name="sec:simple-modules:handlemessage:protocol-model-example"/>4.4.1.4 Example 1: Protocol Models<a class="headerlink" href="#sec:simple-modules:handlemessage:protocol-model-example" title="Permalink to this headline"></a></h4>

<p>Models of protocol layers in a communication network tend to have
a common structure on a high level because fundamentally they all have to react
to three types of events: to messages arriving from higher layer protocols
(or apps), to messages arriving from lower layer protocols (from the network),
and to various timers and timeouts (that is, self-messages).

<p>This usually results in the following source code pattern:

<pre class="cpp">
class FooProtocol : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    // state variables
    // ...

    virtual void processMsgFromHigherLayer(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *packet);
    virtual void processMsgFromLowerLayer(FooPacket *packet);
    virtual void processTimer(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *timer);

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

// ...

void FooProtocol::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    if (msg-&gt;isSelfMessage())
        processTimer(msg);
    else if (msg-&gt;arrivedOn("fromNetw"))
        processMsgFromLowerLayer(check_and_cast&lt;FooPacket *&gt;(msg));
    else
        processMsgFromHigherLayer(msg);
}
</pre>
<p>
The functions <tt>processMsgFromHigherLayer()</tt>, <tt>processMsgFromLowerLayer()</tt>
and <tt>processTimer()</tt> are then usually split further: there are separate
methods to process separate packet types and separate timers.

<p>
<h4><a name="sec:simple-modules:handlemessage:traffic-generator-example"/>4.4.1.5 Example 2: Simple Traffic Generators and Sinks<a class="headerlink" href="#sec:simple-modules:handlemessage:traffic-generator-example" title="Permalink to this headline"></a></h4>

<p>
The code for simple packet generators and sinks programmed with <tt>handleMessage()</tt> might
be as simple as the following pseudocode:

<pre class="cpp">
PacketGenerator::handleMessage(msg)
{
    create and send out a new packet;
    schedule msg again to trigger next call to handleMessage;
}

PacketSink::handleMessage(msg)
{
    delete msg;
}
</pre>
<p>
Note that <i>PacketGenerator</i> will need to redefine <tt>initialize()</tt>
to create <i>m</i> and schedule the first event.

<p>The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been
discussed yet, but the code is probably understandable nevertheless.)

<p>
<pre class="cpp">
class Generator : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  public:
    Generator() : <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>() {}
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

Define_Module(Generator);

void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>);
}

void Generator::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *pkt = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>;
    send(pkt, "out");
    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</pre>

<p>

<p><h4><a name="sec:simple-modules:handlemessage:bursty-trafgen-example"/>4.4.1.6 Example 3: Bursty Traffic Generator<a class="headerlink" href="#sec:simple-modules:handlemessage:bursty-trafgen-example" title="Permalink to this headline"></a></h4>

<p>A bit more realistic example is to rewrite our Generator to create
packet bursts, each consisting of <tt>burstLength</tt> packets.

<p>We add some data members to the class:
<ul>
<li> <tt>burstLength</tt> will store the parameter that specifies how many
    packets a burst must contain,
<li> <tt>burstCounter</tt> will count in how many packets are left to be sent
    in the current burst.
</ul>

<p>The code:

<pre class="cpp">
class BurstyGenerator : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    int burstLength;
    int burstCounter;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burstLength = par("burstLength");
    burstCounter = burstLength;
    // schedule first packet of first burst
    scheduleAt(simTime(), new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>);
}

void BurstyGenerator::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *pkt = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>;
    send(pkt, "out");
    // if this was the last packet of the burst
    if (--burstCounter == 0) {
        // schedule next burst
        burstCounter = burstLength;
        scheduleAt(simTime()+exponential(5.0), msg);
    }
    else {
        // schedule next sending within burst
        scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</pre>
<p>

<p>
<h4><a name="sec:simple-modules:handlemessage:pros-and-cons"/>4.4.1.7 Pros and Cons of Using <tt>handleMessage()</tt><a class="headerlink" href="#sec:simple-modules:handlemessage:pros-and-cons" title="Permalink to this headline"></a></h4>

<p>Pros:
<ul>
  <li> consumes less memory: no separate stack needed for simple modules
  <li> fast: function call is faster than switching between coroutines<!--coroutine-->
</ul>

<p>Cons:
<ul>
  <li> local variables cannot be used to store state information
  <li> need to redefine <tt>initialize()</tt>
</ul>

<p>Usually, <tt>handleMessage()</tt> should be preferred over <tt>activity()</tt>.

<p>
<h4><a name="sec:simple-modules:handlemessage:other-simulators"/>4.4.1.8 Other Simulators<a class="headerlink" href="#sec:simple-modules:handlemessage:other-simulators" title="Permalink to this headline"></a></h4>

<p>Many simulation packages use a similar approach, often topped with
something like a state machine<!--finite state machine-->
(FSM<!--FSM-->) which hides the underlying function calls. Such
systems are:
<ul>
  <li> OPNET<i><sup>TM</sup></i> which uses FSM's designed using a graphical editor;
  <li> NetSim++ clones OPNET's approach;
  <li> SMURPH (University of Alberta) defines a (somewhat eclectic)
      language to describe FSMs, and uses a precompiler to turn it
      into C++ code;
  <li> Ptolemy (UC Berkeley) uses a similar method.
</ul>

<p>OMNeT++'s FSM<!--FSM--> support is described in the next section.

<p>

<p><h3><a name="sec:simple-modules:activity"/>4.4.2 activity()<a class="headerlink" href="#sec:simple-modules:activity" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:simple-modules:activity:overview"/>4.4.2.1 Process-Style Description<a class="headerlink" href="#sec:simple-modules:activity:overview" title="Permalink to this headline"></a></h4>

<p>With <tt>activity()</tt>, a simple module can be coded much like an
operating system process or thread. One can wait for an incoming message
(event) at any point of the code, suspend the execution for some time
(model time!), etc. When the <tt>activity()</tt> function exits, the module
is terminated.  (The simulation can continue if there are other modules
which can run.)

<p>The most important functions that can be used in <tt>activity()</tt> are
(they will be discussed in detail later):
<ul>
<li> <tt>receive()</tt> -- to receive messages (events)
<li> <tt>wait()</tt> -- to suspend execution<!--suspend execution-->
    for some time (model time)
<li> <tt>send()</tt> family of functions -- to send messages to other
    modules
<li> <tt>scheduleAt()</tt> -- to schedule an event (the module &#8220;sends
    a message to itself&#8221;)
<li> <tt>cancelEvent()</tt> -- to delete an event scheduled with
    <tt>scheduleAt()</tt>
<li> <tt>end()</tt> -- to finish execution of this module (same as
    exiting the <tt>activity()</tt> function)
</ul>

<p>The <tt>activity()</tt> function normally contains an infinite loop,
with at least a <tt>wait()</tt> or <tt>receive()</tt> call in its body.

<p>

<p><h4><a name="sec:simple-modules:activity:application-area"/>4.4.2.2 Application Area<a class="headerlink" href="#sec:simple-modules:activity:application-area" title="Permalink to this headline"></a></h4>

<p>Generally you should prefer <tt>handleMessage()</tt> to <tt>activity()</tt>.
The main problem with <tt>activity()</tt> is that it doesn't scale because
every module needs a separate coroutine stack. It has also been observed
that <tt>activity()</tt> does not encourage a good programming style, and
stack switching also confuses many debuggers.

<p>There is one scenario where <tt>activity()</tt>'s process-style
description is convenient: when the process has many
states but transitions are very limited, i.e. from any state the
process can only go to one or two other states.  For example, this is
the case when programming a network application, which uses a single
network connection.  The pseudocode of the application which talks to
a transport layer protocol might look like this:

<p><pre class="verbatim">
<i>activity()</i>
{
    while(true)
    {
        open connection by sending OPEN command to transport layer
        receive reply from transport layer
        if (open not successful)
        {
            wait(some time)
            continue // loop back to while()
        }

        while (there is more to do)
        {
            send data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
            receive data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
        }
        close connection by sending CLOSE command to transport layer
        if (close not successful)
        {
            // handle error
        }
        wait(some time)
    }
}
</pre>

<p>If there is a need to handle several connections concurrently, dynamically creating
simple modules to handle each is an option. Dynamic module creation will be discussed
later.

<p>There are situations when you certainly <i>do not want</i> to use <tt>activity()</tt>.
If the <tt>activity()</tt> function contains no <tt>wait()</tt> and it has only one
<tt>receive()</tt> at the top of a message handling loop, there is no point in
using <tt>activity()</tt>, and the code should be written with <tt>handleMessage()</tt>.
The body of the loop would then become the body of <tt>handleMessage()</tt>,
state variables inside <tt>activity()</tt> would become data members in
the module class, and they would be initialized in <tt>initialize()</tt>.

<p>Example:

<pre class="cpp">
void Sink::activity()
{
    while(true) {
        msg = receive();
        delete msg;
    }
}
</pre>
<p>
should rather be programmed as:

<pre class="cpp">
void Sink::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    delete msg;
}
</pre>
<p>

<p>
<h4><a name="sec:simple-modules:activity:coroutine"/>4.4.2.3 Activity() Is Run as a Coroutine<a class="headerlink" href="#sec:simple-modules:activity:coroutine" title="Permalink to this headline"></a></h4>

<p><tt>activity()</tt> is run in a coroutine<!--coroutine-->.
Coroutines are similar to threads, but are scheduled
non-preemptively (this is also called cooperative
multitasking<!--multitasking!cooperative-->).
One can switch from one coroutine to another coroutine by a
<tt>transferTo(otherCoroutine)</tt> call, causing the first coroutine
to be suspended and second one to run. Later, when the
second coroutine performs a <tt>transferTo(firstCoroutine)</tt> call
to the first one, the execution of the first coroutine will resume
from the point of the <tt>transferTo(otherCoroutine)</tt> call.
The full state of the coroutine, including local variables are preserved while the
thread of execution is in other coroutines.  This implies that each
coroutine has its own CPU stack<!--stack-->, and
<tt>transferTo()</tt> involves a switch from one CPU stack to
another.

<p>Coroutines<!--coroutine--> are at the heart of OMNeT++, and the
simulation programmer doesn't ever need to call <tt>transferTo()</tt>
or other functions in the coroutine library, nor does he need to care
about the coroutine library implementation. It is important to
understand, however, how the event loop found in discrete event simulators
works with coroutines.

<p>When using coroutines, the event loop<!--event loop--> looks like
this (simplified):

<p>
<pre class="verbatim">
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    <b>transferTo(module containing the event)</b>
}
</pre>

<p>

<p>That is, when a module has an event<!--event-->, the simulation
kernel transfers the control to the module's coroutine. It is expected
that when the module &#8220;decides it has finished the processing of the
event&#8221;, it will transfer the control back to the simulation kernel by
a <tt>transferTo(main)</tt> call. Initially,
simple<!--module!simple--> modules using <tt>activity()</tt> are
&#8220;booted&#8221; by events (<i>''starter messages''</i><!--starter messages-->)
inserted into the FES<!--FES--> by the simulation kernel before the
start of the simulation.

<p>
How does the coroutine know it has &#8220;finished processing the event&#8221;?
The answer: <i>when it requests another event</i>.  The functions
which request events from the simulation kernel are the
<tt>receive()</tt> and <tt>wait()</tt>, so their
implementations contain a <tt>transferTo(main)</tt> call
somewhere.

<p>
Their pseudocode, as implemented in OMNeT++:

<p>
<pre class="verbatim">
receive()
{
    transferTo(main)
    retrieve current event
    return the event // remember: events = messages
}

wait()
{
    create event e
    schedule it at (current sim. time + wait interval)
    transferTo(main)
    retrieve current event
    if (current event is not e) {
        error
    }
    delete e  // note: actual impl. reuses events
    return
}
</pre>

<p>

<p>Thus, the <tt>receive()</tt> and <tt>wait()</tt> calls are
special points in the <tt>activity()</tt> function, because
they are where

<p><ul>
  <li> simulation time elapses in the module, and
  <li> other modules get a chance to execute.
</ul>

<p>
<h4><a name="simple-modules:activity:starter-messages"/>4.4.2.4 Starter Messages<a class="headerlink" href="#simple-modules:activity:starter-messages" title="Permalink to this headline"></a></h4>

<p>Modules written with <tt>activity()</tt> need starter
messages<!--starter messages--> to &#8220;boot&#8221;.  These starter messages
are inserted into the FES<!--FES--> automatically by OMNeT++ at the
beginning of the simulation, even before the <tt>initialize()</tt>
functions are called.

<p>
<h4><a name="sec:simple-modules:activity:stack-size"/>4.4.2.5 Coroutine Stack Size<a class="headerlink" href="#sec:simple-modules:activity:stack-size" title="Permalink to this headline"></a></h4>

<p>The simulation programmer needs to define the CPU stack size<!--coroutine!stack size-->
for coroutines. This cannot be automated.

<p>16 or 32 kbytes is usually a good choice, but more space may be needed
if the module uses recursive functions or has many/large local variables.
OMNeT++ has a built-in mechanism that will usually detect if the module stack
is too small and overflows<!--stack!overflow-->. OMNeT++ can also report how
much stack space a module actually uses<!--stack!usage--> at runtime.

<p>
<h4><a name="sec:simple-modules:activity:initialize-and-finish"/>4.4.2.6 initialize() and finish() with activity()<a class="headerlink" href="#sec:simple-modules:activity:initialize-and-finish" title="Permalink to this headline"></a></h4>

<p>Because local variables of <tt>activity()</tt> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of the
<tt>activity()</tt> function, so there isn't much need to use
<tt>initialize()</tt>.

<p>You do need <tt>finish()</tt>, however, if you want to write statistics at
the end of the simulation. Because <tt>finish()</tt> cannot access
the local variables of <tt>activity()</tt>, you have to put the variables
and objects containing the statistics into the module class.
You still don't need <tt>initialize()</tt> because class members can also
be initialized at the top of <tt>activity()</tt>.

<p>Thus, a typical setup looks like this in pseudocode:

<p><pre class="verbatim">
<i>class MySimpleModule...</i>
{
    ...
    variables for statistics collection
    activity();
    finish();
};

MySimpleModule::activity()
{
    declare local vars and initialize them
    initialize statistics collection variables

    while(true)
    {
        ...
    }
}

MySimpleModule::finish()
{
    record statistics into file
}
</pre>

<p>
<h4><a name="sec:simple-modules:activity:pros-and-cons"/>4.4.2.7 Pros and Cons of Using <tt>activity()</tt><a class="headerlink" href="#sec:simple-modules:activity:pros-and-cons" title="Permalink to this headline"></a></h4>

<p>Pros:
<ul>
   <li> <tt>initialize()</tt> not needed, state can be stored in local
       variables of <tt>activity()</tt>
   <li> process-style description is a natural programming model in some cases
</ul>

<p>Cons:
<ul>
   <li> limited scalability: coroutine stacks can unacceptably increase the
       memory requirements of the simulation program if there are many
       <tt>activity()</tt>-based simple modules;
   <li> run-time overhead: switching between coroutines is slower than
       a simple function call
   <li> does not encourage a good programming style: as module complexity
       grows, <tt>activity()</tt> tends to become a large, monolythic function.
</ul>

<p>In most cases, cons outweigh pros and it is a better idea to use
<tt>handleMessage()</tt> instead.

<p>
<h4><a name="sec:simple-modules:activity:other-simulators"/>4.4.2.8 Other Simulators<a class="headerlink" href="#sec:simple-modules:activity:other-simulators" title="Permalink to this headline"></a></h4>

<p>Coroutines are used by a number of other simulation packages:
<ul>
<li> All simulation software which inherits from SIMULA (e.g. C++SIM)
    is based on coroutines, although all in all the programming
    model is quite different.
<li> The simulation/parallel programming language Maisie and its successor
    PARSEC (from UCLA) also use coroutines (although implemented
    with &#8220;normal&#8221; preemptive threads). The philosophy
    is quite similar to OMNeT++. PARSEC, being &#8220;just&#8221;
    a programming language, it has a more elegant syntax but far fewer
    features than OMNeT++.
<li> Many Java-based simulation libraries are based on Java
    threads.
</ul>

<p><h3><a name="sec:simple-modules:global-vars"/>4.4.3 How to Avoid Global Variables<a class="headerlink" href="#sec:simple-modules:global-vars" title="Permalink to this headline"></a></h3>
<!--global variables-->

<p>If possible, avoid using global variables, including
static class members. They are prone to cause several problems.
First, they are not reset to their initial values (to zero)
when you rebuild the simulation in Tkenv/Qtenv, or start another run
in Cmdenv. This may produce surprising results.
Second, they prevent you from parallelizing the simulation.
When using parallel simulation, each partition of the model
runs in a separate process, having their own copies of
global variables. This is usually not what you want.

<p>The solution is to encapsulate the variables into simple modules
as private or protected data members, and expose them via public methods.
Other modules can then call these public methods to get or set the values.
Calling methods of other modules will be discussed in section
<a href="#sec:simple-modules:direct-method-calls">[4.12]</a>.
Examples of such modules are the <tt>Blackboard</tt> in the <i>Mobility Framework</i>,
and <tt>InterfaceTable</tt> and <tt>RoutingTable</tt> in the <i>INET Framework</i>.

<p>
<h3><a name="sec:simple-modules:module-subclassing"/>4.4.4 Reusing Module Code via Subclassing<a class="headerlink" href="#sec:simple-modules:module-subclassing" title="Permalink to this headline"></a></h3>

<p>The code of simple modules can be reused via subclassing, and redefining
virtual member functions. An example:

<pre class="cpp">
class TransportProtocolExt : public TransportProtocol
{
  protected:
    virtual void recalculateTimeout();
};

Define_Module(TransportProtocolExt);

void TransportProtocolExt::recalculateTimeout()
{
    //...
}
</pre>
<p>
The corresponding NED declaration:

<pre class="ned">
simple TransportProtocolExt extends TransportProtocol
{
    @class(TransportProtocolExt);  // Important!
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Note the <tt>@class()</tt> property, which tells OMNeT++ to use the
  <tt>TransportProtocolExt</tt> C++ class for the module type! It is needed
  because NED inheritance is NED inheritance <i>only</i>, so without <tt>@class()</tt>
  the <tt>TransportProtocolExt</tt> NED type would inherit the C++ class from
  its base NED type.
</ul>

<p>

<p><h2><a name="sec:simple-modules:parameters"/>4.5 Accessing Module Parameters<a class="headerlink" href="#sec:simple-modules:parameters" title="Permalink to this headline"></a></h2>

<p>Module parameters declared in NED files are represented with the <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt>
class at runtime, and be accessed<!--module!accessing parameters-->
by calling the <tt>par()</tt> member function of <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPar.html">cPar</a>& delayPar = par("delay");
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt>'s value can be read with methods that correspond to
the parameter's NED type: <tt>boolValue()</tt>, <tt>longValue()</tt>,
<tt>doubleValue()</tt>, <tt>stringValue()</tt>, <tt>stdstringValue()</tt>,
<tt>xmlValue()</tt>.
There are also overloaded type cast operators for the corresponding types
(<tt>bool</tt>; integer types including <tt>int</tt>, <tt>long</tt>, etc;
<tt>double</tt>; <tt>const char *</tt>; <tt><a href="../api/classomnetpp_1_1cXMLElement.html">cXMLElement</a> *</tt>).

<pre class="cpp">
long numJobs = par("numJobs").longValue();
double processingDelay = par("processingDelay"); // using operator double()
</pre>
<p>
Note that <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt> has two methods for returning a string value:
<tt>stringValue()</tt>, which returns <tt>const char *</tt>, and
<tt>stdstringValue()</tt>, which returns <tt>std::string</tt>.
For volatile parameters, only <tt>stdstringValue()</tt> may be used,
but otherwise the two are interchangeable.

<p>If you use the <tt>par("foo")</tt> parameter in expressions (such as
<tt>4*par("foo")+2</tt>), the C++ compiler may be unable to decide
between overloaded operators and report ambiguity. This issue can be
resolved by adding an explicit cast such as <tt>(double)par("foo")</tt>,
or using the <tt>doubleValue()</tt> or <tt>longValue()</tt> methods.

<p>
<h3><a name="sec:simple-modules:volatile-parameters"/>4.5.1 Volatile and Non-Volatile Parameters<a class="headerlink" href="#sec:simple-modules:volatile-parameters" title="Permalink to this headline"></a></h3>

<p>A parameter can be declared <tt>volatile</tt> in the NED file. The <tt>volatile</tt>
modifier indicates that a parameter is re-read every time a value is needed
during simulation. Volatile parameters typically are used for things like
random packet generation interval, and are assigned values like <tt>exponential(1.0)</tt>
(numbers drawn from the exponential distribution with mean 1.0).

<p>In contrast, non-volatile NED parameters are constants, and reading their
values multiple times is guaranteed to yield the same value. When a non-volatile
parameter is assigned a random value like <tt>exponential(1.0)</tt>, it is
evaluated once at the beginning of the simulation and replaced with the result,
so all reads will get same (randomly generated) value.

<p>The typical usage for non-volatile parameters is to read them in the
<tt>initialize()</tt> method of the module class, and store the values
in class variables for easy access later:

<pre class="cpp">
class Source : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    long numJobs;
    virtual void initialize();
    ...
};

void Source::initialize()
{
    numJobs = par("numJobs");
    ...
}
</pre>
<p>
<tt>volatile</tt> parameters need to be re-read every time the value is needed.
For example, a parameter that represents a random packet generation interval
may be used like this:

<pre class="cpp">
void Source::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    ...
    scheduleAt(simTime() + par("interval").doubleValue(), timerMsg);
    ...
}
</pre>
<p>
This code looks up the the parameter by name every time. This lookup
can be avoided by storing the parameter object's pointer in a class variable,
resulting in the following code:

<pre class="cpp">
class Source : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classomnetpp_1_1cPar.html">cPar</a> *intervalp;
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
    ...
};

void Source::initialize()
{
    intervalp = &par("interval");
    ...
}

void Source::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    ...
    scheduleAt(simTime() + intervalp-&gt;doubleValue(), timerMsg);
    ...
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:setting-parameters"/>4.5.2 Changing a Parameter's Value<a class="headerlink" href="#sec:simple-modules:setting-parameters" title="Permalink to this headline"></a></h3>

<p>Parameter values can be changed from the program, during execution.
This is rarely needed, but may be useful for some scenarios.

<p><ul class="note"><b>NOTE</b><br>
    The parameter's type cannot be changed at runtime -- it must
    remain the type declared in the NED file. It is also not possible
    to add or remove module parameters at runtime.
</ul>

<p>The methods to set the parameter value are <tt>setBoolValue()</tt>,
<tt>setLongValue()</tt>, <tt>setStringValue()</tt>,
<tt>setDoubleValue()</tt>, <tt>setXMLValue()</tt>. There are also
overloaded assignment operators for various types including <tt>bool</tt>,
<tt>int</tt>, <tt>long</tt>, <tt>double</tt>, <tt>const char *</tt>, and
<tt><a href="../api/classomnetpp_1_1cXMLElement.html">cXMLElement</a> *</tt>.

<p>To allow a module to be notified about parameter changes, override
its <tt>handleParameterChange()</tt> method, see
<a href="#sec:simple-modules:handleparameterchange">[4.5.5]</a>.

<p>
<h3><a name="sec:simple-modules:further-cpar-methods"/>4.5.3 Further <a href="../api/classomnetpp_1_1cPar.html">cPar</a> Methods<a class="headerlink" href="#sec:simple-modules:further-cpar-methods" title="Permalink to this headline"></a></h3>

<p>The parameter's name and type are returned by the <tt>getName()</tt> and
<tt>getType()</tt> methods. The latter returns a value from an enum,
which can be converted to a readable string with the <tt>getTypeName()</tt>
static method. The enum values are <tt>BOOL</tt>, <tt>DOUBLE</tt>, <tt>LONG</tt>,
<tt>STRING</tt> and <tt>XML</tt>; and since the enum is an inner type,
they usually have to be qualified with <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a>::</tt>.

<p><tt>isVolatile()</tt> returns whether the parameter was declared volatile
in the NED file. <tt>isNumeric()</tt> returns true if the parameter
type is double or long.

<p>The <tt>str()</tt> method returns the parameter's value in a string form.
If the parameter contains an expression, then the string representation
of the expression is returned.

<p>An example usage of the above methods:

<pre class="cpp">
int n = getNumParams();
for (int i = 0; i &lt; n; i++)
{
    <a href="../api/classomnetpp_1_1cPar.html">cPar</a>& p = par(i);
    EV &lt;&lt; "parameter: " &lt;&lt; p.getName() &lt;&lt; "\n";
    EV &lt;&lt; "  type:" &lt;&lt; <a href="../api/classomnetpp_1_1cPar.html">cPar</a>::getTypeName(p.getType()) &lt;&lt; "\n";
    EV &lt;&lt; "  contains:" &lt;&lt; p.str() &lt;&lt; "\n";
}
</pre>
<p>
The NED properties of a parameter can be accessed with the <tt>getProperties()</tt>
method that returns a pointer to the <tt><a href="../api/classomnetpp_1_1cProperties.html">cProperties</a></tt> object that stores
the properties of this parameter. Specifically, <tt>getUnit()</tt> returns
the unit of measurement associated with the parameter (<b><tt>@unit</tt></b> property in NED).

<p>Further <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt> methods and related classes like <tt><a href="../api/classomnetpp_1_1cExpression.html">cExpression</a></tt> and
<tt><a href="../api/classomnetpp_1_1cDynamicExpression.html">cDynamicExpression</a></tt> are used by the NED infrastructure to set up and
assign parameters. They are documented in the <b>API Reference</b>, but
they are normally of little interest to users.

<p>
<h3><a name="sec:simple-modules:emulating-parameter-arrays"/>4.5.4 Emulating Parameter Arrays<a class="headerlink" href="#sec:simple-modules:emulating-parameter-arrays" title="Permalink to this headline"></a></h3>

<p>As of version 4.2, OMNeT++ does not support parameter arrays,
but in practice they can be emulated using string parameters.
One can assign the parameter a string which contains all values
in a textual form (for example, <tt>"0 1.234 3.95 5.467"</tt>), then
parse this string in the simple module.

<p>The <tt><a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a></tt> class can be quite useful for this
purpose. The constructor accepts a string, which it regards as
a sequence of tokens (words) separated by delimiter characters
(by default, spaces). Then you can either enumerate the tokens
and process them one by one (<tt>hasMoreTokens()</tt>, <tt>nextToken()</tt>),
or use one of the <tt><a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a></tt> convenience methods to convert
them into a vector of strings (<tt>asVector()</tt>), integers (<tt>asIntVector()</tt>),
or <tt>double</tt>s (<tt>asDoubleVector()</tt>).

<p>The latter methods can be used like this:

<pre class="cpp">
const char *vstr = par("v").stringValue(); // e.g. "aa bb cc";
std::vector&lt;std::string&gt; v = <a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a>(vstr).asVector();
</pre>
<p>
and

<pre class="cpp">
const char *str = "34 42 13 46 72 41";
std::vector&lt;int&gt; v = <a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a>().asIntVector();

const char *str = "0.4311 0.7402 0.7134";
std::vector&lt;double&gt; v = <a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a>().asDoubleVector();
</pre>
<p>
The following example processes the string by enumerating the tokens:

<pre class="cpp">
const char *str = "3.25 1.83 34 X 19.8"; // input

std::vector&lt;double&gt; result;
<a href="../api/classomnetpp_1_1cStringTokenizer.html">cStringTokenizer</a> tokenizer(str);
while (tokenizer.hasMoreTokens())
{
    const char *token = tokenizer.nextToken();
    if (strcmp(token, "X")==0)
        result.push_back(DEFAULT_VALUE);
    else
        result.push_back(atof(token));
}
</pre>
<p>
<h3><a name="sec:simple-modules:handleparameterchange"/>4.5.5 handleParameterChange()<a class="headerlink" href="#sec:simple-modules:handleparameterchange" title="Permalink to this headline"></a></h3>

<p>It is possible for modules to be notified when the value of a
parameter changes at runtime, possibly due to another module
dynamically changing it. A typical use is to re-read the changed
parameter, and update the module's state if needed.

<p>To enable notification, redefine the <tt>handleParameterChange()</tt> method
of the module class. This method will be called back by the
simulation kernel when a module parameter changes, <i>except during
initialization of the given module</i>.

<p><ul class="note"><b>NOTE</b><br>
  Notifications are disabled during the initialization of the component,
  because they would make it very difficult to write components
  that work reliably under all conditions.
  <tt>handleParameterChange()</tt> is usually triggered from another
  module (it does not make much sense for a module to change
  its own parameters), so the relative order of
  <tt>initialize()</tt> and <tt>handleParameterChange()</tt>
  would be effectively determined by the initialization order
  of modules, which generally cannot be relied upon. After the last
  stage of the initialization of the component is finished,
  <tt>handleParameterChange()</tt> is called by the simulation kernel
  with <tt>nullptr</tt> as a parameter name. This allows the component
  to react to parameter changes that occurred during the initialization phase.
</ul>

<p>The method signature is the following:

<pre class="cpp">
void handleParameterChange(const char *parameterName);
</pre>
<p>
The following example shows a module that re-reads
its <tt>serviceTime</tt> parameter when its value changes:

<pre class="cpp">
void Queue::handleParameterChange(const char *parname)
{
    if (strcmp(parname, "serviceTime")==0)
        serviceTime = par("serviceTime"); // refresh data member
}
</pre>
<p>
If your code heavily depends on notifications and you would like to
receive notifications during initialization or finalization as well, one
workaround is to explicitly call <tt>handleParameterChange()</tt>
from the <tt>initialize()</tt> or <tt>finish()</tt> function:

<pre class="cpp">
for (int i = 0; i &lt; getNumParams(); i++)
    handleParameterChange(par(i).getName());
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Be extremely careful when changing parameters from inside
  <tt>handleParameterChange()</tt>, because it is easy to accidentally
  create an infinite notification loop.
</ul>

<p>
<h2><a name="sec:simple-modules:gates"/>4.6 Accessing Gates and Connections<a class="headerlink" href="#sec:simple-modules:gates" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:simple-modules:gate-objects"/>4.6.1 Gate Objects<a class="headerlink" href="#sec:simple-modules:gate-objects" title="Permalink to this headline"></a></h3>

<p>Module gates<!--gate--> are represented by <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> objects.
Gate objects know to which other gates they are connected, and
what are the channel objects associated with the links.

<p><h4><a name="sec:simple-modules:accessing-gates-by-name"/>4.6.1.1 Accessing Gates by Name<a class="headerlink" href="#sec:simple-modules:accessing-gates-by-name" title="Permalink to this headline"></a></h4>

<p>The <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> class has a number of member functions that
deal with gates. You can look up a gate by name using the <tt>gate()</tt>
method:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *outGate = gate("out");
</pre>
<p>
This works for input and output gates. However, when a gate was declared
<tt>inout</tt> in NED, it is actually represented by the simulation kernel
with two gates, so the above call would result in a <i>gate not found</i>
error. The <tt>gate()</tt> method needs to be told whether the input or
the output half of the gate you need. This can be done by appending
the <tt>"$i"</tt> or <tt>"$o"</tt> to the gate name. The following example
retrieves the two gates for the inout gate <tt>"g"</tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gIn = gate("g$i");
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gOut = gate("g$o");
</pre>
<p>
Another way is to use the <tt>gateHalf()</tt> function, which takes
the inout gate's name plus either <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INPUT</tt> or <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT</tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gIn = gateHalf("g", <a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INPUT);
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gOut = gateHalf("g", <a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT);
</pre>
<p>
These methods throw an error if the gate does not exist, so they cannot
be used to determine whether the module has a particular gate.
For that purpose there is a <tt>hasGate()</tt> method. An example:

<pre class="cpp">
if (hasGate("optOut"))
   send(new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>(), "optOut");
</pre>
<p>
A gate can also be identified and looked up by a numeric gate ID.
You can get the ID from the gate itself (<tt>getId()</tt> method),
or from the module by gate name (<tt>findGate()</tt> method).
The <tt>gate()</tt> method also has an overloaded variant which
returns the gate from the gate ID.

<pre class="cpp">
int gateId = gate("in")-&gt;getId();  // or:
int gateId = findGate("in");
</pre>
<p>
As gate IDs are more useful with gate vectors, we'll cover them
in detail in a later section.

<p>
<h4><a name="sec:simple-modules:gate-vectors"/>4.6.1.2 Gate Vectors<a class="headerlink" href="#sec:simple-modules:gate-vectors" title="Permalink to this headline"></a></h4>

<p>Gate vectors possess one <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> object per element.
To access individual gates in the vector, you need to call
the <tt>gate()</tt> function with an additional <i>index</i>
parameter. The index should be between zero and <i>size</i>-1.
The size of the gate vector can be read with the <tt>gateSize()</tt>
method. The following example iterates through all elements in the
gate vector:

<pre class="cpp">
for (int i = 0; i &lt; gateSize("out"); i++) {
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = gate("out", i);
    //...
}
</pre>
<p>
A gate vector cannot have &#8220;holes&#8221; in it; that is, <tt>gate()</tt>
never returns <tt>nullptr</tt> or throws an error if the gate vector exists
and the index is within bounds.

<p>For inout gates, <tt>gateSize()</tt> may be called with or without
the <tt>"$i"</tt>/<tt>"$o"</tt> suffix, and returns the same number.

<p>The <tt>hasGate()</tt> method may be used both with and without an
index, and they mean two different things: without an index it tells
the existence of a gate vector with the given name, regardless of its
size (it returns <tt>true</tt> for an existing vector even if its size
is currently zero!); with an index it also examines whether the index
is within the bounds.

<p>
<h4><a name="sec:simple-modules:gate-ids"/>4.6.1.3 Gate IDs<a class="headerlink" href="#sec:simple-modules:gate-ids" title="Permalink to this headline"></a></h4>

<p>A gate can also be accessed by its ID. A very important property of gate IDs
is that they are <i>contiguous</i> within a gate vector, that is,
the ID of a gate <tt>g[k]</tt> can be calculated as the ID of <tt>g[0]</tt> plus <i>k</i>.
This allows you to efficiently access any gate in a gate vector, because
retrieving a gate by ID is more efficient than by name and index.
The index of the first gate can be obtained with <tt>gate("out",0)-&gt;getId()</tt>,
but it is better to use a dedicated method, <tt>gateBaseId()</tt>,
because it also works when the gate vector size is zero.

<p>Two further important properties of gate IDs: they are <i>stable</i>
and <i>unique</i> (within the module). By stable we mean that the ID
of a gate never changes; and by unique we not only mean that at any
given time no two gates have the same IDs, but also that IDs of deleted
gates do not get reused later, so gate IDs are unique in the lifetime
of a simulation run.

<p><ul class="note"><b>NOTE</b><br>
    OMNeT++ version earlier than 4.0 did not have these guarantees -- resizing
    a gate vector could cause its ID range to be relocated, if it
    would have overlapped with the ID range of other gate vectors.
    OMNeT++ 4.x solves the same problem by interpreting the gate ID
    as a bitfield, basically containing bits that identify the gate name,
    and other bits that hold the index. This also means that the theoretical
    upper limit for a gate size is now smaller, albeit it is still
    big enough so that it can be safely ignored for practical purposes.
</ul>

<p>The following example iterates through a gate vector, using IDs:

<pre class="cpp">
int baseId = gateBaseId("out");
int size = gateSize("out");
for (int i = 0; i &lt; size; i++) {
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = gate(baseId + i);
    //...
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:enumerating-gates"/>4.6.1.4 Enumerating All Gates<a class="headerlink" href="#sec:simple-modules:enumerating-gates" title="Permalink to this headline"></a></h4>

<p>If you need to go through all gates of a module, there are
two possibilities. One is invoking the <tt>getGateNames()</tt> method
that returns the names of all gates and gate vectors the module
has; then you can call <tt>isGateVector(name)</tt> to determine
whether individual names identify a scalar gate or a gate vector;
then gate vectors can be enumerated by index. Also, for inout
gates <tt>getGateNames()</tt> returns the base name without the
<tt>"$i"</tt>/<tt>"$o"</tt> suffix, so the two directions
need to be handled separately. The <tt>gateType(name)</tt> method
can be used to test whether a gate is inout, input or output
(it returns <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INOUT</tt>, <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INPUT</tt>, or
<tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT</tt>).

<p>Clearly, the above solution can be quite difficult. An alternative is to use
the <tt><a href="../api/classomnetpp_1_1cModule_1_1GateIterator.html">GateIterator</a></tt> class provided by <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>.
It goes like this:

<pre class="cpp">
for (<a href="../api/classomnetpp_1_1cModule.html">cModule</a>::<a href="../api/classomnetpp_1_1cModule_1_1GateIterator.html">GateIterator</a> i(this); !i.end(); i++) {
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = *i;
    ...
}
</pre>
<p>
Where <tt>this</tt> denotes the module whose gates are being enumerated
(it can be replaced by any <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a> *</tt> variable).

<p><ul class="note"><b>NOTE</b><br>
    In earlier OMNeT++ versions, gate IDs used to be small integers, so
    it made sense to iterate over all gates of a module by enumerating
    all IDs from zero to a maximum, skipping the holes (<tt>nullptr</tt>s).
    This is no longer the case with OMNeT++ 4.0 and later versions.
    Moreover, the <tt>gate()</tt> method now throws an error when called
    with an invalid ID, and not just returns <tt>nullptr</tt>.
</ul>

<p>
<h4><a name="sec:simple-modules:adding-and-deleting-gates"/>4.6.1.5 Adding and Deleting Gates<a class="headerlink" href="#sec:simple-modules:adding-and-deleting-gates" title="Permalink to this headline"></a></h4>

<p>Although rarely needed, it is possible to add and remove gates during
simulation. You can add scalar gates and gate vectors, change the size of
gate vectors, and remove scalar gates and whole gate vectors.
It is not possible to remove individual random gates from a gate vector,
to remove one half of an inout gate (e.g. <tt>"gate$o"</tt>), or to set
different gate vector sizes on the two halves of an inout gate vector.

<p>The <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> methods for adding and removing gates are
<tt>addGate(name,type,isvector=false)</tt> and <tt>deleteGate(name)</tt>.
Gate vector size can be changed by using <tt>setGateSize(name,size)</tt>.
None of these methods accept <tt>"$i"</tt> / <tt>"$o"</tt> suffix in gate names.

<p><ul class="note"><b>NOTE</b><br>
    When memory efficiency is of concern, it is useful to know that
    in OMNeT++ 4.0 and later, a gate vector will consume significantly less
    memory than the same number of individual scalar gates.
</ul>

<p>
<h4><a name="sec:simple-modules:cgate-methods"/>4.6.1.6 <a href="../api/classomnetpp_1_1cGate.html">cGate</a> Methods<a class="headerlink" href="#sec:simple-modules:cgate-methods" title="Permalink to this headline"></a></h4>

<p>The <tt>getName()</tt> method of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> returns the name of the
gate or gate vector without the index. If you need a string that contains the gate index
as well, <tt>getFullName()</tt> is what you want. If you also want to
include the hierarchical name of the owner module, call <tt>getFullPath()</tt>.

<p>The <tt>getType()</tt> method of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> returns the gate type,
either <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INPUT</tt> or <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT</tt>. (It cannot return
<tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>::INOUT</tt>, because an inout gate is represented by a pair
of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>s.)

<p>If you have a gate that represents half of an inout gate (that is,
<tt>getName()</tt> returns something like <tt>"g$i"</tt> or <tt>"g$o"</tt>), you
can split the name with the <tt>getBaseName()</tt> and
<tt>getNameSuffix()</tt> methods. <tt>getBaseName()</tt> method returns the
name without the <tt>$i</tt>/<tt>$o</tt> suffix; and <tt>getNameSuffix()</tt>
returns just the suffix (including the dollar sign). For normal gates,
<tt>getBaseName()</tt> is the same as <tt>getName()</tt>, and
<tt>getNameSuffix()</tt> returns the empty string.

<p>The <tt>isVector()</tt>, <tt>getIndex()</tt>, <tt>getVectorSize()</tt> speak
for themselves; <tt>size()</tt> is an alias to <tt>getVectorSize()</tt>. For
non-vector gates, <tt>getIndex()</tt> returns 0 and <tt>getVectorSize()</tt>
returns 1.

<p>The <tt>getId()</tt> method returns the gate ID (not to be confused
with the gate index).

<p>The <tt>getOwnerModule()</tt> method returns the module the gate object
belongs to.

<p>To illustrate these methods, we expand the gate iterator example
to print some information about each gate:

<pre class="cpp">
for (<a href="../api/classomnetpp_1_1cModule.html">cModule</a>::<a href="../api/classomnetpp_1_1cModule_1_1GateIterator.html">GateIterator</a> i(this); !i.end(); i++) {
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = *i;
    EV &lt;&lt; gate-&gt;getFullName() &lt;&lt; ": ";
    EV &lt;&lt; "id=" &lt;&lt; gate-&gt;getId() &lt;&lt; ", ";
    if (!gate-&gt;isVector())
        EV &lt;&lt; "scalar gate, ";
    else
        EV &lt;&lt; "gate " &lt;&lt; gate-&gt;getIndex()
           &lt;&lt; " in vector " &lt;&lt; gate-&gt;getName()
           &lt;&lt; " of size " &lt;&lt; gate-&gt;getVectorSize() &lt;&lt; ", ";
    EV &lt;&lt; "type:" &lt;&lt; <a href="../api/classomnetpp_1_1cGate.html">cGate</a>::getTypeName(gate-&gt;getType());
    EV &lt;&lt; "\n";
}
</pre>
<p>
There are further <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> methods to access and manipulate
the connection(s) attached to the gate; they will be covered in the
following sections.

<p>
<h3><a name="sec:simple-modules:connections"/>4.6.2 Connections<a class="headerlink" href="#sec:simple-modules:connections" title="Permalink to this headline"></a></h3>

<p>Simple module gates have normally one connection attached. Compound module
gates, however, need to be connected both inside and outside of the
module to be useful. A series of connections (joined with compound
module gates) is called a <i>connection path</i> or just path.
A path is directed, and it normally starts at an output gate of
a simple module, ends at an input gate of a simple module,
and passes through several compound module gates.

<p>Every <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> object contains pointers to the previous gate
and the next gate in the path (returned by the <tt>getPreviousGate()</tt>
and <tt>getNextGate()</tt> methods), so a path can be thought of as
a double-linked list.

<p>The use of the <i>previous gate</i> and <i>next gate</i> pointers
with various gate types is illustrated on figure
<a href="#fig:ch-simple-modules:gates">below</a>.

<p>
  <center>
    <img src="simple-gates.svg">
    <center><div class="caption"><i>Figure: (a) simple module output gate, (b) compound module output gate,
             (c) simple module input gate, (d) compound module input gate</i></div></center>
    <a name="fig:ch-simple-modules:gates"></a>
  </center>

<p>
The start and end gates of the path can be found with the <tt>getPathStartGate()</tt>
and <tt>getPathEndGate()</tt> methods, which simply follow the <i>previous gate</i> and
<i>next gate</i> pointers, respectively, until they are <tt>nullptr</tt>.

<p>The <tt>isConnectedOutside()</tt> and <tt>isConnectedInside()</tt> methods
return whether a gate is connected on the outside or on the inside. They
examine either the <i>previous</i> or the <i>next</i> pointer, depending on the
gate type (input or output). For example, an output gate is <i>connected outside</i>
if the <i>next</i> pointer is non-<tt>nullptr</tt>; the same function for an input gate
checks the <i>previous</i> pointer. Again, see figure <a href="#fig:ch-simple-modules:gates">below</a>
for an illustration.

<p>The <tt>isConnected()</tt> method is a bit different: it returns true if the gate
is <i>fully</i> connected, that is, for a compound module gate
both inside and outside, and for a simple module gate, outside.

<p>The following code prints the name of the gate a simple module gate is
connected to:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = gate("somegate");
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *otherGate = gate-&gt;getType()==<a href="../api/classomnetpp_1_1cGate.html">cGate</a>::OUTPUT ? gate-&gt;getNextGate() :
                                                    gate-&gt;getPreviousGate();
if (otherGate)
  EV &lt;&lt; "gate is connected to: " &lt;&lt; otherGate-&gt;getFullPath() &lt;&lt; endl;
else
  EV &lt;&lt; "gate not connected" &lt;&lt; endl;
</pre>
<p>

<p><h3><a name="sec:simple-modules:connections-channel"/>4.6.3 The Connection's Channel<a class="headerlink" href="#sec:simple-modules:connections-channel" title="Permalink to this headline"></a></h3>

<p>The channel object associated with a connection is accessible by
a pointer stored at the source gate of the connection. The pointer
is returned by the <tt>getChannel()</tt> method of the gate:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *channel = gate-&gt;getChannel();
</pre>
<p>
The result may be <tt>nullptr</tt>, that is, a connection may not have
an associated channel object.

<p>If you have a channel pointer, you can get back its source gate
with the <tt>getSourceGate()</tt> method:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = channel-&gt;getSourceGate();
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt> is just an abstract base class for channels, so
to access details of the channel you might need to cast the resulting
pointer into a specific channel class, for example <tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt>
or <tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt>.

<p>Another specific channel type is <tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt>, which basically
does nothing: it acts as if there was no channel object assigned to the
connection. OMNeT++ sometimes transparently inserts a <tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt>
into a channel-less connection, for example to hold the display string
associated with the connection.

<p>Often you are not really interested in a specific connection's channel, but
rather in the <i>transmission channel</i> (see
<a href="#sec:simple-modules:packet-transmission">[4.7.6]</a>) of the connection path that
starts at a specific output gate. The transmission channel can be found by
following the connection path until you find a channel whose
<tt>isTransmissionChannel()</tt> method returns <tt>true</tt>, but
<tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> has a convenience method for this, named
<tt>getTransmissionChannel()</tt>. An example usage:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *txChan = gate("ppp$o")-&gt;getTransmissionChannel();
</pre>
<p>
A complementer method to <tt>getTransmissionChannel()</tt> is
<tt>getIncomingTransmissionChannel()</tt>; it is usually invoked
on input gates, and searches the connection path in reverse direction.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *incomingTxChan = gate("ppp$i")-&gt;getIncomingTransmissionChannel();
</pre>
<p>
Both methods throw an error if no transmission channel is found. If this
is not suitable, use the similar <tt>findTransmissionChannel()</tt> and
<tt>findIncomingTransmissionChannel()</tt> methods that simply return
<tt>nullptr</tt> in that case.

<p>Channels are covered in more detail in section <a href="#sec:simple-modules:channels">[4.8]</a>.

<p>
<h2><a name="sec:simple-modules:sending-and-receiving"/>4.7 Sending and Receiving Messages<a class="headerlink" href="#sec:simple-modules:sending-and-receiving" title="Permalink to this headline"></a></h2>

<p>On an abstract level, an OMNeT++ simulation model is a set of
simple modules that communicate with each other via message passing.
The essence of simple modules is that they create, send, receive,
store, modify, schedule and destroy messages -- the rest of OMNeT++ exists
to facilitate this task, and collect statistics
about what was going on.

<p>Messages in OMNeT++ are instances of the <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> class or one of
its subclasses. Network packets are represented with <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>,
which is also subclassed from <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>. Message objects are
created using the C++ <tt>new</tt> operator, and destroyed using the
<tt>delete</tt> operator when they are no longer needed.

<p>Messages are described in detail in chapter <a href="#cha:messages">[5]</a>.
At this point, all we need to know about them is that they are
referred to as <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *</tt> pointers. In the examples below,
messages will be created with <tt>new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("foo")</tt> where
<tt>"foo"</tt> is a descriptive message name, used for visualization
and debugging purposes.

<p>
<h3><a name="sec:simple-modules:self-messages"/>4.7.1 Self-Messages<a class="headerlink" href="#sec:simple-modules:self-messages" title="Permalink to this headline"></a></h3>

<p>Nearly all simulation models need to schedule future events in order
to implement timers, timeouts, delays, etc. Some typical examples:

<p><ul>
  <li> A source module that periodically creates and sends messages
    needs to schedule the next send after every send operation;
  <li> A server which processes jobs from a queue needs to start
    a timer every time it begins processing a job. When the timer
    expires, the finished job can be sent out, and a new job may
    start processing;
  <li> When a packet is sent by a communications protocol that employs
    retransmission, it needs to schedule a timeout so that the packet
    can be retransmitted if no acknowledge arrives within a certain
    amount of time.
</ul>

<p>In OMNeT++, you solve such tasks by letting the simple module send a message
to itself; the message would be delivered to the simple module at a later
point of time. Messages used this way are called
<i>self-messages</i><!--self-message-->, and the module class has
special methods for them that allow for implementing self-messages without
gates and connections.

<p><h4><a name="sec:simple-modules:scheduling"/>4.7.1.1 Scheduling an Event<a class="headerlink" href="#sec:simple-modules:scheduling" title="Permalink to this headline"></a></h4>

<p>The module can send a message to itself using the <tt>scheduleAt()</tt> function.
<tt>scheduleAt()</tt> accepts an <i>absolute</i> simulation time,
usually calculated as <tt>simTime()</tt>+<i>delta</i>:

<pre class="cpp">
scheduleAt(absoluteTime, msg);
scheduleAt(simTime()+delta, msg);
</pre>
<p>
Self-messages are delivered to the module in the same way as other
messages (via the usual receive calls or <tt>handleMessage()</tt>);
the module may call the <tt>isSelfMessage()</tt> member of any received
message to determine if it is a self-message.

<p>You can determine whether a message is currently in the FES<!--FES-->
by calling its <tt>isScheduled()</tt> member function.

<p><h4><a name="sec:simple-modules:cancelling"/>4.7.1.2 Cancelling an Event<a class="headerlink" href="#sec:simple-modules:cancelling" title="Permalink to this headline"></a></h4>

<p>Scheduled self-messages can be cancelled<!--self-message!cancelling-->
<!--message!cancelling--> (i.e. removed from the FES<!--FES-->).
This feature facilitates implementing timeouts.

<pre class="cpp">
cancelEvent(msg);
</pre>
<p>
The <tt>cancelEvent()</tt> function takes a pointer to the message to
be cancelled, and also returns the same pointer. After having it
cancelled, you may delete the message or reuse it in subsequent
<tt>scheduleAt()</tt> calls. <tt>cancelEvent()</tt> has no effect if
the message is not scheduled at that time.

<p>There is also a convenience method called <tt>cancelAndDelete()</tt>
implemented as <tt>if (msg!=nullptr) delete cancelEvent(msg)</tt>;
this method is primarily useful for writing destructors.

<p>The following example shows how to implement a timeout in a simple
imaginary stop-and-wait protocol. The code utilizes a <tt>timeoutEvent</tt>
module class data member that stores the pointer of the <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> used
as self-message, and compares it to the pointer of the received message
to identify whether a timeout has occurred.

<pre class="cpp">
void Protocol::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    if (msg == timeoutEvent) {
        // timeout expired, re-send packet and restart timer
        send(currentPacket-&gt;dup(), "out");
        scheduleAt(simTime() + timeout, timeoutEvent);
    }
    else if (...) {  // if acknowledgement received
        // cancel timeout, prepare to send next packet, etc.
        cancelEvent(timeoutEvent);
        ...
    }
    else {
       ...
    }
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:rescheduling"/>4.7.1.3 Re-scheduling an Event<a class="headerlink" href="#sec:simple-modules:rescheduling" title="Permalink to this headline"></a></h4>

<p>To reschedule an event which is currently scheduled to a different
simulation time, it first needs to be cancelled using <tt>cancelEvent()</tt>.
This is shown in the following example code:

<pre class="cpp">
if (msg-&gt;isScheduled())
    cancelEvent(msg);
scheduleAt(simTime() + delay, msg);
</pre>
<p>

<p><h3><a name="sec:simple-modules:sending-messages"/>4.7.2 Sending Messages<a class="headerlink" href="#sec:simple-modules:sending-messages" title="Permalink to this headline"></a></h3>

<p>Once created, a message object can be sent through an
output gate<!--output!gate--> using one of the following functions:

<pre class="cpp">
send(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, const char *gateName, int index=0);
send(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, int gateId);
send(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate);
</pre>
<p>
In the first function, the argument <tt>gateName</tt> is the name of
the gate the message has to be sent through. If this gate is
a vector gate, <tt>index</tt> determines though which particular output
gate this has to be done; otherwise, the <tt>index</tt> argument is not
needed.

<p>The second and third functions use the gate ID and the pointer to the gate
object. They are faster than the first one because they don't have to
search for the gate by name.

<p>Examples:

<pre class="cpp">
send(msg, "out");
send(msg, "outv", i); // send via a gate in a gate vector
</pre>
<p>
To send via an inout gate, remember that an inout gate is an input and an
output gate glued together, and the two halves can be identified with the
<tt>$i</tt> and <tt>$o</tt> name suffixes. Thus, the gate name needs to be
specified in the <tt>send()</tt> call with the <tt>$o</tt> suffix:

<pre class="cpp">
send(msg, "g$o");
send(msg, "g$o", i); // if "g[]" is a gate vector
</pre>
<p>

<p><h3><a name="sec:simple-modules:broadcasts-and-retransmissions"/>4.7.3 Broadcasts and Retransmissions<a class="headerlink" href="#sec:simple-modules:broadcasts-and-retransmissions" title="Permalink to this headline"></a></h3>

<p>When implementing broadcasts or retransmissions, two frequently
occurring tasks in protocol simulation, you might feel tempted
to use the same message in multiple <tt>send()</tt> operations.
Do not do it -- you cannot send the same message object multiple times.
Instead, duplicate the message object.

<p>Why? A message is like a real-world object -- it cannot be at two places
at the same time. Once sent out, the message no longer belongs
to the module: it is taken over by the simulation kernel, and will
eventually be delivered to the destination module. The sender module should
not even refer to its pointer any more. Once the message arrives in the
destination module, that module will have full authority over it -- it can
send it on, destroy it immediately, or store it for further handling. The
same applies to messages that have been scheduled -- they belong to the
simulation kernel until they are delivered back to the module.

<p>To enforce the rules above, all message sending functions check that the
module actually owns the message it is about to send. If the message is in
another module, in a queue, currently scheduled, etc., a runtime error
will be generated: <i>not owner of message</i>.
  <br><ul><font size=-1>[The feature does not increase runtime overhead significantly, because
  it uses the object ownership<!--ownership--> management (described in
  Section <a href="#sec:sim-lib:ownership-management">[7.13]</a>);
  it merely checks that the owner of the message is the module that
  wants to send it.]</font></ul>

<p>
<h4><a name="sec:simple-modules:broadcasting-messages"/>4.7.3.1 Broadcasting Messages<a class="headerlink" href="#sec:simple-modules:broadcasting-messages" title="Permalink to this headline"></a></h4>

<p>In your model, you may need to broadcast a message to several destinations.
Broadcast can be implemented in a simple module by sending out copies
of the same message, for example on every gate of a gate vector.
As described above, you cannot use the same message pointer for
in all <tt>send()</tt> calls -- what you have to do instead is
create copies (duplicates) of the message object and send them.

<p>Example:

<pre class="cpp">
for (int i = 0; i &lt; n; i++)
{
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *copy = msg-&gt;dup();
    send(copy, "out", i);
}
delete msg;
</pre>
<p>
You might have noticed that copying the message for the last gate is
redundant: we can just send out the original message there.
Also, we can utilize gate IDs to avoid looking up the gate by name
for each send operation. We can exploit the fact that the ID of gate
<i>k</i> in a gate vector can be produced as <i>baseID + k</i>.
The optimized version of the code looks like this:

<pre class="cpp">
int outGateBaseId = gateBaseId("out");
for (int i = 0; i &lt; n; i++)
    send(i==n-1 ? msg : msg-&gt;dup(), outGateBaseId+i);
</pre>
<p>

<p><h4><a name="sec:simple-modules:retransmissions"/>4.7.3.2 Retransmissions<a class="headerlink" href="#sec:simple-modules:retransmissions" title="Permalink to this headline"></a></h4>

<p>Many communication protocols involve retransmissions of packets (frames).
When implementing retransmissions, you cannot just hold a pointer
to the same message object and send it again and again -- you'd get
the <i>not owner of message</i> error on the first resend.

<p>Instead, for (re)transmission, you should create and
send copies of the message, and retain the original.
When you are sure there will not be any more retransmission,
you can delete the original message.

<p>Creating and sending a copy:

<pre class="cpp">
// (re)transmit packet:
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *copy = packet-&gt;dup();
send(copy, "out");
</pre>
<p>
and finally (when no more retransmissions will occur):

<pre class="cpp">
delete packet;
</pre>
<p>

<p><h3><a name="sec:simple-modules:delayed-sending"/>4.7.4 Delayed Sending<a class="headerlink" href="#sec:simple-modules:delayed-sending" title="Permalink to this headline"></a></h3>

<p>Sometimes it is necessary for module to hold a message for some time interval,
and then send it. This can be achieved with self-messages, but there is a
more straightforward method: delayed sending<!--delayed sending-->. The
following methods are provided for delayed sending:

<pre class="cpp">
sendDelayed(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, double delay, const char *gateName, int index);
sendDelayed(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, double delay, int gateId);
sendDelayed(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, double delay, <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate);
</pre>
<p>
The arguments are the same as for <tt>send()</tt>, except for the extra
<i>delay</i> parameter. The delay value must be non-negative.
The effect of the function is similar to as if the module
had kept the message for the delay interval and sent it afterwards;
even the <i>sending time</i> timestamp of the message will be set to
the current simulation time plus <i>delay</i>.

<p>A example call:

<pre class="cpp">
sendDelayed(msg, 0.005, "out");
</pre>
<p>
The <tt>sendDelayed()</tt> function does not internally perform a
<tt>scheduleAt()</tt> followed by a <tt>send()</tt>, but rather it computes
everything about the message sending up front, including the arrival time
and the target module. This has two consequences. First,
<tt>sendDelayed()</tt> is more efficient than a <tt>scheduleAt()</tt>
followed by a <tt>send()</tt> because it eliminates one event. The second, less
pleasant consequence is that changes in the connection path during the
delay will <i>not</i> be taken into account (because everything is
calculated in advance, before the changes take place).

<p><ul class="note"><b>NOTE</b><br>
  The fact that <tt>sendDelayed()</tt> computes the message arrival
  information up front does not make a difference if the model is static,
  but may lead to surprising results if the model changes in time.
  For example, if a connection in the path gets deleted, disabled, or
  reconnected to another module during the delay period, the message
  will still be delivered to the original module as if nothing happened.

<p>  Therefore, despite its performance advantage, you should think twice
  before using <tt>sendDelayed()</tt> in a simulation model. It may have
  its place in a one-shot simulation model that you know is static,
  but it certainly should be avoided in reusable modules that need to
  work correctly in a wide variety of simulation models.
</ul>

<p>
<h3><a name="sec:simple-modules:direct-sending"/>4.7.5 Direct Message Sending<a class="headerlink" href="#sec:simple-modules:direct-sending" title="Permalink to this headline"></a></h3>

<p>At times it is covenient to be able to send a message directly to an input
gate of another module. The <tt>sendDirect()</tt> function is provided for
this purpose.

<p>This function has several flavors. The first set of <tt>sendDirect()</tt>
functions accept a message and a target gate; the latter can be specified
in various forms:

<pre class="cpp">
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, int gateId)
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, const char *gateName, int index=-1)
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate)
</pre>
<p>
An example for direct sending:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *targetModule = getParentModule()-&gt;getSubmodule("node2");
sendDirect(new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("msg"), targetModule, "in");
</pre>
<p>
At the target module, there is no difference between messages received
directly and those received over connections.

<p>The target gate must be an unconnected gate; in other words,
modules must have dedicated gates to be able to receive messages
sent via <tt>sendDirect()</tt>. You cannot have a gate which receives
messages via both connections and <tt>sendDirect()</tt>.

<p>It is recommended to tag gates dedicated for receiving messages via
<tt>sendDirect()</tt> with the <tt>@directIn</tt> property in the module's NED
declaration. This will cause OMNeT++ not to complain that the gate is not
connected in the network or compound module where the module is used.

<p>An example:

<pre class="ned">
simple Radio {
    gates:
        input radioIn @directIn; // for receiving air frames
}
</pre>
<p>
The target module is usually a simple module, but it can also be a compound
module. The message will follow the connections that start at the target
gate, and will be delivered to the module at the end of the path -- just as
with normal connections. The path must end in a simple module.

<p>It is even permitted to send to an output gate, which will also cause the
message to follow the connections starting at that gate.
This can be useful, for example, when several submodules are sending
to a single output gate of their parent module.

<p>A second set of <tt>sendDirect()</tt> methods accept a propagation
delay and a transmission duration as parameters as well:

<pre class="cpp">
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, int gateId)
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, const char *gateName, int index=-1)
sendDirect(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate)
</pre>
<p>
The transmission duration parameter is important when the message is also
a packet (instance of <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>). For messages that are not packets
(not subclassed from <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>), the duration parameter
is ignored.

<p>If the message is a packet, the duration will be written into the packet,
and can be read by the receiver with the <tt>getDuration()</tt> method of
the packet.

<p>The receiver module can choose whether it wants the simulation kernel
to deliver the packet object to it at the start or at the end of the
reception. The default is the latter; the module can change it by calling
<tt>setDeliverOnReceptionStart()</tt> on the final input gate, that is, on
<tt>targetGate-&gt;getPathEndGate()</tt>.

<p>
<h3><a name="sec:simple-modules:packet-transmission"/>4.7.6 Packet Transmissions<a class="headerlink" href="#sec:simple-modules:packet-transmission" title="Permalink to this headline"></a></h3>

<p>When a message is sent out on a gate, it usually travels through
a series of connections until it arrives at the destination module.
We call this series of connections a <i>connection path</i>.

<p>Several connections in the path may have an associated channel,
but there can be only one channel per path that models nonzero
transmission duration. This restriction is enforced by the simulation
kernel. This channel is called the <i>transmission channel</i>.
  <br><ul><font size=-1>[Moreover, if <tt>sendDirect()</tt> with a nonzero duration
  was used to send the packet to the start gate of the path,
  then the path cannot have a transmission channel at all.
  The point is that the a transission duration must be unambiguous.]</font></ul>

<p><ul class="note"><b>NOTE</b><br>
  In practice, this means that there can be only one <tt>ned.DatarateChannel</tt>
  in the path. Note that unnamed channels with a <tt>datarate</tt> parameter
  also map to <tt>ned.DatarateChannel</tt>.
</ul>

<p><h4><a name="sec:simple-modules:transmitting-a-packet"/>4.7.6.1 Transmitting a Packet<a class="headerlink" href="#sec:simple-modules:transmitting-a-packet" title="Permalink to this headline"></a></h4>

<p>Packets may only be sent when the transmission channel is idle.
This means that after each transmission, the sender module needs
to wait until the channel has finished transmitting before it can
send another packet.

<p>You can get a pointer to the transmission channel by calling the
<tt>getTransmissionChannel()</tt> method on the output gate.
The channel's <tt>isBusy()</tt> and <tt>getTransmissionFinishTime()</tt>
methods can tell you whether a channel is currently transmitting,
and when the transmission is going to finish. (When the latter is
less or equal the current simulation time, the channel is free.)
If the channel is currently busy, sending needs to be postponed:
the packet can be stored in a queue, and a timer (self-message) can be
scheduled for the time when the channel becomes empty.

<p>A code example to illustrate the above process:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *pkt = ...; // packet to be transmitted
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *txChannel = gate("out")-&gt;getTransmissionChannel();
simtime_t txFinishTime = txChannel-&gt;getTransmissionFinishTime();
if (txFinishTime &lt;= simTime())
{
    // channel free; send out packet immediately
    send(pkt, "out");
}
else
{
    // store packet and schedule timer; when the timer expires,
    // the packet should be removed from the queue and sent out
    txQueue.insert(pkt);
    scheduleAt(txFinishTime, endTxMsg);
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  If there is a channel with a propagation delay in
  the path before the transmission channel, the delay should be manually
  substracted from the value returned by <tt>getTransmissionFinishTime()</tt>!
  The same applies to <tt>isBusy()</tt>: it tells whether the channel is
  currently busy, and not whether it will be busy when a packet that you send
  gets there. It is therefore advisable that you never use propagation delays
  in front of a transmission channel in a path.
</ul>

<p>The <tt>getTransmissionChannel()</tt> method searches the connection path each
time it is called. If performance is important, it is a good idea to obtain
the transmission channel pointer once, and then cache it. When the network topology
changes, the cached channel pointer needs to be updated; section
<a href="#sec:simple-modules:model-change">[4.14.3]</a> describes the mechanism that can
be used to get notifications about topology changes.

<p><h4><a name="sec:simple-modules:receiving-a-packet"/>4.7.6.2 Receiving a Packet<a class="headerlink" href="#sec:simple-modules:receiving-a-packet" title="Permalink to this headline"></a></h4>

<p>As a result of error modeling in the channel, the packet may arrive
with the <i>bit error</i> flag set (<tt>hasBitError() method</tt>.
It is the receiver module's responsibility to examine this flag
and take appropriate action (i.e. discard the packet).

<p>Normally the packet object gets delivered to the destination module
at the simulation time that corresponds to finishing the reception
of the message (ie. the arrival of its last bit). However, the receiver
module may change this by &#8220;reprogramming&#8221; the receiver gate with
the <tt>setDeliverOnReceptionStart()</tt> method:

<pre class="cpp">
gate("in")-&gt;setDeliverOnReceptionStart(true);
</pre>
<p>
This method may only be called on simple module input gates, and it
instructs the simulation kernel to deliver packets arriving through
that gate at the simulation time that corresponds to the
beginning of the reception process.
<tt>getDeliverOnReceptionStart()</tt> only needs to be called once,
so it is usually done in the <tt>initialize()</tt> method of the module.

<p>
  <center>
    <img src="transmission.svg">
    <center><div class="caption"><i>Figure: Packet transmission</i></div></center>
    <a name="fig:ch-simple-modules:transmission"></a>
  </center>

<p>
When a packet is delivered to the module, the packet's
<tt>isReceptionStart()</tt> method can be called to determine
whether it corresponds to the start or end of the reception
process (it should be the same as the <tt>getDeliverOnReceptionStart()</tt>
flag of the input gate), and <tt>getDuration()</tt> returns the transmission
duration.

<p>The following example code prints the start and end times of a packet reception:

<pre class="cpp">
simtime_t startTime, endTime;
if (pkt-&gt;isReceptionStart())
{
    // gate was reprogrammed with setDeliverOnReceptionStart(true)
    startTime = pkt-&gt;getArrivalTime(); // or: simTime();
    endTime = startTime + pkt-&gt;getDuration();
}
else
{
    // default case
    endTime = pkt-&gt;getArrivalTime(); // or: simTime();
    startTime = endTime - pkt-&gt;getDuration();
}
EV &lt;&lt; "interval: " &lt;&lt; startTime &lt;&lt; ".." &lt;&lt; endTime &lt;&lt; "\n";
</pre>
<p>
Note that this works with wireless connections (<tt>sendDirect()</tt>)
as well; there, the duration is an argument to the <tt>sendDirect()</tt>
call.

<p><h4><a name="sec:simple-modules:aborting-transmissions"/>4.7.6.3 Aborting Transmissions<a class="headerlink" href="#sec:simple-modules:aborting-transmissions" title="Permalink to this headline"></a></h4>

<p>Certain protocols, for example Ethernet require the ability to abort
a transmission before it completes. The support OMNeT++ provides
for this task is the <tt>forceTransmissionFinishTime()</tt> channel method.
This method forcibly overwrites the <i>transmissionFinishTime</i>
member of the channel with the given value, allowing the sender to transmit
another packet without raising the <i>&#8220;channel is currently busy&#8221;</i>
error. The receiving party needs to be notified about the aborted transmission
by some external means, for example by sending another packet or an
out-of-band message.

<p><h4><a name="sec:simple-modules:implementation-of-message-sending"/>4.7.6.4 Implementation of Message Sending<a class="headerlink" href="#sec:simple-modules:implementation-of-message-sending" title="Permalink to this headline"></a></h4>

<p>Message sending is implemented like this: the arrival time<!--arrival time-->
and the bit error<!--bit error--> flag of a message are calculated right inside
the <tt>send()</tt> call, then the message is inserted into the FES<!--FES-->
with the calculated arrival time. The message does <i>not</i> get scheduled
individually for each link. This implementation was chosen because of its
run-time efficiency.

<p><ul class="note"><b>NOTE</b><br>
   The consequence of this implementation is that any change in the
   channel's parameters (delay, data rate, bit error rate, etc.) will only affect
   messages <i>sent</i> after the change. Messages already underway will not
   be influenced by the change.

<p>   This is not a huge problem in practice, but if it is important to model
   channels with changing parameters, the solution is to insert simple modules
   into the path to ensure strict scheduling.
</ul>

<p>The code which inserts the message into the FES is the <tt>arrived()</tt>
method of the recipient module. By overriding this method it is possible 
to perform custom processing at the recipient module immediately, still 
from within the <tt>send()</tt> call. Use only if you know what you are doing!

<p>
<h3><a name="sec:simple-modules:receiving-with-activity"/>4.7.7 Receiving Messages with activity()<a class="headerlink" href="#sec:simple-modules:receiving-with-activity" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:simple-modules:receive"/>4.7.7.1 Receiving Messages<a class="headerlink" href="#sec:simple-modules:receive" title="Permalink to this headline"></a></h4>

<p><tt>activity()</tt>-based modules receive messages with the <tt>receive()</tt>
method of <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>. <tt>receive()</tt> cannot be used with
<tt>handleMessage()</tt>-based modules.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg = receive();
</pre>
<p>
The <tt>receive()</tt> function accepts an optional <i>timeout</i>
parameter<!--receive!timeout-->. (This is a <i>delta</i>, not an
absolute simulation time.) If no message arrives within the timeout
period, the function returns <tt>nullptr</tt>.
    <br><ul><font size=-1>[Putaside-queue and the functions <tt>receiveOn()</tt>,
    <tt>receiveNew()</tt>, and <tt>receiveNewOn()</tt> were deprecated
    in OMNeT++ 2.3 and removed in OMNeT++ 3.0.]</font></ul>

<pre class="cpp">
simtime_t timeout = 3.0;
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg = receive(timeout);

if (msg==nullptr)
{
    ...   // handle timeout
}
else
{
    ...  // process message
}
</pre>
<p>
<h4><a name="sec:simple-modules:wait"/>4.7.7.2 The wait() Function<a class="headerlink" href="#sec:simple-modules:wait" title="Permalink to this headline"></a></h4>

<p>The <tt>wait()</tt> function suspends the execution of the module for a
given amount of simulation time (a <i>delta</i>). <tt>wait()</tt> cannot
be used with <tt>handleMessage()</tt>-based modules.

<pre class="cpp">
wait(delay);
</pre>
<p>
In other simulation software, <tt>wait()</tt> is often called <i>hold</i>.
Internally, the <tt>wait()</tt> function is implemented by a
<tt>scheduleAt()</tt> followed by a <tt>receive()</tt>.
The <tt>wait()</tt> function is very convenient in modules that do not need
to be prepared for arriving messages, for example message generators.
An example:

<pre class="cpp">
for (;;)
{
    // wait for some, potentially random, amount of time, specified
    // in the interarrivalTime volatile module parameter
    wait(par("interarrivalTime").doubleValue());

    // generate and send message
    ...
}
</pre>
<p>
It is a runtime error if a message arrives during the wait interval.
If you expect messages to arrive during the wait period, you can
use the <tt>waitAndEnqueue()</tt> function. It takes a pointer to a queue object
(of class <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>, described in chapter <a href="#cha:sim-lib">[7]</a>)
in addition to the wait interval. Messages that arrive during the
wait interval are accumulated in the queue, and they can be
processed after the <tt>waitAndEnqueue()</tt> call returns.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a> queue("queue");
...
waitAndEnqueue(waitTime, &queue);
if (!queue.empty())
{
    // process messages arrived during wait interval
    ...
}
</pre>
<p>

<p><h2><a name="sec:simple-modules:channels"/>4.8 Channels<a class="headerlink" href="#sec:simple-modules:channels" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:simple-modules:channels-overview"/>4.8.1 Overview<a class="headerlink" href="#sec:simple-modules:channels-overview" title="Permalink to this headline"></a></h3>

<p>Channels encapsulate parameters and behavior associated with connections.
Channel types are like simple modules, in the sense that they are declared
in NED, and there are C++ implementation classes behind them. Section
<a href="#sec:ned-lang:channels">[3.5]</a> describes NED language support for channels,
and explains how to associate C++ classes with channel types declared in
NED.

<p>C++ channel classes must subclass from the abstract base class
<tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>. However, when creating a new channel class, it may be
more practical to extend one of the existing C++ channel classes behind the
three predefined NED channel types:

<p><ul>
  <li> <tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt> implements the functionality of <tt>ned.IdealChannel</tt>
  <li> <tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> implements the functionality of <tt>ned.DelayChannel</tt>
  <li> <tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt> implements the functionality of <tt>ned.DatarateChannel</tt>
</ul>

<p>Channel classes need to be registered with the <tt>Define_Channel()</tt> macro,
just like simple module classes need <tt>Define_Module()</tt>.

<p>The channel base class <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt> inherits from <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>,
so channels participate in the initialization and finalization protocol
(<tt>initialize()</tt> and <tt>finish()</tt>) described in
<a href="#sec:simple-modules:initialize-and-finish">[4.3.3]</a>.

<p>The parent module of a channel (as returned by the
<tt>getParentModule()</tt>) is the module that contains
the connection. If a connection connects two modules that are children of
the same compound module, the channel's parent is the compound module. If
the connection connects a compound module to one of its submodules, the
channel's parent is also the compound module.

<p>
<h3><a name="sec:simple-modules:channel-api"/>4.8.2 The Channel API<a class="headerlink" href="#sec:simple-modules:channel-api" title="Permalink to this headline"></a></h3>

<p>When subclassing <tt>Channel</tt>, the following pure virtual member functions
need to be overridden:

<p><ul>
  <li> <tt>bool isTransmissionChannel() const</tt>
  <li> <tt>simtime_t getTransmissionFinishTime() const</tt>
  <li> <tt>void processMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t t, result_t&amp; result)</tt>
</ul>

<p>The first two functions are usually one-liners; the channel behavior is
encapsulated in the third function, <tt>processMessage()</tt>.

<p><h4><a name="sec:simple-modules:transmission-channels"/>4.8.2.1 Transmission Channels<a class="headerlink" href="#sec:simple-modules:transmission-channels" title="Permalink to this headline"></a></h4>

<p>The first function, <tt>isTransmissionChannel()</tt>, determines whether
the channel is a <i>transmission channel</i>, i.e. one that models
transmission duration. A transmission channel sets the duration field of
packets sent through it (see the <tt>setDuration()</tt> field of
<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>).

<p>The <tt>getTransmissionFinishTime()</tt> function is only used with
transmission channels, and it should return the simulation time the sender
will finish (or has finished) transmitting. This method is called by
modules that send on a transmission channel to find out when the channel
becomes available. The channel's <tt>isBusy()</tt> method is implemented
simply as <tt>return getTransmissionFinishTime() &lt; simTime()</tt>. For
non-transmission channels, the <tt>getTransmissionFinishTime()</tt> return
value may be any simulation time which is less than or equal to the current
simulation time.

<p><h4><a name="sec:simple-modules:channel-processmessage"/>4.8.2.2 The processMessage() Function<a class="headerlink" href="#sec:simple-modules:channel-processmessage" title="Permalink to this headline"></a></h4>

<p>The third function, <tt>processMessage()</tt> encapsulates the channel's
functionality. However, before going into the details of this function
we need to understand how OMNeT++ handles message sending on connections.

<p>Inside the <tt>send()</tt> call, OMNeT++ follows the
connection path denoted by the <tt>getNextGate()</tt> functions of gates,
until it reaches the target module. At each &#8220;hop&#8221;, the corresponding
connection's channel (if the connection has one) gets a chance to add to
the message's arrival time (<i>propagation time modeling</i>), calculate a
<i>transmission duration</i>, and to modify the message object in various
ways, such as set the bit error flag in it (<i>bit error modeling</i>).
After processing all hops that way, OMNeT++ inserts the message object
into the Future Events Set (FES<!--FES-->, see section
<a href="#sec:simple-modules:event-loop">[4.1.2]</a>), and the <tt>send()</tt> call returns.
Then OMNeT++ continues to process events in increasing timestamp order.
The message will be delivered to the target module's <tt>handleMessage()</tt>
(or <tt>receive()</tt>) function when it gets to the front of the FES.

<p>A few more details: a channel may instruct OMNeT++ to delete the message
instead of inserting it into the FES; this can be useful to model
disabled channels, or to model that the message has been lost altogether.
The <tt>getDeliverOnReceptionStart()</tt> flag of the final gate in the path
will determine whether the transmission duration will be added to the
arrival time or not. Packet transmissions have been described in section
<a href="#sec:simple-modules:packet-transmission">[4.7.6]</a>.

<p>Now, back to the <tt>processMessage()</tt> method.

<p>The method gets called as part of the above process, when the message
is processed at the given hop. The method's arguments are the message
object, the simulation time the beginning of the message will reach
the channel (i.e. the sum of all previous propagation delays),
and a struct in which the method can return the results.

<p>The <tt>result_t</tt> struct is an inner type of <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>,
and looks like this:

<pre class="cpp">
struct result_t {
    simtime_t delay;     // propagation delay
    simtime_t duration;  // transmission duration
    bool discard;        // whether the channel has lost the message
};
</pre>
<p>
It also has a constructor that initializes all fields to zero; it is left
out for brevity.

<p>The method should model the transmission of the given message starting at
the given <i>t</i> time, and store the results (propagation delay,
transmission duration, deletion flag) in the result object. Only the
relevant fields in the result object need to be changed, others can be left
untouched.

<p>Transmission duration and bit error modeling only applies to packets (i.e.
to instances of <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>, where <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>'s
<tt>isPacket()</tt> returns true); it should be skipped for non-packet
messages. <tt>processMessage()</tt> does not need to call the <tt>setDuration()</tt>
method on the packet; this is done by the simulation kernel. However,
it should call <tt>setBitError(true)</tt> on the packet
if error modeling results in bit errors.

<p>If the method sets the <tt>discard</tt> flag in the result object, that
means that the message object will be deleted by OMNeT++; this facility
can be used to model that the message gets lost in the channel.

<p>The <tt>processMessage()</tt> method does not need to throw error on overlapping
transmissions, or if the packet's duration field is already set; these
checks are done by the simulation kernel before <tt>processMessage()</tt> is called.



<p><h3><a name="sec:simple-modules:channel-examples"/>4.8.3 Channel Examples<a class="headerlink" href="#sec:simple-modules:channel-examples" title="Permalink to this headline"></a></h3>

<p>To illustrate coding channel behavior, we look at how the built-in channel
types are implemented.

<p><tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt> lets through messages and packets without
any delay or change. Its <tt>isTransmissionChannel()</tt> method returns
<tt>false</tt>, <tt>getTransmissionFinishTime()</tt> returns <i>0s</i>, and the
body of its <tt>processMessage()</tt> method is empty:

<pre class="cpp">
void <a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a>::processMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
}
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> implements propagation delay, and it can be
disabled; in its disabled state, messages sent though it will be discarded.
This class still models zero transmission duration, so its
<tt>isTransmissionChannel()</tt> and <tt>getTransmissionFinishTime()</tt>
methods still return <tt>false</tt> and <i>0s</i>. The <tt>processMessage()</tt> method
sets the appropriate fields in the <tt>result_t</tt> struct:

<pre class="cpp">
void <a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a>::processMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
    // if channel is disabled, signal that message should be deleted
    result.discard = isDisabled;

    // propagation delay modeling
    result.delay = delay;
}
</pre>
<p>
The <tt>handleParameterChange()</tt> method is also redefined, so that
the channel can update its internal <tt>delay</tt> and <tt>isDisabled</tt>
data members if the corresponding channel parameters change during simulation.
<br><ul><font size=-1>[This code is a little simplified; the actual code uses a bit
in a bitfield to store the value of <tt>isDisabled</tt>.]</font></ul>

<p><tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt> is different. It performs model packet duration
(duration is calculated from the data rate and the length of the packet),
so <tt>isTransmissionChannel()</tt> returns <tt>true</tt>.
<tt>getTransmissionFinishTime()</tt> returns the value of a <tt>txfinishtime</tt>
data member, which gets updated after every packet.

<pre class="cpp">
simtime_t <a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a>::getTransmissionFinishTime() const
{
    return txfinishtime;
}
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt>'s <tt>processMessage()</tt> method makes use of
the <tt>isDisabled</tt>, <tt>datarate</tt>, <tt>ber</tt> and <tt>per</tt> data
members, which are also kept up to date with the help of
<tt>handleParameterChange()</tt>.

<pre class="cpp">
void <a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a>::processMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
    // if channel is disabled, signal that message should be deleted
    if (isDisabled) {
        result.discard = true;
        return;
    }

    // datarate modeling
    if (datarate!=0 && msg-&gt;isPacket()) {
        simtime_t duration = ((<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *)msg)-&gt;getBitLength() / datarate;
        result.duration = duration;
        txfinishtime = t + duration;
    }
    else {
        txfinishtime = t;
    }

    // propagation delay modeling
    result.delay = delay;

    // bit error modeling
    if ((ber!=0 || per!=0) && msg-&gt;isPacket()) {
        <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *pkt = (<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *)msg;
        if (ber!=0 && dblrand() &lt; 1.0 - pow(1.0-ber, (double)pkt-&gt;getBitLength())
            pkt-&gt;setBitError(true);
        if (per!=0 && dblrand() &lt; per)
            pkt-&gt;setBitError(true);
    }
}
</pre>
<p>

<p>
<h2><a name="sec:simple-modules:stopping"/>4.9 Stopping the Simulation<a class="headerlink" href="#sec:simple-modules:stopping" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:simple-modules:endsimulation"/>4.9.1 Normal Termination<a class="headerlink" href="#sec:simple-modules:endsimulation" title="Permalink to this headline"></a></h3>

<p>You can finish the simulation with the <tt>endSimulation()</tt> function:

<pre class="cpp">
endSimulation();
</pre>
<p>
<tt>endSimulation()</tt> is rarely needed in practice because you
can specify simulation time and CPU time limits<!--simulation time limits-->
in the ini file (see later).

<p><h3><a name="sec:simple-modules:raising-errors"/>4.9.2 Raising Errors<a class="headerlink" href="#sec:simple-modules:raising-errors" title="Permalink to this headline"></a></h3>

<p>When the simulation encounters an error condition, it can throw a
<tt><a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a></tt> exception to terminate the simulation with an error
message. (Under Cmdenv, the exception also causes a nonzero program exit
code). The <tt><a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a></tt> class has a constructor with a
<tt>printf()</tt>-like argument list. An example:

<pre class="cpp">
if (windowSize &lt;= 0)
    throw <a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a>("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>
Do not include newline (<tt>\n</tt>), period or exclamation mark
in the error text; it will be added by OMNeT++.

<p>The same effect can be achieved by calling the <tt>error()</tt> method of
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>:

<pre class="cpp">
if (windowSize &lt;= 0)
    error("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>
Of course, the <tt>error()</tt> method can only be used when a module pointer
is available.

<p>

<p><h2><a name="sec:simple-modules:fsm"/>4.10 Finite State Machines<a class="headerlink" href="#sec:simple-modules:fsm" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:simple-modules:fsm-overview"/>4.10.1 Overview<a class="headerlink" href="#sec:simple-modules:fsm-overview" title="Permalink to this headline"></a></h3>

<p>Finite State Machines<!--finite state machine--> (FSMs)<!--FSM-->
can make life with <tt>handleMessage()</tt> easier. OMNeT++ provides a
class and a set of macros to build FSMs.

<p>The key points are:
<ul>
<li> There are two kinds of states:
    <i>transient</i><!--transient states--> and
    <i>steady</i><!--steady states-->. On each event (that is, at
    each call to <tt>handleMessage()</tt>), the FSM transitions out of
    the current (<i>steady</i>) state, undergoes a series of state
    changes (runs through a number of <i>transient</i> states), and
    finally arrives at another <i>steady</i> state. Thus between two
    events, the system is always in one of the steady states.
    Transient states are therefore not really a must -- they exist
    only to group actions to be taken during a transition in a
    convenient way.
<li> You can assign program code to handle entering and leaving a state
    (known as entry/exit code)<!--entry code--><!--exit code-->.
    Staying in the same state is handled as leaving and re-entering
    the state.
<li> Entry code should not modify the state (this is verified by
    OMNeT++).  State changes (transitions) must be put into the exit
    code.
</ul>

<p>OMNeT++'s FSMs <i>can</i> be nested<!--FSM!nested-->. This means
that any state (or rather, its entry or exit code) may contain a
further full-fledged <tt>FSM_Switch()</tt> (see below). This allows you
to introduce sub-states and thereby bring some structure into the
state space if it becomes too large.

<p>
<h4><a name="sec:simple-modules:fsm-api"/>4.10.1.1 The FSM API<a class="headerlink" href="#sec:simple-modules:fsm-api" title="Permalink to this headline"></a></h4>

<p>FSM state is stored in an object of type <tt><a href="../api/classomnetpp_1_1cFSM.html">cFSM</a></tt>. The possible states
are defined by an enum; the enum is also a place to define which
state is transient and which is steady. In the following example, SLEEP
and ACTIVE are steady states and SEND is transient (the numbers
in parentheses must be unique within the state type and they are used
for constructing the numeric IDs for the states):

<pre class="cpp">
enum {
  INIT = 0,
  SLEEP = FSM_Steady(1),
  ACTIVE = FSM_Steady(2),
  SEND = FSM_Transient(1),
};
</pre>
<p>
The actual FSM is embedded in a switch-like statement, <tt>FSM_Switch()</tt>,
with cases for entering and leaving each state:

<pre class="cpp">
FSM_Switch(fsm)
{
  case FSM_Exit(state1):
    //...
    break;
  case FSM_Enter(state1):
    //...
    break;
  case FSM_Exit(state2):
    //...
    break;
  case FSM_Enter(state2):
    //...
    break;
  //...
};
</pre>
<p>

<p>State transitions<!--state transition--> are done via calls to
<tt>FSM_Goto()</tt>, which simply stores the new state in the
<tt><a href="../api/classomnetpp_1_1cFSM.html">cFSM</a></tt> object:

<pre class="cpp">
FSM_Goto(fsm, newState);
</pre>
<p>
The FSM starts from the state with the numeric code 0; this state
is conventionally named INIT.

<p>
<h4><a name="sec:simple-modules:debugging-fsms"/>4.10.1.2 Debugging FSMs<a class="headerlink" href="#sec:simple-modules:debugging-fsms" title="Permalink to this headline"></a></h4>

<p>FSMs can log their state transitions, with the output looking like this:

<pre class="filelisting">
...
FSM GenState: leaving state SLEEP
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SEND
FSM GenState: leaving state SEND
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SLEEP
...
</pre>
<p>
To enable the above output, define <tt>FSM_DEBUG</tt> before including <tt>omnetpp.h</tt>.

<pre class="cpp">
#define FSM_DEBUG    // enables debug output from FSMs
#include &lt;omnetpp.h&gt;
</pre>
<p>
FSMs perform their logging via the <tt>FSM_Print()</tt> macro, defined as
something like this:

<pre class="cpp">
#define FSM_Print(fsm,exiting)
  (EV &lt;&lt; "FSM " &lt;&lt; (fsm).getName()
      &lt;&lt; ((exiting) ? ": leaving state " : ": entering state ")
      &lt;&lt; (fsm).getStateName() &lt;&lt; endl)
</pre>
<p>
The log output format can be changed by undefining <tt>FSM_Print()</tt> after the
inclusion of <tt>omnetpp.ini</tt>, and providing a new definition.

<p>
<h4><a name="sec:simple-modules:fsm-implementation"/>4.10.1.3 Implementation<a class="headerlink" href="#sec:simple-modules:fsm-implementation" title="Permalink to this headline"></a></h4>

<p><tt>FSM_Switch()</tt> is a macro. It expands to a <tt>switch</tt>
statement embedded in a <tt>for()</tt> loop which repeats until the
FSM reaches a steady state.

<p>Infinite loops are avoided by counting state transitions: if
an FSM goes through 64 transitions without reaching a steady
state, the simulation will terminate with an error message.

<p>
<h4><a name="sec:simple-modules:fsm-example"/>4.10.1.4 An Example<a class="headerlink" href="#sec:simple-modules:fsm-example" title="Permalink to this headline"></a></h4>

<p>Let us write another bursty packet generator. It will have two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the Fifo2 sample
simulation.

<p>
<pre class="cpp">
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;
using namespace omnetpp;

class BurstyGenerator : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    // parameters
    double sleepTimeMean;
    double burstTimeMean;
    double sendIATime;
    <a href="../api/classomnetpp_1_1cPar.html">cPar</a> *msgLength;

    // FSM and its states
    <a href="../api/classomnetpp_1_1cFSM.html">cFSM</a> fsm;
    enum {
      INIT = 0,
      SLEEP = FSM_Steady(1),
      ACTIVE = FSM_Steady(2),
      SEND = FSM_Transient(1),
    };

    // variables used
    int i;
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *startStopBurst;
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *sendMessage;

    // the virtual functions
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    fsm.setName("fsm");
    sleepTimeMean = par("sleepTimeMean");
    burstTimeMean = par("burstTimeMean");
    sendIATime = par("sendIATime");
    msgLength = &par("msgLength");
    i = 0;
    WATCH(i); // always put watches in initialize()
    startStopBurst = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("startStopBurst");
    sendMessage = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("sendMessage");
    scheduleAt(0.0,startStopBurst);
}

void BurstyGenerator::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
   FSM_Switch(fsm)
   {
     case FSM_Exit(INIT):
       // transition to SLEEP state
       FSM_Goto(fsm,SLEEP);
       break;
     case FSM_Enter(SLEEP):
       // schedule end of sleep period (start of next burst)
       scheduleAt(simTime()+exponential(sleepTimeMean),
                  startStopBurst);
     break;
     case FSM_Exit(SLEEP):
       // schedule end of this burst
       scheduleAt(simTime()+exponential(burstTimeMean),
                  startStopBurst);
       // transition to ACTIVE state:
       if (msg!=startStopBurst) {
         error("invalid event in state ACTIVE");
       }
       FSM_Goto(fsm,ACTIVE);
       break;
     case FSM_Enter(ACTIVE):
       // schedule next sending
       scheduleAt(simTime()+exponential(sendIATime), sendMessage);
     break;
     case FSM_Exit(ACTIVE):
       // transition to either SEND or SLEEP
       if (msg==sendMessage) {
         FSM_Goto(fsm,SEND);
       } else if (msg==startStopBurst) {
         cancelEvent(sendMessage);
         FSM_Goto(fsm,SLEEP);
       } else {
         error("invalid event in state ACTIVE");
       }
       break;
     case FSM_Exit(SEND): {
       // generate and send out job
       char msgname[32];
       sprintf(msgname, "job-%d", ++i);
       EV &lt;&lt; "Generating " &lt;&lt; msgname &lt;&lt; endl;
       <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *job = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>(msgname);
       job-&gt;setBitLength((long) *msgLength);
       job-&gt;setTimestamp();
       send(job, "out");
       // return to ACTIVE
       FSM_Goto(fsm,ACTIVE);
       break;
     }
   }
}
</pre>

<p>

<p>
<h2><a name="sec:simple-modules:walking-module-hierarchy"/>4.11 Navigating the Module Hierarchy<a class="headerlink" href="#sec:simple-modules:walking-module-hierarchy" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:simple-modules:module-vectors"/>4.11.1 Module Vectors<a class="headerlink" href="#sec:simple-modules:module-vectors" title="Permalink to this headline"></a></h3>

<p>If a module is part of a module vector<!--module!vector-->, the
<tt>getIndex()</tt> and <tt>getVectorSize()</tt> member functions can be used to
query its index and the vector size:

<pre class="cpp">
EV &lt;&lt; "This is module [" &lt;&lt; module-&gt;getIndex() &lt;&lt;
      "] in a vector of size [" &lt;&lt; module-&gt;size() &lt;&lt; "].\n";
</pre>
<p>

<p><h3><a name="sec:simple-modules:module-ids"/>4.11.2 Component IDs<a class="headerlink" href="#sec:simple-modules:module-ids" title="Permalink to this headline"></a></h3>

<p>Every component (module and channel) in the network has an ID that
can be obtained from <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>'s <tt>getId()</tt> member
function:

<pre class="cpp">
int componentId = getId();
</pre>
<p>
IDs uniquely identify a module or channel for the whole duration of the
simulation. This holds even when modules are created and destroyed
dynamically, because IDs of deleted modules or channels are never reused for
newly created ones.

<p>To look up a component by ID, one needs to use methods of the simulation
manager object, <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>. <tt>getComponent()</tt> expects an ID, and
returns the component's pointer if the component still exists, otherwise it
returns <tt>nullptr</tt>. The method has two variations, <tt>getModule(id)</tt>
and <tt>getChannel(id)</tt>. They return <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>
pointers if the identified component is in fact a module or a channel, respectively,
otherwise they return <tt>nullptr</tt>.

<pre class="cpp">
int id = 100;
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod = getSimulation()-&gt;getModule(id); // exists, and is a module
</pre>
<p>

<p><h3><a name="sec:simple-modules:walking-up-and-down-module-hierarchy"/>4.11.3 Walking Up and Down the Module Hierarchy<a class="headerlink" href="#sec:simple-modules:walking-up-and-down-module-hierarchy" title="Permalink to this headline"></a></h3>

<p>The parent module can be accessed by the <tt>getParentModule()</tt>
member function:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *parent = getParentModule();
</pre>
<p>
For example, the parameters of the parent module are accessed
like this:

<pre class="cpp">
double timeout = getParentModule()-&gt;par("timeout");
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>findSubmodule()</tt> and <tt>getSubmodule()</tt>
member functions make it possible to look up the module's submodules
by name<!--module!submodule!lookup--> (or name and index if the submodule
is in a module vector). The first one returns the module ID of
the submodule, and the latter returns the module pointer. If the
submodule is not found, they return -1 or <tt>nullptr</tt>, respectively.

<pre class="cpp">
int submodID = module-&gt;findSubmodule("foo", 3); // look up "foo[3]"
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *submod = module-&gt;getSubmodule("foo", 3);
</pre>
<p>

<p><h3><a name="sec:simple-modules:finding-modules-by-path"/>4.11.4 Finding Modules by Path<a class="headerlink" href="#sec:simple-modules:finding-modules-by-path" title="Permalink to this headline"></a></h3>

<p><tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>getModuleByPath()</tt> member function can be used to
find modules by relative or absolute path. It accepts a path string, and
returns the pointer of the matching module, or <tt>nullptr</tt> if the module
identified by the path does not exist.

<p>The path is dot-separated list of module names. The special module name
<tt>^</tt> (caret) stands for the parent module. If the path
starts with a dot or caret, it is understood as relative to this module,
otherwise it is taken to mean an absolute path. For absolute paths,
inclusion of the toplevel module's name in the path is optional.
The toplevel module itself may be referred to as <tt>&lt;root&gt;</tt>.

<p>The following lines demonstrate relative paths, and find the <tt>app[3]</tt>
submodule and the <tt>gen</tt> submodule of the <tt>app[3]</tt> submodule of the
module in question:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *app = module-&gt;getModuleByPath(".app[3]");  // note leading dot
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *gen = module-&gt;getModuleByPath(".app[3].gen");
</pre>
<p>
Without the leading dot, the path is interpreted as absolute. The following
lines both find the <tt>tcp</tt> submodule of <tt>host[2]</tt> in the network,
regardless of the module on which the <tt>getModuleByPath()</tt> has been
invoked.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *tcp = module-&gt;getModuleByPath("Network.host[2].tcp");
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *tcp = module-&gt;getModuleByPath("host[2].tcp");
</pre>
<p>
The parent module may be expressed with a caret:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *parent = module-&gt;getModuleByPath("^"); // parent module
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *tcp = module-&gt;getModuleByPath("^.tcp"); // sibling module
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *other = module-&gt;getModuleByPath("^.^.host[1].tcp"); // two levels up, then...
</pre>
<p>

<p><h3><a name="sec:simple-modules:iterating-over-submodules"/>4.11.5 Iterating over Submodules<a class="headerlink" href="#sec:simple-modules:iterating-over-submodules" title="Permalink to this headline"></a></h3>

<p>To access all modules within a compound module,
one can use <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a>::<a href="../api/classomnetpp_1_1cModule_1_1SubmoduleIterator.html">SubmoduleIterator</a></tt>.

<pre class="cpp">
for (<a href="../api/classomnetpp_1_1cModule.html">cModule</a>::<a href="../api/classomnetpp_1_1cModule_1_1SubmoduleIterator.html">SubmoduleIterator</a> it(module); !it.end(); it++)
{
  <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *submodule = *it;
  EV &lt;&lt; submodule-&gt;getFullName() &lt;&lt; endl;
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:navigating-connections"/>4.11.6 Navigating Connections<a class="headerlink" href="#sec:simple-modules:navigating-connections" title="Permalink to this headline"></a></h3>

<p>To determine the module at the other end of a connection, use
<tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>'s <tt>getPreviousGate()</tt>, <tt>getNextGate()</tt> and
<tt>getOwnerModule()</tt> methods. An example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *neighbour = gate("out")-&gt;getNextGate()-&gt;getOwnerModule();
</pre>
<p>
For input gates, use <tt>getPreviousGate()</tt> instead of <tt>getNextGate()</tt>.

<p>The endpoints of the connection path are returned by the
<tt>getPathStartGate()</tt> and <tt>getPathEndGate()</tt> <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>
methods. These methods follow the connection path by repeatedly calling
<tt>getPreviousGate()</tt> and <tt>getNextGate()</tt>, respectively,
until they arrive at a <tt>nullptr</tt>. An example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *peer = gate("out")-&gt;getPathEndGate()-&gt;getOwnerModule();
</pre>
<p>

<p><h2><a name="sec:simple-modules:direct-method-calls"/>4.12 Direct Method Calls Between Modules<a class="headerlink" href="#sec:simple-modules:direct-method-calls" title="Permalink to this headline"></a></h2>
<!--method calls!between modules-->

<p>In some simulation models, there might be modules which are too
tightly coupled for message-based communication to be efficient.
In such cases, the solution might be calling one simple module's public
C++ methods from another module.

<p>Simple modules are C++ classes, so normal C++ method calls will
work. Two issues need to be mentioned, however:

<p><ul>
  <li> how to get a pointer to the object representing the module;
  <li> how to let the simulation kernel know that a method call across modules
     is taking place.
</ul>

<p>Typically, the called module is in the same compound module as the caller,
so the <tt>getParentModule()</tt> and <tt>getSubmodule()</tt> methods of
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> can be used to get a <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a>*</tt> pointer to the
called module. (Further ways to obtain the pointer are described
in the section <a href="#sec:simple-modules:walking-module-hierarchy">[4.11]</a>.)
The <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a>*</tt> pointer then has to be cast to the actual C++ class
of the module, so that its methods become visible.

<p>This makes the following code:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *targetModule = getParentModule()-&gt;getSubmodule("foo");
Foo *target = check_and_cast&lt;Foo *&gt;(targetModule);
target-&gt;doSomething();
</pre>
<p>
The <tt>check_and_cast&lt;&gt;()</tt> template function on the second line
is part of OMNeT++. It performs a standard C++ <tt>dynamic_cast</tt>, and checks
the result: if it is <tt>nullptr</tt>, <tt>check_and_cast</tt> raises an OMNeT++ error.
Using <tt>check_and_cast</tt> saves you from writing error checking
code: if <tt>targetModule</tt> from the first line is <tt>nullptr</tt> because
the submodule named <tt>"foo"</tt> was not found, or if that
module is actually not of type <tt>Foo</tt>, an exception is thrown
from <tt>check_and_cast</tt> with an appropriate error message.<br><ul><font size=-1>[A
<tt>check_and_cast_nullable&lt;&gt;()</tt> function also exists. It
accepts <tt>nullptr</tt> as input, and only complains if the cast
goes wrong.]</font></ul>

<p>The second issue is how to let the simulation kernel know that
a method call across modules is taking place. Why is this necessary
in the first place? First, the simulation kernel always has to know which
module's code is currently executing, in order for ownership handling
and other internal mechanisms to work correctly. Second, the Tkenv and
Qtenv simulation GUIs can animate method calls, but to be able to do that,
they need to know about them. Third, method calls are also recorded
in the event log.

<p>The solution is to add the <tt>Enter_Method()</tt> or <tt>Enter_Method_Silent()</tt>
macro at the top of the methods that may be invoked from other
modules. These calls perform context switching, and, in case of
<tt>Enter_Method()</tt>, notify the simulation GUI so that animation
of the method call can take place. <tt>Enter_Method_Silent()</tt>
does not animate the method call, but otherwise it is equivalent
<tt>Enter_Method()</tt>. Both macros accept a <tt>printf()</tt>-like
argument list (it is optional for <tt>Enter_Method_Silent()</tt>),
which should produce a string with the method name and the
actual arguments as much as practical. The string is displayed in
the animation (<tt>Enter_Method()</tt> only) and recorded into the event log.

<p>
<pre class="cpp">
void Foo::doSomething()
{
    Enter_Method("doSomething()");
    ...
}
</pre>

<p>

<p><h2><a name="sec:simple-modules:creating-modules"/>4.13 Dynamic Module Creation<a class="headerlink" href="#sec:simple-modules:creating-modules" title="Permalink to this headline"></a></h2>
<!--module!dynamic creation-->

<p><h3><a name="sec:simple-modules:dynamic-creation:when-to-use"/>4.13.1 When To Use<a class="headerlink" href="#sec:simple-modules:dynamic-creation:when-to-use" title="Permalink to this headline"></a></h3>

<p>Certain simulation scenarios require the ability to dynamically create
and destroy modules. For example, simulating the arrival and departure
of new users in a mobile network may be implemented in terms of adding
and removing modules during the course of the simulation. Loading and
instantiating network topology (i.e. nodes and links) from a data file
is another common technique enabled by dynamic module (and link) creation.

<p>OMNeT++ allows both simple and compound modules to be created at runtime.
When instantiating a compound module, its full internal structure
(submodules and internal connections) is reproduced.

<p>Once created and started, dynamic modules aren't any different from
&#8220;static&#8221; modules.

<p>
<h3><a name="sec:simple-modules:dynamic-creation:overview"/>4.13.2 Overview<a class="headerlink" href="#sec:simple-modules:dynamic-creation:overview" title="Permalink to this headline"></a></h3>

<p>To understand how dynamic module creation works, you have to know a
bit about how OMNeT++ normally instantiates modules. Each module type
(class) has a corresponding factory object of the class
<tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt>. This object is created under the hood by the
<tt>Define_Module()</tt> macro, and it has a factory
method which can instantiate the module class (this function basically
only consists of a <tt>return new <i>&lt;moduleclass&gt;</i>(...)</tt> statement).

<p>The <tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt> object can be looked up by its name
string (which is the same as the module class name). Once you have its
pointer, it is possible to call its factory method and create an
instance of the corresponding module class -- without having to
include the C++ header file containing module's class declaration
into your source file.

<p>The <tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt> object also knows what gates and
parameters the given module type has to have. (This info comes from
NED files.)

<p>Simple modules can be created in one step. For a compound module, the
situation is more complicated, because its internal structure
(submodules, connections) may depend on parameter values and gate
vector sizes. Thus, for compound modules it is generally required to
first create the module itself, second, set parameter values and gate
vector sizes, and then call the method that creates its submodules and
internal connections.

<p>As you know already, simple modules with <tt>activity()</tt> need a
starter message<!--starter messages-->. For statically created
modules, this message is created automatically by OMNeT++, but for
dynamically created modules, you have to do this explicitly by calling
the appropriate functions.

<p>Calling <tt>initialize()</tt> has to take place after insertion of the
starter messages, because the initializing code may insert new messages
into the FES<!--FES-->, and these messages should be processed
<i>after</i> the starter message.

<p>
<h3><a name="sec:simple-modules:dynamic-creation:api"/>4.13.3 Creating Modules<a class="headerlink" href="#sec:simple-modules:dynamic-creation:api" title="Permalink to this headline"></a></h3>

<p>The first step is to find the factory object. The <tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get()</tt>
function expects a fully qualified NED type name, and returns the factory
object:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *moduleType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");
</pre>
<p>
The return value does not need to be checked for <tt>nullptr</tt>, because
the function raises an error if the requested NED type is not found.
(If this behavior is not what you need, you can use the similar
<tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::find()</tt> function, which returns <tt>nullptr</tt> if the type
was not found.)

<p><h4><a name="sec:simple-modules:dynamic:createscheduleinit"/>4.13.3.1 The All-in-One Method<a class="headerlink" href="#sec:simple-modules:dynamic:createscheduleinit" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt> has a
<tt>createScheduleInit(const char *name, <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *parentmod)</tt> % don't break this line (for html)
convenience function to get a module up and running in one step.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod = moduleType-&gt;createScheduleInit("node", this);
</pre>
<p>
<tt>createScheduleInit()</tt> performs the following steps: <tt>create()</tt>,
<tt>finalizeParameters()</tt>, <tt>buildInside()</tt>,
<tt>scheduleStart(now)</tt> and <tt>callInitialize()</tt>.

<p>This method can be used for both simple and compound modules. Its
applicability is somewhat limited, however: because it does everything in
one step, you do not have the chance to set parameters or gate sizes, and
to connect gates before <tt>initialize()</tt> is called.
(<tt>initialize()</tt> expects all parameters and gates to be in place and
the network fully built when it is called.) Because of the above
limitation, this function is mainly useful for creating basic simple
modules.

<p>
<h4><a name="sec:simple-modules:dynamic-creation:details"/>4.13.3.2 The Detailed Procedure<a class="headerlink" href="#sec:simple-modules:dynamic-creation:details" title="Permalink to this headline"></a></h4>

<p>If the <tt>createScheduleInit()</tt> all-in-one method is not applicable,
one needs to use the full procedure. It consists of five steps:

<p><ol>
  <li> Find the factory object;
  <li> Create the module;
  <li> Set up its parameters and gate sizes as needed;
  <li> Tell the (possibly compound) module to recursively create
        its internal submodules and connections;
  <li> Schedule activation message(s) for the new simple module(s).
</ol>

<p>Each step (except for Step 3.) can be done with one line of code.

<p>See the following example, where Step 3 is omitted:

<pre class="cpp">
// find factory object
<a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *moduleType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");

// create (possibly compound) module and build its submodules (if any)
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *module = moduleType-&gt;create("node", this);
module-&gt;finalizeParameters();
module-&gt;buildInside();

// create activation message
module-&gt;scheduleStart(simTime());
</pre>
<p>
If you want to set up parameter values or gate vector sizes (Step 3.),
the code goes between the <tt>create()</tt> and
<tt>buildInside()</tt> calls:

<pre class="cpp">
// create
<a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *moduleType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *module = moduleType-&gt;create("node", this);

// set up parameters and gate sizes before we set up its submodules
module-&gt;par("address") = ++lastAddress;
module-&gt;finalizeParameters();

module-&gt;setGateSize("in", 3);
module-&gt;setGateSize("out", 3);

// create internals, and schedule it
module-&gt;buildInside();
module-&gt;scheduleStart(simTime());
</pre>
<p>

<p><h3><a name="sec:simple-modules:deleting-modules"/>4.13.4 Deleting Modules<a class="headerlink" href="#sec:simple-modules:deleting-modules" title="Permalink to this headline"></a></h3>

<p>To delete a module dynamically<!--module!dynamic deletion-->, use
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>deleteModule()</tt> member function:

<pre class="cpp">
module-&gt;deleteModule();
</pre>
<p>
If the module was a compound module, this involves recursively
deleting all its submodules. A simple module can also delete itself;
in this case, the <tt>deleteModule()</tt> call does not return to the
caller.

<p>Currently, you cannot safely delete a compound module from a simple module
in it; you must delegate the job to a module outside the compound
module.

<p>
<h3><a name="sec:simple-modules:module-deletion-and-finish"/>4.13.5 Module Deletion and finish()<a class="headerlink" href="#sec:simple-modules:module-deletion-and-finish" title="Permalink to this headline"></a></h3>

<p><tt>finish()</tt> is called for <i>all</i> modules at the end of the
simulation, no matter how the modules were created. If a module is
dynamically deleted before that, <tt>finish()</tt> will not be invoked
(<tt>deleteModule()</tt> does not do it). However, you can still manually
invoke it before <tt>deleteModule()</tt>.

<p>You can use the <tt>callFinish()</tt> function to invoke <tt>finish()</tt>
(It is not a good idea to invoke <tt>finish()</tt> directly). If you are
deleting a compound module, <tt>callFinish()</tt> will recursively invoke
<tt>finish()</tt> for all submodules, and if you are deleting a simple
module from another module, <tt>callFinish()</tt> will do the context switch
for the duration of the call.
  <br><ul><font size=-1>[The <tt>finish()</tt> function has even been made <tt>protected</tt>
  in <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>, in order to discourage its invocation from
  other modules.]</font></ul>

<p>Example:

<pre class="cpp">
mod-&gt;callFinish();
mod-&gt;deleteModule();
</pre>
<p>

<p><h3><a name="sec:simple-modules:creating-connections"/>4.13.6 Creating Connections<a class="headerlink" href="#sec:simple-modules:creating-connections" title="Permalink to this headline"></a></h3>
<!--connection!creating-->

<p>Connections can be created using <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt>'s <tt>connectTo()</tt>
method. <tt>connectTo()</tt> should be invoked on the source gate
of the connection, and expects the destination gate pointer as
an argument. The use of the words <i>source</i> and <i>destination</i>
correspond to the direction of the arrow in NED files.

<pre class="cpp">
srcGate-&gt;connectTo(destGate);
</pre>
<p>
<tt>connectTo()</tt> also accepts a channel object (<tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a>*</tt>) as an
additional, optional argument. Similarly to modules, channels can be
created using their factory objects that have the type <tt><a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a></tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *outGate, *inGate;
...

// find factory object and create a channel
<a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a> *channelType = <a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a>::get("foo.util.Channel");
<a href="../api/classomnetpp_1_1cChannel.html">cChannel</a> *channel = channelType-&gt;create("channel");

// create connecting
outGate-&gt;connectTo(inGate, channel);
</pre>
<p>
The channel object will be owned by the source gate of the connection, and
one cannot reuse the same channel object with several connections.

<p>Instantiating one of the built-in channel types (<tt><a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a></tt>,
<tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> or <tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt>) is somewhat simpler,
because those classes have static <tt>create()</tt> factory functions, and the
step of finding the factory object can be spared. Alternatively, one can use
<tt><a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a></tt>'s <tt>createIdealChannel()</tt>, <tt>createDelayChannel()</tt>
and <tt>createDatarateChannel()</tt> static methods.

<p>The channel object may need to be parameterized before using it for a
connection. For example, <tt><a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a></tt> has a <tt>setDelay()</tt>
method, and <tt><a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a></tt> has <tt>setDelay()</tt>,
<tt>setDatarate()</tt>, <tt>setBitErrorRate()</tt> and
<tt>setPacketErrorRate()</tt>.

<p>An example that sets up a channel with a datarate and a delay between two
modules:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a> *datarateChannel = <a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a>::create("channel");
datarateChannel-&gt;setDelay(0.001);
datarateChannel-&gt;setDatarate(1e9);
outGate-&gt;connectTo(inGate, datarateChannel);
</pre>
<p>
Finally, here is a more complete example that creates two modules and
connects them in both directions:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *moduleType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::get("TicToc");
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *a = modtype-&gt;createScheduleInit("a", this);
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *b = modtype-&gt;createScheduleInit("b", this);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"));
b-&gt;gate("out")-&gt;connectTo(a-&gt;gate("in"));
</pre>
<p>

<p><h3><a name="sec:simple-modules:removing-connections"/>4.13.7 Removing Connections<a class="headerlink" href="#sec:simple-modules:removing-connections" title="Permalink to this headline"></a></h3>
<!--connection!removing-->

<p>The <tt>disconnect()</tt> method of <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a></tt> can be
used to remove connections. This method has to be invoked
on the <i>source</i> side of the connection. It also destroys
the channel object associated with the connection, if one has been set.

<pre class="cpp">
srcGate-&gt;disconnect();
</pre>
<p>

<p>
<h2><a name="sec:simple-modules:signals"/>4.14 Signals<a class="headerlink" href="#sec:simple-modules:signals" title="Permalink to this headline"></a></h2>

<p>This section describes <i>simulation signals</i>, or signals for short.
Signals are a versatile concept that first appeared in OMNeT++ 4.1.

<p>Simulation signals can be used for:

<p><ul>
  <li> exposing statistical properties of the model, without specifying
        whether and how to record them
  <li> receiving notifications about simulation model changes at runtime, and
        acting upon them
  <li> implementing a publish-subscribe style communication among modules;
        this is advantageous when the producer and consumer of the information
        do not know about each other, and possibly there is many-to-one or
        many-to-many relationship among them
  <li> emitting information for other purposes, for example as input for
        custom animation effects
</ul>

<p>Signals are emitted by components (modules and channels). Signals propagate on
the module hierarchy up to the root. At any level, one can register listeners,
that is, objects with callback methods. These listeners will be notified (their
appropriate methods called) whenever a signal value is emitted. The result of
upwards propagation is that listeners registered at a compound module can
receive signals from all components in that submodule tree. A listener
registered at the system module can receive signals from the whole simulation.

<p><ul class="note"><b>NOTE</b><br>
    A channel's parent is the (compound) module that contains the connection,
    not the owner of either gate the channel is connected to.
</ul>

<p>Signals are identified by signal <i>names</i> (i.e. strings), but for efficiency,
at runtime we use dynamically assigned numeric identifiers (<i>signal IDs</i>,
typedef'd as <tt>simsignal_t</tt>). The mapping of signal names to signal IDs is
global, so all modules and channels asking to resolve a particular signal name
will get back the same numeric signal ID.

<p>Listeners can subscribe to signal names or IDs, regardless of their
source. For example, if two different and unrelated module types, say
<tt>Queue</tt> and <tt>Buffer</tt>, both emit a signal named <tt>"length"</tt>, then
a listener that subscribes to <tt>"length"</tt> at some higher compound module
will get notifications from both <tt>Queue</tt> and <tt>Buffer</tt> module
instances. The listener can still look at the source of the signal if it
wants to distinguish the two (it is available as a parameter to the
callback function), but the signals framework itself does not have such a
feature.

<p><ul class="note"><b>NOTE</b><br>
  Because the component type that emits the signal is not part of the signal's
  identity, it is advised to choose signal names carefully. A good naming scheme
  facilitates "merging" of signals that arrive from different sources but
  mean the same thing, and reduces the chance of collisions between signals that
  accidentally have the same name but represent different things.
</ul>

<p>When a signal is emitted, it can carry a <i>value</i> with it. There are
multiple overloaded versions of the <tt>emit()</tt> method for different
data types, and also overloaded <tt>receiveSignal()</tt> methods in
listeners. The signal value can be of selected primitive types, or an
object pointer; anything that is not feasible to emit as a primitive type
may be wrapped into an object, and emitted as such.

<p>Even when the signal value is of a primitive type, it is possible to convey
extra information to listeners via an additional <i>details</i> object,
which an optional argument of <tt>emit()</tt>.

<p>
<h3><a name="sec:simple-modules:signals-design"/>4.14.1 Design Considerations and Rationale<a class="headerlink" href="#sec:simple-modules:signals-design" title="Permalink to this headline"></a></h3>

<p>The implementation of signals is based on the following assumptions:

<p><ul>
  <li> subscribe/unsubscribe operations are rare compared to <tt>emit()</tt>
    calls, so it is <tt>emit()</tt> that needs to be efficient
  <li> the signals mechanism is present in every module, so per-module
    memory overhead must be kept as low as possible
  <li> it is expected that modules and channels will be heavily instrumented
    with signals, and only a subset of signals will actually be used
    (will have listeners) in any particular simulation; therefore,
    the CPU and memory overhead of momentarily unused signals must be
    as low as possible
</ul>

<p>These goals have been achieved in the 4.1 version with the following
implementation. First, the data structure that used to store listeners in
components is dynamically allocated, so if there are no listeners, the
per-component overhead is only the size of the pointer (which will be
<tt>nullptr</tt> then).

<p>Second, additionally there are two bitfields in every component that store
which one of the first 64 signals (IDs 0..63) have local listeners and
listeners in ancestor modules.<br><ul><font size=-1>[It is assumed that there will be
typically less than 64 frequently used signals used at a time in a
simulation.]</font></ul> Using these bitfields, it is possible to determine in constant
time for the first 64 signals whether the signal has listeners, so
<tt>emit()</tt> can return immediately if there are none. For other signals,
<tt>emit()</tt> needs to examine the listener lists up to the root every
time. Even if a simulation uses more than 64 signals, in
performance-critical situations it is possible to arrange that frequently
emitted signals (e.g. <tt>"txBegin"</tt>) get the &#8220;fast&#8221; signal IDs, while
infrequent signals (like e.g. <tt>"routerDown"</tt>) get the rest.

<p>
<h3><a name="sec:simple-modules:signals-api"/>4.14.2 The Signals Mechanism<a class="headerlink" href="#sec:simple-modules:signals-api" title="Permalink to this headline"></a></h3>

<p>Signal-related methods are declared on <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>, so they are available
for both <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>.

<p><h4><a name="sec:simple-modules:signal-ids"/>4.14.2.1 Signal IDs<a class="headerlink" href="#sec:simple-modules:signal-ids" title="Permalink to this headline"></a></h4>

<p>Signals are identified by names, but internally numeric signal IDs are used
for efficiency. The <tt>registerSignal()</tt> method takes a signal name as
parameter, and returns the corresponding <tt>simsignal_t</tt> value.
The method is static, illustrating the fact that signal names are global.
An example:

<pre class="cpp">
simsignal_t lengthSignalId = registerSignal("length");
</pre>
<p>
The <tt>getSignalName()</tt> method (also static) does the reverse:
it accepts a <tt>simsignal_t</tt>, and returns the name of the signal as
<tt>const char *</tt> (or <tt>nullptr</tt> for invalid signal handles):

<pre class="cpp">
const char *signalName = getSignalName(lengthSignalId); // --&gt; "length"
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Since OMNeT++ 4.3, the lifetime of signal IDs is the entire program, and
  it is possible to call <tt>registerSignal()</tt> from initializers of
  global variables, e.g. static class members. In earlier versions,
  signal IDs were usually allocated in <tt>initialize()</tt>, and were
  only valid for that simulation run.
</ul>

<p><h4><a name="sec:simple-modules:emitting-signals"/>4.14.2.2 Emitting Signals<a class="headerlink" href="#sec:simple-modules:emitting-signals" title="Permalink to this headline"></a></h4>

<p>The <tt>emit()</tt> family of functions emit a signal from the module or
channel. <tt>emit()</tt> takes a signal ID (<tt>simsignal_t</tt>) and
a value as parameters:

<pre class="cpp">
emit(lengthSignalId, queue.length());
</pre>
<p>
The value can be of type <tt>bool</tt>, <tt>long</tt>, <tt>double</tt>, <tt>simtime_t</tt>,
<tt>const char *</tt>, or <tt>(const) <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *</tt>. Other types can be cast into
one of these types, or wrapped into an object subclassed from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.

<p><tt>emit()</tt> also has an extra, optional object pointer argument named
<tt>details</tt>, with the type <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a>*</tt>. This argument may be used
to convey to listeners extra information.

<p><ul class="note"><b>NOTE</b><br>
  The <i>details</i> parameter was added in OMNeT++ 5.0. You should update
  your models to use the new listener interface or as a temporary solution, compile
  OMNeT++ with the <tt>WITH_OMNETPP4x_LISTENER_SUPPORT</tt> macro.
</ul>

<p>When there are no listeners, the runtime cost of <tt>emit()</tt> is usually minimal.
However, if producing a value has a significant runtime cost, then the
<tt>mayHaveListeners()</tt> or <tt>hasListeners()</tt> method can be used
to check beforehand whether the given signal has any listeners at all --
if not, producing the value and emitting the signal can be skipped.

<p>Example usage:

<pre class="cpp">
if (mayHaveListeners(distanceToTargetSignal)) {
    double d = sqrt((x-targetX)*(x-targetX) + (y-targetY)*(y-targetY));
    emit(distanceToTargetSignal, d);
}
</pre>
<p>
The <tt>mayHaveListeners()</tt> method is very efficient (a constant-time
operation), but may return false positive. In contrast,
<tt>hasListeners()</tt> will search up to the top of the module tree if
the answer is not cached, so it is generally slower. We recommend that
you take into account the cost of producing notification information when
deciding between <tt>mayHaveListeners()</tt> and <tt>hasListeners()</tt>.

<p>
<h4><a name="sec:simple-modules:signal-declarations"/>4.14.2.3 Signal Declarations<a class="headerlink" href="#sec:simple-modules:signal-declarations" title="Permalink to this headline"></a></h4>

<p>Since OMNeT++ 4.4, signals can be declared in NED files for documentation
purposes, and OMNeT++ can check that only declared signals are emitted,
and that they actually conform to the declarations (with regard to the
data type, etc.)

<p>The following example declares a queue module that emits a signal named
<tt>queueLength</tt>:

<pre class="ned">
simple Queue
{
    parameters:
        @signal[queueLength](type=long);
        ...
}
</pre>
<p>
Signals are declared with the <b><tt>@signal</tt></b> property on
the module or channel that emits it. (NED properties are described in
<a href="#sec:ned-lang:properties">[3.12]</a>). The property index corresponds
to the signal name, and the property's body may declare various attributes
of the signal; currently only the data type is supported.

<p>The <tt>type</tt> property key is optional; when present, its value should be
<tt>bool</tt>, <tt>long</tt>, <tt>unsigned long</tt>, <tt>double</tt>, <tt>simtime_t</tt>,
<tt>string</tt>, or a registered class name optionally followed by a question
mark. Classes can be registered using the <tt>Register_Class()</tt> or
<tt>Register_Abstract_Class()</tt> macros; these macros create a
<tt><a href="../api/classomnetpp_1_1cObjectFactory.html">cObjectFactory</a></tt> instance, and the simulation kernel will call
<tt><a href="../api/classomnetpp_1_1cObjectFactory.html">cObjectFactory</a></tt>'s <tt>isInstance()</tt> method to check that the
emitted object is really a subclass of the declared class.
<tt>isInstance()</tt> just wraps a C++ <tt>dynamic_cast</tt>.)

<p>A question mark after the class name means that the signal is allowed to
emit <tt>nullptr</tt> pointers. For example, a module named <tt>PPP</tt> may emit
the frame (packet) object every time it starts transmiting, and emit
<tt>nullptr</tt> when the transmission is completed:

<pre class="ned">
simple PPP
{
    parameters:
        @signal[txFrame](type=PPPFrame?);  // a PPPFrame or nullptr
        ...
}
</pre>
<p>
The property index may contain wildcards, which is important for declaring
signals whose names are only known at runtime. For example, if a module emits
signals called <tt>session-1-seqno</tt>, <tt>session-2-seqno</tt>, <tt>session-3-seqno</tt>,
etc., those signals can be declared as:

<pre class="ned">
    @signal[session-*-seqno]();
</pre>
<p>

<p><h4><a name="sec:simple-modules:enabling-signal-checking"/>4.14.2.4 Enabling/Disabling Signal Checking<a class="headerlink" href="#sec:simple-modules:enabling-signal-checking" title="Permalink to this headline"></a></h4>

<p>Starting with OMNeT++ 5.0, signal checking is turned on by default when the
simulation kernel is compiled in debug mode, requiring all signals to be
declared with <b><tt>@signal</tt></b>. (It is turned off in release mode
simulation kernels due to performance reasons.)

<p>If needed, signal checking can be disabled with the <b><tt>check-signals</tt></b>
configuration option:

<pre class="inifile">
check-signals = false
</pre>
<p>

<p><h4><a name="sec:simple-modules:signal-data-objects"/>4.14.2.5 Signal Data Objects<a class="headerlink" href="#sec:simple-modules:signal-data-objects" title="Permalink to this headline"></a></h4>

<p>When emitting a signal with a <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a>*</tt> pointer, you can pass as data
an object that you already have in the model, provided you have a suitable
object at hand. However, it is often necessary to declare a custom class
to hold all the details, and fill in an instance just for the purpose of
emitting the signal.

<p>The custom notification class must be derived from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.
We recommend that you also add <tt><a href="../api/classomnetpp_1_1noncopyable.html">noncopyable</a></tt> as a base class, because
then you don't need to write a copy constructor, assignment operator, and
<tt>dup()</tt> function, sparing some work. When emitting the signal, you
can create a temporary object, and pass its pointer to the <tt>emit()</tt>
function.

<p>An example of custom notification classes are the ones associated with
model change notifications (see <a href="#sec:simple-modules:model-change">[4.14.3]</a>).
For example, the data class that accompanies a signal that announces that a
gate or gate vector is about to be created looks like this:

<pre class="cpp">
class <a href="../api/classomnetpp_1_1cPreGateAddNotification.html">cPreGateAddNotification</a> : public <a href="../api/classomnetpp_1_1cObject.html">cObject</a>, <a href="../api/classomnetpp_1_1noncopyable.html">noncopyable</a>
{
  public:
    <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *module;
    const char *gateName;
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a>::Type gateType;
    bool isVector;
};
</pre>
<p>
And the code that emits the signal:

<pre class="cpp">
if (hasListeners(PRE_MODEL_CHANGE))
{
    <a href="../api/classomnetpp_1_1cPreGateAddNotification.html">cPreGateAddNotification</a> tmp;
    tmp.module = this;
    tmp.gateName = gatename;
    tmp.gateType = type;
    tmp.isVector = isVector;
    emit(PRE_MODEL_CHANGE, &tmp);
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:subscribing-to-signals"/>4.14.2.6 Subscribing to Signals<a class="headerlink" href="#sec:simple-modules:subscribing-to-signals" title="Permalink to this headline"></a></h4>

<p>The <tt>subscribe()</tt> method registers a listener for a signal.
Listeners are objects that extend the <tt><a href="../api/classomnetpp_1_1cIListener.html">cIListener</a></tt> class.
The same listener object can be subscribed to multiple signals.
<tt>subscribe()</tt> has two arguments: the signal and a pointer to
the listener object:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a> *listener = ...;
simsignal_t lengthSignalId = registerSignal("length");
subscribe(lengthSignalId, listener);
</pre>
<p>
For convenience, the <tt>subscribe()</tt> method has a variant
that takes the signal name directly, so the <tt>registerSignal()</tt>
call can be omitted:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a> *listener = ...;
subscribe("length", listener);
</pre>
<p>
One can also subscribe at other modules, not only the local one.
For example, in order to get signals from all parts of the model,
one can subscribe at the system module level:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a> *listener = ...;
getSimulation()-&gt;getSystemModule()-&gt;subscribe("length", listener);
</pre>
<p>
The <tt>unsubscribe()</tt> method has the same parameter list
as <tt>subscribe()</tt>, and unregisters the given listener
from the signal:

<pre class="cpp">
unsubscribe(lengthSignalId, listener);
</pre>
<p>
or

<pre class="cpp">
unsubscribe("length", listener);
</pre>
<p>
It is an error to subscribe the same listener to the same
signal twice.

<p><ul class="note"><b>NOTE</b><br>
  When a listener is deleted, it must already be unsubscribed from
  all components it has subscribed to. This is explained in
  <a href="#sec:simple-modules:signals:life-cycle">[4.14.2.8]</a>.
</ul>

<p>It is possible to test whether a listener is subscribed to a signal,
using the <tt>isSubscribed()</tt> method which also takes the same
parameter list.

<pre class="cpp">
if (isSubscribed(lengthSignalId, listener))
{
    ...
}
</pre>
<p>
For completeness, there are methods for getting the list of signals
that the component has subscribed to (<tt>getLocalListenedSignals()</tt>),
and the list of listeners for a given signal (<tt>getLocalSignalListeners()</tt>).
The former returns <tt>std::vector&lt;simsignal_t&gt;</tt>; the latter takes
a signal ID (<tt>simsignal_t</tt>) and returns <tt>std::vector&lt;<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a>*&gt;</tt>.

<p>The following example prints the number of listeners for each signal:

<pre class="cpp">
EV &lt;&lt; "Signal listeners:\n";
std::vector&lt;simsignal_t&gt; signals = getLocalListenedSignals();
for (unsigned int i = 0; i &lt; signals.size(); i++) {
    simsignal_t signalID = signals[i];
    std::vector&lt;<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a>*&gt; listeners = getLocalSignalListeners(signalID);
    EV &lt;&lt; getSignalName(signalID) &lt;&lt; ": " &lt;&lt; listeners.size() &lt;&lt; " signals\n";
}
</pre>
<p>
<h4><a name="sec:simple-modules:signal-listeners"/>4.14.2.7 Listeners<a class="headerlink" href="#sec:simple-modules:signal-listeners" title="Permalink to this headline"></a></h4>

<p>Listeners are objects that subclass from the <tt><a href="../api/classomnetpp_1_1cIListener.html">cIListener</a></tt> class, which
declares the following methods:

<pre class="cpp">
class <a href="../api/classomnetpp_1_1cIListener.html">cIListener</a>
{
  public:
    virtual ~<a href="../api/classomnetpp_1_1cIListener.html">cIListener</a>() {}
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               bool value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               long value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               double value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               simtime_t value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               const char *value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id,
                               <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
    virtual void finish(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *component, simsignal_t id) {}
    virtual void subscribedTo(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *component, simsignal_t id) {}
    virtual void unsubscribedFrom(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *component, simsignal_t id) {}
};
</pre>
<p>
This class has a number of virtual methods:

<p><ul>
  <li> Several overloaded <tt>receiveSignal()</tt> methods, one for each
    data type. Whenever a signal is emitted (via <tt>emit()</tt>), the matching
    <tt>receiveSignal()</tt> method is invoked on the subscribed listeners.
  <li> <tt>finish()</tt> is called by a component on its local listeners
    after the component's <tt>finish()</tt> method was called. If the listener
    is subscribed to multiple signals or at multiple components, the method
    will be called multiple times. Note that <tt>finish()</tt> methods in general
    are not invoked if the simulation terminates with an error, so that method
    is not a place for doing cleanup.
  <li> <tt>subscribedTo()</tt>, <tt>unsubscribedFrom()</tt> are called
    when this listener object is subscribed/unsubscribed to (from) a signal.
    These methods give the opportunity for listeners to track whether
    and where they are subscribed. It is also OK for a listener to delete
    itself in the last statement of the <tt>unsubscribedFrom()</tt> method,
    but you must be sure that there are no other places the same listener
    is still subscribed.
</ul>

<p>Since <tt><a href="../api/classomnetpp_1_1cIListener.html">cIListener</a></tt> has a large number of pure virtual methods, it is more
convenient to subclass from <tt><a href="../api/classomnetpp_1_1cListener.html">cListener</a></tt>, a do-nothing implementation
instead. It defines <tt>finish()</tt>, <tt>subscribedTo()</tt> and
<tt>unsubscribedFrom()</tt> with an empty body, and the <tt>receiveSignal()</tt>
methods with a bodies that throw a <tt>"Data type not supported"</tt> error.
You can redefine the <tt>receiveSignal()</tt> method(s) whose data type
you want to support, and signals emitted with other (unexpected) data
types will result in an error instead of going unnoticed.

<p>The order in which listeners will be notified is undefined (it is not necessarily
the same order in which listeners were subscribed.)

<p><h4><a name="sec:simple-modules:signals:life-cycle"/>4.14.2.8 Listener Life Cycle<a class="headerlink" href="#sec:simple-modules:signals:life-cycle" title="Permalink to this headline"></a></h4>

<p>When a component (module or channel) is deleted, it automatically
unsubscribes (but does not delete) the listeners it has. When a
module is deleted, it first unsubscribes all listeners from all
modules and channels in its submodule tree before starting
to recursively delete the modules and channels themselves.

<p>When a listener is deleted, it must already be unsubscribed from all
components at that point. If it is not unsubscribed, pointers to the dead
listener object will be left in the components' listener lists, and the
components will crash inside an <tt>emit()</tt> call, or when they
try to invoke <tt>unsubscribedFrom()</tt> on the dead listener from their
destructors. The <tt><a href="../api/classomnetpp_1_1cIListener.html">cIListener</a></tt> class contains a subscription count,
and prints a warning message when it is not zero in the destructor.

<p><ul class="note"><b>NOTE</b><br>
  If your module has added listeners to other modules (e.g. the toplevel
  module), these listeners must be unsubscribed in the module
  destructor at latest. Remember to make sure the modules still exist before you
  call <tt>unsubscribe()</tt> on them, unless they are an ancestor
  of your module in the module tree.
</ul>

<p>
<h3><a name="sec:simple-modules:model-change"/>4.14.3 Listening to Model Changes<a class="headerlink" href="#sec:simple-modules:model-change" title="Permalink to this headline"></a></h3>

<p>In simulation models it is often useful to hold references to other
modules, a connecting channel or other objects, or to cache information
derived from the model topology. However, such pointers or data may
become invalid when the model changes at runtime, and need to be updated
or recalculated. The problem is how to get notification that something has
changed in the model.

<p><ul class="note"><b>NOTE</b><br>
  Whenever you see a <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a>*</tt>, <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a>*</tt>, <tt><a href="../api/classomnetpp_1_1cGate.html">cGate</a>*</tt> or
  similar pointer kept as state in a simple module, you should think about
  how it will be kept up-to-date if the model changes at runtime.
</ul>

<p>The solution is, of course, signals. OMNeT++ has two built-in signals,
<tt>PRE_MODEL_CHANGE</tt> and <tt>POST_MODEL_CHANGE</tt> (these macros
are <tt>simsignal_t</tt> values, not names) that are emitted before and
after each model change.

<p>Pre/post model change notifications are emitted with data objects that
carry the details of the change. The data classes are:

<p><ul>
  <li> <tt><a href="../api/classomnetpp_1_1cPreModuleAddNotification.html">cPreModuleAddNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostModuleAddNotification.html">cPostModuleAddNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostModuleDeleteNotification.html">cPostModuleDeleteNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreModuleReparentNotification.html">cPreModuleReparentNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostModuleReparentNotification.html">cPostModuleReparentNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateAddNotification.html">cPreGateAddNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateAddNotification.html">cPostGateAddNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateDeleteNotification.html">cPreGateDeleteNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateDeleteNotification.html">cPostGateDeleteNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateVectorResizeNotification.html">cPreGateVectorResizeNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateVectorResizeNotification.html">cPostGateVectorResizeNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateConnectNotification.html">cPreGateConnectNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateConnectNotification.html">cPostGateConnectNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreGateDisconnectNotification.html">cPreGateDisconnectNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostGateDisconnectNotification.html">cPostGateDisconnectNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPrePathCreateNotification.html">cPrePathCreateNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostPathCreateNotification.html">cPostPathCreateNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPrePathCutNotification.html">cPrePathCutNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostPathCutNotification.html">cPostPathCutNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreParameterChangeNotification.html">cPreParameterChangeNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostParameterChangeNotification.html">cPostParameterChangeNotification</a></tt>
  <li> <tt><a href="../api/classomnetpp_1_1cPreDisplayStringChangeNotification.html">cPreDisplayStringChangeNotification</a></tt> / <tt><a href="../api/classomnetpp_1_1cPostDisplayStringChangeNotification.html">cPostDisplayStringChangeNotification</a></tt>
</ul>

<p>They all subclass from <tt><a href="../api/classomnetpp_1_1cModelChangeNotification.html">cModelChangeNotification</a></tt>, which is of course a
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>. Inside the listener, you can use <tt>dynamic_cast&lt;&gt;</tt> to figure
out what notification arrived.

<p><ul class="note"><b>NOTE</b><br>
  Please look up these classes in the API documentation to see their data fields,
  when exactly they get fired, and what one needs to be careful about when using them.
</ul>

<p>An example listener that prints a message when a module is deleted:

<pre class="cpp">
class MyListener : public <a href="../api/classomnetpp_1_1cListener.html">cListener</a>
{
   ...
};

void MyListener::receiveSignal(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *src, simsignal_t id, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *value,
                               <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details)
{
    if (dynamic_cast&lt;<a href="../api/classomnetpp_1_1cPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *&gt;(value)) {
        <a href="../api/classomnetpp_1_1cPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *data = (<a href="../api/classomnetpp_1_1cPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *)value;
        EV &lt;&lt; "Module " &lt;&lt; data-&gt;module-&gt;getFullPath() &lt;&lt; " is about to be deleted\n";
    }
}
</pre>
<p>
If you'd like to get notification about the deletion of any module, you need
to install the listener on the system module:

<pre class="cpp">
getSimulation()-&gt;getSystemModule()-&gt;subscribe(PRE_MODEL_CHANGE, listener);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  <tt>PRE_MODEL_CHANGE</tt> and <tt>POST_MODEL_CHANGE</tt> are fired on the
  module (or channel) affected by the change, and <i>not</i> on the module
  which executes the code that causes the change. For example,
  <i>pre-module-deleted</i> is fired on the module to be removed, and
  <i>post-module-deleted</i> is fired on its parent (because the original
  module no longer exists), and not on the module that contains the
  <tt>deleteModule()</tt> call.
</ul>

<p><ul class="note"><b>NOTE</b><br>
  A listener will <i>not</i> receive <i>pre/post-module-deleted</i>
  notifications if the whole submodule tree that contains the subscription
  point is deleted. This is because compound module destructors begin
  by unsubscribing all modules/channels in the subtree before starting
  recursive deletion.
</ul>

<p>
<h2><a name="sec:simple-modules:signal-based-statistics"/>4.15 Signal-Based Statistics Recording<a class="headerlink" href="#sec:simple-modules:signal-based-statistics" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:simple-modules:signal-based-statistics-motivation"/>4.15.1 Motivation<a class="headerlink" href="#sec:simple-modules:signal-based-statistics-motivation" title="Permalink to this headline"></a></h3>

<p>One use of signals is to expose variables for result collection without
telling where, how, and whether to record them. With this approach,
modules only publish the variables, and the actual result recording
takes place in listeners. Listeners may be added by the simulation
framework (based on the configuration), or by other modules (for example
by dedicated result collection modules).

<p>The signals approach allows for several possibilities:

<p><ul>
 <li> Provides a controllable level of detail: in some simulation runs
    you may want to record all values as a time series, in other runs
    only record the mean, time average, minimum/maximum value, standard
    deviation etc, and in yet other runs you may want to record the
    distribution as a histogram;
 <li> Depending on the purpose of the simulation experiment, you may want
    to process the results before recording them, for example
    record a smoothed or filtered value, record the percentage of time the
    value is nonzero or over a threshold, record the sum of the values, etc.;
 <li> You may want aggregate statistics, e.g. record the total number
    of packet drops or the average end-to-end delay for the whole network;
 <li> You may want to record combined statistics, for example a drop
    percentage (drop count/total number of packets);
 <li> You may want to ignore results generated during the warm-up period
    or during other transients.
</ul>

<p>With the signals approach the above goals can be fulfilled.

<p>
<h3><a name="sec:simple-modules:declaring-statistics"/>4.15.2 Declaring Statistics<a class="headerlink" href="#sec:simple-modules:declaring-statistics" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:simple-modules:declared-statistics:introduction"/>4.15.2.1 Introduction<a class="headerlink" href="#sec:simple-modules:declared-statistics:introduction" title="Permalink to this headline"></a></h4>

<p>In order to record simulation results based on signals, one must add
<b><tt>@statistic</tt></b> properties to the simple module's (or channel's) NED
definition. A <b><tt>@statistic</tt></b> property defines the name of the
statistic, which signal(s) are used as input, what processing steps are to
be applied to them (e.g. smoothing, filtering, summing, differential
quotient), and what properties are to be recorded (minimum, maximum,
average, etc.) and in which form (vector, scalar, histogram). Record items
can be marked optional, which lets you denote a <i>&#8220;default&#8221;</i> and a
more comprehensive <i>&#8220;all&#8221;</i> result set to be recorded; the list of
record items can be further tweaked from the configuration. One can also
specify a descriptive name (&#8220;title&#8221;) for the statistic, and also a
measurement unit.

<p>The following example declares a queue module with a queue length statistic:

<pre class="ned">
simple Queue
{
    parameters:
        @statistic[queueLength](record=max,timeavg,vector?);
    gates:
        input in;
        output out;
}
</pre>
<p>
As you can see, statistics are represented with indexed NED properties (see
<a href="#sec:ned-lang:properties">[3.12]</a>). The property name is always
<tt>statistic</tt>, and the index (here, <tt>queueLength</tt>) is the
name of the statistic. The property value, that is, everything inside the
parentheses, carries hints and extra information for recording.

<p>The above <tt>@statistic</tt> declaration assumes that module's C++ code
emits the queue's updated length as signal <tt>queueLength</tt> whenever
elements are inserted into the queue or are removed from it.
By default, the maximum and the time average of the queue length will
be recorded as scalars. One can also instruct the simulation (or parts
of it) to record &#8220;all&#8221; results; this will turn on optional record items,
those marked with a question mark, and then the queue lengths will also be
recorded into an output vector.

<p><ul class="note"><b>NOTE</b><br>
The configuration lets you fine-tune the list of result items even
beyond the <tt>default</tt> and <tt>all</tt> settings; see section
<a href="#sec:ana-sim:configuring-recording-modes">[12.2.3]</a>.
</ul>

<p>In the above example, the signal to be recorded was taken from the
statistic name. When that is not suitable, the <tt>source</tt> property key
lets you specify a different signal as input for the statistic. The
following example assumes that the C++ code emits a <tt>qlen</tt> signal, and
declares a <tt>queueLength</tt> statistic based on that:

<pre class="ned">
simple Queue
{
    parameters:
        @signal[qlen](type=int); // optional
        @statistic[queueLength](source=qlen; record=max,timeavg,vector?);
        ...
}
</pre>
<p>
Note that beyond the <tt>source=qlen</tt> property key we have also added
a signal declaration (<b><tt>@signal</tt></b> property) for the <tt>qlen</tt> signal.
Declaring signals is currently optional and in fact <tt>@signal</tt> properties
are currently ignored by the system, but it is a good practice nevertheless.

<p>It is also possible to apply processing to a signal before recording it.
Consider the following example:

<pre class="ned">
@statistic[dropCount](source=count(drop); record=last,vector?);
</pre>
<p>
This records the total number of packet drops as a scalar, and
optionally the number of packets dropped in the function of time as a
vector, provided the C++ code emits a <tt>drop</tt> signal every time a packet
is dropped. The value and even the data type of the <tt>drop</tt> signal is
indifferent, because only the number of emits will be counted.
Here, <tt>count()</tt> is a <i>result filter</i>.

<p><ul class="note"><b>NOTE</b><br>
Starting from OMNeT++ 4.4, items containing parens (e.g. <tt>count(drop)</tt>)
no longer need to be enclosed in quotation marks.
</ul>

<p>Another example:

<pre class="ned">
@statistic[droppedBytes](source=sum(packetBytes(pkdrop)); record=last,
vector?);
</pre>
<p>
This example assumes that the C++ code emits a <tt>pkdrop</tt> signal with a
packet (<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>*</tt> pointer) as a value. Based on that signal, it
records the total number of bytes dropped (as a scalar, and optionally as a
vector too). The <tt>packetBytes()</tt> filter extracts the number of bytes
from each packet using <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>'s <tt>getByteLength()</tt> method,
and the <tt>sum()</tt> filter, well, sums them up.

<p>Arithmetic expressions can also be used. For example, the following line
computes the number of dropped bytes using the <tt>packetBits()</tt> filter.

<pre class="ned">
@statistic[droppedBytes](source=sum(8*packetBits(pkdrop)); record=last,
vector?);
</pre>
<p>
The source can also combine multiple signals in an arithmetic expression:

<pre class="ned">
@statistic[dropRate](source=count(drop)/count(pk); record=last,vector?);
</pre>
<p>
When multiple signals are used, a value arriving on either signal will
result in one output value. The computation will use the last values of the
other signals (sample-hold interpolation). One limitation regarding
multiple signals is that the same signal cannot occur twice, because it
would cause glitches in the output.

<p>Record items may also be expressions and contain filters. For example, the
statistic below is functionally equivalent to one of the above examples: it
also computes and records as scalar and as vector the total number of bytes
dropped, using a <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>*</tt>-valued signal as input; however, some of
the computations have been shifted into the recorder part.

<pre class="ned">
@statistic[droppedBytes](source=packetBits(pkdrop); record=last(8*sum),
vector(8*sum)?);
</pre>
<p>

<p><h4><a name="sec:simple-modules:declared-statistics:property-keys"/>4.15.2.2 Property Keys<a class="headerlink" href="#sec:simple-modules:declared-statistics:property-keys" title="Permalink to this headline"></a></h4>

<p>The following keys are understood in <b><tt>@statistic</tt></b> properties:

<p><ul class="dl">
  <li><b>source</b> : Defines the input for the recorders (see <tt>record=</tt> key).
     When missing, the statistic name is taken as the signal name;
  <li><b>record</b> : Contains a list of recording modes, separated by comma.
     Recording modes define how to record the source (see <tt>source=</tt> key).
  <li><b>title</b> : A longer, descriptive name for the statistic signal; result
      visualization tools may use it as chart label, e.g. in the legend.
  <li><b>unit</b> : Measurement unit of the values. This may also appear in charts.
  <li><b>interpolationmode</b> : Defines how to interpolate signal values where
      needed (e.g. for drawing); possible values are <tt>none</tt>,
      <tt>sample-hold</tt>, <tt>backward-sample-hold</tt>, <tt>linear</tt>.
  <li><b>enum</b> : Defines symbolic names for various integer signal values.
      The property value must be a string, containing <i>name=value</i> pairs
      separated by comma. Example: <tt>"IDLE=1,BUSY=2,DOWN=3"</tt>.
</ul>

<p>
<h4><a name="sec:simple-modules:available-result-filters-and-recorders"/>4.15.2.3 Available Filters and Recorders<a class="headerlink" href="#sec:simple-modules:available-result-filters-and-recorders" title="Permalink to this headline"></a></h4>

<p>The following table contains the list of predefined result filters.
All filters in the table output a value for each input value.

<p><table border>
<TR> <TD align=left>
  
<p>  <b>Filter</b> </TD> <TD align=left> <b>Description</b> </TD></TR>
<TR> <TD align=left>   <tt>count</tt> </TD> <TD align=left> Computes and outputs the count of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>sum</tt> </TD> <TD align=left> Computes and outputs the sum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>min</tt> </TD> <TD align=left> Computes and outputs the minimum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>max</tt> </TD> <TD align=left> Computes and outputs the maximum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>mean</tt> </TD> <TD align=left> Computes and outputs the average (sum / count) of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>timeavg</tt> </TD> <TD align=left> Regards the input values and their timestamps as a step function (sample-hold style), and
                  computes and outputs its time average (integral divided by duration). </TD></TR>
<TR> <TD align=left>   <tt>constant0</tt> </TD> <TD align=left> Outputs a constant 0 for each received value (independent of the value). </TD></TR>
<TR> <TD align=left>   <tt>constant1</tt> </TD> <TD align=left> Outputs a constant 1 for each received value (independent of the value). </TD></TR>
<TR> <TD align=left>   <tt>packetBits</tt> </TD> <TD align=left> Expects <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> pointers as value, and outputs the bit length
                     for each received one. Non-<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> values are ignored. </TD></TR>
<TR> <TD align=left>   <tt>packetBytes</tt> </TD> <TD align=left> Expects <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> pointers as value, and outputs the byte length
                      for each received one. Non-<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> values are ignored. </TD></TR>
<TR> <TD align=left>   <tt>sumPerDuration</tt> </TD> <TD align=left> For each value, computes the sum of values received so far,
                         divides it by the duration, and outputs the result. </TD></TR>
<TR> <TD align=left>   <tt>removeRepeats</tt> </TD> <TD align=left> Removes repeated values, i.e. discards values that are the same as the previous value. </TD></TR>
</table>

<p>The list of predefined result recorders:

<p><table border>
<TR> <TD align=left>
  
<p>  <b>Recorder</b> </TD> <TD align=left> <b>Description</b> </TD></TR>
<TR> <TD align=left>   <tt>last</tt> </TD> <TD align=left> Records the last value into an output scalar. </TD></TR>
<TR> <TD align=left>   <tt>count</tt> </TD> <TD align=left> Records the count of the input values into an output scalar;
                functionally equivalent to <tt>last(count)</tt> </TD></TR>
<TR> <TD align=left>   <tt>sum</tt> </TD> <TD align=left> Records the sum of the input values into an output scalar
              (or zero if there was none);
              functionally equivalent to <tt>last(sum)</tt> </TD></TR>
<TR> <TD align=left>   <tt>min</tt> </TD> <TD align=left> Records the minimum of the input values into an output scalar
              (or positive infinity if there was none);
              functionally equivalent to <tt>last(min)</tt> </TD></TR>
<TR> <TD align=left>   <tt>max</tt> </TD> <TD align=left> Records the maximum of the input values into an output scalar
              (or negative infinity if there was none);
              functionally equivalent to <tt>last(max)</tt> </TD></TR>
<TR> <TD align=left>   <tt>mean</tt> </TD> <TD align=left> Records the mean of the input values into an output scalar
               (or NaN if there was none);
               functionally equivalent to <tt>last(mean)</tt> </TD></TR>
<TR> <TD align=left>   <tt>timeavg</tt> </TD> <TD align=left> Regards the input values with their timestamps as a step
               function (sample-hold style), and records the time average of the
               input values into an output scalar;
               functionally equivalent to <tt>last(timeavg)</tt> </TD></TR>
<TR> <TD align=left>   <tt>stats</tt> </TD> <TD align=left> Computes basic statistics (count, mean, std.dev, min, max) from the input values,
                and records them into the output scalar file as a statistic object. </TD></TR>
<TR> <TD align=left>   <tt>histogram</tt> </TD> <TD align=left> Computes a histogram and basic statistics (count, mean, std.dev, min, max)
                from the input values, and records the reslut into the output scalar file
                as a histogram object. </TD></TR>
<TR> <TD align=left>   <tt>vector</tt> </TD> <TD align=left> Records the input values with their timestamps into an output vector. </TD></TR>
</table>

<p><ul class="note"><b>NOTE</b><br>
You can have the list of available result filters and result recorders
printed by executing the <tt>opp_run -h resultfilters</tt> and <tt>opp_run
-h resultrecorders</tt> commands.
</ul>

<p>
<h4><a name="sec:simple-modules:naming-and-attributes-of-recorded-results"/>4.15.2.4 Naming and Attributes of Recorded Results<a class="headerlink" href="#sec:simple-modules:naming-and-attributes-of-recorded-results" title="Permalink to this headline"></a></h4>

<p>The names of recorded result items will be formed by concatenating the
statistic name and the recording mode with a colon between them:
<tt>"<i>&lt;statisticName&gt;</i>:<i>&lt;recordingMode&gt;</i>"</tt>.

<p>Thus, the following statistics

<pre class="ned">
@statistic[dropRate](source=count(drop)/count(pk); record=last,vector?);
@statistic[droppedBytes](source=packetBytes(pkdrop); record=sum,vector(sum)?);
</pre>
<p>
will produce the following scalars: <tt>dropRate:last</tt>, <tt>droppedBytes:sum</tt>,
and the following vectors: <tt>dropRate:vector</tt>, <tt>droppedBytes:vector(sum)</tt>.

<p>All property keys (except for <tt>record</tt>) are recorded as result
attributes into the vector file or scalar file. The <tt>title</tt> property
will be tweaked a little before recording: the recording mode will be added
after a comma, otherwise all result items saved from the same statistic
would have exactly the same name.

<p>Example: "Dropped Bytes, sum", "Dropped Bytes, vector(sum)"

<p>
It is allowed to use other property keys as well, but they won't be
interpreted by the OMNeT++ runtime or the result analysis tool.

<p>
<h4><a name="sec:simple-modules:statistic-source-and-record-details"/>4.15.2.5 Source and Record Expressions in Detail<a class="headerlink" href="#sec:simple-modules:statistic-source-and-record-details" title="Permalink to this headline"></a></h4>

<p>To fully understand <tt>source</tt> and <tt>record</tt>, it will be useful to see
how result recording is set up.

<p>When a module or channel is created in the simulation, the OMNeT++ runtime
examines the <tt>@statistic</tt> properties on its NED declaration, and adds
listeners on the signals they mention as input. There are two kinds of
listeners associated with result recording: <i>result filters</i> and
<i>result recorders</i>. Result filters can be chained, and at the end of
the chain there is always a recorder. So, there may be a recorder directly
subscribed to a signal, or there may be a chain of one or more filters plus
a recorder. Imagine it as a pipeline, or rather a &#8220;pipe tree&#8221;, where the
tree roots are signals, the leaves are result recorders, and the
intermediate nodes are result filters.

<p>Result filters typically perform some processing on the values they receive
on their inputs (the previous filter in the chain or directly a signal),
and propagate them to their output (chained filters and recorders). A
filter may also swallow (i.e. not propagate) values. Recorders may write
the received values into an output vector, or record output scalar(s)
at the end of the simulation.

<p>Many operations exist both in filter and recorder form. For example, the
<tt>sum</tt> <i>filter</i> propagates the sum of values received on its
input to its output; and the <tt>sum</tt> <i>recorder</i> only computes the
the sum of received values in order to record it as an output scalar on
simulation completion.

<p>The next figure illustrates which filters and recorders are created and how
they are connected for the following statistics:

<pre class="ned">
@statistic[droppedBits](source=8*packetBytes(pkdrop); record=sum,vector(sum));
</pre>
<p>

<p>  <center>
    <img src="statisticrecording.svg">
    <center><div class="caption"><i>Figure: Result filters and recorders chained</i></div></center>
  </center>

<p>
<ul class="hint"><b>HINT</b><br>
To see how result filters and recorders have been set up for a particular
simulation, run the simulation with the <b><tt>debug-statistics-recording</tt></b>
configuration option, e.g. specify <tt>--debug-statistics-recording=true</tt>
on the command line.
</ul>

<p>
<h3><a name="sec:simple-modules:statistic-recording-dynamic-signals"/>4.15.3 Statistics Recording for Dynamically Registered Signals<a class="headerlink" href="#sec:simple-modules:statistic-recording-dynamic-signals" title="Permalink to this headline"></a></h3>

<p>It is often convenient to have a module record statistics per session, per
connection, per client, etc. One way of handling this use case is registering
signals dynamically (e.g. <tt>session1-jitter</tt>, <tt>session2-jitter</tt>, ...),
and setting up <b><tt>@statistic</tt></b>-style result recording on each.

<p>The NED file would look like this:

<pre class="ned">
@signal[session*-jitter](type=simtime_t); // note the wildcard
@statisticTemplate[sessionJitter](record=mean,vector?);
</pre>
<p>
In the C++ code of the module, you need to register each new signal with
<tt>registerSignal()</tt>, and in addition, tell OMNeT++ to set up statistics
recording for it as described by the <b><tt>@statisticTemplate</tt></b> property.
The latter can be achieved by calling <tt>getEnvir()-&gt;addResultRecorders()</tt>.

<pre class="cpp">
char signalName[32];
sprintf(signalName, "session%d-jitter", sessionNum);
simsignal_t signal = registerSignal(signalName);

char statisticName[32];
sprintf(statisticName, "session%d-jitter", sessionNum);
<a href="../api/classomnetpp_1_1cProperty.html">cProperty</a> *statisticTemplate =
    getProperties()-&gt;get("statisticTemplate", "sessionJitter");
getEnvir()-&gt;addResultRecorders(this, signal, statisticName, statisticTemplate);
</pre>
<p>
In the <b><tt>@statisticTemplate</tt></b> property, the <tt>source</tt> key will be
ignored (because the signal given as parameter will be used as source). The
actual name and index of property will also be ignored. (With
<b><tt>@statistic</tt></b>, the index holds the result name, but here the name is
explicitly specified in the statisticName parameter.)

<p>When multiple signals are recorded using a common <b><tt>@statisticTemplate</tt></b>
property, you'll want the titles of the recorded statistics to differ
for each signal. This can be achieved by using dollar variables in the
<tt>title</tt> key of <b><tt>@statisticTemplate</tt></b>. The following variables
are available:

<p><ul>
  <li> <tt>$name</tt>: name of the statistic
  <li> <tt>$component</tt>: component fullpath
  <li> <tt>$mode</tt>: recording mode
  <li> <tt>$namePart[0-9]+</tt>: given part of statistic name, when split
    along colons (:); numbering starts with 1
</ul>

<p>For example, if the statistic name is <tt>"conn:host1-to-host4(3):bytesSent"</tt>,
and the title is <tt>"bytes sent in connection $namePart2"</tt>, it will become
<tt>"bytes sent in connection host1-to-host4(3)"</tt>.

<p>
<h3><a name="sec:simple-modules:statistic-recording-programmatically"/>4.15.4 Adding Result Filters and Recorders Programmatically<a class="headerlink" href="#sec:simple-modules:statistic-recording-programmatically" title="Permalink to this headline"></a></h3>

<p>As an alternative to <b><tt>@statisticTemplate</tt></b> and <tt>addResultRecorders()</tt>,
it is also possible to set up result recording programmatically, by creating and
attaching result filters and recorders to the desired signals.

<p><ul class="note"><b>NOTE</b><br>
It is important to know that <tt>@statistic</tt> implements warmup period 
support by including a special <i>warmup period filter</i> at the
front of the filter/recorder chain. When adding result filters and recorders
manually, you need to add this filter manually as well.
</ul>

<p>The following code example sets up recording to an output vector after
removing duplicate values, and is essentially equivalent to the following
<tt>@statistic</tt> line:

<pre class="ned">
@statistic[queueLength](source=qlen; record=vector(removeRepeats);
                        title="Queue Length"; unit=packets);
</pre>
<p>
The C++ code:

<pre class="cpp">
simsignal_t signal = registerSignal("qlen");

<a href="../api/classomnetpp_1_1cResultFilter.html">cResultFilter</a> *warmupFilter =
        <a href="../api/classomnetpp_1_1cResultFilterType.html">cResultFilterType</a>::get("warmup")-&gt;create();
<a href="../api/classomnetpp_1_1cResultFilter.html">cResultFilter</a> *removeRepeatsFilter = 
        <a href="../api/classomnetpp_1_1cResultFilterType.html">cResultFilterType</a>::get("removeRepeats")-&gt;create();
<a href="../api/classomnetpp_1_1cResultRecorder.html">cResultRecorder</a> *vectorRecorder = 
        <a href="../api/classomnetpp_1_1cResultRecorderType.html">cResultRecorderType</a>::get("vector")-&gt;create();
<a href="../api/classomnetpp_1_1opp__string__map.html">opp_string_map</a> *attrs = new <a href="../api/classomnetpp_1_1opp__string__map.html">opp_string_map</a>;
(*attrs)["title"] = "Queue Length";
(*attrs)["unit"] = "packets";
vectorRecorder-&gt;init(this, "queueLength", "vector", nullptr, attrs);

subscribe(signal, warmupFilter);
warmupFilter-&gt;addDelegate(removeRepeatsFilter);
removeRepeatsFilter-&gt;addDelegate(vectorRecorder);
</pre>
<p>

<p><h3><a name="sec:simple-modules:emitting-statistic-signals"/>4.15.5 Emitting Signals<a class="headerlink" href="#sec:simple-modules:emitting-statistic-signals" title="Permalink to this headline"></a></h3>

<p>Emitting signals for statistical purposes does not differ much from
emitting signals for any other purpose. Statistic signals are primarily
expected to contain numeric values, so the overloaded <tt>emit()</tt> functions
that take <tt>long</tt>, <tt>double</tt> and <tt>simtime_t</tt> are going to be the
most useful ones.

<p><b>Emitting with timestamp.</b> The emitted values are associated with
the current simulation time. At times it might be desirable to associate
them with a different timestamp, in much the same way as the
<tt>recordWithTimestamp()</tt> method of <tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> (see
<a href="#sec:sim-lib:coutvector">[7.9.1]</a>) does. For example, assume that you want to
emit a signal at the start of every successful wireless frame reception.
However, whether any given frame reception is going to be successful can
only be known after the reception has completed. Hence, values can only be
emitted at reception completion, and need to be associated with past
timestamps.

<p>To emit a value with a different timestamp, an object containing
a <i>(timestamp, value)</i> pair needs to be filled in, and emitted using
the <tt>emit(simsignal_t, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *)</tt> method. The class is called
<tt><a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a></tt>, and it simply has two public data members called
<tt>time</tt> and <tt>value</tt>, with types <tt>simtime_t</tt> and <tt>double</tt>.
It also has a convenience constructor taking these two values.

<p><ul class="note"><b>NOTE</b><br>
<tt><a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a></tt> is not part of the signal mechanism. Instead,
the result recording listeners provided by OMNeT++ have been written
in a way so that they understand <tt><a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a></tt>, and know how
to handle it.
</ul>

<p>An example usage:

<pre class="cpp">
simtime_t frameReceptionStartTime = ...;
double receivePower = ...;
<a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a> tmp(frameReceptionStartTime, receivePower);
emit(recvPowerSignal, &tmp);
</pre>
<p>
If performance is critical, the <tt><a href="../api/classomnetpp_1_1cTimestampedValue.html">cTimestampedValue</a></tt> object may be
made a class member or a static variable to eliminate object
construction/destruction time.<br><ul><font size=-1>[It is safe to use a static
variable here because the simulation program is single-threaded,
but ensure that there isn't a listener somewhere that would modify
the same static variable during firing.]</font></ul>

<p>Timestamps must be monotonically increasing.

<p><b>Emitting non-numeric values.</b> Sometimes it is practical to have
multi-purpose signals, or to retrofit an existing non-statistical signal so
that it can be recorded as a result. For this reason, signals having
non-numeric types (that is, <tt>const char *</tt> and <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a> *</tt>) may
also be recorded as results. Wherever such values need to be interpreted as
numbers, the following rules are used by the built-in result recording
listeners:

<p><ul>
  <li> Strings are recorded as 1.0, except for <tt>nullptr</tt> which is recorded as 0.0;
  <li> Objects that can be cast to <tt><a href="../api/classomnetpp_1_1cITimestampedValue.html">cITimestampedValue</a></tt> are recorded
     using the <tt>getSignalTime()</tt> and <tt>getSignalValue()</tt>
     methods of the class;
  <li> Other objects are recorded as 1.0, except for <tt>nullptr</tt> which is recorded as 0.0.
</ul>

<p><tt><a href="../api/classomnetpp_1_1cITimestampedValue.html">cITimestampedValue</a></tt> is a C++ interface that may be used as an additional
base class for any class. It is declared like this:

<pre class="cpp">
class <a href="../api/classomnetpp_1_1cITimestampedValue.html">cITimestampedValue</a> {
    public:
        virtual ~<a href="../api/classomnetpp_1_1cITimestampedValue.html">cITimestampedValue</a>() {}
        virtual double getSignalValue(simsignal_t signalID) = 0;
        virtual simtime_t getSignalTime(simsignal_t signalID);
};
</pre>
<p>
<tt>getSignalValue()</tt> is pure virtual (it must return some value),
but <tt>getSignalTime()</tt> has a default implementation that
returns the current simulation time. Note the <tt>signalID</tt> argument
that allows the same class to serve multiple signals (i.e. to return
different values for each).

<p>
<h3><a name="sec:simple-modules:writing-result-filters"/>4.15.6 Writing Result Filters and Recorders<a class="headerlink" href="#sec:simple-modules:writing-result-filters" title="Permalink to this headline"></a></h3>

<p>You can define your own result filters and recorders in addition to the
built-in ones. Similar to defining modules and new NED functions, you have
to write the implementation in C++, and then register it with a
registration macro to let OMNeT++ know about it. The new result filter or
recorder can then be used in the <tt>source=</tt> and <tt>record=</tt> attributes
of <b><tt>@statistic</tt></b> properties just like the built-in ones.

<p>Result filters must be subclassed from <tt><a href="../api/classomnetpp_1_1cResultFilter.html">cResultFilter</a></tt> or from one
of its more specific subclasses <tt><a href="../api/classomnetpp_1_1cNumericResultFilter.html">cNumericResultFilter</a></tt> and
<tt><a href="../api/classomnetpp_1_1cObjectResultFilter.html">cObjectResultFilter</a></tt>. The new result filter class needs to be
registered using the <tt>Register_ResultFilter(NAME, CLASSNAME)</tt> macro.

<p>Similarly, a result recorder must subclass from the
<tt><a href="../api/classomnetpp_1_1cResultRecorder.html">cResultRecorder</a></tt> or the more specific
<tt><a href="../api/classomnetpp_1_1cNumericResultRecorder.html">cNumericResultRecorder</a></tt> class, and be registered using the
<tt>Register_ResultRecorder(NAME, CLASSNAME)</tt> macro.

<p>
  <center>
    <img src="resultlistener-inheritance.svg">
    <center><div class="caption"><i>Figure: Inheritance of result filter and recorder classes</i></div></center>
  </center>

<p>
An example result filter implementation from the simulation runtime:

<p>
<pre class="cpp">
/**
 * Filter that outputs the sum of signal values divided by the measurement
 * interval (simtime minus warmup period).
 */
class <a href="../api/classomnetpp_1_1SumPerDurationFilter.html">SumPerDurationFilter</a> : public <a href="../api/classomnetpp_1_1cNumericResultFilter.html">cNumericResultFilter</a>
{
    protected:
        double sum;
    protected:
        virtual bool process(simtime_t& t, double& value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details);
    public:
        <a href="../api/classomnetpp_1_1SumPerDurationFilter.html">SumPerDurationFilter</a>() {sum = 0;}
};

Register_ResultFilter("sumPerDuration", <a href="../api/classomnetpp_1_1SumPerDurationFilter.html">SumPerDurationFilter</a>);

bool <a href="../api/classomnetpp_1_1SumPerDurationFilter.html">SumPerDurationFilter</a>::process(simtime_t& t, double& value, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *)
{
    sum += value;
    value = sum / (simTime() - getSimulation()-&gt;getWarmupPeriod());
    return true;
}
</pre>

<p>


<hr class='pgbr'><h1><a name="cha:messages"/>5 Messages and Packets<a class="headerlink" href="#cha:messages" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:msgs:overview"/>5.1 Overview<a class="headerlink" href="#sec:msgs:overview" title="Permalink to this headline"></a></h2>

<p>Messages are a central concept in OMNeT++. In the model, message objects
represent events, packets, commands, jobs, customers or other kinds of
entities, depending on the model domain.

<p>Messages are represented with the <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> class and its subclass
<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>. <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> is used for network packets (frames,
datagrams, transport packets, etc.) in a communication network, and
<tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> is used for everything else. Users are free to subclass
both <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> and <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> to create new types and to
add data.

<p><tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> has the following fields; some are used by
the simulation kernel, and others are provided for the convenience
of the simulation programmer:

<p><ul>
  <li> The <i>name</i> field is a string (<tt>const char *</tt>),
    which can be freely used by the simulation programmer. The message
    name is displayed at many places in the graphical runtime interface,
    so it is generally useful to choose a descriptive name. Message name
    is inherited from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> (see section
    <a href="#sec:sim-lib:cobject">[7.1.2]</a>).
  <li> <i>Message kind</i> is an integer field.
    Some negative values are reserved by the simulation library, but zero
    and positive values can be freely used in the model for any purpose.
    Message kind is typically used to carry a value that conveys the
    role, type, category or identity of the message.
  <li> The <i>scheduling priority</i> field is used by the simulation
    kernel to determine the delivery order of messages that have the same
    arrival time values. This field is rarely used in practice.
  <li> The <i>send time</i>, <i>arrival time</i>, <i>source module</i>,
    <i>source gate</i>, <i>destination module</i>, <i>destination gate</i>
    fields store information about the message's last sending or scheduling,
    and should not be modified from the model. These fields are primarily
    used internally by the simulation kernel while the message is in the
    future events set (FES)<!--FES-->, but the information is still in
    the message object when the message is delivered to a module.
  <li> <i>Time stamp</i> (not to be confused with <i>arrival time</i>)
    is a utility field, which the programmer can freely use for any purpose.
    The time stamp is not examined or changed by the simulation kernel at all.
  <li> The <i>parameter list</i>, <i>control info</i> and
    <i>context pointer</i> fields make some simulation tasks easier
    to program, and they will be discussed later.
</ul>

<p>The <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> class extends <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> with fields that are
useful for representing network packets:

<p><ul>
  <li> The <i>packet length</i> field represents the length of the packet
    in bits. It is used by the simulation kernel to compute the transmission
    duration when a packet travels through a connection that has an assigned
    data rate, and also for error modeling on channels with a nonzero
    bit error rate.
  <li> The <i>encapsulated packet</i> field helps modeling protocol layers
    by supporting the concept of encapsulation and decapsulation.
  <li> The <i>bit error flag</i> field carries the result of error
    modelling after the packet is sent through a channel that has a nonzero
    packet error rate (PER) or bit error rate (BER). It is up to the receiver
    to examine this flag after having received the packet, and to act upon it.
  <li> The <i>duration</i> field carries the transmission duration after
    the packet was sent through a channel with a data rate.
  <li> The <i>is-reception-start</i> flag tells whether this packet
    represents the start or the end of the reception after the packet travelled
    through a channel with a data rate. This flag is controlled by the
    <i>deliver-on-reception-start</i> flag of the receiving gate.
</ul>

<p>
<h2><a name="sec:msgs:cmessage"/>5.2 The <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> Class<a class="headerlink" href="#sec:msgs:cmessage" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:messages:cmessage-basic-usage"/>5.2.1 Basic Usage<a class="headerlink" href="#sec:messages:cmessage-basic-usage" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> constructor accepts an <i>object name</i>
and a <i>message kind</i>, both optional:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>(const char *name=nullptr, short kind=0);
</pre>
<p>
Descriptive message names can be very useful when tracing, debugging or
demonstrating the simulation, so it is recommended to use them.
Message kind is usually initialized with a symbolic constant
(e.g. an <i>enum</i> value) which signals what the message object
represents. Only positive values and zero can be used --
negative values are reserved for use by the simulation kernel.

<p>The following lines show some examples of message creation:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg1 = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>();
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg2 = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("timeout");
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg3 = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("timeout", KIND_TIMEOUT);
</pre>
<p>
Once a message has been created, its basic data members can be set
with the following methods:

<pre class="cpp">
void setName(const char *name);
void setKind(short k);
void setTimestamp();
void setTimestamp(simtime_t t);
void setSchedulingPriority(short p);
</pre>
<p>
The argument-less <tt>setTimeStamp()</tt> method is equivalent to
<tt>setTimeStamp(simTime())</tt>.

<p>The corresponding getter methods are:

<pre class="cpp">
const char *getName() const;
short getKind() const;
simtime_t getTimestamp() const;
short getSchedulingPriority() const;
</pre>
<p>
The <tt>getName()</tt>/<tt>setName()</tt> methods are inherited from
a generic base class in the simulation library, <tt><a href="../api/classomnetpp_1_1cNamedObject.html">cNamedObject</a></tt>.

<p>Two more interesting methods:

<pre class="cpp">
bool isPacket() const;
simtime_t getCreationTime() const;
</pre>
<p>
The <tt>isPacket()</tt> method returns <tt>true</tt> if the particular message
object is a subclass of <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>, and <tt>false</tt> otherwise. As
<tt>isPacket()</tt> is implemented as a virtual function that just contains
a <tt>return false</tt> or a <tt>return true</tt> statement, it might be faster
than calling <tt>dynamic_cast&lt;<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>*&gt;</tt>.

<p>The <tt>getCreationTime()</tt> method returns the creation time of the
message. It is worthwhile to mention that with cloned messages (see
<tt>dup()</tt> later), the creation time of the original message is returned
and not the time of the cloning operation. This is particularly useful when
modeling communication protocols, because many protocols clone the
transmitted packages to be able to do retransmissions and/or
segmentation/reassembly.

<p>
<h3><a name="sec:messages:duplicating-messages"/>5.2.2 Duplicating Messages<a class="headerlink" href="#sec:messages:duplicating-messages" title="Permalink to this headline"></a></h3>
<!--message!duplication-->

<p>It is often necessary to duplicate a message or a packet, for example,
to send one and keep a copy. Duplication can be done in the same way as
for any other OMNeT++ object:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *copy = msg-&gt;dup();
</pre>
<p>
The resulting message (or packet) will be an exact copy of the original
including message parameters and encapsulated messages, except for the
message ID field. The creation time field is also copied, so
for cloned messages <tt>getCreationTime()</tt> will return the creation
time of the original, not the time of the cloning operation.
  <br><ul><font size=-1>[Note, however, that the simulation library may delay the
  duplication of the encapsulated message until it is really needed;
  see section <a href="#sec:messages:reference-counting">[5.4.5]</a>.]</font></ul>

<p>When subclassing <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> or <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>, one needs
to reimplement <tt>dup()</tt>. The recommended implementation is to delegate
to the copy constructor of the new class:

<pre class="cpp">
class FooMessage : public <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> {
  public:
    FooMessage(const FooMessage& other) {...}
    virtual FooMessage *dup() const {return new FooMessage(*this);}
    ...
};
</pre>
<p>
For generated classes (chapter <a href="#cha:msg-def">[6]</a>), this is
taken care of automatically.

<p>
<h3><a name="sec:messages:message-ids"/>5.2.3 Message IDs<a class="headerlink" href="#sec:messages:message-ids" title="Permalink to this headline"></a></h3>
<!--message!IDs-->

<p>Every message object has a unique numeric <i>message ID</i>. It is normally
used for identifying the message in a recorded event log file, but may occasionally
be useful for other purposes as well. When a message is cloned (<tt>msg-&gt;dup()</tt>),
the clone will have a different ID.

<p>There is also another ID called <i>tree ID</i>. The tree ID is initialized
to the message ID. However, when a message is cloned, the clone will retain
the tree ID of the original. Thus, messages that have been created by cloning
the same message or its clones will have the same tree ID.  Message IDs are
of the type <tt>long</tt>, which is is usually enough so that IDs remain unique
during the simulation run (i.e. the counter does not wrap).

<p>The methods for obtaining message IDs:

<pre class="cpp">
long getId() const;
long getTreeId() const;
</pre>
<p>

<p><h3><a name="sec:messages:control-info"/>5.2.4 Control Info<a class="headerlink" href="#sec:messages:control-info" title="Permalink to this headline"></a></h3>

<p>One of the main application areas of OMNeT++ is the simulation of
telecommunication networks. Here, protocol layers are usually
implemented as modules which exchange packets. Packets themselves
are represented by messages subclassed from <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>.

<p>However, communication between protocol layers requires sending
additional information to be attached to packets. For example,
a TCP implementation sending down a TCP packet to IP will want
to specify the destination IP address and possibly
other parameters. When IP passes up a packet to TCP after
decapsulation from the IP header, it will want to let TCP know
at least the source IP address.

<p>This additional information is represented by <i>control info</i> objects
in OMNeT++. Control info objects have to be subclassed from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>
(a small footprint base class with no data members), and can be attached to
any message. <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> has the following methods for this purpose:

<pre class="cpp">
void setControlInfo(<a href="../api/classomnetpp_1_1cObject.html">cObject</a> *controlInfo);
<a href="../api/classomnetpp_1_1cObject.html">cObject</a> *getControlInfo() const;
<a href="../api/classomnetpp_1_1cObject.html">cObject</a> *removeControlInfo();
</pre>
<p>
When a "command" is associated with the message sending (such as
TCP OPEN, SEND, CLOSE, etc), the message kind field (<tt>getKind()</tt>,
<tt>setKind()</tt> methods of <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>) should carry the command code.
When the command doesn't involve a data packet (e.g.
TCP CLOSE command), a dummy packet (empty <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>) can be sent.

<p>An object set as control info via <tt>setControlInfo()</tt> will be owned
by the message object. When the message is deallocated, the control
info object is deleted as well.

<p>
<h3><a name="sec:messages:information-about-last-arrival"/>5.2.5 Information About the Last Arrival<a class="headerlink" href="#sec:messages:information-about-last-arrival" title="Permalink to this headline"></a></h3>

<p>The following methods return the sending and arrival times that correspond
to the last sending of the message.

<pre class="cpp">
simtime_t getSendingTime() const;
simtime_t getArrivalTime() const;
</pre>
<p>
The following methods can be used to determine where the message came from
and which gate it arrived on (or will arrive if it is currently scheduled
or under way.) There are two sets of methods, one returning module/gate Ids,
and the other returning pointers.

<pre class="cpp">
int getSenderModuleId() const;
int getSenderGateId() const;
int getArrivalModuleId() const;
int getArrivalGateId() const;
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *getSenderModule() const;
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *getSenderGate() const;
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *getArrivalModule() const;
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *getArrivalGate() const;
</pre>
<p>
There are further convenience functions to tell whether
the message arrived on a specific gate given with id or
with name and index.

<pre class="cpp">
bool arrivedOn(int gateId) const;
bool arrivedOn(const char *gatename) const;
bool arrivedOn(const char *gatename, int gateindex) const;
</pre>
<p>

<p><h3><a name="sec:messages:displaystring"/>5.2.6 Display String<a class="headerlink" href="#sec:messages:displaystring" title="Permalink to this headline"></a></h3>

<p><i>Display strings</i> affect the message's visualization in graphical
user interfaces like Tkenv and Qtenv. Message objects do not store a
display string by default, but contain a <tt>getDisplayString()</tt> method
that can be overridden in subclasses to return the desired string.  The
method:

<pre class="cpp">
const char *getDisplayString() const;
</pre>
<p>
Since OMNeT++ version 5.1, <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>'s default <tt>getDisplayString()</tt>
implementation is such so that a packet &#8220;inherits&#8221; the display string of its
encapsulated packet, provided it has one. Thus, in the model of a network stack,
the appearance of e.g. an application layer packet will be preserved even
after multiple levels of encapsulation.

<p>See section <a name="sec:graphics:message-displaystrings"></a> for
more information on message display string syntax and possibilities.

<p>

<p><h2><a name="sec:msgs:self-messages"/>5.3 Self-Messages<a class="headerlink" href="#sec:msgs:self-messages" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:messages:using-message-as-self-message"/>5.3.1 Using a Message as Self-Message<a class="headerlink" href="#sec:messages:using-message-as-self-message" title="Permalink to this headline"></a></h3>

<p>Messages are often used to represent events internal to a module,
such as a periodically firing timer to represent expiry of a timeout.
A message is termed <i>self-message</i> when it is used
in such a scenario -- otherwise self-messages are normal messages
of class <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> or a class derived from it.

<p>When a message is delivered to a module by the simulation kernel, the
<tt>isSelfMessage()</tt> method can be used to determine if it is
a self-message; that is, whether it was scheduled with <tt>scheduleAt()</tt>,
or sent with one of the <tt>send...()</tt> methods. The <tt>isScheduled()</tt>
method returns true if the message is currently scheduled. A scheduled
message can also be cancelled (<tt>cancelEvent()</tt>).

<pre class="cpp">
bool isSelfMessage() const;
bool isScheduled() const;
</pre>
<p>
The methods <tt>getSendingTime()</tt> and <tt>getArrivalTime()</tt> are also
useful with self-messages: they return the time the message was scheduled
and arrived (or will arrive; while the message is scheduled, arrival time
is the time it will be delivered to the module).

<p>
<h3><a name="sec:messages:context-pointer"/>5.3.2 <a href="../api/classomnetpp_1_1cExpression_1_1Context.html">Context</a> Pointer<a class="headerlink" href="#sec:messages:context-pointer" title="Permalink to this headline"></a></h3>

<p><tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> contains a <i>context pointer</i> of type <tt>void*</tt>,
which can be accessed by the following functions:

<pre class="cpp">
void setContextPointer(void *p);
void *getContextPointer() const;
</pre>
<p>
The context pointer can be used for any purpose by the simulation programmer.
It is not used by the simulation kernel, and it is treated as
a mere pointer (no memory management is done on it).

<p>Intended purpose: a module which schedules several self-messages (timers)
will need to identify a self-message when it arrives back to the module,
ie. the module will have to determine which timer went off and what to do
then. The context pointer can be made to point at a data structure kept by
the module which can carry enough &#8220;context&#8221; information about the event.

<p>

<p><h2><a name="sec:msgs:cpacket"/>5.4 The <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> Class<a class="headerlink" href="#sec:msgs:cpacket" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:messages:cpacket-basic-usage"/>5.4.1 Basic Usage<a class="headerlink" href="#sec:messages:cpacket-basic-usage" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> constructor is similar to the <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>
constructor, but it accepts an additional <i>bit length</i> argument:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>(const char *name=nullptr, short kind=0, int64 bitLength=0);
</pre>
<p>
The most important field <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> has over <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> is
the message length. This field is kept in bits, but it can also be
set/get in bytes. If the bit length is not a multiple of eight, the
<tt>getByteLength()</tt> method will round it up.

<pre class="cpp">
void setBitLength(int64_t l);
void setByteLength(int64_t l);
void addBitLength(int64_t delta);
void addByteLength(int64_t delta);
int64_t getBitLength() const;
int64_t getByteLength() const;
</pre>
<p>
Another extra field is the bit error flag. It can be accessed with the
following methods:

<pre class="cpp">
void setBitError(bool e);
bool hasBitError() const;
</pre>
<p>

<p><h3><a name="sec:messages:identifying-protocol-of-packet"/>5.4.2 Identifying the Protocol<a class="headerlink" href="#sec:messages:identifying-protocol-of-packet" title="Permalink to this headline"></a></h3>

<p>In OMNeT++ protocol models, the protocol type is usually represented in the
message subclass. For example, instances of class <tt>IPv6Datagram</tt>
represent IPv6 datagrams and <tt>EthernetFrame</tt> represents Ethernet
frames. The C++ <tt>dynamic_cast</tt> operator can be used to determine if a
message object is of a specific protocol.

<p>An example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg = receive();
if (dynamic_cast&lt;IPv6Datagram *&gt;(msg) != nullptr)
{
    IPv6Datagram *datagram = (IPv6Datagram *)msg;
    ...
}
</pre>
<p>

<p><h3><a name="sec:messages:information-about-last-transmission"/>5.4.3 Information About the Last Transmission<a class="headerlink" href="#sec:messages:information-about-last-transmission" title="Permalink to this headline"></a></h3>

<p>When a packet has been received, some information can be obtained
about the transmission, namely the <i>transmission duration</i>
and the <i>is-reception-start</i> flag. They are returned by
the following methods:

<pre class="cpp">
simtime_t getDuration() const;
bool isReceptionStart() const;
</pre>
<p>

<p><h3><a name="sec:messages:encapsulating-packets"/>5.4.4 Encapsulating Packets<a class="headerlink" href="#sec:messages:encapsulating-packets" title="Permalink to this headline"></a></h3>

<p>When modeling layered protocols of computer networks, it is commonly
needed to encapsulate a packet<!--packet!encapsulation--> into another.
The following <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> methods are associated with encapsulation:

<pre class="cpp">
void encapsulate(<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *packet);
<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *decapsulate();
<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *getEncapsulatedPacket() const;
</pre>
<p>
The <tt>encapsulate()</tt> function encapsulates a packet into another one.
The length of the packet will grow by the length of the encapsulated
packet. An exception: when the encapsulating (outer) packet has zero
length, OMNeT++ assumes it is not a real packet but an out-of-band signal,
so its length is left at zero.

<p>A packet can only hold one encapsulated packet at a time; the second
<tt>encapsulate()</tt> call will result in an error. It is also an error if
the packet to be encapsulated is not owned by the module.

<p>Decapsulation, that is, removing the encapsulated packet, is done by the
<tt>decapsulate()</tt> method. <tt>decapsulate()</tt> will decrease the
length of the packet accordingly, except if it was zero. If the length
would become negative, an error occurs.

<p>The <tt>getEncapsulatedPacket()</tt> function returns a pointer to the
encapsulated packet, or <tt>nullptr</tt> if no packet is encapsulated.

<p>Example usage:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *data = new <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>("data");
data-&gt;setByteLength(1024);

UDPPacket *udp = new UDPPacket("udp"); // subclassed from <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>
udp-&gt;setByteLength(8);

udp-&gt;encapsulate(data);
EV &lt;&lt; udp-&gt;getByteLength() &lt;&lt; endl; // --&gt; 8+1024 = 1032
</pre>
<p>
And the corresponding decapsulation code:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *payload = udp-&gt;decapsulate();
</pre>
<p>

<p>
<h3><a name="sec:messages:reference-counting"/>5.4.5 Reference Counting<a class="headerlink" href="#sec:messages:reference-counting" title="Permalink to this headline"></a></h3>

<p>Since the 3.2 release, OMNeT++ implements reference counting of encapsulated
packets, meaning that when a packet containing an encapsulated packet is
cloned (<tt>dup()</tt>), the encapsulated packet will not be duplicated,
only a reference count is incremented. Duplication of
the encapsulated packet is deferred until <tt>decapsulate()</tt>
actually gets called. If the outer packet is deleted without its
<tt>decapsulate()</tt> method ever being called, then the reference
count of the encapsulated packet is simply decremented. The
encapsulated packet is deleted when its reference count reaches
zero.

<p>Reference counting can significantly improve performance, especially
in LAN and wireless scenarios. For example, in the simulation of a
broadcast LAN or WLAN, the IP, TCP and higher layer packets won't
be duplicated (and then discarded without being used) if the
MAC address doesn't match in the first place.

<p>The reference counting mechanism works transparently. However, there
is one implication: <b>one must not change anything in a packet
that is encapsulated into another!</b> That is,
<tt>getEncapsulatedPacket()</tt> should be viewed as if it returned a
pointer to a read-only object (it returns a <tt>const</tt> pointer
indeed), for quite obvious reasons: the encapsulated packet may be
shared between several packets, and any change would affect those
other packets as well.

<p>
<h3><a name="sec:messages:encapsulating-several-packets"/>5.4.6 Encapsulating Several Packets<a class="headerlink" href="#sec:messages:encapsulating-several-packets" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> class does not directly support encapsulating more
than one packet, but one can subclass <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> or <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>
to add the necessary functionality.

<p>Encapsulated packets can be stored in a fixed-size or a dynamically
allocated array, or in a standard container like <tt>std::vector</tt>.
In addition to storage, object ownership needs to be taken care of as well.
The message class has to <b>take ownership</b> of the inserted messages, and
<b>release</b> them when they are removed from the message. These tasks are
done via the <tt>take()</tt> and <tt>drop()</tt> methods.

<p>Here is an example that assumes that the class has an <tt>std::list</tt> member
called <tt>messages</tt> for storing message pointers:

<pre class="cpp">
void MultiMessage::insertMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    take(msg);  // take ownership
    messages.push_back(msg);  // store pointer
}

void MultiMessage::removeMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    messages.remove(msg);  // remove pointer
    drop(msg);  // release ownership
}
</pre>
<p>
One also needs to provide an <tt>operator=()</tt> method to make sure that
message objects are copied and duplicated properly. Section
<a href="#sec:sim-lib:deriving-new-classes">[7.12]</a> covers requirements and conventions
associated with deriving new classes in more detail.

<p>

<p><h2><a name="sec:msgs:attaching-objects"/>5.5 Attaching Objects To a Message<a class="headerlink" href="#sec:msgs:attaching-objects" title="Permalink to this headline"></a></h2>

<p>When parameters or objects need to be added to a message, the preferred
way to do that is via message definitions, described in chapter
<a href="#cha:msg-def">[6]</a>.

<p>
<h3><a name="sec:messages:attaching-objects"/>5.5.1 Attaching Objects<a class="headerlink" href="#sec:messages:attaching-objects" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> class has an internal <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> object which
can carry objects. Only objects that are derived from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> can
be attached. The <tt>addObject()</tt>, <tt>getObject()</tt>,
<tt>hasObject()</tt>, <tt>removeObject()</tt> methods use the object's name
(as returned by the <tt>getName()</tt> method) as the key to the array.

<p>An example where the sender attaches an object, and the receiver
checks for the object's existence and obtains a pointer to it:

<pre class="cpp">
// sender:
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> *histogram = new <a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a>("histogram");
msg-&gt;addObject(histogram);

// receiver:
if (msg-&gt;hasObject("histogram")) {
   <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *obj = msg-&gt;getObject("histogram");
   <a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> *histogram = check_and_cast&lt;<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> *&gt;(obj);
   ...
}
</pre>
<p>
One needs to take care that names of the attached objects don't
conflict with each other. Note that message parameters (<tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt>,
see next section) are also attached the same way, so their names
also count.

<p>When no objects are attached to a message (and <tt>getParList()</tt> is not
invoked), the internal <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> object is not created.
This saves both storage and execution time.

<p>Non-<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> data can be attached to messages by wrapping them into
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>, for example into <tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt> which has been designed
expressly for this purpose. <tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt> will be covered in the next
section.

<p><h3><a name="sec:messages:attaching-parameters"/>5.5.2 Attaching Parameters<a class="headerlink" href="#sec:messages:attaching-parameters" title="Permalink to this headline"></a></h3>

<p>The preferred way of extending messages with new data fields is to use
message definitions (see chapter <a href="#cha:msg-def">[6]</a>).

<p>The old, deprecated way of adding new fields to messages is via
attaching <tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt> objects.
There are several downsides of this approach, the worst being
large memory and execution time overhead. <tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt>'s are
heavy-weight and fairly complex objects themselves.
It has been reported that using <tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt> message parameters
might account for a large part of execution time, sometimes as much as 80%.
Using <tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt> is also error-prone because <tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt> objects
have to be added dynamically and individually to each message object.
In contrast, subclassing benefits from static type checking:
if one mistypes the name of a field in the C++ code, the compiler
can detect the mistake.

<p>If one still needs <tt><a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a></tt>s for some reason, here is a short summary.
At the sender side, one can add a new named parameter to the message
with the <tt>addPar()</tt> member function, then set its value with
one of the methods <tt>setBoolValue()</tt>, <tt>setLongValue()</tt>,
<tt>setStringValue()</tt>, <tt>setDoubleValue()</tt>, <tt>setPointerValue()</tt>,
<tt>setObjectValue()</tt>, and <tt>setXMLValue()</tt>. There are also overloaded
assignment operators for the corresponding C/C++ types.

<p>At the receiver side, one can look up the parameter object on the message
by name and obtain a reference to it with the <tt>par()</tt> member function.
<tt>hasPar()</tt> can be used to check first whether the message object has a parameter
object with the given name. Then the value can be read with the methods
<tt>boolValue()</tt>, <tt>longValue()</tt>, <tt>stringValue()</tt>,
<tt>doubleValue()</tt>, <tt>pointerValue()</tt>, <tt>objectValue()</tt>,
<tt>xmlValue()</tt>, or by using the provided overloaded type cast operators.

<p>Example usage:

<pre class="cpp">
msg-&gt;addPar("destAddr");
msg-&gt;par("destAddr").setLongValue(168);
...
long destAddr = msg-&gt;par("destAddr").longValue();
</pre>
<p>
Or, using overloaded operators:

<pre class="cpp">
msg-&gt;addPar("destAddr");
msg-&gt;par("destAddr") = 168;
...
long destAddr = msg-&gt;par("destAddr");
</pre>
<p>
<hr class='pgbr'><h1><a name="cha:msg-def"/>6 Message Definitions<a class="headerlink" href="#cha:msg-def" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:msg-defs:intro"/>6.1 Introduction<a class="headerlink" href="#sec:msg-defs:intro" title="Permalink to this headline"></a></h2>

<p>In practice, one needs to add various fields to <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> or
<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> to make them useful. For example, when modeling
communication networks, message/packet objects need to carry protocol
header fields. Since the simulation library is written in C++, the natural
way of extending <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>/<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> is via subclassing
them. However, at least three items has to be added to the new class for
each field (a private data member, a getter and a setter method) and the
resulting class needs to integrate with the simulation framework, which
means that writing the necessary C++ code can be a tedious and
time-consuming task.

<p>OMNeT++ offers a more convenient way called <i>message definitions</i>.
Message definitions offer a compact syntax to describe message contents,
and the corresponding C++ code is automatically generated from the
definitions. When needed, the generated class can also be customized via
subclassing. Even when the generated class needs to be heavily customized,
message definitions can still save the programmer a great deal of manual
work.

<p>
<h3><a name="sec:msg-defs:first-msg-class"/>6.1.1 The First Message Class<a class="headerlink" href="#sec:msg-defs:first-msg-class" title="Permalink to this headline"></a></h3>

<p>Let us begin with a simple example. Suppose that you need a packet class that
carries source and destination addresses as well as a hop count. You may then
write a <tt>MyPacket.msg</tt> file with the following contents:

<pre class="msg">
packet MyPacket
{
     int srcAddress;
     int destAddress;
     int remainingHops = 32;
};
</pre>
<p>
It is the task of the <i>message compiler</i> to generate C++ classes
that can be instantiated from C++ model code. The message compiler is
normally invoked automatically for <tt>.msg</tt> files during build.

<p>When the message compiler processes <tt>MyPacket.msg</tt>, it creates the
following files: <tt>MyPacket_m.h</tt> and <tt>MyPacket_m.cc</tt>. The
generated <tt>MyPacket_m.h</tt> will contain the following class declaration:

<pre class="cpp">
class MyPacket : public <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
</pre>
<p>
In order to use the <tt>MyPacket</tt> class from a C++ source file, the
generated header file needs to be included:

<pre class="cpp">
#include "MyPacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt-&gt;setSrcAddress(localAddr);
...
</pre>
<p>
The <tt>MyPacket_m.cc</tt> file will contain implementation of the generated
<tt>MyPacket</tt> class as well as &#8220;reflection&#8221; code that allows inspection of
these data structures under graphical user interfaces like Qtenv. The
<tt>MyPacket_m.cc</tt> file should be compiled and linked into the simulation;
this is normally taken care of automatically.

<p>The following sections describe the message syntax and features in detail.

<p>

<p><h2><a name="sec:msg-defs:messages-and-packets"/>6.2 Messages and Packets<a class="headerlink" href="#sec:msg-defs:messages-and-packets" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:msg-defs:defining-messages-and-packets"/>6.2.1 Defining Messages and Packets<a class="headerlink" href="#sec:msg-defs:defining-messages-and-packets" title="Permalink to this headline"></a></h3>

<p>Message and packet contents can be defined in a syntax resembling C structs.
The keyword can be <b><tt>message</tt></b> or <b><tt>packet</tt></b>; they cause
the generated C++ class to be derived from <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> and
<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>, respectively. (Further keywords, <b><tt>class</tt></b> and
<b><tt>struct</tt></b>, will be covered later.)

<p>An example packet definition:

<pre class="msg">
packet FooPacket
{
    int sourceAddress;
    int destAddress;
    bool hasPayload;
};
</pre>
<p>
Saving the above code into a <tt>FooPacket.msg</tt> file and processing it
with the message compiler, <tt>opp_msgc</tt>, will produce the files
<tt>FooPacket_m.h</tt> and <tt>FooPacket_m.cc</tt>. The header file will
contain the declaration of the generated C++ class.

<p>The generated class will have a constructor that optionally accepts object
name and message kind, and also a copy constructor. An assignment operator
(<tt>operator=()</tt>) and cloning method (<tt>dup()</tt>) will also be
generated.

<pre class="cpp">
class FooPacket : public <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>
{
  public:
    FooPacket(const char *name=nullptr, int kind=0);
    FooPacket(const FooPacket& other);
    FooPacket& operator=(const FooPacket& other);
    virtual FooPacket *dup() const;
    ...
</pre>
<p>
For each field in the above description, the generated class will have a
protected data member, and a public getter and setter method. The names of
the methods will begin with <tt>get</tt> and <tt>set</tt>, followed by the field
name with its first letter converted to uppercase. Thus, <tt>FooPacket</tt>
will contain the following methods:

<pre class="cpp">
    virtual int getSourceAddress() const;
    virtual void setSourceAddress(int sourceAddress);
    virtual int getDestAddress() const;
    virtual void setDestAddress(int destAddress);
    virtual bool getHasPayload() const;
    virtual void setHasPayload(bool hasPayload);
</pre>
<p>
Note that the methods are all declared <b><tt>virtual</tt></b> to allow overriding them.

<p>String fields can also be declared:

<pre class="msg">
packet HttpRequestMessage
{
    string method; // "GET", "POST", etc.
    string resource;
};
</pre>
<p>
The generated getter and setter methods will return and accept <tt>const char*</tt>
pointers:

<pre class="cpp">
virtual const char *getMethod() const;
virtual void setMethod(const char *method);
virtual const char *getResource() const;
virtual void setResource(const char *resource);
</pre>
<p>
The generated object will have its own copy of the string, so it not only stores
the <tt>const char*</tt> pointer.

<p>
<h3><a name="sec:msg-defs:field-data-types"/>6.2.2 Field Data Types<a class="headerlink" href="#sec:msg-defs:field-data-types" title="Permalink to this headline"></a></h3>

<p>Data types for fields are not limited to <b><tt>int</tt></b> and
<b><tt>bool</tt></b>. Several C/C++ and other data types can be used:

<p><ul>
   <li> logical: <b><tt>bool</tt></b>
   <li> integral types: <b><tt>char</tt></b>, <b><tt>short</tt></b>, <b><tt>int</tt></b>,
      <b><tt>long</tt></b>; and their unsigned versions <b><tt>unsigned char</tt></b>,
      <b><tt>unsigned short</tt></b>, <b><tt>unsigned int</tt></b>, <b><tt>unsigned long</tt></b>
   <li> floating-point types: <b><tt>float</tt></b>, <b><tt>double</tt></b>
   <li> C99-style fixed-size integral types: <b><tt>int8_t</tt></b>, <b><tt>int16_t</tt></b>,
      <b><tt>int32_t</tt></b>, <b><tt>int64_t</tt></b>; and their unsigned versions
      <b><tt>uint8_t</tt></b>, <b><tt>uint16_t</tt></b>, <b><tt>uint32_t</tt></b>, <b><tt>uint64_t</tt></b>;
      <br><ul><font size=-1>[These type names are accepted without the <tt>_t</tt> suffix as well,
      but you are responsible to ensure that the generated code compiles, i.e. the
      shortened type names must be defined in a header file you include.]</font></ul>
   <li> OMNeT++ simulation time: <b><tt>simtime_t</tt></b>
   <li> <b><tt>string</tt></b>. Getters and setters use the <tt>const char*</tt> data type;
      <tt>nullptr</tt> is not allowed. The object will store a copy of the string,
      not just the pointer.
   <li> structs and classes, defined in message files or elsewhere (see
      in later sections <a href="#sec:msg-defs:other-types-as-fields">[6.2.7]</a>
      and <a href="#sec:msg-defs:using-cpp-types">[6.6]</a>)
   <li> typedef'd names declared in C++ and announced to the message compiler
)
</ul>

<p>Numeric fields are initialized to zero, booleans to <tt>false</tt>, and string
fields to empty string.

<p>
<h3><a name="sec:msg-defs:initial-values"/>6.2.3 Initial Values<a class="headerlink" href="#sec:msg-defs:initial-values" title="Permalink to this headline"></a></h3>

<p>Initial values for fields can be specified after an equal sign, like so:

<pre class="msg">
packet RequestPacket
{
    int version = HTTP_VERSION;
    string method = "GET";
    string resource = "/";
    int maxBytes = 100*1024*1024; // 100MiB
    bool keepAlive = true;
};
</pre>
<p>
Macros and expressions are also accepted as initalizer values, as the code
above demonstrates. The message compiler does not check the syntax of the
values, it merely copies them into the generated C++ file. If there are
errors in them, they will be reported by the C++ compiler.

<p>Field initialization statements will be placed into the constructor of the
generated class.

<p>
<h3><a name="sec:msg-defs:enums"/>6.2.4 Enums<a class="headerlink" href="#sec:msg-defs:enums" title="Permalink to this headline"></a></h3>

<p>Using a <b><tt>@enum</tt></b> property, a field of the type <b><tt>int</tt></b> or any
other integral type can be declared to take its value from an enum. The
message compiler will then generate code that allows graphical user
interfaces display the symbolic value of the field.

<p>Example:

<pre class="msg">
packet FooPacket
{
    int payloadType @enum(PayloadType);
};
</pre>
<p>
The enum itself has to be declared separately. An enum is declared with
the <b><tt>enum</tt></b> keyword, using the following syntax:

<pre class="msg">
enum PayloadType
{
   NONE = 0;
   UDP = 1;
   TCP = 2;
   SCTP = 3;
};
</pre>
<p>
Enum values need to be unique.

<p>The message compiler translates an enum into a normal C++ enum, plus
creates an object which stores text representations of the constants. The
latter makes it possible for Tkenv and Qtenv to display symbolic names.

<p>If the enum to be associated with a field comes from a different message file,
then the enum must be announced and its generated header file be included.
An example:

<pre class="msg">
cplusplus {{
#include "PayloadType_m.h"
}}

enum PayloadType;

packet FooPacket
{
    int payloadType @enum(PayloadType);
};
</pre>
<p>

<p>
<h3><a name="sec:msg-defs:fixed-size-arrays"/>6.2.5 Fixed-Size Arrays<a class="headerlink" href="#sec:msg-defs:fixed-size-arrays" title="Permalink to this headline"></a></h3>

<p>Fixed-size arrays can be declared with the usual syntax of putting the
array size in square brackets after the field name:

<pre class="msg">
packet SourceRoutedPacket
{
    int route[4];
};
</pre>
<p>
The generated getter and setter methods will have an extra <tt>k</tt> argument,
the array index:

<pre class="cpp">
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
</pre>
<p>
When these methods are called with an index that is out of bounds, an
exception will be thrown.

<p>
<h3><a name="sec:msg-defs:variable-size-arrays"/>6.2.6 Variable-Size Arrays<a class="headerlink" href="#sec:msg-defs:variable-size-arrays" title="Permalink to this headline"></a></h3>

<p>If the array size is not known in advance, the field can be declared
to have a variable size by using an empty pair in brackets:

<pre class="msg">
packet SourceRoutedPacket
{
    int route[];
};
</pre>
<p>
In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

<pre class="cpp">
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
</pre>
<p>
The <tt>set...ArraySize()</tt> method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

<p>The default array size is zero. This means that <tt>set...ArraySize(n)</tt> needs
to be called before one can start filling array elements.

<p>
<h3><a name="sec:msg-defs:other-types-as-fields"/>6.2.7 Classes and Structs as Fields<a class="headerlink" href="#sec:msg-defs:other-types-as-fields" title="Permalink to this headline"></a></h3>

<p>In addition to primitive types, classes, structs and their typedefs may
also be used as fields. For example, given a class named <tt>IPAddress</tt>,
one can write the following:

<pre class="msg">
packet IPPacket
{
    int version = 4;
    IPAddress src;
    IPAddress dest;
};
</pre>
<p>
The <tt>IPAddress</tt> type must be known to the message compiler, and
also at compile time to the C++ compiler; section
<a href="#sec:msg-defs:using-cpp-types">[6.6]</a> will describe how to achieve that.

<p>The generated class will contain <tt>IPAddress</tt> data members
(that is, not pointers to <tt>IPAddress</tt> objects), and
the following getter and setter methods will be generated for them:

<pre class="cpp">
virtual IPAddress& getSrc();
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);

virtual IPAddress& getDest();
virtual const IPAddress& getDest() const;
virtual void setDest(const IPAddress& dest);
</pre>
<p>

<p><h3><a name="sec:msg-defs:pointers-fields"/>6.2.8 Pointer Fields<a class="headerlink" href="#sec:msg-defs:pointers-fields" title="Permalink to this headline"></a></h3>

<p>Pointer fields where the setters and the destructor would delete the
previous value are not supported yet. However, there are workarounds, as
described below.

<p>You can create a typedef for the pointer and use the typedef name as field
type. Then you'll get a plain pointer field where neither the setter nor
the destructor deletes the old value (which is a likely memory leak).

<p>Example (section <a href="#sec:msg-defs:using-cpp-types">[6.6]</a> will explain the
details):

<pre class="msg">
cplusplus {{ typedef Foo *FooPtr; }} // C++ typedef
class noncobject FooPtr; // announcement for the message compiler

packet Bar
{
    FooPtr fooPtr;  // leaky pointer field
};
</pre>
<p>
Then you can customize the class via C++ inheritance and reimplement
the setter methods in C++, inserting the missing <tt>delete</tt> statements.
Customization via C++ inheritance will be described in section
<a href="#sec:msg-defs:customizing-via-inheritance">[6.7.2]</a>.

<p>
<h3><a name="sec:msg-defs:inheritance"/>6.2.9 Inheritance<a class="headerlink" href="#sec:msg-defs:inheritance" title="Permalink to this headline"></a></h3>

<p>By default, messages are subclassed from <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> or
<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>. However, you can explicitly specify the base class using
the <b><tt>extends</tt></b> keyword (only single inheritance is supported):

<pre class="msg">
packet Ieee80211DataFrame extends Ieee80211Frame
{
    ...
};
</pre>
<p>
For the example above, the generated C++ code will look like this:

<pre class="cpp">
// generated C++
class Ieee80211DataFrame : public Ieee80211Frame {
    ...
};
</pre>
<p>

<p><h3><a name="sec:msg-defs:assignment-of-inherited-fields"/>6.2.10 Assignment of Inherited Fields<a class="headerlink" href="#sec:msg-defs:assignment-of-inherited-fields" title="Permalink to this headline"></a></h3>

<p>Message definitions allow for changing the initial value of an inherited
field. The syntax is similar to that of a field definition with initial
value, only the data type is missing.

<p>An example:

<pre class="msg">
packet Ieee80211Frame
{
    int frameType;
    ...
};

packet Ieee80211DataFrame extends Ieee80211Frame
{
    frameType = DATA_FRAME;  // assignment of inherited field
    ...
};
</pre>
<p>
It may seem like the message compiler would need the definition of the base
class to check the definition of the field being assigned. However, it is
not the case. The message compiler trusts that such field exists; or
rather, it leaves the check to the C++ compiler.

<p>What the message compiler actually does is derives a setter method name
from the field name, and generates a call to it into the constructor.
Thus, the generated constructor for the above packet type would be
something like this:

<pre class="cpp">
Ieee80211DataFrame::Ieee80211DataFrame(const char *name, int kind) :
    Ieee80211Frame(name, kind)
{
    this-&gt;setFrameType(DATA_FRAME);
    ...
}
</pre>
<p>
This implementation also lets one initialize <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> /
<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> fields such as message kind or packet length:

<pre class="msg">
packet UDPPacket
{
    byteLength = 16;  // results in 'setByteLength(16);' being placed into ctor
};
</pre>
<p>

<p>
<h2><a name="sec:msg-defs:defining-classes"/>6.3 Classes<a class="headerlink" href="#sec:msg-defs:defining-classes" title="Permalink to this headline"></a></h2>

<p>Until now we have only seen message and packet descriptions, which generate
classes derived from <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> or <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt>. However, it is
also useful to be able to generate classes and structs, for building blocks
for messages, as control info objects (see <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>'s
<tt>setControlInfo()</tt> and for other purposes. This section covers
classes; structs will be described in the next section.

<p>The syntax for defining classes is almost the same as defining messages,
only the <b><tt>class</tt></b> keyword is used instead of <b><tt>message</tt></b> /
<b><tt>packet</tt></b>. The base class can be specified with the <b><tt>extends</tt></b>
keyword, and defaults to <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.

<p><ul class="note"><b>NOTE</b><br>
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> has no data members. It only defines virtual methods, so
the only overhead would be the <i>vptr</i>; however, the generated class already has
a vptr because the generated methods are also virtual. In other words,
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> adds zero overhead to the generated class, and there is no
reason not to always use it as base class.
</ul>

<p>Examples:

<pre class="msg">
class TCPCommand  // same as "extends <a href="../api/classomnetpp_1_1cObject.html">cObject</a>"
{
    ...
};

class TCPOpenCommand extends TCPCommand
{
    ...
};
</pre>
<p>
The generated code:

<pre class="cpp">
// generated C++
class TCPCommand : public <a href="../api/classomnetpp_1_1cObject.html">cObject</a>
{
    ...
};

class TCPOpenCommand : public TCPCommand
{
    ...
};
</pre>
<p>

<p><h2><a name="sec:msg-defs:defining-structs"/>6.4 Structs<a class="headerlink" href="#sec:msg-defs:defining-structs" title="Permalink to this headline"></a></h2>

<p>Message definitions allow one to define C-style structs, &#8220;C-style&#8221;
meaning &#8220;containing only data and no methods&#8221;. These structs can be
useful as fields in message classes.

<p>The syntax is similar to that of defining messages:

<pre class="msg">
struct Place
{
    int type;
    string description;
    double coords[3];
};
</pre>
<p>
The generated struct has public data members, and no getter or setter
methods. The following code is generated from the above definition:

<pre class="cpp">
// generated C++
struct Place
{
    int type;
    <a href="../api/classomnetpp_1_1opp__string.html">opp_string</a> description; // minimal string class that wraps a const char*
    double coords[3];
};
</pre>
<p>
Note that <b><tt>string</tt></b> fields are generated with the <tt><a href="../api/classomnetpp_1_1opp__string.html">opp_string</a></tt>
C++ type, which is a minimalistic string class that wraps <tt>const char*</tt>
and takes care of allocation/deallocation. It was chosen instead of
<tt>std::string</tt> because of its significantly smaller memory footprint
(the sizeof of <tt><a href="../api/classomnetpp_1_1opp__string.html">opp_string</a></tt> is the same as that of a <tt>const char*</tt>
pointer).

<p>Inheritance is supported for structs:

<pre class="msg">
struct Base
{
    ...
};

struct Extended extends Base
{
    ...
};
</pre>
<p>
However, because a struct has no member functions, there are limitations:

<p><ul>
   <li> variable-size arrays are not supported;
   <li> customization via inheritance and <b><tt>abstract</tt></b> fields
      (see later in <a href="#sec:msg-defs:customizing-via-inheritance">[6.7.2]</a>)
      cannot be used;
   <li> cannot have classes subclassed from <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt> as fields,
      because structs cannot be owners.
</ul>

<p>

<p><h2><a name="sec:msg-defs:cplusplus-blocks"/>6.5 Literal C++ Blocks<a class="headerlink" href="#sec:msg-defs:cplusplus-blocks" title="Permalink to this headline"></a></h2>

<p>It is possible to have C++ code placed directly into the generated code,
more precisely, into the generated header file. This is done with the
<b><tt>cplusplus</tt></b> keyword and a double curly braces. As we'll see in
later sections, <b><tt>cplusplus</tt></b> blocks are customarily used to insert
<tt>#include</tt> directives, typedefs, <tt>#define</tt> macros and other
elements into the generated header.

<p>Example:

<pre class="msg">
cplusplus {{
#include &lt;vector&gt;
#include "foo.h"
#define FOO_VERSION 4
typedef std::vector&lt;int&gt; IntVector;
}}
</pre>
<p>
The message compiler does not try to make sense of the text in the body of
the <tt>cplusplus</tt> block, it just simply copies it into the generated
header file.

<p>
<h2><a name="sec:msg-defs:using-cpp-types"/>6.6 Using C++ Types<a class="headerlink" href="#sec:msg-defs:using-cpp-types" title="Permalink to this headline"></a></h2>

<p>The message compile only knows about the types defined within the same msg
file, and the built-in types. To be able to use other types, for example
for fields or as base class, you need to do two things:

<p><ol>
   <li> Let the message compiler know about the type by announcing it; and
   <li> Make sure its C++ declaration will be available at compile time
</ol>

<p>The next two sections describe how to do each.

<p>
<h3><a name="sec:msg-defs:announcing-types"/>6.6.1 Announcing Types to the Message Compiler<a class="headerlink" href="#sec:msg-defs:announcing-types" title="Permalink to this headline"></a></h3>

<p>To use a C++ type (class, struct a typedef) defined outside the msg file,
that type needs to be announced to the message compiler. Type annoucements
have a similar syntax to those in C++:

<pre class="msg">
struct Point;
class PrioQueue;  // implies it is derived from <a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a>! see below
message TimeoutMessage;
packet TCPSegment;
</pre>
<p>
However, with the <b><tt>class</tt></b> keyword, the message compiler needs to
know the whether the class is derived (directly or indirectly) from
<tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>, <tt><a href="../api/classomnetpp_1_1cNamedObject.html">cNamedObject</a></tt>, <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> or none of
the above, because it affects code generation. The ancestor class can be
declared with the <b><tt>extends</tt></b> keyword, like this:

<pre class="msg">
class IPAddress extends void;  // does not extend any "interesting" class
class ModulePtr extends void;  // ditto
class IntVector extends void;  // ditto
class IPCtlInfo extends <a href="../api/classomnetpp_1_1cObject.html">cObject</a>;
class FooOption extends <a href="../api/classomnetpp_1_1cNamedObject.html">cNamedObject</a>;
class PrioQueue extends <a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a>;
class IPAddrExt extends IPAddress;  // also OK: IPAddress has been announced
</pre>
<p>
An alternative to <tt>extends void</tt> is the <b><tt>noncobject</tt></b> modifier:

<pre class="msg">
class noncobject IPAddress; // same as "extends void"
</pre>
<p>
By default, that is, when <b><tt>extends</tt></b> is missing, it is assumed
that the class is derived from <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>. Thus, the following
two announcements are equivalent:

<pre class="msg">
class PrioQueue;
class PrioQueue extends <a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a>;
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
Notice that this default is inconsistent with the default base class for
generating classes, which is <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> (see
<a href="#sec:msg-defs:defining-classes">[6.3]</a>). The reason why type announcements
assume <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt> is that it is safer: a mistake will surface in
the form of a compile error and will not remain hidden until it causes some
obscure runtime error.
</ul>

<p>
<h3><a name="sec:msg-def:making-cpp-declarations-available"/>6.6.2 Making the C++ Declarations Available<a class="headerlink" href="#sec:msg-def:making-cpp-declarations-available" title="Permalink to this headline"></a></h3>

<p>In addition to announcing types to the message compiler, their C++
declarations also need to be available at compile time so that the
generated code will actually compile. This can be ensured using
<b><tt>cplusplus</tt></b> blocks that insert includes, typedefs, class/struct
declarations, etc. into the generated header file:

<pre class="msg">
cplusplus {{
#include "IPAddress.h"
typedef std::vector&lt;int&gt; IntVector;
}}
</pre>
<p>
A <b><tt>cplusplus</tt></b> block is also needed if the desired types are
defined in a different message file. The block should contain an include
directive to pull in the header file generated from the other message file.
It is currently not supported to import types from other message files
directly,

<p>Example:

<pre class="msg">
cplusplus {{
#include "TCPSegment_m.h"  // make types defined in TCPSegment.msg available
                           // for the C++ compiler
}}
</pre>
<p>

<p><h3><a name="sec:msg-def:putting-it-together"/>6.6.3 Putting it Together<a class="headerlink" href="#sec:msg-def:putting-it-together" title="Permalink to this headline"></a></h3>

<p>Suppose you have header files and message files that define various types:

<pre class="cpp">
// IPAddress.h
class IPAddress {
   ...
};
</pre>
<p>
<pre class="cpp">
// Location.h
struct Location {
    double lon;
    double lat;
};
</pre>

<pre class="msg">
// AppPacket.msg
packet AppPacket {
   ...
}
</pre>
<p>
To be able to use the above types in a message definition (and two more,
an <tt>IntVector</tt> and a module pointer), the message file should contain
the following lines:

<pre class="msg">
cplusplus {{
#include &lt;vector&gt;
#include "IPAddress.h"
#include "Location.h"
#include "AppPacket_m.h"
typedef std::vector&lt;int&gt; IntVector;
typedef <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *ModulePtr;
}};

class noncobject IPAddress;
struct Location;
packet AppPacket;
class noncobject IntVector;
class noncobject ModulePtr;

packet AppPacketExt extends AppPacket {
    IPAddress destAddress;
    Location senderLocation;
    IntVector data;
    ModulePtr originatingModule;
}
</pre>
<p>

<p><h2><a name="sec:msg-defs:customizing-generated-class"/>6.7 Customizing the Generated Class<a class="headerlink" href="#sec:msg-defs:customizing-generated-class" title="Permalink to this headline"></a></h2>

<p>
<h3><a name="sec:msg-defs:customizing-method-names"/>6.7.1 Customizing Method Names<a class="headerlink" href="#sec:msg-defs:customizing-method-names" title="Permalink to this headline"></a></h3>

<p>The names and some other properties of generated methods can be influenced
with metadata annotations (properties).

<p>The names of the getter and setter methods can be changed with the
<b><tt>@getter</tt></b> and <b><tt>@setter</tt></b> properties. For variable-size array
fields, the names of array size getter and setter methods can be changed
with <b><tt>@sizeGetter</tt></b> and <b><tt>@sizeSetter</tt></b>.

<p>In addition, the data type for the array size (by default <tt>unsigned
int</tt>) can be changed with <b><tt>@sizetype</tt></b> property.

<p>Consider the following example:

<pre class="msg">
packet IPPacket {
    int ttl @getter(getTTL) @setter(setTTL);
    Option options[] @sizeGetter(getNumOptions)
                     @sizeSetter(setNumOptions)
                     @sizetype(short);
}
</pre>
<p>
The generated class would have the following methods (note the differences
from the default names <tt>getTtl()</tt>, <tt>setTtl()</tt>, <tt>getOptions()</tt>,
<tt>setOptions()</tt>, <tt>getOptionsArraySize()</tt>, <tt>getOptionsArraySize()</tt>;
also note that indices and array sizes are now <tt>short</tt>):

<pre class="cpp">
virtual int getTTL() const;
virtual void setTTL(int ttl);
virtual const Option& getOption(short k) const;
virtual void setOption(short k, const Option& option);
virtual short getNumOptions() const;
virtual void setNumOptions(short n);
</pre>
<p>
In some older simulation models you may also see the use of the
<b><tt>@omitGetVerb</tt></b> class property. This property tells the message
compiler to generate getter methods without the &#8220;get&#8221; prefix, e.g. for a
<tt>sourceAddress</tt> field it would generate a <tt>sourceAddress()</tt> method
instead of the default <tt>getSourceAddress()</tt>. It is not recommended to
use <tt>@omitGetVerb</tt> in new models, because it is inconsistent with the
accepted naming convention.

<p>

<p><h3><a name="sec:msg-defs:customizing-via-inheritance"/>6.7.2 Customizing the Class via Inheritance<a class="headerlink" href="#sec:msg-defs:customizing-via-inheritance" title="Permalink to this headline"></a></h3>

<p>Sometimes you need the generated code to do something
more or do something differently than the version generated
by the message compiler.
For example, when setting an integer field named <tt>payloadLength</tt>,
you might also need to adjust the packet length. That is,
the following default (generated) version of the
<tt>setPayloadLength()</tt> method is not suitable:

<pre class="cpp">
void FooPacket::setPayloadLength(int payloadLength)
{
    this-&gt;payloadLength = payloadLength;
}
</pre>
<p>
Instead, it should look something like this:

<pre class="cpp">
void FooPacket::setPayloadLength(int payloadLength)
{
    addByteLength(payloadLength - this-&gt;payloadLength);
    this-&gt;payloadLength = payloadLength;
}
</pre>
<p>
According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

<p>However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the <i>Generation Gap</i> design pattern.
It is enabled with the <b><tt>@customize</tt></b> property set on the
message:

<pre class="msg">
packet FooPacket
{
   @customize(true);
   int payloadLength;
};
</pre>
<p>
If you process the above code with the message compiler,
the generated code will contain a <tt>FooPacket_Base</tt> class
instead of <tt>FooPacket</tt>. Then you would subclass
<tt>FooPacket_Base</tt> to produce <tt>FooPacket</tt>,
while doing your customizations by redefining the necessary methods.

<pre class="cpp">
class FooPacket_Base : public <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=nullptr);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
</pre>
<p>
There is a minimum amount of code you have to write
for <tt>FooPacket</tt>, because not everything can be
pre-generated as part of <tt>FooPacket_Base</tt>, e.g.
constructors cannot be inherited. This minimum
code is the following (you will find it the generated C++ header
too, as a comment):

<pre class="cpp">
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=nullptr) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual FooPacket *dup() const {return new FooPacket(*this);}
};

Register_Class(FooPacket);
</pre>
<p>
Note that it is important that you redefine <tt>dup()</tt> and
provide an assignment operator (<tt>operator=()</tt>).

<p>So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

<pre class="cpp">
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy constructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    addByteLength(newlength - getPayloadLength());

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
</pre>
<p>

<p>
<h3><a name="sec:msg-defs:abstract-fields"/>6.7.3 Abstract Fields<a class="headerlink" href="#sec:msg-defs:abstract-fields" title="Permalink to this headline"></a></h3>

<p>The purpose of abstract fields is to let you to override the way the value
is stored inside the class, and still benefit from inspectability in
graphical user interfaces.

<p>For example, this is the situation when you want to store a bitfield
in a single <b><tt>int</tt></b> or <b><tt>short</tt></b>, and yet you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

<p>A field is declared abstract by using <b><tt>abstract </tt></b> keyword:

<pre class="msg">
packet FooPacket
{
   @customize(true);
   abstract bool urgentBit;
};
</pre>
<p>
For an abstract field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

<pre class="cpp">
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
</pre>
<p>
Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.

<p>

<p><h2><a name="sec:msg-defs:using-stl"/>6.8 Using Standard Container Classes for Fields<a class="headerlink" href="#sec:msg-defs:using-stl" title="Permalink to this headline"></a></h2>

<p>One often wants to use standard container classes (STL) as fields, such as
<tt>std::vector</tt>, <tt>std::stack</tt> or <tt>std::map</tt>. The following sections
describe two ways this can be done:

<p><ol>
  <li> via a typedef;
  <li> by defining the field as abstract, and customizing the generated class.
</ol>

<p><h3><a name="sec:msg-def:typedefs"/>6.8.1 Typedefs<a class="headerlink" href="#sec:msg-def:typedefs" title="Permalink to this headline"></a></h3>

<p>The basic idea is that if we create a typedef for the desired type,
we can use it for fields just as any other type. Example:

<pre class="msg">
cplusplus {{
#include &lt;vector&gt;
typedef std::vector&lt;int&gt; IntVector;
}}

class noncobject IntVector;

packet FooPacket {
    IntVector addresses;
};
</pre>
<p>
The generated class will have the following methods:

<pre class="cpp">
virtual IntVector& getAddresses();
virtual const IntVector& getAddresses() const;
virtual void setAddresses(const IntVector& addresses);
</pre>
<p>
Thus, the underlying <tt>std::vector&lt;int&gt;</tt> is exposed and you can directly
manipulate it from C++ code, for example like this:

<pre class="cpp">
FooPacket *pk = new FooPacket();
pk-&gt;getAddresses().push_back(1);
pk-&gt;getAddresses().push_back(5);
pk-&gt;getAddresses().push_back(9);
// or:
IntVector& v = pk-&gt;getAddresses();
v.push_back(1);
v.push_back(5);
v.push_back(9);
</pre>
<p>
It is easy. However, there are also some drawbacks:

<p><ol>
  <li> The message compiler won't know that your field is actually
      a data structure, so the generated reflection code won't be able
      to look into it;
  <li> The fact that STL classes are directly exposed may be a mixed
      blessing; on one hand this makes it easier to manipulate its
      contents, but on the other hand it violates the encapsulation
      principle. Container classes work best when they are used as
      &#8220;nuts and bolts&#8221; for your C++ program, but they shouldn't really
      be used as public API.
</ol>

<p><h3><a name="sec:msg-def:abstract-fields"/>6.8.2 Abstract Fields<a class="headerlink" href="#sec:msg-def:abstract-fields" title="Permalink to this headline"></a></h3>

<p>This approach uses abstract fields. We exploit the fact that
<tt>std::vector</tt> and <tt>std::stack</tt> are representations of
<i>sequence</i>, which is the same abstraction as fields' variable-size
array. That is, if you declare the field to be <tt>abstract fieldname[]</tt>,
the message compiler will only generate pure virtual functions and you can
implement the underlying data storage using standard container classes. You
can also write additional C++ methods that delegate to the container
object's <tt>push_back()</tt>, <tt>push()</tt>, <tt>pop()</tt>, etc. methods.

<p>Consider the following message declaration:

<pre class="msg">
packet FooPacket
{
    @customize(true);
    abstract int foo[]; // will use std::vector&lt;int&gt;
    abstract int bar[]; // will use std::stack&lt;int&gt;
}
</pre>
<p>
If you compile the above code, in the generated C++ code you will only find
abstract methods for <tt>foo</tt> and <tt>bar</tt>, but no underlying data
members or method implementations. You can implement everything as you
like. You can write the following C++ file then to implement <tt>foo</tt> and
<tt>bar</tt> with <tt>std::vector</tt> and <tt>std::stack</tt> (some details omitted
for brevity):

<pre class="cpp">
#include &lt;vector&gt;
#include &lt;stack&gt;
#include "FooPacket_m.h"

class FooPacket : public FooPacket_Base
{
  protected:
    std::vector&lt;int&gt; foo;
    std::stack&lt;int&gt; bar;

    // helper method
    void unsupported() {throw <a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a>("unsupported method called");}

  public:
    ...
    // foo methods
    virtual int getFoo(unsigned int k) {return foo[k];}
    virtual void setFoo(unsigned int k, int x) {foo[k]=x;}
    virtual void addFoo(int x) {foo.push_back(x);}
    virtual void setFooArraySize(unsigned int size) {foo.resize(size);}
    virtual unsigned int getFooArraySize() const {return foo.size();}

    // bar methods
    virtual int getBar(unsigned int k) {...}
    virtual void setBar(unsigned int k, int x) {unsupported();}
    virtual void barPush(int x) {bar.push(x);}
    virtual void barPop() {bar.pop();}
    virtual int barTop() {return bar.top();}
    virtual void setBarArraySize(unsigned int size) {unsupported();}
    virtual unsigned int getBarArraySize() const {return bar.size();}
};

Register_Class(FooPacket);
</pre>
<p>
Some additional boilerplate code is needed so that the class conforms
to conventions, and duplication and copying works properly:

<pre class="cpp">
    FooPacket(const char *name=nullptr, int kind=0) : FooPacket_Base(name,kind) {
    }
    FooPacket(const FooPacket& other) : FooPacket_Base(other.getName()) {
        operator=(other);
    }
    FooPacket& operator=(const FooPacket& other) {
        if (&other==this) return *this;
        FooPacket_Base::operator=(other);
        foo = other.foo;
        bar = other.bar;
        return *this;
    }
    virtual FooPacket *dup() {
        return new FooPacket(*this);
    }
</pre>
<p>
Some additional notes:

<p><ol>
  <li> <tt>setFooArraySize()</tt>, <tt>setBarArraySize()</tt> are redundant.
  <li> <tt>getBar(int k)</tt> cannot be implemented in a straightforward way
     (<tt>std::stack</tt> does not support accessing elements by index).
     It could still be implemented in a less efficient way using STL iterators,
     and efficiency does not seem to be major problem because only Tkenv
     is going to invoke this function.
  <li> <tt>setBar(int k, int x)</tt> could not be implemented, but this
     is not particularly a problem. The exception will materialize in a
     Tkenv error dialog when you try to change the field value.
</ol>

<p>

<p><h2><a name="sec:msg-defs:namespaces"/>6.9 Namespaces<a class="headerlink" href="#sec:msg-defs:namespaces" title="Permalink to this headline"></a></h2>

<p>It is possible to place the generated classes into a C++ namespace,
and also to use types from other namespaces.

<p><h3><a name="sec:msg-defs:declaring-a-namespace"/>6.9.1 Declaring a Namespace<a class="headerlink" href="#sec:msg-defs:declaring-a-namespace" title="Permalink to this headline"></a></h3>

<p>To place the generated types into a namespace, add a namespace declaration
near the top of the message file:

<pre class="msg">
namespace inet;
</pre>
<p>
If you are fond of hierarchical (nested) namespaces, you can declare one
with a straightforward syntax, using double colons in the namespace
declaration. There is no need for multiple nested <tt>namespace</tt>
declarations as in C++:

<pre class="msg">
namespace org::omnetpp::inet::ieee80211;
</pre>
<p>
The above code will be translated into nested namespaces in the C++ code:

<pre class="cpp">
namespace org { namespace omnetpp { namespace inet { namespace ieee80211 {
...
}}}}
</pre>
<p>
Conceptually, the namespace extends from the place of the namespace
declaration to the end of the message file. (A message file may contain
only one namespace declaration.) In other words, it <i>does</i> matter
whether you put something above the namespace declaration line or below it:

<p><ol>
<li> The contents of <b><tt>cplusplus</tt></b> blocks above the namespace
      declaration will be placed outside (i.e. above) the namespace block
      in the generated C++ header; blocks below the namespace declaration
      will placed inside the C++ namespace block.
<li> Type announcements are interpreted differently depending on whether
      they occur above or below the namespace declaration (this will be
      detailed later).
<li> Types defined with the message syntax are placed into the namespace
      of the message file; thus, definitions must always be <i>after</i>
      the namespace declaration. Type definitions above the namespace line
      will be rejected with an error message.
</ol>

<p><h3><a name="sec:msg-def:cpp-blocks-and-namespace"/>6.9.2 C++ Blocks and Namespace<a class="headerlink" href="#sec:msg-def:cpp-blocks-and-namespace" title="Permalink to this headline"></a></h3>

<p>As described above, the contents of a <b><tt>cplusplus</tt></b> block will be
copied above or into the C++ namespace block in the generated header
depending on whether it occurs above or below the namespace declaration in
the message file.

<p>The placement of <b><tt>cplusplus</tt></b> blocks relative to the namespace
declaration is important because you don't want <tt>#include</tt> directives
to be placed inside the C++ namespace block. That would cause the
declarations in the header file to be interpreted as being part of the
namespace, which they are not. Includes should always be put into
<tt>cplusplus</tt> blocks <i>above</i> the namespace declaration. This is so
important that I repeat it:

<p><ul class="important"><b>IMPORTANT</b><br>
Includes should always be placed into a <b><tt>cplusplus</tt></b> block <b>above</b>
the namespace declaration.
</ul>

<p>As for typedefs and other C++ code, you need to place them above or below
the namespace declaration based on whether you want them to be in the C++
namespace or not.

<p><h3><a name="sec:msg-def:type-announcements-and-namespace"/>6.9.3 Type Announcements and Namespace<a class="headerlink" href="#sec:msg-def:type-announcements-and-namespace" title="Permalink to this headline"></a></h3>

<p>The type announcement syntax allows one to specify the namespace of the type
as well, so the following lines are syntactically correct:

<pre class="msg">
packet foo::FooPacket;
packet nes::ted::name::space::BarPacket;
packet ::BazPacket;
</pre>
<p>
Announced type names are interpreted in the following way:

<p><ol>
<li> If the type name contains a double colon (<tt>::</tt>), it is interpreted
      as being fully qualified with an absolute namespace.
<li> If the name is just an identifier (no double colon), the interpretation
      depends on whether it is above or below the namespace declaration.
      If it is above, the name is interpreted as a global type; otherwise
      it is interpreted as part of the package file's namespace.
</ol>

<p>This also means that if you want to announce a global type, you either
have to put the announcement above the namespace declaration, or prefix
the type with &#8220;<tt>::</tt>&#8221; to declare that it is not part of a namespace.

<p>When the announced types are used later (as field type, base class, etc.),
they can be referred to just with their simple names (without namespace);
or alternatively with their fully qualified names. When a message compiler
encounters type name as field type or base class, it interprets the type
name in the following way:

<p><ol>
<li> If the type name contains a double colon (<tt>::</tt>), it is interpreted
      as being fully qualified with an absolute namespace.
<li> If the name is just an identifier (no double colon), and the message
      file's namespace contains that name, it is chosen; otherwise:
<li> It is looked up among all announced types in all namespaces (including
      the global namespace), and there must be exactly one match. That is,
      if the same name exists in multiple namespaces, it may only be
      referenced with fully qualified name.
</ol>

<p>The following code illustrates the above rules:

<pre class="msg">
cplusplus {{
// includes go above the namespace line
#include &lt;vector&gt;
#include "IPAddress.h"
}}

// the IPAddress type is in the global namespace
class noncobject IPAddress;

namespace foo;  // namespace begins with this line

// we could also have announced IPAddress here as "::IPAddress":
//class noncobject ::IPAddress;

cplusplus {{
// we want IPAddressVector to be part of the namespace
typedef std::vector&lt;IPAddress&gt; IPAddressVector;
}}

// type will be understood as foo::IPAddressVector
class noncobject IPAddressVector;

packet FooPacket {
    IPAddress source;
    IPAddressVector neighbors;
};
</pre>
<p>
Another example that uses a <tt>PacketData</tt> class and a <tt>NetworkPacket</tt> type
from a <tt>net</tt> namespace:

<pre class="msg">
// NetworkPacket.msg
namespace net;
class PacketData { }
packet NetworkPacket { }
</pre>
<p>
<pre class="msg">
// FooPacket.msg
cplusplus {{
#include "NetworkPacket_m.h"
}}
class net::PacketData;
packet net::NetworkPacket;

namespace foo;

packet FooPacket extends NetworkPacket
{
    PacketData data;
}
</pre>

<p>

<p><h2><a name="sec:msg-defs:descriptor-classes"/>6.10 Descriptor Classes<a class="headerlink" href="#sec:msg-defs:descriptor-classes" title="Permalink to this headline"></a></h2>

<p>For each generated class and struct, the message compiler generates an
associated descriptor class. The descriptor class carries &#8220;reflection&#8221;
information about the new class, and makes it possible to inspect message
contents in Tkenv.

<p>The descriptor class encapsulates virtually all information that the
original message definition contains, and exposes it via member functions.
It has methods for enumerating fields (<tt>getFieldCount()</tt>,
<tt>getFieldName()</tt>, <tt>getFieldTypeString()</tt>, etc.), for getting
and setting a field's value in an instance of the class
(<tt>getFieldAsString()</tt>, <tt>setFieldAsString()</tt>), for exploring the
class hierarchy (<tt>getBaseClassDescriptor()</tt>, etc.), for accessing
class and field properties, and for similar tasks. When you inspect a
message or packet in the simulation, Tkenv can uses the associated
descriptor class to extract and display the field values.

<p>The <b><tt>@descriptor</tt></b> class property can be used to control the generation
of the descriptor class. <tt>@descriptor(readonly)</tt> instructs the message
compiler not to generate field setters for the descriptor, and
<tt>@descriptor(false)</tt> instructs it not to generate a description class
for the class at all.

<p>It is also possible to use (or abuse) the message compiler for generating a
descriptor class for an existing class. (This can be useful for making your
class inspectable in Tkenv.) To do that, write a message definition for
your existing class (for example, if it has <tt>int getFoo()</tt> and
<tt>setFoo(int)</tt> methods, add an <tt>int foo</tt> field to the message
definition), and mark it with <tt>@existingClass(true)</tt>. This will tell the
message compiler that it should not generate an actual class (as it already
exists), only a descriptor class.

<p>

<p><h2><a name="sec:msg-defs:summary"/>6.11 Summary<a class="headerlink" href="#sec:msg-defs:summary" title="Permalink to this headline"></a></h2>

<p>This section summarizes the possibilities offered by message definitions.

<p>Base functionality:

<p><ul>
  <li> generation of classes and plain C structs from concise descriptions
  <li> default base classes:
    <tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> (with the <b><tt>packet</tt></b> keyword),
    <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> (with the <b><tt>message</tt></b> keyword), or
    <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> (with the <b><tt>class</tt></b> keyword)
</ul>

<p>The following data types are supported for fields:

<p><ul>
  <li> primitive types:
    <tt>bool</tt>, <tt>char</tt>, <tt>short</tt>, <tt>int</tt>, <tt>long</tt>;
    <tt>unsigned char</tt>, <tt>unsigned short</tt>, <tt>unsigned int</tt>, <tt>unsigned long</tt>;
    <tt>int8_t</tt>, <tt>int16_t</tt>, <tt>int32_t</tt>, <tt>int64_t</tt>;
    <tt>uint8_t</tt>, <tt>uint16_t</tt>, <tt>uint32_t</tt>, <tt>uint64_t</tt>;
    <tt>float</tt>, <tt>double</tt>; <tt>simtime_t</tt>
  <li> <tt>string</tt>, a dynamically allocated string, presented as <tt>const char *</tt>
  <li> structs and classes, declared with the message syntax or in C++ code
  <li> typedef'd names declared in C++ and announced to the message compiler
  <li> fixed-size arrays of the above types
  <li> variable-size arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
</ul>

<p>Further features:

<p><ul>
  <li> fields initialize to zero (except for struct/class fields)
  <li> field initializers can be specified (except for struct/class fields)
  <li> associating fields of integral types with enums
  <li> inheritance
  <li> namespaces
  <li> customization of generated method names
  <li> customization of the generated class via subclassing (<i>Generation Gap</i> pattern)
  <li> abstract fields (for nonstandard storage and calculated fields)
  <li> generation of descriptor objects that encapsulate reflection information
</ul>

<p>Generated code (all generated methods are <tt>virtual</tt>, although
this is not written out in the following table):

<p><table border>
<TR> <TD align=left>

<p>
<b>Field declaration</b>
    </TD> <TD align=left>
<b>Generated code</b>
</TD></TR>
<TR> <TD align=left> 
primitive types
<pre class="verbatim">
double field;
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
double getField();
void setField(double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
string type
<pre class="verbatim">
string field;
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
const char *getField();
void setField(const char *);
</pre>
</TD></TR>
<TR> <TD align=left> 
fixed-size arrays
<pre class="verbatim">
double field[4];
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
</pre>

<p></TD></TR>
<TR> <TD align=left> 
variable-size arrays
<pre class="verbatim">
double field[];
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
customized class
<pre class="verbatim">
class Foo {
  @customize(true);
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
class Foo_Base { ... };
</pre>
and you have to write:
<pre class="verbatim">
class Foo : public Foo_Base {
   ...
};
</pre>
</TD></TR>
<TR> <TD align=left> 
abstract fields
<pre class="verbatim">
abstract double field;
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
double getField() = 0;
void setField(double d) = 0;
</pre>
</TD></TR>
<TR> <TD align=left> 
</table>

<p>

<p><hr class='pgbr'><h1><a name="cha:sim-lib"/>7 The Simulation Library<a class="headerlink" href="#cha:sim-lib" title="Permalink to this headline"></a></h1>

<p>OMNeT++ has an extensive C++ class library available to the user for
implementing simulation models and model components. Part of the class
library's functionality has already been covered in the previous chapters,
including discrete event simulation basics, the simple module programming
model, module parameters and gates, scheduling events, sending and
receiving messages, channel operation and programming model, finite state
machines, dynamic module creation, signals, and more.

<p>This chapter discusses the rest of the simulation library. Topics will
include logging, random number generation, queues, topology discovery and
routing support, and statistics and result collection. This chapter also
covers some of the conventions and internal mechanisms of the simulation
library to allow one extending it and using it to its full potential.

<p>
<h2><a name="sec:sim-lib:fundamentals"/>7.1 Fundamentals<a class="headerlink" href="#sec:sim-lib:fundamentals" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:sim-lib:using-omnetpp-library"/>7.1.1 Using the Library<a class="headerlink" href="#sec:sim-lib:using-omnetpp-library" title="Permalink to this headline"></a></h3>

<p>Classes in the OMNeT++ simulation library are part of the <tt>omnetpp</tt>
namespace. To use the OMNeT++ API, one must include the <tt>omnetpp.h</tt>
header file and either import the namespace with <tt>using namespace
omnetpp</tt>, or qualify names with the <tt>omnetpp::</tt> prefix.

<p>Thus, simulation models will contain the

<pre class="cpp">
#include &lt;omnetpp.h&gt;
</pre>
<p>
line, and often also

<pre class="cpp">
using namespace omnetpp;
</pre>
<p>
When writing code that should work with various versions of OMNeT++, it is
often useful to have compile-time access to the OMNeT++ version in a numeric
form. The <tt>OMNETPP_VERSION</tt> macro exists for that purpose, and it is
defined by OMNeT++ to hold the version number in the form
<i>major*256+minor</i>. For example, in OMNeT++ 4.6 it was defined as

<pre class="cpp">
#define OMNETPP_VERSION 0x406
</pre>
<p>

<p><h3><a name="sec:sim-lib:cobject"/>7.1.2 The <a href="../api/classomnetpp_1_1cObject.html">cObject</a> Base Class<a class="headerlink" href="#sec:sim-lib:cobject" title="Permalink to this headline"></a></h3>

<p>Most classes in the simulation library are derived from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>,
or its subclasses <tt><a href="../api/classomnetpp_1_1cNamedObject.html">cNamedObject</a></tt> and <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>.
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> defines several virtual member functions that are either
inherited or redefined by subclasses. Otherwise, <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> is a
zero-overhead class as far as memory consumption goes: it purely defines an
interface but has no data members. Thus, having <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> a base
class does not add anything to the size of a class if it already has at
least one virtual member function.

<p>
  <center>
    <img src="cobject-inheritance.svg">
    <center><div class="caption"><i>Figure: <a href="../api/classomnetpp_1_1cObject.html">cObject</a> is the base class for most of the simulation library</i></div></center>
  </center>

<p>
The subclasses <tt><a href="../api/classomnetpp_1_1cNamedObject.html">cNamedObject</a></tt> and <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt> add data
members to implement more functionality. The following sections discuss
some of the practically important functonality defined by <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.

<p>
<h4><a name="sec:sim-lib:object-name"/>7.1.2.1 Name and Full Name<a class="headerlink" href="#sec:sim-lib:object-name" title="Permalink to this headline"></a></h4>
<!--object!name-->

<p>The most useful and most visible member functions of <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> are
<tt>getName()</tt> and <tt>getFullName()</tt>. The idea behind them is that
many objects in OMNeT++ have names by default (for example, modules,
parameters and gates), and even for other objects, having a printable name
is a huge gain when it comes to logging and debugging.

<p><tt>getFullName()</tt> is important for gates and modules, which may be part
of gate or module vectors. For them, <tt>getFullName()</tt> returns the name
with the index in brackets, while <tt>getName()</tt> only returns the name
of the module or gate vector. That is, for a gate <tt>out[3]</tt> in the gate
vector <tt>out[10]</tt>, <tt>getName()</tt> returns <tt>"out"</tt>, and
<tt>getFullName()</tt> returns <tt>"out[3]"</tt>. For other objects,
<tt>getFullName()</tt> simply returns the same string as <tt>getName()</tt>.
An example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = gate("out", 3);  // out[3]
EV &lt;&lt; gate-&gt;getName();  // prints "out"
EV &lt;&lt; gate-&gt;getFullName();  // prints "out[3]"
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
When printing out the name of an object, prefer <tt>getFullName()</tt> to
<tt>getName()</tt>, especially if the runtime type is not know. This will
ensure that the vector index will also be printed if the object has one.
</ul>

<p><tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> merely defines these member functions, but they return an
empty string. Actual storage for a name string and a <tt>setName()</tt>
method is provided by the class <tt><a href="../api/classomnetpp_1_1cNamedObject.html">cNamedObject</a></tt>, which is also an
(indirect) base class for most library classes. Thus, one can assign names
to nearly all user-created objects. It it also recommended to do so, because
a name makes an object easier to identify in graphical runtimes like Tkenv
or Qtenv.

<p>By convention, the object name is the first argument to the constructor
of every class, and it defaults to the empty string. To create an object with
a name, pass the name string (a <tt>const char*</tt> pointer) as the first
argument of the constructor. For example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *timeoutMsg = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>("timeout");
</pre>
<p>
To change the name of an object, use <tt>setName()</tt>:

<pre class="cpp">
timeoutMsg-&gt;setName("timeout");
</pre>
<p>
Both the constructor and <tt>setName()</tt> make an internal copy of the string,
instead of just storing the pointer passed to them.<br><ul><font size=-1>[
  In a simulation, there are usually many objects with the same name:
  modules, parameters, gates, etc. To conserve memory, several classes
  keep names in a shared, reference-counted <i>name pool</i> instead of
  making separate copies for each object. The runtime cost of looking up an
  existing string in the name pool and incrementing its reference count
  also compares favorably to the cost of allocation and copying.]</font></ul>

<p>For convenience and efficiency reasons, the empty string <tt>""</tt>
and <tt>nullptr</tt> are treated as interchangeable by library objects.
That is, <tt>""</tt> is stored as <tt>nullptr</tt> but returned as <tt>""</tt>.
If one creates a message object with either <tt>nullptr</tt>
or <tt>""</tt> as its name string, it will be stored as <tt>nullptr</tt>,
and <tt>getName()</tt> will return a pointer to a static <tt>""</tt>.

<p>
<h4><a name="sec:sim-lib:object-fullpath"/>7.1.2.2 Hierarchical Name<a class="headerlink" href="#sec:sim-lib:object-fullpath" title="Permalink to this headline"></a></h4>
<!--object!fullpath-->

<p><tt>getFullPath()</tt> returns the object's hierarchical name. This name is
produced by prepending the <i>full name</i> (<tt>getFullName()</tt>) with
the parent or owner object's <tt>getFullPath()</tt>, separated by a dot. For
example, if the <tt>out[3]</tt> gate in the previous example belongs to a
module named <tt>classifier</tt>, which in turn is part of a network called
<tt>Queueing</tt>, then the gate's <tt>getFullPath()</tt> method will return
<tt>"Queueing.classifier.out[3]"</tt>.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = gate("out", 3);  // out[3]
EV &lt;&lt; gate-&gt;getName();  // prints "out"
EV &lt;&lt; gate-&gt;getFullName();  // prints "out[3]"
EV &lt;&lt; gate-&gt;getFullPath();  // prints "Queueing.classifier.out[3]"
</pre>
<p>
The <tt>getFullName()</tt> and <tt>getFullPath()</tt> methods are
extensively used in graphical runtime environments (Tkenv, Qtenv),
and also when assembling runtime error messages.

<p>In contrast to <tt>getName()</tt> and <tt>getFullName()</tt> which return
<tt>const char *</tt> pointers, <tt>getFullPath()</tt> returns
<tt>std::string</tt>. This makes no difference when logging via <tt>EV&lt;&lt;</tt>,
but when <tt>getFullPath()</tt> is used as a <tt>"%s"</tt> argument to
<tt>sprintf()</tt>, one needs to write <tt>getFullPath().c_str()</tt>.

<pre class="cpp">
char buf[100];
sprintf("msg is '%80s'", msg-&gt;getFullPath().c_str()); // note c_str()
</pre>
<p>

<p><h4><a name="sec:sim-lib:classname"/>7.1.2.3 Class Name<a class="headerlink" href="#sec:sim-lib:classname" title="Permalink to this headline"></a></h4>

<p>The <tt>getClassName()</tt> member function returns the class
name as a string, including the namespace. <tt>getClassName()</tt> internally
relies on C++ RTTI.

<p>An example:

<pre class="cpp">
const char *className = msg-&gt;getClassName(); // returns "omnetpp::<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>"
</pre>
<p>

<h4><a name="sec:sim-lib:dup"/>7.1.2.4 Cloning Objects<a class="headerlink" href="#sec:sim-lib:dup" title="Permalink to this headline"></a></h4>

<p>The <tt>dup()</tt> member function creates an exact copy of the
object<!--object!copy-->, duplicating<!--object!duplication-->
contained objects also if necessary. This is especially useful in the
case of message objects.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *copy = msg-&gt;dup();
</pre>
<p>
<tt>dup()</tt> delegates to the copy constructor. Classes also declare
an assignment operator (<tt>operator=()</tt>) which can be used to copy contents
of an object into another object of the same type. <tt>dup()</tt>, the copy
constructor and the assignment operator all perform deep coping: objects
contained in the copied object will also be duplicated if necessary.

<p><tt>operator=()</tt> differs from the other two in that it does <i>not</i>
copy the object's name string, i.e. does not invoke <tt>setName()</tt>.
The rationale is that the name string is often used for identifying the particular
object instance, as opposed to being considered as part of its contents.


<h3><a name="sec:sim-lib:iterators"/>7.1.3 Iterators<a class="headerlink" href="#sec:sim-lib:iterators" title="Permalink to this headline"></a></h3>

<p>There are several container classes in the library (<tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>,
<tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> etc.) For many of them, there is a corresponding
iterator class that one can use to loop through the objects stored in
the container.

<p>For example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a> queue;

//...
for (<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>::<a href="../api/classomnetpp_1_1cQueue_1_1Iterator.html">Iterator</a> it(queue); !it.end(); ++it) {
    <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *containedObject = *it;
    //...
}
</pre>
<p>
<h3><a name="sec:sim-lib:runtime-errors"/>7.1.4 Runtime Errors<a class="headerlink" href="#sec:sim-lib:runtime-errors" title="Permalink to this headline"></a></h3>

<p>When library objects detect an error condition, they throw a C++ exception.
This exception is then caught by the simulation environment which pops up
an error dialog or displays the error message.

<p>At times it can be useful to be able stop the simulation at the place of
the error (just before the exception is thrown) and use a C++ debugger to
look at the stack trace and examine variables. Enabling the
<b><tt>debug-on-errors</tt></b> or the <b><tt>debugger-attach-on-error</tt></b>
configuration option lets you do that -- check it in section
<a href="#sec:run-sim:debugging-support">[11.12]</a>.

<p>
<h2><a name="sec:sim-lib:logging-from-modules"/>7.2 Logging from Modules<a class="headerlink" href="#sec:sim-lib:logging-from-modules" title="Permalink to this headline"></a></h2>

<p>In a simulation there are often thousands of modules which simultaneously carry
out non-trivial tasks. In order to understand a complex simulation, it is
essential to know the inputs and outputs of algorithms, the information on
which decisions are based, and the performed actions along with their parameters.
In general, logging facilitates understanding which module is doing what and why.

<p>OMNeT++ makes logging easy and consistent among simulation models by providing
its own C++ API and configuration options. The API provides efficient logging
with several predefined log levels, global compile-time and runtime filters,
per-component runtime filters, automatic context information, log prefixes and
other useful features. In the following sections, we look at how to write log
statements using the OMNeT++ logging API.

<p><h3><a name="sec:sim-lib:log-output"/>7.2.1 Log Output<a class="headerlink" href="#sec:sim-lib:log-output" title="Permalink to this headline"></a></h3>

<p>The exact way log messages are displayed to the user depends on the user interface.
In the command-line user interface (Cmdenv<!--Cmdenv-->), the log is simply
written to the standard output. In the graphical user interfaces, Tkenv and Qtenv,
the main window displays the log output of all modules by default. One can also
open new output windows on a per module basis, these windows automatically filter
for the log messages of the selected module.

<p><h3><a name="sec:sim-lib:log-levels"/>7.2.2 Log Levels<a class="headerlink" href="#sec:sim-lib:log-levels" title="Permalink to this headline"></a></h3>

<p>All logging must be categorized into one of the predefined log levels. The
assigned log level determines how important and how detailed a log statement
is. When deciding which log level is appropriate for a particular log statement,
keep in mind that they are meant to be local to components. There's no need for
a global agreement among all components, because OMNeT++ provides per component
filtering. Log levels are mainly useful because log output can be filtered
based on them.

<p><ul>
  <li> <tt>LOGLEVEL_OFF</tt> is not a real log level, it can't be used for actual
    logging. It is only useful for configuration purposes, it completely disables
    logging.
  <li> <tt>LOGLEVEL_FATAL</tt> is the highest log level. It should be used for
    fatal (unrecoverable) errors that prevent the component from further
    operation. It doesn't mean that the simulation must stop immediately
    (because in such cases the code should throw a <a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a>), but rather
    that the a component is unable to continue normal operation. For example, a
    special purpose recording component may be unable to continue recording due
    to the disk being full.
  <li> <tt>LOGLEVEL_ERROR</tt> should be used for recoverable (non-fatal)
    errors that allow the component to continue normal operation. For example,
    a MAC layer protocol component could log unsuccessful packet receptions and
    unsuccessful packet transmissions using this level.
  <li> <tt>LOGLEVEL_WARN</tt> should be used for exceptional (non-error)
    situations that may be important for users and rarely occur in the
    component. For example, a MAC layer protocol component could log detected
    bit errors using this level.
  <li> <tt>LOGLEVEL_INFO</tt> should be used for high-level protocol specific
    details that are most likely important for the users of the component. For
    example, a MAC layer protocol component could log successful packet
    receptions and successful packet transmissions using this level.
  <li> <tt>LOGLEVEL_DETAIL</tt> should be used for low-level protocol-specific
    details that may be useful and understandable by the users of the component.
    These messages may help to track down various protocol-specific issues
    without actually looking too deep into the code. For example, a MAC layer
    protocol component could log state machine updates, acknowledge timeouts
    and selected back-off periods using this level.
  <li> <tt>LOGLEVEL_DEBUG</tt> should be used for high-level
    implementation-specific technical details that are most likely important
    for the developers of the component. These messages may help to debug
    various issues when one is looking at the code. For example, a MAC layer
    protocol component could log updates to internal state variables, updates
    to complex data structures using this level.
  <li> <tt>LOGLEVEL_TRACE</tt> is the lowest log level. It should be used for
    low-level implementation-specific technical details that are mostly useful
    for the developers of the component. For example, a MAC layer protocol
    component could log control flow in loops and if statements,
    entering/leaving methods and code blocks using this level.
</ul>

<p><h3><a name="sec:sim-lib:log-statements"/>7.2.3 Log Statements<a class="headerlink" href="#sec:sim-lib:log-statements" title="Permalink to this headline"></a></h3>

<p>OMNeT++ provides several C++ macros for the actual logging. Each one of these
macros act like a C++ stream, so they can be used similarly to <tt>std::cout</tt>
with <tt>operator&lt;&lt;</tt> (shift operator).

<p><ul>
  <li> <tt>EV_FATAL</tt> for <tt>LOGLEVEL_FATAL</tt>
  <li> <tt>EV_ERROR</tt> for <tt>LOGLEVEL_ERROR</tt>
  <li> <tt>EV_WARN</tt> for <tt>LOGLEVEL_WARN</tt>
  <li> <tt>EV_INFO</tt> for <tt>LOGLEVEL_INFO</tt>
  <li> <tt>EV_DETAIL</tt> for <tt>LOGLEVEL_DETAIL</tt>
  <li> <tt>EV_DEBUG</tt> for <tt>LOGLEVEL_DEBUG</tt>
  <li> <tt>EV_TRACE</tt> for <tt>LOGLEVEL_TRACE</tt>
  <li> <tt>EV</tt> is provided for backward compatibility, and defaults to <tt>EV_INFO</tt>
</ul>

<p>The actual logging is as simple as writing information into one of these special
log streams as follows:

<pre class="cpp">
EV_ERROR &lt;&lt; "Connection to server is lost.\n";
EV_WARN &lt;&lt; "Queue is full, discarding packet.\n";
EV_INFO &lt;&lt; "Packet received , sequence number = " &lt;&lt; seqNum &lt;&lt; "." &lt;&lt; endl;
EV_TRACE &lt;&lt; "routeUnicastPacket(" &lt;&lt; packet &lt;&lt; ");" &lt;&lt; endl;
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
It is not recommended to use plain <tt>printf()</tt> or <tt>std::cout</tt> for
logging. Output from <tt>EV_INFO</tt> and the other log macros can be controlled
more easily from <tt>omnetpp.ini</tt>, and it is more convenient to view
using Tkenv or Qtenv.
</ul>

<p>The above C++ macros work well from any C++ class, including OMNeT++ modules. In
fact, they automatically capture a number of context specific information such
as the current event, current simulation time, context module, <tt>this</tt>
pointer, source file and line number. The final log lines will be automatically
extended with a prefix that is created from the captured information (see
section <a href="#sec:config-sim:logging">[10.6]</a>).

<p>In static class member functions or in non-class member functions an extra
<tt>EV_STATICCONTEXT</tt> macro must be present to make sure that normal log
macros compile. <br><ul><font size=-1>[This is due to that in C++ it is impossible
determine at compile-time whether a <tt>this</tt> pointer is accessible.]</font></ul>

<pre class="cpp">
void findModule(const char *name, <a href="../api/classomnetpp_1_1cModule.html">cModule</a> *from)
{
    EV_STATICCONTEXT;
    EV_TRACE &lt;&lt; "findModule(" &lt;&lt; name &lt;&lt; ", " &lt;&lt; from &lt;&lt; ");" &lt;&lt; endl;
</pre>
<p>
<h3><a name="sec:sim-lib:log-categories"/>7.2.4 Log Categories<a class="headerlink" href="#sec:sim-lib:log-categories" title="Permalink to this headline"></a></h3>

<p>Sometimes it might be useful to further classify log statements into user
defined log categories. In the OMNeT++ logging API, a log category is an
arbitrary string provided by the user.

<p>For example, a module test may check for a specific log message in the test's
output. Putting the log statement into the <tt>test</tt> category ensures that
extra care is taken when someone changes the wording in the statement to match
the one in the test.

<p>Similarily to the normal C++ log macros, there are separate log macros for each
log level which also allow specifying the log category. Their name is the same
as the normal variants' but simply extended with the <tt>_C</tt> suffix. They
take the log category as the first parameter before any shift operator calls:

<pre class="cpp">
EV_INFO_C("test") &lt;&lt; "Received " &lt;&lt; numPacket &lt;&lt; " packets in total.\n";
</pre>
<p>
<h3><a name="sec:sim-lib:logging-composition-and-new-lines"/>7.2.5 Composition and New lines<a class="headerlink" href="#sec:sim-lib:logging-composition-and-new-lines" title="Permalink to this headline"></a></h3>

<p>Occasionally it's easier to produce a log line using multiple statements.
Mostly because some computation has to be done between the parts. This can be
achieved by omitting the new line from the log statements which are to be
continued. And then subsequent log statements must use the same log level,
otherwise an implicit new line would be inserted.

<pre class="cpp">
EV_INFO &lt;&lt; "Line starts here, ";
... // some other code without logging
EV_INFO &lt;&lt; "and it continues here" &lt;&lt; endl;
</pre>
<p>
Assuming a simple log prefix that prints the log level in brakets, the above
code fragment produces the following output in Cmdenv:

<pre class="filelisting">
[INFO] Line starts here, and it continues here
</pre>
<p>
Sometimes it might be useful to split a line into multiple lines to achieve
better formatting. In such cases, there's no need to write multiple log
statements. Simply insert new lines into the sequence of shift operator calls:

<pre class="cpp">
EV_INFO &lt;&lt; "First line" &lt;&lt; endl &lt;&lt; "second line" &lt;&lt; endl;
</pre>
<p>
In the produced output, each line will have the same log prefix, as shown below:

<pre class="filelisting">
[INFO] First line
[INFO] Second line
</pre>
<p>
The OMNeT++ logging API also supports direct printing to a log stream. This is
mainly useful when printing is really complicated algorithmically (e.g. printing
a multi-dimensional value). The following code could produce multiple log lines
each having the same log prefix.

<pre class="cpp">
void Matrix::print(std::stream &output) { ... }
void Matrix::someFunction()
{
   print(EV_INFO);
</pre>
<p>

<p><h3><a name="sec:sim-lib:logging-implementation"/>7.2.6 Implementation<a class="headerlink" href="#sec:sim-lib:logging-implementation" title="Permalink to this headline"></a></h3>

<p>OMNeT++ does its best to optimize the performance of logging. The implementation
fully supports conditinal compilation of log statements based on their log
level. It automatically checks whether the log is recorded anywhere. It also
checks global and per-component runtime log levels. The latter is efficiently
cached in the components for subsequent checks. See section
<a href="#sec:config-sim:logging">[10.6]</a> for more details on how to configure these log
levels.

<p>The implementation of the C++ log macros makes use of the fact that the
<tt>operator&lt;&lt;</tt> is bound more loosely than the conditional operator
(<tt>?:</tt>). This solves conditional compilation, and also helps runtime
checks by redirecting the output to a <tt>null</tt> stream. Unfortunately the
<tt>operator&lt;&lt;</tt> calls are still evaluated on the <tt>null</tt> stream, even if
the log level is disabled.

<p>Rarely just the computation of log statement parameters may be very expensive,
and thus it must be avoided if possible. In this case, it is a good idea to
make the log statement conditional on whether the output is actually being
displayed or recorded anywhere. The <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a>::isLoggingEnabled()</tt> call
returns false when the output is disabled, such as in &#8220;express&#8221; mode. Thus,
one can write code like this:

<p>
<pre class="cpp">
if (!getEnvir()-&gt;isLoggingEnabled())
    EV_DEBUG &lt;&lt; "CRC: " &lt;&lt; computeExpensiveCRC(packet) &lt;&lt; endl;
</pre>

<p>


<p><h2><a name="sec:sim-lib:random-number-generators"/>7.3 Random Number Generators<a class="headerlink" href="#sec:sim-lib:random-number-generators" title="Permalink to this headline"></a></h2>

<p>Random numbers in simulation are usually not really random. Rather, they
are produced using deterministic algorithms. Based on some internal state,
the algorithm performs some deterministic computation to produce a
&#8220;random&#8221; number and the next state. Such algorithms and their
implementations are called <i>random number generators</i> or RNGs, or
sometimes pseudo random number generators or PRNGs to highlight their
deterministic nature. The algorithm's internal state is usually initialized
from a smaller <i>seed</i> value.

<p>Starting from the same seed, RNGs always produce the same sequence of
random numbers. This is a useful property and of great importance, because
it makes simulation runs repeatable.

<p>RNGs are rarely used directly, because they produce uniformly distributed
random numbers. When non-uniform random numbers are needed, mathematical
transformations are used to produce random numbers from RNG input that
correspond to specific distributions. This is called random variate
generation, and it will be covered in the next section,
<a href="#sec:sim-lib:random-variate-generation">[7.4]</a>.

<p>It is often advantageous for simulations to use random numbers from
multiple RNG instances. For example, a wireless network simulation may use
one RNG for generating traffic, and another RNG for simulating transmission
errors in the noisy wireless channel. Since seeds for individual RNGs can
be configured independently, this arrangement allows one e.g. to perform
several simulation runs with the same traffic but with bit errors occurring
in different places. A simulation technique called <i>variance
reduction</i> is also related to the use of different random number streams.
OMNeT++ makes it easy to use multiple RNGs in various flexible configurations.

<p>When assigning seeds, it is important that different RNGs and also
different simulation runs use non-overlapping series of random numbers.
Overlap in the generated random number sequences can introduce unwanted
correlation in the simulation results.

<p><h3><a name="sec:sim-lib:rngs"/>7.3.1 RNG Implementations<a class="headerlink" href="#sec:sim-lib:rngs" title="Permalink to this headline"></a></h3>

<p>OMNeT++ comes with the following RNG implementations.

<p><h4><a name="sec:sim-lib:mersenne-twister"/>7.3.1.1 Mersenne Twister<a class="headerlink" href="#sec:sim-lib:mersenne-twister" title="Permalink to this headline"></a></h4>

<p>By default, OMNeT++ uses the Mersenne Twister RNG (MT) by M. Matsumoto and
T. Nishimura [<a href="#bib-Matsumoto98">Matsumoto98</a>]. MT has a period of <i>2<sup>19937</sup>-1</i>,
and 623-dimensional equidistribution property is assured. MT is
also very fast: as fast or faster than ANSI C's <tt>rand()</tt>.

<p><h4><a name="sec:sim-lib:minimal-standard-rng"/>7.3.1.2 The "Minimal Standard" RNG<a class="headerlink" href="#sec:sim-lib:minimal-standard-rng" title="Permalink to this headline"></a></h4>

<p>OMNeT++ releases prior to 3.0 used a linear congruential generator
(LCG) with a cycle length of <i>2<sup>31</sup>-2</i>, described in
[<a href="#bib-Jain91">Jain91</a>], pp. 441-444,455. This RNG is still available
and can be selected from <tt>omnetpp.ini</tt> (Chapter <a href="#cha:run-sim">[11]</a>).
This RNG is only suitable for small-scale simulation studies.
As shown by Karl Entacher et al. in [<a href="#bib-Entacher02">Entacher02</a>],
the cycle length of about <i>2<sup>31</sup></i> is too small (on todays
fast computers it is easy to exhaust all random numbers), and
the structure of the generated &#8220;random&#8221; points is too regular.
The [<a href="#bib-Hellekalek98">Hellekalek98</a>] paper provides a broader overview of issues
associated with RNGs used for simulation, and it is well worth reading.
It also contains useful links and references on the topic.

<p><h4><a name="sec:sim-lib:akaroa-rng"/>7.3.1.3 The Akaroa RNG<a class="headerlink" href="#sec:sim-lib:akaroa-rng" title="Permalink to this headline"></a></h4>

<p>When a simulation is executed under Akaroa control (see section
<a href="#sec:run-sim:akaroa">[11.21]</a>), it is also possible to let OMNeT++ use Akaroa's
RNG. This needs to be configured in <tt>omnetpp.ini</tt> (section
<a href="#sec:config-sim:rng-config">[10.5]</a>).

<p><h4><a name="sec:sim-lib:other-rngs"/>7.3.1.4 Other RNGs<a class="headerlink" href="#sec:sim-lib:other-rngs" title="Permalink to this headline"></a></h4>

<p>OMNeT++ allows plugging in your own RNGs as well. This mechanism,
based on the <tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt> interface, is described in section
<a href="#sec:plugin-exts:rng">[17.5]</a>.
For example, one candidate to include could be L'Ecuyer's CMRG [<a href="#bib-LEcuyer02">LEcuyer02</a>]
which has a period of about <i>2<sup>191</sup></i> and can provide a large
number of <i>guaranteed</i> independent streams.

<p>
<h3><a name="sec:sim-lib:global-and-component-local-rngs"/>7.3.2 Global and Component-Local RNGs<a class="headerlink" href="#sec:sim-lib:global-and-component-local-rngs" title="Permalink to this headline"></a></h3>

<p>OMNeT++ can be configured to make several RNGs available for the simulation
model. These <i>global</i> or <i>physical</i> RNGs are numbered from
<i>0</i> to <i>numRNGs-1</i>, and can be seeded independently.

<p>However, usually model code doesn't directly work with those RNGs. Instead,
there is an indirection step introduced for additional flexibility. When
random numbers are drawn in a model, the code usually refers to
<i>component-local</i> or <i>logical</i> RNG numbers. These
local RNG numbers are mapped to global RNG indices to arrive at
actual RNG instances. This mapping occurs on per-component basis. That is,
each module and channel object contains a mapping table similar to the
following:

<p><center>
<table>
<TR> <TD align=center> Local RNG index </TD> <TD align=center>               </TD> <TD align=center> Global RNG </TD></TR>
<TR> <TD align=center>               0 </TD> <TD align=center> <i>--></i> </TD> <TD align=center> 0 </TD></TR>
<TR> <TD align=center>               1 </TD> <TD align=center> <i>--></i> </TD> <TD align=center> 0 </TD></TR>
<TR> <TD align=center>               2 </TD> <TD align=center> <i>--></i> </TD> <TD align=center> 2 </TD></TR>
<TR> <TD align=center>               3 </TD> <TD align=center> <i>--></i> </TD> <TD align=center> 1 </TD></TR>
<TR> <TD align=center>               4 </TD> <TD align=center> <i>--></i> </TD> <TD align=center> 1 </TD></TR>
<TR> <TD align=center>               5 </TD> <TD align=center> <i>--></i> </TD> <TD align=center> 3 </TD></TR>
</table>
</center>

<p>In the example, the module or channel in question has 6 local (logical)
RNGs that map to 4 global (physical) RNGs.

<p><ul class="note"><b>NOTE</b><br>
Local RNG number 0 is special in the sense that all random number functions
use that RNG, unless explicitly told otherwise by specifying an <i>rng=k</i>
argument.
</ul>

<p>The local-to-global mapping, as well as the number of number of global
RNGs and their seeding can be configured in <tt>omnetpp.ini</tt> (see
section <a href="#sec:config-sim:rng-config">[10.5]</a>).

<p>The mapping can be set up arbitrarily, with the default being identity
mapping (that is, local RNG <i>k</i> refers to global RNG <i>k</i>.) The mapping
allows for flexibility in RNG and random number streams configuration
-- even for simulation models which were not written with RNG awareness.
For example, even if modules in a simulation only use the default, local
RNG number 0, one can set up mapping so that different groups of modules
use different physical RNGs.

<p>In theory, RNGs could also be instantiated and used directly from C++ model
code. However, doing so is not recommended, because the model would lose
configurability via <tt>omnetpp.ini</tt>.

<p><h3><a name="sec:sim-lib:accessing-rngs"/>7.3.3 Accessing the RNGs<a class="headerlink" href="#sec:sim-lib:accessing-rngs" title="Permalink to this headline"></a></h3>

<p>RNGs are represented with subclasses of the abstract class <tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt>.
In addition to random number generation methods like <tt>intRand()</tt> and
<tt>doubleRand()</tt>, the <tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt> interface also includes methods like
<tt>selfTest()</tt> for basic integrity checking and <tt>getNumbersDrawn()</tt>
to query the number of random numbers generated.

<p>RNGs can be accessed by local RNG number via <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>'s
<tt>getRNG(k)</tt> method. To access global global RNGs directly by their
indices, one can use <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>'s <tt>getRNG(k)</tt> method.
However, RNGs rarely need to be accessed directly. Most simulations will
only use them via random variate generation functions, described in the
next section.

<p>
<h2><a name="sec:sim-lib:random-variate-generation"/>7.4 Generating Random Variates<a class="headerlink" href="#sec:sim-lib:random-variate-generation" title="Permalink to this headline"></a></h2>

<p>Random numbers produced by RNGs are uniformly distributed. This section
describes how to obtain streams of non-uniformly distributed random numbers
from various distributions.

<p>The simulation library supports the following distributions:

<p><table border>
<TR> <TD align=left>
<b>Distribution</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <i><b>uniform</b>(a, b)</i> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <i><b>exponential</b>(mean)</i> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <i><b>normal</b>(mean, stddev)</i> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <i><b>truncnormal</b>(mean, stddev)</i> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <i><b>gamma_d</b>(alpha, beta)</i> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <i><b>beta</b>(alpha1, alpha2)</i> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <i><b>erlang_k</b>(k, mean)</i> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <i><b>chi_square</b>(k)</i> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <i><b>student_t</b>(i)</i> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <i><b>cauchy</b>(a, b)</i> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <i><b>triang</b>(a, b, c)</i> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <i><b>lognormal</b>(m, s)</i> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <i><b>weibull</b>(a, b)</i> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <i><b>pareto_shifted</b>(a, b, c)</i> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <i><b>intuniform</b>(a, b)</i> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <i><b>bernoulli</b>(p)</i> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <i><b>binomial</b>(n, p)</i> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <i><b>geometric</b>(p)</i> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <i><b>negbinomial</b>(n, p)</i> </TD> <TD align=left> negative binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <i><b>poisson</b>(lambda)</i> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
</table>

<p>Some notes:

<p><ul>
<li> <i>intuniform()</i> generates integers including both the lower and upper
    limit, so for example the outcome of tossing a coin could be written as
    <tt>intuniform(1,2)</tt>.
<li> <i>truncnormal()</i> is the normal distribution truncated to nonnegative
    values; its implementation generates a number with normal distribution and
    if the result is negative, it keeps generating other numbers until the
    outcome is nonnegative.
</ul>

<p>There are several ways to generate random numbers from these distributions,
as described in the next sections.

<p><h3><a name="sec:sim-lib:random-variate-component-methods"/>7.4.1 Component Methods<a class="headerlink" href="#sec:sim-lib:random-variate-component-methods" title="Permalink to this headline"></a></h3>

<p>The preferred way is to use methods defined on <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>, the
common base class of modules and channels:

<pre class="cpp">
double uniform(double a, double b, int rng=0) const;
double exponential(double mean, int rng=0) const;
double normal(double mean, double stddev, int rng=0) const;
...
</pre>
<p>
These methods work with the component's local RNGs, and accept the RNG
index (default 0) in their extra <tt>int</tt> parameter.

<p>Since most simulation code is located in methods of simple modules, these
methods can be usually called in a concise way, without an explicit module
or channel pointer. An example:

<pre class="cpp">
scheduleAt(simTime() + exponential(1.0), msg);
</pre>
<p>
There are two additional methods, <tt>intrand()</tt> and <tt>dblrand()</tt>.
<tt>intrand(n)</tt> generates random integers in the range <i>[0, n-1]</i>, and
<tt>dblrand()</tt> generates a random double on <i>[0,1)</i>. They also accept
an additional local RNG index that defaults to 0.

<p><h3><a name="sec:sim-lib:random-number-stream-classes"/>7.4.2 Random Number Stream Classes<a class="headerlink" href="#sec:sim-lib:random-number-stream-classes" title="Permalink to this headline"></a></h3>

<p>It is sometimes useful to be able to pass around random variate generators
as objects. The classes <tt><a href="../api/classomnetpp_1_1cUniform.html">cUniform</a></tt>, <tt><a href="../api/classomnetpp_1_1cExponential.html">cExponential</a></tt>,
<tt><a href="../api/classomnetpp_1_1cNormal.html">cNormal</a></tt>, etc. fulfill this need.

<p>These classes subclass from the <tt><a href="../api/classomnetpp_1_1cRandom.html">cRandom</a></tt> abstract class.
<tt><a href="../api/classomnetpp_1_1cRandom.html">cRandom</a></tt> was designed to encapsulate random number streams. Its
most important method is <tt>draw()</tt> that returns a new random number
from the stream. <tt><a href="../api/classomnetpp_1_1cUniform.html">cUniform</a></tt>, <tt><a href="../api/classomnetpp_1_1cExponential.html">cExponential</a></tt> and other classes
essentially bind the distribution's parameters and an RNG to the generation
function.

<p>
  <center>
    <img src="crandom-inheritance.svg">
    <center><div class="caption"><i>Figure: Random number stream classes</i></div></center>
  </center>

<p>
Let us see for example <tt><a href="../api/classomnetpp_1_1cNormal.html">cNormal</a></tt>. The constructor expects an RNG
(<tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt> pointer) and the parameters of the distribution, mean and
standard deviation. It also has a default constructor, as it is a
requirement for <tt>Register_Class()</tt>. When the default constructor
is used, the parameters can be set with <tt>setRNG()</tt>, <tt>setMean()</tt>
and <tt>setStddev()</tt>. <tt>setRNG()</tt> is defined on <tt><a href="../api/classomnetpp_1_1cRandom.html">cRandom</a></tt>.
The <tt>draw()</tt> method, of course, is redefined to return a random
number from the normal distribution.

<p>An example that shows the use of a random number stream as an object:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cNormal.html">cNormal</a> *normal = new <a href="../api/classomnetpp_1_1cNormal.html">cNormal</a>(getRNG(0), 0, 1); // unit normal distr.
printRandomNumbers(normal, 10);
...

void printRandomNumbers(<a href="../api/classomnetpp_1_1cRandom.html">cRandom</a> *rand, int n)
{
    EV &lt;&lt; "Some numbers from a " &lt;&lt; rand-&gt;getClassName() &lt;&lt; ":" &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        EV &lt;&lt; rand-&gt;draw() &lt;&lt; endl;
}
</pre>
<p>
Another important property of <tt><a href="../api/classomnetpp_1_1cRandom.html">cRandom</a></tt> is that it can encapsulate
state. That is, subclasses can be implemented that, for example, return
autocorrelated numbers, numbers from a stochastic process, or simply
elements of a stored sequence (e.g. one loaded from a trace file).

<p><h3><a name="sec:sim-lib:random-variate-generator-functions"/>7.4.3 Generator Functions<a class="headerlink" href="#sec:sim-lib:random-variate-generator-functions" title="Permalink to this headline"></a></h3>

<p>Both the <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt> methods and the random number stream classes
described above have been implemented with the help of standalone generator
functions. These functions take a <tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt> pointer as their first
argument.

<pre class="cpp">
double uniform(<a href="../api/classomnetpp_1_1cRNG.html">cRNG</a> *rng, double a, double b);
double exponential(<a href="../api/classomnetpp_1_1cRNG.html">cRNG</a> *rng, double mean);
double normal(<a href="../api/classomnetpp_1_1cRNG.html">cRNG</a> *rng, double mean, double stddev);
...
</pre>
<p>
<h3><a name="sec:sim-lib:random-numbers-from-histograms"/>7.4.4 Random Numbers from Histograms<a class="headerlink" href="#sec:sim-lib:random-numbers-from-histograms" title="Permalink to this headline"></a></h3>

<p>One can also specify a distribution as a histogram<!--distribution!as histogram-->.
The <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>, <tt><a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a></tt> and <tt><a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a></tt> classes
can be used to generate random numbers from histograms. This feature is
documented later, with the statistical classes.

<p><h3><a name="sec:sim-lib:adding-new-distributions"/>7.4.5 Adding New Distributions<a class="headerlink" href="#sec:sim-lib:adding-new-distributions" title="Permalink to this headline"></a></h3>

<p>One can easily add support for new distributions. We recommend that
you write a standalone generator function first. Then you can add
a <tt><a href="../api/classomnetpp_1_1cRandom.html">cRandom</a></tt> subclass that wraps it, and/or module (channel)
methods that invoke it with the module's local RNG.
If the function is registered with the <tt>Define_NED_Function()</tt>
macro (see <a href="#sec:sim-lib:defining-ned-functions">[7.11]</a>), it will be
possible to use the new distribution in NED files and ini files, as well.

<p>If you need a random number stream that has state, you need to
subclass from <tt><a href="../api/classomnetpp_1_1cRandom.html">cRandom</a></tt>.

<p>
<h2><a name="sec:sim-lib:container-classes"/>7.5 Container Classes<a class="headerlink" href="#sec:sim-lib:container-classes" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:sim-lib:cqueue"/>7.5.1 Queue class: <a href="../api/classomnetpp_1_1cQueue.html">cQueue</a><a class="headerlink" href="#sec:sim-lib:cqueue" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:sim-lib:cqueue-basic-usage"/>7.5.1.1 Basic Usage<a class="headerlink" href="#sec:sim-lib:cqueue-basic-usage" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> is a container class that acts as a queue.
<tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> can hold objects of type derived from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>
(almost all classes from the OMNeT++ library), such as
<tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>, <tt><a href="../api/classomnetpp_1_1cPar.html">cPar</a></tt>, etc. Normally, new elements
are inserted at the back, and removed from the front.

<p>
  <center>
    <img src="simlib-queue.svg">
    <center><div class="caption"><i>Figure: <a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>: insertion and removal</i></div></center>
    <a name="fig:ch-sim-lib:cqueue"></a>
  </center>

<p>
The member functions dealing with insertion and removal are
<tt>insert()</tt> and <tt>pop()</tt>.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a> queue("my-queue");
<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg;

// insert messages
for (int i = 0; i &lt; 10; i++) {
    msg = new <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>;
    queue.insert(msg);
}

// remove messages
while(!queue.isEmpty()) {
    msg = (<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *)queue.pop();
    delete msg;
}
</pre>
<p>
The <tt>length()</tt> member function returns the number of items in the
queue, and <tt>empty()</tt> tells whether there is anything in the queue.

<p>There are other functions dealing with insertion and removal.  The
<tt>insertBefore()</tt> and <tt>insertAfter()</tt> functions insert a
new item exactly before or after a specified one, regardless of the
ordering function.

<p>The <tt>front()</tt> and <tt>back()</tt> functions return pointers to the objects
at the front and back of the queue, without affecting queue contents.

<p>The <tt>pop()</tt> function can be used to remove items from the
tail of the queue, and the <tt>remove()</tt> function can be
used to remove any item known by its pointer from the queue:

<pre class="cpp">
queue.remove(msg);
</pre>
<p>

<p><h4><a name="sec:sim-lib:cqueue-as-priority-queue"/>7.5.1.2 Priority Queue<a class="headerlink" href="#sec:sim-lib:cqueue-as-priority-queue" title="Permalink to this headline"></a></h4>

<p>By default, <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> implements a FIFO, but it can also act as a
priority queue, that is, it can keep the inserted objects
ordered<!--queue!order-->.  To use this feature, one needs to provide a
comparison function that takes two <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> pointers, and returns
-1, 0 or 1 (see the reference for details).  An example of setting up an
ordered <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a> queue("queue", someCompareFunc);
</pre>
<p>
If the queue object is set up as an ordered queue, the <tt>insert()</tt>
function uses the ordering function: it searches the queue contents
from the head until it reaches the position where the new item
needs to be inserted, and inserts it there.

<p>
<h4><a name="sec:sim-lib:cqueue-iteration"/>7.5.1.3 Iterators<a class="headerlink" href="#sec:sim-lib:cqueue-iteration" title="Permalink to this headline"></a></h4>

<p>The <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>::<a href="../api/classomnetpp_1_1cQueue_1_1Iterator.html">Iterator</a></tt> class lets one iterate over the contents
of the queue and examine each object<!--queue!iteration-->.

<p>The <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>::<a href="../api/classomnetpp_1_1cQueue_1_1Iterator.html">Iterator</a></tt> constructor expects the queue object in the
first argument. Normally, forward iteration is assumed, and the iteration
is initialized to point at the front of the queue. For reverse iteration,
specify <tt>reverse=true</tt> as the optional second argument. After that, the
class acts as any other OMNeT++ iterator: one can use the <tt>++</tt> and
<tt>--</tt> operators to advance it, the <tt>*</tt> operator to get a pointer
to the current item, and the <tt>end()</tt> member function to examine
whether the iterator has reached the end (or the beginning) of the queue.

<p>Forward iteration:

<pre class="cpp">
for (<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>::<a href="../api/classomnetpp_1_1cQueue_1_1Iterator.html">Iterator</a> iter(queue); !iter.end(), iter++) {
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg = (<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *) *iter;
    //...
}
</pre>
<p>
Reverse iteration:

<pre class="cpp">
for (<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>::<a href="../api/classomnetpp_1_1cQueue_1_1Iterator.html">Iterator</a> iter(queue, true); !iter.end(), iter--) {
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg = (<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *) *iter;
    //...
}
</pre>
<p>

<p>
<h3><a name="sec:sim-lib:carray"/>7.5.2 Expandable Array: <a href="../api/classomnetpp_1_1cArray.html">cArray</a><a class="headerlink" href="#sec:sim-lib:carray" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:sim-lib:carray-basic-usage"/>7.5.2.1 Basic Usage<a class="headerlink" href="#sec:sim-lib:carray-basic-usage" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> is a container class that holds objects derived from
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>. <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> implements a dynamic-size array: its
capacity grows automatically when it becomes full. <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> stores
pointers of objects inserted instead of making copies.

<p>Creating an array:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cArray.html">cArray</a> array("array");
</pre>
<p>
Adding an object at the first free index:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a> *p = new <a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a>("par");
int index = array.add(p);
</pre>
<p>
Adding an object at a given index (if the index is occupied,
you will get an error message):

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a> *p = new <a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a>("par");
int index = array.addAt(5,p);
</pre>
<p>
Finding an object in the array:

<pre class="cpp">
int index = array.find(p);
</pre>
<p>
Getting a pointer to an object at a given index:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPar.html">cPar</a> *p = (<a href="../api/classomnetpp_1_1cPar.html">cPar</a> *) array[index];
</pre>
<p>
You can also search the array or get a pointer to an object by
the object's name:

<pre class="cpp">
int index = array.find("par");
Par *p = (<a href="../api/classomnetpp_1_1cPar.html">cPar</a> *) array["par"];
</pre>
<p>
You can remove an object from the array by calling <tt>remove()</tt>
with the object name, the index position or the object pointer:

<pre class="cpp">
array.remove("par");
array.remove(index);
array.remove(p);
</pre>
<p>

<p>The <tt>remove()</tt> function doesn't deallocate the object, but it
returns the object pointer. If you also want to deallocate it, you can
write:

<pre class="cpp">
delete array.remove(index);
</pre>
<p>
<h4><a name="sec:sim-lib:carray-iteration"/>7.5.2.2 Iteration<a class="headerlink" href="#sec:sim-lib:carray-iteration" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> has no iterator, but it is easy to loop through all the
indices with an integer variable. The <tt>size()</tt> member function
returns the largest index plus one.

<pre class="cpp">
for (int i = 0; i &lt; array.size(); i++) {
  if (array[i]) { // is this position used?
    <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *obj = array[i];
    EV &lt;&lt; obj-&gt;getName() &lt;&lt; endl;
  }
}
</pre>
<p>



<p><h2><a name="sec:sim-lib:ctopology"/>7.6 Routing Support: <a href="../api/classomnetpp_1_1cTopology.html">cTopology</a><a class="headerlink" href="#sec:sim-lib:ctopology" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:sim-lib:ctopology-overview"/>7.6.1 Overview<a class="headerlink" href="#sec:sim-lib:ctopology-overview" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> class was designed primarily to support
routing<!--routing support--> in communication networks.

<p>A <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> object stores an abstract representation of the
network in a graph form:
<ul>
  <li> each <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> node corresponds to a <i>module</i>
    (simple or compound), and
  <li> each <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> edge corresponds to a <i>link</i> or
    <i>series of connecting links</i>.
</ul>

<p>One can specify which modules to include in the graph. Compound modules
may also be selected. The graph will include all connections among the
selected modules. In the graph, all nodes are at the same level;
there is no submodule nesting.  Connections which span across compound
module boundaries are also represented as one graph edge. Graph edges
are directed, just as module gates are.

<p>If you are writing a router or switch model, the <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt>
graph can help you determine what nodes are available through which
gate and also to find optimal routes<!--optimal routes-->. The
<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> object can calculate shortest paths<!--shortest
  path--> between nodes for you.

<p>The mapping between the graph (nodes, edges) and network model (modules,
gates, connections) is preserved: one can find the corresponding module for
a <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> node and vice versa.

<p>
<h3><a name="sec:sim-lib:ctopology-basic-usage"/>7.6.2 Basic Usage<a class="headerlink" href="#sec:sim-lib:ctopology-basic-usage" title="Permalink to this headline"></a></h3>

<p>One can extract the network topology into a <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt>
object with a single method call. There are several ways to specify
which modules should be included in the topology:

<p><ul>
  <li> by module type
  <li> by a parameter's presence and value
  <li> with a user-supplied boolean function
</ul>

<p>First, you can specify which node types you want to include. The
following code extracts all modules of type <tt>Router</tt> or <tt>Host</tt>.
(<tt>Router</tt> and <tt>Host</tt> can be either simple or compound module types.)

<pre class="cpp">
<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a> topo;
topo.extractByModuleType("Router", "Host", nullptr);
</pre>
<p>
Any number of module types can be supplied; the list must be terminated by <tt>nullptr</tt>.

<p>A dynamically assembled list of module types can be passed as a
<tt>nullptr</tt>-terminated array of <tt>const char*</tt> pointers, or
in an STL string vector <tt>std::vector&lt;std::string&gt;</tt>.
An example for the former:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a> topo;
const char *typeNames[3];
typeNames[0] = "Router";
typeNames[1] = "Host";
typeNames[2] = nullptr;
topo.extractByModuleType(typeNames);
</pre>
<p>
Second, you can extract all modules which have a certain parameter:

<pre class="cpp">
topo.extractByParameter("ipAddress");
</pre>
<p>
You can also specify that the parameter must have a certain value
for the module to be included in the graph:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMsgPar.html">cMsgPar</a> yes = "yes";
topo.extractByParameter("includeInTopo", &yes);
</pre>
<p>
The third form allows you to pass a function which can determine for
each module whether it should or should not be included.  You can have
<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> pass supplemental data to the function through a
<tt>void*</tt> pointer. An example which selects all top-level modules (and
does not use the <tt>void*</tt> pointer):

<pre class="cpp">
int selectFunction(<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod, void *)
{
  return mod-&gt;getParentModule() == getSimulation()-&gt;getSystemModule();
}

topo.extractFromNetwork(selectFunction, nullptr);
</pre>
<p>

A <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> object uses two types: <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> for
nodes and <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Link.html">Link</a></tt> for edges. (<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1LinkIn.html">LinkIn</a></tt> and
<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1LinkOut.html">LinkOut</a></tt> are aliases for <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Link.html">Link</a></tt>; we'll
talk about them later.)

<p>Once you have the topology extracted, you can start exploring
it. Consider the following code (we'll explain it shortly):

<pre class="cpp">
for (int i = 0; i &lt; topo.getNumNodes(); i++) {
  <a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *node = topo.getNode(i);
  EV &lt;&lt; "<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> i=" &lt;&lt; i &lt;&lt; " is " &lt;&lt; node-&gt;getModule()-&gt;getFullPath() &lt;&lt; endl;
  EV &lt;&lt; " It has " &lt;&lt; node-&gt;getNumOutLinks() &lt;&lt; " conns to other nodes\n";
  EV &lt;&lt; " and " &lt;&lt; node-&gt;getNumInLinks() &lt;&lt; " conns from other nodes\n";

  EV &lt;&lt; " Connections to other modules are:\n";
  for (int j = 0; j &lt; node-&gt;getNumOutLinks(); j++) {
    <a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *neighbour = node-&gt;getLinkOut(j)-&gt;getRemoteNode();
    <a href="../api/classomnetpp_1_1cGate.html">cGate</a> *gate = node-&gt;getLinkOut(j)-&gt;getLocalGate();
    EV &lt;&lt; " " &lt;&lt; neighbour-&gt;getModule()-&gt;getFullPath()
       &lt;&lt; " through gate " &lt;&lt; gate-&gt;getFullName() &lt;&lt; endl;
  }
}
</pre>
<p>
The <tt>getNumNodes()</tt> member function returns the number of
nodes in the graph, and <tt>getNode(i)</tt> returns a pointer to the <i>i</i>th
node, a <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> structure.

<p>The correspondence between a graph node and a module can be obtained
by <tt>getNodeFor()</tt> method:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *node = topo.getNodeFor(module);
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *module = node-&gt;getModule();
</pre>
<p>
The <tt>getNodeFor()</tt> member function returns a pointer to the graph
node for a given module. (If the module is not in the graph, it
returns <tt>nullptr</tt>). <tt>getNodeFor()</tt> uses binary search within the
<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> object so it is relatively fast.

<p><tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>'s other member functions let you determine the
connections of this node: <tt>getNumInLinks()</tt>, <tt>getNumOutLinks()</tt> return
the number of connections, <tt>getLinkIn(i)</tt> and
<tt>getLinkOut(i)</tt> return pointers to graph edge objects.

<p>By calling member functions of the graph edge object, you can
determine the modules and gates involved. The <tt>getRemoteNode()</tt>
function returns the other end of the connection, and
<tt>getLocalGate()</tt>, <tt>getRemoteGate()</tt>, <tt>getLocalGateId()</tt> and
<tt>getRemoteGateId()</tt> return the gate pointers and ids of the gates
involved. (Actually, the implementation is a bit tricky here: the same
graph edge object <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Link.html">Link</a></tt> is returned either as
<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1LinkIn.html">LinkIn</a></tt> or as <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1LinkOut.html">LinkOut</a></tt> so that &#8220;remote&#8221;
and &#8220;local&#8221; can be correctly interpreted for edges of both
directions.)

<p>
<h3><a name="sec:sim-lib:ctopology-shortest-paths"/>7.6.3 Shortest Paths<a class="headerlink" href="#sec:sim-lib:ctopology-shortest-paths" title="Permalink to this headline"></a></h3>

<p>The real power of <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> is in finding shortest
paths<!--topology!shortest path--> in the network to support optimal
routing<!--optimal routing-->. <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> finds shortest paths
from <i>all</i> nodes <i>to</i> a target node. The algorithm is
computationally inexpensive. In the simplest case, all edges are
assumed to have the same weight.

<p>A real-life example assumes we have the target module pointer; finding
the shortest path to the target looks like this:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *targetmodulep =...;
<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *targetnode = topo.getNodeFor(targetmodulep);
topo.calculateUnweightedSingleShortestPathsTo(targetnode);
</pre>
<p>

<p>This performs the Dijkstra algorithm<!--Dijkstra algorithm--> and
stores the result in the <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> object. The result can
then be extracted using <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> and
<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt><!--<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>--> methods.  Naturally, each call to
<tt>calculateUnweightedSingleShortestPathsTo()</tt> overwrites the results of
the previous call.

<p>Walking along the path from our module to the target node:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *node = topo.getNodeFor(this);

if (node == nullptr) {
  EV &lt;&lt; "We (" &lt;&lt; getFullPath() &lt;&lt; ") are not included in the topology.\n";
}
else if (node-&gt;getNumPaths()==0) {
  EV &lt;&lt; "No path to destination.\n";
}
else {
  while (node != topo.getTargetNode()) {
    EV &lt;&lt; "We are in " &lt;&lt; node-&gt;getModule()-&gt;getFullPath() &lt;&lt; endl;
    EV &lt;&lt; node-&gt;getDistanceToTarget() &lt;&lt; " hops to go\n";
    EV &lt;&lt; "There are " &lt;&lt; node-&gt;getNumPaths()
       &lt;&lt; " equally good directions, taking the first one\n";
    <a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1LinkOut.html">LinkOut</a> *path = node-&gt;getPath(0);
    EV &lt;&lt; "Taking gate " &lt;&lt; path-&gt;getLocalGate()-&gt;getFullName()
       &lt;&lt; " we arrive in " &lt;&lt; path-&gt;getRemoteNode()-&gt;getModule()-&gt;getFullPath()
       &lt;&lt; " on its gate " &lt;&lt; path-&gt;getRemoteGate()-&gt;getFullName() &lt;&lt; endl;
    node = path-&gt;getRemoteNode();
  }
}
</pre>
<p>
The purpose of the <tt>getDistanceToTarget()</tt> member function of a
node is self-explanatory. In the unweighted case, it returns the
number of hops. The <tt>getNumPaths()</tt> member function returns the number
of edges which are part of a shortest path, and
<tt>path(i)</tt> returns the <i>i</i>th edge of them as
<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1LinkOut.html">LinkOut</a></tt>. If the shortest paths were created by the
<tt>...SingleShortestPaths()</tt> function,
<tt>getNumPaths()</tt> will always return 1 (or 0 if the target is not
reachable), that is, only one of the several possible shortest paths
are found.  The
<tt>...MultiShortestPathsTo()</tt> functions
find all paths, at increased run-time cost. The <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt>'s
<tt>getTargetNode()</tt> function returns the target node of the last
shortest path search.

<p>You can enable/disable nodes or edges in the graph. This is done by
calling their <tt>enable()</tt> or <tt>disable()</tt> member functions.
Disabled nodes or edges are ignored by the shortest paths calculation
algorithm. The <tt>isEnabled()</tt> member function returns the state of
a node or edge in the topology graph.

<p>One usage of <tt>disable()</tt> is when you want to determine in how many
hops the target node can be reached from our node <i>through
a particular output gate</i>. To compute this, you compute the
shortest paths to the target <i>from the neighbor node</i> while
disabling the current node to prevent the shortest paths
from going through it:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *thisnode = topo.getNodeFor(this);
thisnode-&gt;disable();
topo.calculateUnweightedSingleShortestPathsTo(targetnode);
thisnode-&gt;enable();

for (int j = 0; j &lt; thisnode-&gt;getNumOutLinks(); j++) {
  <a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1LinkOut.html">LinkOut</a> *link = thisnode-&gt;getLinkOut(i);
  EV &lt;&lt; "Through gate " &lt;&lt; link-&gt;getLocalGate()-&gt;getFullName() &lt;&lt; " : "
     &lt;&lt; 1 + link-&gt;getRemoteNode()-&gt;getDistanceToTarget() &lt;&lt; " hops" &lt;&lt; endl;
}
</pre>
<p>
In the future, other shortest path algorithms will also be implemented:

<pre class="cpp">
unweightedMultiShortestPathsTo(<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *target);
weightedSingleShortestPathsTo(<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *target);
weightedMultiShortestPathsTo(<a href="../api/classomnetpp_1_1cTopology.html">cTopology</a>::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *target);
</pre>
<p>
<h3><a name="sec:sim-lib:ctopology-manipulating"/>7.6.4 Manipulating the graph<a class="headerlink" href="#sec:sim-lib:ctopology-manipulating" title="Permalink to this headline"></a></h3>

<p><tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> also has methods that let one manipulate the stored graph,
or even, build a graph from scratch. These methods are <tt>addNode()</tt>,
<tt>deleteNode()</tt>, <tt>addLink()</tt> and <tt>deleteLink()</tt>.

<p>When extracting the topology from the network, <tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> uses
the factory methods <tt>createNode()</tt> and <tt>createLink()</tt> to instantiate
the node and link objects. These methods may be overridden by subclassing
<tt><a href="../api/classomnetpp_1_1cTopology.html">cTopology</a></tt> if the need arises, for example when it is useful to be
able to store additional information in those objects.

<p>
<h2><a name="sec:sim-lib:pattern-matching"/>7.7 Pattern Matching<a class="headerlink" href="#sec:sim-lib:pattern-matching" title="Permalink to this headline"></a></h2>

<p>Since version 4.3, OMNeT++ contains two utility classes for pattern
matching, <tt><a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a></tt> and <tt><a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a></tt>.

<p><tt><a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a></tt> is a glob-style pattern matching class, adopted to
special OMNeT++ requirements. It recognizes wildcards, character ranges and
numeric ranges, and supports options such as case sensitive and whole
string matching. <tt><a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a></tt> builds on top of
<tt><a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a></tt> and extends it in two ways: first, it lets you
combine patterns with AND, OR, NOT into boolean expressions, and second, it
applies the pattern expressions to <i>objects</i> instead of text. These
classes are especially useful for making model-specific configuration files
more concise or more powerful by introducing patterns.

<p>

<p><h3><a name="sec:sim-lib:cpatternmatcher"/>7.7.1 <a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a><a class="headerlink" href="#sec:sim-lib:cpatternmatcher" title="Permalink to this headline"></a></h3>

<p><tt><a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a></tt> holds a pattern string and several option flags,
and has a <tt>matches()</tt> boolean function that determines whether the
string passed as argument matches the pattern with the given flags. The
pattern and the flags can be set via the constructor or by calling the
<tt>setPattern()</tt> member function.

<p>The pattern syntax is a variation on Unix <i>glob</i>-style patterns. The
most apparent differences to globbing rules are the distinction between
<tt>*</tt> and <tt>**</tt>, and that character ranges should be written with
curly braces instead of square brackets; that is, <i>any-letter</i> is
expressed as <tt>{a-zA-Z}</tt> and not as <tt>[a-zA-Z]</tt>, because square
brackets are reserved for the notation of module vector indices.

<p>The following option flags are supported:

<p><ul>
  <li> <i>dottedpath</i>: controls whether some wildcards (<tt>?</tt>, <tt>*</tt>) will match dots
  <li> <i>fullstring</i>: controls whether to do full string or substring match.
  <li> <i>casesensitive</i>: whether matching is case sensitive or case insensitive
</ul>

<p>Patterns may contain the following elements:

<p><ul>
  <li> <i>question mark</i>, <tt>?</tt> : matches any character (except dot if <i>dottedpath</i>=true)
  <li> <i>asterisk</i>, <tt>*</tt> : matches zero or more characters (except dots if <i>dottedpath</i>=true)
  <li> <i>double asterisk</i>, <tt>**</tt> : matches zero or more characters, including dots
  <li> <i>set</i>, e.g. <tt>{a-zA-Z}</tt> : matches any character that is contained in the set
  <li> <i>negated set</i>, e.g. <tt>{^a-z}</tt>: matches any character that is NOT contained in the set
  <li> <i>numeric range</i>, e.g. <tt>{38..150}</tt> : matches any number (i.e. sequence of digits) in the given range
  <li> <i>numeric index range</i>, e.g. <tt>[38..150]</tt> : matches any number in square brackets in the given range
  <li> <i>backslash</i>, \ : takes away the special meaning of the subsequent character
</ul>

<p><ul class="note"><b>NOTE</b><br>
The <i>dottedpath</i> option was introduced to make matching OMNeT++
module paths more powerful. When it is off (<i>dottedpath</i>=false),
there is no difference between <tt>*</tt> and <tt>**</tt>, they both match any
character sequence. However, when matching OMNeT++ module paths or other
strings where dot is a separator character, it is useful to turn on the
dottedpath mode (<i>dottedpath</i>=true). In that mode, <tt>*</tt>, not
being able to cross a dot, can match only a single path component (or part
of it), and <tt>**</tt> can match multiple path components.
</ul>

<p>Sets and negated sets can contain several character ranges and also
enumeration of characters, for example <tt>{_a-zA-Z0-9}</tt> or
<tt>{xyzc-f}</tt>. To include a hyphen in the set, place it at a position
where it cannot be interpreted as character range, for example
<tt>{a-z-}</tt> or <tt>{-a-z}</tt>. To include a close brace in
the set, it must be the first character: <tt>{}a-z}</tt>, or for a negated
set: <tt>{^}a-z}</tt>. A backslash is always taken as
literal backslash (and NOT as escape character) within set definitions.
When doing case-insensitive match, avoid ranges that include both alpha and
non-alpha characters, because they might cause funny results.

<p>For numeric ranges and numeric index ranges, ranges are inclusive, and both
the start and the end of the range are optional; that is, <tt>{10..}</tt>,
<tt>{..99}</tt> and <tt>{..}</tt> are all valid numeric ranges (the last one
matches any number). Only nonnegative integers can be matched. Caveat:
<tt>{17..19}</tt> will match <tt>"a17"</tt>, <tt>"117"</tt> and also <tt>"963217"</tt>!

<p>The <tt><a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a></tt> constructor and the <tt>setPattern()</tt> member
function have similar signatures:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a>(const char *pattern, bool dottedpath, bool fullstring,
                bool casesensitive);
void setPattern(const char *pattern, bool dottedpath, bool fullstring,
                bool casesensitive);
</pre>
<p>
The matcher function:

<pre class="cpp">
bool matches(const char *text);
</pre>
<p>
There are also some more utility functions for printing the pattern,
determining whether a pattern contains wildcards, etc.

<p>Example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a> matcher("**.host[*]", true, true, true);
EV &lt;&lt; matcher.matches("Net.host[0]") &lt;&lt; endl;  // -&gt; true
EV &lt;&lt; matcher.matches("Net.area1.host[0]") &lt;&lt; endl;  // -&gt; true
EV &lt;&lt; matcher.matches("Net.host") &lt;&lt; endl;  // -&gt; false
EV &lt;&lt; matcher.matches("Net.host[0].tcp") &lt;&lt; endl;  // -&gt; false
</pre>
<p>

<p><h3><a name="sec:sim-lib:cmatchexpression"/>7.7.2 <a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a><a class="headerlink" href="#sec:sim-lib:cmatchexpression" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a></tt> class builds on top of <tt><a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a></tt>,
and lets one determine whether an <i>object</i> matches a given pattern
expression.

<p>A pattern expression consists of elements in the
<i>fieldname(pattern)</i> syntax; they check whether the string
representation of the given field of the object matches the pattern. For
example, <tt>srcAddr(192.168.0.*)</tt> will match if the <i>srcAddr</i>
field of the object starts with <tt>192.168.0.</tt> A naked pattern (without
field name and parens) is also accepted, and it will be matched against the
<i>default field</i> of the object, which will usually be its name.

<p>These elements can be combined with the AND, OR, NOT operators, accepted in
both lowercase and uppercase. AND has higher precedence than OR, but
parentheses can be used to change the evaluation order.

<p>Pattern examples:

<p><ul>
 <li> <tt>"node*"</tt>
 <li> <tt>"node* or host*"</tt>
 <li> <tt>"packet-* and className(PPPFrame)"</tt>
 <li> <tt>"className(TCPSegment) and byteLength({4096..})"</tt>
 <li> <tt>"className(TCPSegment) and (SYN or DATA-*) and not kind({0..2})"</tt>
</ul>

<p>The <tt><a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a></tt> class has a constructor and <tt>setPattern()</tt>
method similar to those of <tt><a href="../api/classomnetpp_1_1cPatternMatcher.html">cPatternMatcher</a></tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a>(const char *pattern, bool dottedpath, bool fullstring,
                bool casesensitive);
void setPattern(const char *pattern, bool dottedpath, bool fullstring,
                bool casesensitive);
</pre>
<p>
However, the matcher function takes a <tt><a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a>::<a href="../api/classomnetpp_1_1cMatchExpression_1_1Matchable.html">Matchable</a></tt>
instead of string:

<pre class="cpp">
bool matches(const <a href="../api/classomnetpp_1_1cMatchExpression_1_1Matchable.html">Matchable</a> *object);
</pre>
<p>
This means that objects to be matched must either be subclassed from
<tt><a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a>::<a href="../api/classomnetpp_1_1cMatchExpression_1_1Matchable.html">Matchable</a></tt>, or be wrapped into some adapter class
that does. <tt><a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a>::<a href="../api/classomnetpp_1_1cMatchExpression_1_1Matchable.html">Matchable</a></tt> is a small abstract class
with only a few pure virtual functions:

<pre class="cpp">
/**
 * Objects to be matched must implement this interface
 */
class SIM_API <a href="../api/classomnetpp_1_1cMatchExpression_1_1Matchable.html">Matchable</a>
{
  public:
    /**
     * Return the default string to match. The returned pointer will not be
     * cached by the caller, so it is OK to return a pointer to a static buffer.
     */
    virtual const char *getAsString() const = 0;

    /**
     * Return the string value of the given attribute, or nullptr if the object
     * doesn't have an attribute with that name. The returned pointer will not
     * be cached by the caller, so it is OK to return a pointer to a static buffer.
     */
    virtual const char *getAsString(const char *attribute) const = 0;

    /**
     * Virtual destructor.
     */
    virtual ~<a href="../api/classomnetpp_1_1cMatchExpression_1_1Matchable.html">Matchable</a>() {}
};
</pre>
<p>
To be able to match instances of an existing class that is not already a
<tt><a href="../api/classomnetpp_1_1cMatchExpression_1_1Matchable.html">Matchable</a></tt>, one needs to write an adapter class. An adapter class that
we can look at as an example is <tt><a href="../api/classomnetpp_1_1cMatchableString.html">cMatchableString</a></tt>. <tt><a href="../api/classomnetpp_1_1cMatchableString.html">cMatchableString</a></tt>
makes it possible to match strings with a <tt><a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a></tt>, and is part
of OMNeT++:

<pre class="cpp">
/**
 * Wrapper to make a string matchable with <a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a>.
 */
class <a href="../api/classomnetpp_1_1cMatchableString.html">cMatchableString</a> : public <a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a>::<a href="../api/classomnetpp_1_1cMatchExpression_1_1Matchable.html">Matchable</a>
{
  private:
    std::string str;
  public:
    <a href="../api/classomnetpp_1_1cMatchableString.html">cMatchableString</a>(const char *s) {str = s;}
    virtual const char *getAsString() const {return str.c_str();}
    virtual const char *getAsString(const char *name) const {return nullptr;}
};
</pre>
<p>
An example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cMatchExpression.html">cMatchExpression</a> expr("foo* or bar*", true, true, true);
<a href="../api/classomnetpp_1_1cMatchableString.html">cMatchableString</a> str1("this is a foo");
<a href="../api/classomnetpp_1_1cMatchableString.html">cMatchableString</a> str2("something else");
EV &lt;&lt; expr.matches(&str1) &lt;&lt; endl; // -&gt; true
EV &lt;&lt; expr.matches(&str2) &lt;&lt; endl; // -&gt; false
</pre>
<p>
Or, by using temporaries:

<pre class="cpp">
EV &lt;&lt; expr.matches(&<a href="../api/classomnetpp_1_1cMatchableString.html">cMatchableString</a>("this is a foo")) &lt;&lt; endl; // -&gt; true
EV &lt;&lt; expr.matches(&<a href="../api/classomnetpp_1_1cMatchableString.html">cMatchableString</a>("something else")) &lt;&lt; endl; // -&gt; false
</pre>
<p>

<p><h2><a name="sec:sim-lib:statistics"/>7.8 Collecting Summary Statistics and Histograms<a class="headerlink" href="#sec:sim-lib:statistics" title="Permalink to this headline"></a></h2>

<p>There are several statistic and result collection classes:
<tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt>, <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>, <tt><a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a></tt> and
<tt><a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a></tt>. They are all derived from the abstract base class
<tt><a href="../api/classomnetpp_1_1cStatistic.html">cStatistic</a></tt>; histogram-like classes derive from 
<tt><a href="../api/classomnetpp_1_1cAbstractHistogram.html">cAbstractHistogram</a></tt>.<br><ul><font size=-1>[Earlier versions of OMNeT++ had more
statistical classes: <tt><a href="../api/classomnetpp_1_1cWeightedStdDev.html">cWeightedStdDev</a></tt>, <tt><a href="../api/classomnetpp_1_1cLongHistogram.html">cLongHistogram</a></tt>,
<tt><a href="../api/classomnetpp_1_1cDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classomnetpp_1_1cVarHistogram.html">cVarHistogram</a></tt>. The functionality
of these classes have been consolidated into <tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt> and
<tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>.]</font></ul>

<p><ul>
  <li> <tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt> keeps summary statistics (mean, standard deviation,
    range) of weighted or unweighted observations. 
  <li> <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> is for collecting observations into a histogram.
    <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> is highly configurable, suports adding/removing/merging bins
    dynamically, and can produce a good histogram from most distributions
    without requiring manual configuration.
  <li> <tt><a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a></tt> is a class that uses the <i>P<sup>2</sup></i> algorithm
    described in [<a href="#bib-JCh85">JCh85</a>]. The algorithm calculates quantiles without
    storing the observations; one can also think of it as a histogram
    with equiprobable cells<!--histogram!equiprobable-cells-->.
  <li> <tt><a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a></tt> is adaptive histogram-like algorithm
    which performs dynamic subdivision of the bins to refine resolution
    at the bulk of the distribution.
</ul>

<p>
  <center>
    <img src="cstatistic-inheritance.svg">
    <center><div class="caption"><i>Figure: Statistics classes</i></div></center>
  </center>

<p>
All classes use the <tt>double</tt> type for representing observations,
and compute all metrics in the same data type (except the observation
count, which is <tt>int64_t</tt>.)

<p>For weighted statistics, weights are also <tt>double</tt>s. Being able to
handle non-integer weights is important because weighted statistics
are often used for computing time averages, e.g. average queue length
or average channel utilization. 

<p><h3><a name="sec:sim-lib:cstatistic-and-descendants"/>7.8.1 <a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a><a class="headerlink" href="#sec:sim-lib:cstatistic-and-descendants" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt> class is meant to collect summary statistics of
observations. If you also need to compute a histogram, use <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>
(or <tt><a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a></tt>/<tt><a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a></tt>) instead, because those classes 
already include the functionality of <tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt>.

<p><tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt> can collect unweighted or weighted statistics. This needs
to be decided in the constructor call, and cannot be changed later. 
Specify <tt>true</tt> as the second argument for weighted statistics.
 
<pre class="cpp">
<a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a> unweighted("packetDelay");  // unweighted
<a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a> weighted("queueLength", true); // weighted
</pre>
<p> 
Observations are added to the statistics by using the <tt>collect()</tt>
or the <tt>collectweighted()</tt> methods. The latter takes two parameters,
the value and the weight.

<pre class="cpp">
for (double value : values)
    unweighted.collect(value);

for (double value : values2) {
    double weight = ...
    weighted.collectWeighted(value, weight);
}
</pre>
<p>
Statistics can be obtained from the object with the following methods: 
<tt>getCount()</tt>, <tt>getMin()</tt>, <tt>getMax()</tt>, <tt>getMean()</tt>, 
<tt>getStddev()</tt>, <tt>getVariance()</tt>.

<p>There are two getter methods that only work for unweighted statistics:
<tt>getSum()</tt> and <tt>getSqrSum()</tt>. Plain (unweighted) sum and 
sum of squares are not computed for weighted observations, and it is
an error to call these methods in the weighted case.

<p>Other getter methods are primarily meant for weighted statistics:
<tt>getSumWeights()</tt>, <tt>getWeightedSum()</tt>, 
<tt>getSqrSumWeights()</tt>, <tt>getWeightedSqrSum()</tt>.
When called on unweighted statistics, these methods simply
assume a weight of 1.0 for all observations.

<p>An example:

<pre class="cpp">
EV &lt;&lt; "count = " &lt;&lt; unweighted.getCount() &lt;&lt; endl;
EV &lt;&lt; "mean = " &lt;&lt; unweighted.getMean() &lt;&lt; end;
EV &lt;&lt; "stddev = " &lt;&lt; unweighted.getStddev() &lt;&lt; end;
EV &lt;&lt; "min = " &lt;&lt; unweighted.getMin() &lt;&lt; end;
EV &lt;&lt; "max = " &lt;&lt; unweighted.getMax() &lt;&lt; end;
</pre>
<p>

<p><h3><a name="sec:sim-lib:histograms"/>7.8.2 <a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a><a class="headerlink" href="#sec:sim-lib:histograms" title="Permalink to this headline"></a></h3>

<p><tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> is able to represent both uniform and non-uniform
bin histograms, and supports both weighted and unweighted observations.
The histogram can be modified dynamically: it can be extended with new bins,
and adjacent bins can be merged. In addition to the bin values (which mean
count in the unweighted case, and sum of weights in the weighted case),
the histogram object also keeps the number (or sum of weights) of the 
lower and upper outliers (&#8220;underflows&#8221; and &#8220;overflows&#8221;.) 

<p>
  <center>
    <img src="simlib-histogramsetup.svg">
    <center><div class="caption"><i>Figure: Histograms keep track of outliers as well</i></div></center>
  </center>

<p>
Setting up and managing the bins based on the collected observations
is usually delegated to a strategy object. However, for most
use cases, histogram strategies is not something the user needs
to be concerned with. The default constructor of <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>
sets up the histogram with a default strategy that usually produces
a good quality histogram without requiring manual configuration or a-priori 
knowledge about the distribution. For special use cases, there are
other histogram strategies, and it is also possible to write new ones. 

<p><h4><a name="sec:sim-lib:creating-a-histogram"/>7.8.2.1 Creating a Histogram<a class="headerlink" href="#sec:sim-lib:creating-a-histogram" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> has several constructors variants. Like with 
<tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt>, it needs to be decided in the constructor call
by a boolean argument whether the histogram should collect 
unweighted (<tt>false</tt>) or weighted (<tt>true</tt>) statistics;
the default is unweighted. Another argument is a number of bins
hint. (The actual number of bins produced might slightly differ,
due to dynamic range extensions and bin merging performed by
some strategies.)

<pre class="cpp">
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> unweighted1("packetDelay");  // unweighted
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> unweighted2("packetDelay", 10);  // unweighted, with ~10 bins
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> weighted1("queueLength", true); // weighted
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> weighted2("queueLength", 10, true); // weighted, with ~10 bins
</pre>
<p>
It is also possible to provide a strategy object in a constructor call.
(The strategy object may also be set later though, using <tt>setStrategy()</tt>.
It must be called before the first observation is collected.)

<pre class="cpp">
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> autoRangeHist("queueLength", new <a href="../api/classomnetpp_1_1cAutoRangeHistogramStrategy.html">cAutoRangeHistogramStrategy</a>());
</pre>
<p>
This constructor can also be used to create a histogram without a strategy
object, which is useful if you want to set up the histogram bins manually.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> hist("queueLength", nullptr, true); // weighted, no strategy
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> also has methods where you can provide constraints
and hints for setting up the bins: <tt>setMode()</tt>, <tt>setRange()</tt>,
<tt>setRangeExtensionFactor()</tt>, <tt>setAutoExtend()</tt>, 
<tt>setNumBinsHint()</tt>, <tt>setBinSizeHint()</tt>. These methods
delegate to similar methods of <tt><a href="../api/classomnetpp_1_1cAutoRangeHistogramStrategy.html">cAutoRangeHistogramStrategy</a></tt>.

<p>
<h4><a name="sec:sim-lib:collecting-observations"/>7.8.2.2 Collecting Observations<a class="headerlink" href="#sec:sim-lib:collecting-observations" title="Permalink to this headline"></a></h4>

<p>Observations are added to the histogram in the same way as with <tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt>:
using the <tt>collect()</tt> and <tt>collectWeighted()</tt> methods. 

<p><h4><a name="sec:sim-lib:querying-bins"/>7.8.2.3 Querying the Bins<a class="headerlink" href="#sec:sim-lib:querying-bins" title="Permalink to this headline"></a></h4>

<p>Histogram bins can be accessed with three member functions: 
<tt>getNumBins()</tt> returns the number of bins, 
<tt>getBinEdge(int k)</tt> returns the <i>k</i>th bin edge, 
<tt>getBinValue(int k)</tt> returns the count or sum of weights in bin <i>k</i>,
and <tt>getBinPDF(int k)</tt> returns the PDF value in the bin 
(i.e. between <tt>getBinEdge(k)</tt> and <tt>getBinEdge(k+1)</tt>).
The <tt>getBinInfo(k)</tt> method returns multiple bin data
(edges, value, relative frequency) packed together in a struct.
Four other methods, <tt>getUnderflowSumWeights()</tt>, <tt>getOverflowSumWeights()</tt>, 
<tt>getNumUnderflows()</tt>, <tt>getNumOverflows()</tt>, provide access to
the outliers.  

<p>These functions, being defined on <tt>cHistogramBase</tt>, are not only
available on <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> but also for <tt><a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a></tt> and <tt><a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a></tt>.

<p>For <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>, bin edges and bin values can also be accessed 
as a vector of <tt>double</tt>s, using the <tt>getBinEdges()</tt> and 
<tt>getBinValues()</tt> methods. 

<p>
  <center>
    <img src="simlib-histogramcells.svg">
    <center><div class="caption"><i>Figure: Bin edges and bins of an <i>N</i>-bin histogram</i></div></center>
  </center>

<p>
An example:

<pre class="cpp">
EV &lt;&lt; "[" &lt;&lt; hist.getMin() &lt;&lt; "," &lt;&lt; hist.getBinEdge(0) &lt;&lt; "): " 
   &lt;&lt; hist.getUnderflowSumWeights() &lt;&lt; endl;
int numBins = hist.getNumBins();
for (int i = 0; i &lt; numBins; i++) {
  EV &lt;&lt; "[" &lt;&lt; hist.getBinEdge(i) &lt;&lt; "," &lt;&lt; hist.getBinEdge(i+1) &lt;&lt; "): " 
     &lt;&lt; hist.getBinValue(i) &lt;&lt; endl;
}
EV &lt;&lt; "[" &lt;&lt; hist.getBinEdge(numBins) &lt;&lt; "," &lt;&lt; hist.getMax() &lt;&lt; "]: " 
   &lt;&lt; hist.getOverflowSumWeights() &lt;&lt; endl;
</pre>
<p>
The <tt>getPDF(x)</tt> and <tt>getCDF(x)</tt> member functions
return the value of the Probability Density Function and the Cumulated
Density Function at a given <i>x</i>, respectively.

<p>Note that bins may not be immediately available during observation
collection, because some histogram strategies use precollection
to gather information about the distribution before setting up the bins.
Use <tt>binsAlreadySetUp()</tt> to figure out whether bins are
set up already. Setting up the bins can be forced with the
<tt>setupBins()</tt> method. 

<p>
<h4><a name="sec:sim-lib:setting-up-bins"/>7.8.2.4 Setting Up and Managing the Bins<a class="headerlink" href="#sec:sim-lib:setting-up-bins" title="Permalink to this headline"></a></h4>

<p>The <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> class has several methods for creating and 
manipulating bins. These methods are primarily intended to be called
from strategy classes, but are also useful if you want to manage
the bins manually, i.e. without a strategy class.

<p>For setting up the bins, you can either use <tt>createUniformBins()</tt> 
with the range (lo, hi) and the step size as parameters, or specify 
all bin edges explicitly in a vector of <tt>double</tt>s to <tt>setBinEdges()</tt>.

<p>When the bins have already been set up, the histogram can be extended
with new bins down or up using the <tt>prependBins()</tt> and <tt>appendBins()</tt>
methods that take a list of new bin edges to add. There is also an 
<tt>extendBinsTo()</tt> method that extends the histogram with equal-sized
bins at either end to make sure that a supplied value falls into the 
histogram range. Of course, extending the histogram is only possible
if there are no outliers in that direction. (The positions of the 
outliers is not preserved, so it is not known how many would fall in
each of the newly created bins.) 

<p>If the histogram has too many bins, adjacent ones (pairs, triplets, 
or groups of size <i>n</i>) can be merged, using the <tt>mergeBins()</tt>
method.

<p>Example code which sets up a histogram with uniform bins:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> hist("queueLength", nullptr); // create w/o strategy object
hist.createUniformBins(0, 100, 10); // 10 bins over (0,100)
</pre>
<p>
The following code achieves the same, but uses <tt>setBinEdges()</tt>:

<pre class="cpp">
std::vector&lt;double&gt; edges = {0,10,20,30,40,50,60,70,80,90,100}; // C++11
<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> hist("queueLength", nullptr);
hist.setBinEdges(edges);
</pre>
<p>

<p><h4><a name="sec:sim-lib:histogram-strategy-concept"/>7.8.2.5 Strategy Concept<a class="headerlink" href="#sec:sim-lib:histogram-strategy-concept" title="Permalink to this headline"></a></h4>

<p>Histogram strategies subclass from <tt><a href="../api/classomnetpp_1_1cIHistogramStrategy.html">cIHistogramStrategy</a></tt>, and are
responsible for setting up and managing the bins.

<p>A <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> is created with a <tt><a href="../api/classomnetpp_1_1cDefaultHistogramStrategy.html">cDefaultHistogramStrategy</a></tt>
by default, which works well in most cases. Other <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> 
constructors allow passing in an arbitrary histogram strategy. 

<p>The <tt>collect()</tt> and <tt>collectWeighted()</tt> methods of a 
<tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt> delegate to similar methods of the strategy
object, which in turn decides when and how to set up the bins,
and how to manage the bins later. (Setting up the bins may be 
postponed until a few observations have been collected, in order to
gather more information for it.) The histogram strategy
uses public histogram methods like <tt>createUniformBins()</tt>
to create and manage the bins.
 
<p><h4><a name="sec:sim-lib:available-histogram-strategies"/>7.8.2.6 Available Histogram Strategies<a class="headerlink" href="#sec:sim-lib:available-histogram-strategies" title="Permalink to this headline"></a></h4>

<p>The following histogram strategy classes exist.

<p><tt><a href="../api/classomnetpp_1_1cFixedRangeHistogramStrategy.html">cFixedRangeHistogramStrategy</a></tt> sets up uniform bins over 
a predetermined interval. The number of bins and the histogram mode 
(integers or reals) also need to be configured. This strategy does 
not use precollection, as all input for setting up the bins must be
explicitly provided by the user.

<p><tt><a href="../api/classomnetpp_1_1cDefaultHistogramStrategy.html">cDefaultHistogramStrategy</a></tt> is used by the default setup of <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>.
This strategy uses precollection to gather input information about the
distribution before setting up the bins. Precollection is used to determine
the initial histogram range and the histogram mode (integers vs. reals).
In integers mode, bin edges will be whole numbers.

<p>To keep up with distributions that change over time, this histogram strategy
can auto-extend the histogram range by adding new bins as needed. It also
performs bin merging when necessary, to keep the number of bins reasonably low.

<p><tt><a href="../api/classomnetpp_1_1cAutoRangeHistogramStrategy.html">cAutoRangeHistogramStrategy</a></tt> is a generic, very configurable,
precollection-based histogram strategy which creates uniform bins, and 
creates quality histograms for practical distributions.

<p>Several constraints and hints can be specified for setting up the bins: 
range lower and/or upper endpoint, bin size, number of bins, 
mode (integers vs. reals), and whether bin size rounding is to be used. 

<p>This histogram strategy can auto-extend the histogram range by adding new
bins at either end. One can also set up an upper limit to the number of
histogram bins to prevent it from growing indefinitely. Bin merging can
also be enabled: it will cause every two (or N) adjacent bins to be
merged to reduce the number of bins if their number grows too high.

<p>
<h4><a name="sec:sim-lib:random-number-generation-from-distributions"/>7.8.2.7 Random Number Generation from Distributions<a class="headerlink" href="#sec:sim-lib:random-number-generation-from-distributions" title="Permalink to this headline"></a></h4>

<p>The <tt>random()</tt> member function generates random
numbers<!--random!numbers--> from the distribution stored by the
object:

<pre class="cpp">
double rnd = histogram.random();
</pre>
<p>

<p><h4><a name="sec:sim-lib:storing-and-loading-distributions"/>7.8.2.8 Storing and Loading Distributions<a class="headerlink" href="#sec:sim-lib:storing-and-loading-distributions" title="Permalink to this headline"></a></h4>

<p>The statistic classes have <tt>loadFromFile()</tt> member functions
that read the histogram data from a text file. If you need a custom
distribution<!--distribution!custom--> that cannot be written (or it
is inefficient) as a C++ function, you can describe it in histogram form
stored in a text file, and use a histogram object with
<tt>loadFromFile()</tt>.

<p>You can also use <tt>saveToFile()</tt> that writes out the distribution
collected by the histogram object:

<pre class="cpp">
FILE *f = fopen("histogram.dat","w");
histogram.saveToFile(f); // save the distribution
fclose(f);

<a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a> restored;
FILE *f2 = fopen("histogram.dat","r");
restored.loadFromFile(f2); // load stored distribution
fclose(f2);
</pre>
<p>

<p><h3><a name="sec:sim-lib:psquare"/>7.8.3 <a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a><a class="headerlink" href="#sec:sim-lib:psquare" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a></tt> class implements the <i>P<sup>2</sup></i> algorithm
described in [<a href="#bib-JCh85">JCh85</a>]. <i>P<sup>2</sup></i> is a heuristic algorithm 
for dynamic calculation of the median and other quantiles. 
The estimates are produced dynamically as the observations arrive. 
The observations are not stored; therefore, the algorithm has 
a very small and fixed storage requirement regardless of 
the number of observations. The <i>P<sup>2</sup></i> algorithm operates 
by adaptively shifting bin edges as observations arrive.

<p><tt><a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a></tt> only needs the number of cells, for example 
in the constructor:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a> psquare("endToEndDelay", 20);
</pre>
<p>
Afterwards, observations can be added and the resulting histogram
can be queried with the same <tt><a href="../api/classomnetpp_1_1cAbstractHistogram.html">cAbstractHistogram</a></tt> methods 
as with <tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>. 

<p>
<h3><a name="sec:sim-lib:ksplit"/>7.8.4 <a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a><a class="headerlink" href="#sec:sim-lib:ksplit" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:sim-lib:ksplit-purpose"/>7.8.4.1 Motivation<a class="headerlink" href="#sec:sim-lib:ksplit-purpose" title="Permalink to this headline"></a></h4>

<p>The <i>k</i>-split algorithm is an on-line distribution
estimation<!--distribution!online estimation--> method.  It was
designed for on-line result collection in simulation programs.  The
method was proposed by Varga and Fakhamzadeh in 1997. The primary
advantage of <i>k</i>-split is that without having to store the
observations, it gives a good estimate without requiring a-priori
information about the distribution, including the sample size. The
<i>k</i>-split algorithm can be extended to multi-dimensional
distributions<!--distribution!multi-dimensional-->, but here we deal
with the one-dimensional version only.

<p>
<h4><a name="sec:sim-lib:ksplit-algorithm"/>7.8.4.2 The k-split Algorithm<a class="headerlink" href="#sec:sim-lib:ksplit-algorithm" title="Permalink to this headline"></a></h4>

<p>The <i>k-split</i> algorithm is an adaptive histogram-type estimate which
maintains a good partitioning by doing cell splits. We start out with
a histogram range <i>[x<sub>lo</sub>, x<sub>hi</sub>)</i> with <i>k</i> equal-sized histogram
cells with observation counts <i>n<sub>1</sub>,n<sub>2</sub>, .. n<sub>k</sub></i>.  Each collected
observation increments the corresponding observation count. When an
observation count <i>n<sub>i</sub></i> reaches a <i>split threshold</i>, the cell
is split into <i>k</i> smaller, equal-sized cells with observation counts
<i>n<sub>i,1</sub>, n<sub>i,2</sub>, .. n<sub>i,k</sub></i> initialized to zero. The <i>n<sub>i</sub></i>
observation count is remembered and is called the <i>mother
  observation count</i> to the newly created cells. Further observations
may cause cells to be split further (e.g. <i>n<sub>i,1,1</sub>,...n<sub>i,1,k</sub></i>
etc.), thus creating a <i>k</i>-order tree of observation counts where
leaves contain live counters that are actually incremented by new
observations, and intermediate nodes contain mother observation counts
for their children. If an observation falls outside the histogram
range, the range is extended in a natural manner by inserting new
level(s) at the top of the tree. The fundamental parameter to the
algorithm is the split factor <i>k</i>. Experience has shown that <i>k=2</i>
works best.

<p>
  <center>
    <img src="simlib-ksplit1.svg">
    <center><div class="caption"><i>Figure: Illustration of the k-split algorithm, <i>k=2</i>. The
      numbers in boxes represent the observation count values</i></div></center>
  </center>

<p>

<p>For density estimation, the total number of observations that
fell into each cell of the partition has to be determined. For
this purpose, mother observations in each internal node of the
tree must be distributed among its child cells and propagated
up to the leaves.

<p>
Let <i>n<sub>...,i</sub></i> be the (mother) observation count for a cell,
<i>s<sub>...,i</sub></i> be the total observation count in a cell <i>n<sub>...,i</sub></i> plus
the observation counts in all its sub-, sub-sub-, etc. cells), and
<i>m<sub>...,i</sub></i> the mother observations propagated to the cell. We are
interested in the <i>&ntilde;<sub>...,i</sub> = n<sub>...,i</sub> + m<sub>...,i</sub></i>
estimated amount of observations in the tree nodes, especially in the
leaves. In other words, if we have <i>&ntilde;<sub>...,i</sub></i> estimated
observation amount in a cell, how to divide it to obtain
<i>m<sub>...,i,1</sub>, m<sub>...,i,2</sub> .. m<sub>...,i,k</sub></i>
that can be propagated to child cells. Naturally,
<i>m<sub>...,i,1</sub> + m<sub>...,i,2</sub> + .. + m<sub>...,i,k</sub> = &ntilde;<sub>...,i</sub></i>.

<p>
Two natural distribution methods are even
distribution<!--distribution!even--> (when
<i>m<sub>...,i,1</sub> = m<sub>...,i,2</sub> = .. = m<sub>...,i,k</sub></i>) and proportional
distribution<!--distribution!proportional--> (when
<i>m<sub>...,i,1</sub> : m<sub>...,i,2</sub> : .. : m<sub>...,i,k</sub> = s<sub>...,i,1</sub> : s<sub>...,i,2</sub> : .. : s<sub>...,i,k</sub></i>).
Even distribution is optimal when the
<i>s<sub>...,i,j</sub></i> values are very small, and proportional distribution is
good when the <i>s<sub>...,i,j</sub></i> values are large compared to
<i>m<sub>...,i,j</sub></i>. In practice, a linear combination of them seems
appropriate, where <i>&lambda;=0</i> means even and <i>&lambda;=1</i> means
proportional distribution:

<p>
<i>m<sub>..,i,j</sub> = (1-&lambda;)&ntilde;<sub>..,i</sub>/k + &lambda; &ntilde;<sub>..,i</sub> s<sub>...,i,j</sub> / s<sub>..,i</sub></i>
where <i>&lambda; is in [0,1]</i>

<p>
  <center>
    <img src="simlib-ksplit2.svg">
    <center><div class="caption"><i>Figure: Density estimation from the k-split cell tree. We
      assume <i>&lambda;=0</i>, i.e. we distribute mother observations
      evenly.</i></div></center>
  </center>

<p>

Note that while <i>n<sub>...,i</sub></i> are integers, <i>m<sub>...,i</sub></i> and thus
<i>&ntilde;<sub>...,i</sub></i> are typically real numbers. The histogram estimate
calculated from <i>k</i>-split is not exact, because the frequency
counts calculated in the above manner contain a degree of estimation
themselves. This introduces a certain <i>cell division error</i>;
the <i>&lambda;</i> parameter should be selected so that it minimizes that
error. It has been shown that the cell division error can
be reduced to a more-than-acceptable small value.<br>
Strictly speaking, the <i>k</i>-split algorithm is semi-online,
because its needs some observations to set up the initial histogram
range.  Because of the range extension and cell split
capabilities, the algorithm is not very sensitive to the choice of the
initial range, so very few observations are sufficient for range
estimation (say <i>N<sub>pre</sub>=10</i>). Thus we can regard <i>k</i>-split as
an on-line method.

<p><i>K</i>-split can also be used in semi-online mode, when the
algorithm is only used to create an optimal partition from a larger
number of <i>N<sub>pre</sub></i> observations. When the partition has been created,
the observation counts are cleared and the <i>N<sub>pre</sub></i> observations are
fed into <i>k</i>-split once again. This way all mother (non-leaf)
observation counts will be zero and the cell division error is
eliminated. It has been shown that the partition created by
<i>k</i>-split can be better than both the equi-distant and the
equal-frequency partition.

<p>OMNeT++ contains an implementation of the <i>k</i>-split algorithm,
the <tt><a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a></tt> class.

<p>
<h4><a name="sec:sim-lib:cksplit-class"/>7.8.4.3 The <a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a> Class<a class="headerlink" href="#sec:sim-lib:cksplit-class" title="Permalink to this headline"></a></h4>

<p>The <tt><a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a></tt> class is an implementation of the <i>k-split</i>
method. It is a subclass of <tt><a href="../api/classomnetpp_1_1cAbstractHistogram.html">cAbstractHistogram</a></tt>, so configuring,
adding observations and querying histogram cells is done the same way as
with other histogram classes.

<p>Specific member functions allow one to fine-tune the <i>k</i>-split
algorithm. <tt>setCritFunc()</tt> and <tt>setDivFunc()</tt> let one replace
the split criteria and the cell division function, respectively.
<tt>setRangeExtension()</tt> lets one enable/disable range extension. (If
range extension is disabled, out-of-range observations will simply be
counted as underflows or overflows.)

<p>The class also allows one to access the <i>k</i>-split data structure,
directly, via methods like <tt>getTreeDepth()</tt>, <tt>getRootGrid()</tt>,
<tt>getGrid(i)</tt>, and others.

<p>

<h2><a name="sec:sim-lib:result-recording"/>7.9 Recording Simulation Results<a class="headerlink" href="#sec:sim-lib:result-recording" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:sim-lib:coutvector"/>7.9.1 Output Vectors: <a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a><a class="headerlink" href="#sec:sim-lib:coutvector" title="Permalink to this headline"></a></h3>

<p>Objects of type <tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> are responsible for writing time series
data (referred to as <i>output vectors</i>) to a file. The <tt>record()</tt>
method is used to output a value (or a value pair) with a timestamp.
The object name will serve as the name of the output vector.

<p>The vector name can be passed in the constructor,

<pre class="cpp">
<a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a> responseTimeVec("response time");
</pre>
<p>
but in the usual arrangement you'd make the <tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> a member
of the module class and set the name in <tt>initialize()</tt>. You'd
record values from <tt>handleMessage()</tt> or from a function called from
<tt>handleMessage()</tt>.

<p>The following example is a <tt>Sink</tt> module which records the lifetime
of every message that arrives to it.

<pre class="cpp">
class Sink : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a> endToEndDelayVec;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
};

Define_Module(Sink);

void Sink::initialize()
{
    endToEndDelayVec.setName("End-to-End Delay");
}

void Sink::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    simtime_t eed = simTime() - msg-&gt;getCreationTime();
    endToEndDelayVec.record(eed);
    delete msg;
}
</pre>
<p>
There is also a <tt>recordWithTimestamp()</tt> method, to make it
possible to record values into output vectors with a timestamp other than
<tt>simTime()</tt>. Increasing timestamp order is still enforced though.

<p>All <tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> objects write to a single <i>output vector file</i>
that has a file extension <tt>.vec</tt>.
  <br><ul><font size=-1>[A <tt>.vci</tt> file is also created, but it is just an index for
  the <tt>.vec</tt> file and does not contain any new information. The IDE
  re-creates the <tt>.vci</tt> file if it gets lost.]</font></ul>
The format and processing of output vector files is described in section
<a href="#cha:ana-sim">[12]</a>.

<p>You can configure output vectors from <tt>omnetpp.ini</tt>:
you can disable individual vectors, or limit recording to certain
simulation time intervals (see sections
<a href="#sec:ana-sim:disabling-result-items">[12.2.2]</a>,
<a href="#sec:ana-sim:vector-recording-intervals">[12.2.5]</a>).

<p>If the output vector object is disabled or the simulation time is
outside the specified interval, <tt>record()</tt> doesn't write
anything to the output file. However, if you have a Tkenv or Qtenv inspector
window open for the output vector object<!--output!vector object-->,
the values will be displayed there, regardless of the state of the
output vector object.

<p>

<p><h3><a name="sec:sim-lib:output-scalars"/>7.9.2 Output Scalars<a class="headerlink" href="#sec:sim-lib:output-scalars" title="Permalink to this headline"></a></h3>

<p>While output vectors are to record time series data and thus they
typically record a large volume of data during a simulation run,
output scalars<!--output!scalars--> are supposed to record a single
value per simulation run. You can use output scalars

<p><ul>
<li> to record summary data at the end of the simulation run
<li> to do several runs with different parameter settings/random seed
    and determine the dependence of some measures on the parameter
    settings. For example, multiple runs and output scalars are the
    way to produce <i>Throughput vs. Offered Load</i> plots.
</ul>

<p>Output scalars are recorded with the <tt>record()</tt> method of
<tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>, and you will usually want to insert this code
into the <tt>finish()</tt> function. An example:

<pre class="cpp">
void Transmitter::finish()
{
    double avgThroughput = totalBits / simTime();
    recordScalar("Average throughput", avgThroughput);
}
</pre>
<p>
You can record whole statistic objects by calling their <tt>record()</tt>
methods, declared as part of <tt><a href="../api/classomnetpp_1_1cStatistic.html">cStatistic</a></tt>. In the following example
we create a <tt>Sink</tt> module which calculates the mean, standard
deviation, minimum and maximum values of a variable, and records them at the
end of the simulation.

<pre class="cpp">
class Sink : public <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a> eedStats;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg);
    virtual void finish();
};

Define_Module(Sink);

void Sink::initialize()
{
    eedStats.setName("End-to-End Delay");
}

void Sink::handleMessage(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg)
{
    simtime_t eed = simTime() - msg-&gt;getCreationTime();
    eedStats.collect(eed);
    delete msg;
}

void Sink::finish()
{
    recordScalar("Simulation duration", simTime());
    eedStats.record();
}
</pre>
<p>
The above calls record the data into an <i>output scalar file</i>,
a line-oriented text file that has the file extension <tt>.sca</tt>.
The format and processing of output vector files is described in chapter
<a href="#cha:ana-sim">[12]</a>.

<p>

<p><h2><a name="sec:sim-lib:watches-and-snapshots"/>7.10 Watches and Snapshots<a class="headerlink" href="#sec:sim-lib:watches-and-snapshots" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:sim-lib:basic-watches"/>7.10.1 Basic Watches<a class="headerlink" href="#sec:sim-lib:basic-watches" title="Permalink to this headline"></a></h3>

<p>Unfortunately, variables of type <tt>int</tt>, <tt>long</tt>, <tt>double</tt>
do not show up by default in Tkenv/Qtenv; neither do STL classes
(<tt>std::string</tt>, <tt>std::vector</tt>, etc.) or your own structs and
classes. This is because the simulation kernel, being a library, knows
nothing about types and variables in your source code.

<p>OMNeT++ provides <tt>WATCH()</tt> and a set of other macros to
allow variables to be inspectable in Tkenv/Qtenv and to be output into the snapshot
file<!--snapshot file-->. <tt>WATCH()</tt> macros are usually placed into
<tt>initialize()</tt> (to watch instance variables) or to the top of the
<tt>activity()</tt> function (to watch its local variables); the point being
that they should only be executed once.

<pre class="cpp">
long packetsSent;
double idleTime;

WATCH(packetsSent);
WATCH(idleTime);
</pre>
<p>
Of course, members of classes and structs can also be watched:

<pre class="cpp">
WATCH(config.maxRetries);
</pre>
<p>
The Tkenv and Qtenv runtime environments let you inspect and also change
the values of inspected variables.

<p>The <tt>WATCH()</tt> macro can be used with any type that has a
stream output operator (<tt>operator&lt;&lt;</tt>) defined. By default,
this includes all primitive types and <tt>std::string</tt>, but since
you can write <tt>operator&lt;&lt;</tt> for your classes/structs and basically
any type, <tt>WATCH()</tt> can be used with anything. The only limitation
is that since the output should more or less fit on single line, the
amount of information that can be conveniently displayed is limited.

<p>An example stream output operator:

<pre class="cpp">
std::ostream& operator&lt;&lt;(std::ostream& os, const ClientInfo& cli)
{
    os &lt;&lt; "addr=" &lt;&lt; cli.clientAddr &lt;&lt; "  port=" &lt;&lt; cli.clientPort; // no endl!
    return os;
}
</pre>
<p>
And the <tt>WATCH()</tt> line:

<pre class="cpp">
WATCH(currentClientInfo);
</pre>
<p>

<p><h3><a name="sec:sim-lib:read-write-watches"/>7.10.2 Read-write Watches<a class="headerlink" href="#sec:sim-lib:read-write-watches" title="Permalink to this headline"></a></h3>

<p>Watches for primitive types and <tt>std::string</tt> allow for changing
the value from the GUI as well, but for other types you need to explicitly
add support for that. What you need to do is define a stream input
operator (<tt>operator&gt;&gt;</tt>) and use the <tt>WATCH_RW()</tt> macro instead of
<tt>WATCH()</tt>.

<p>The stream input operator:

<pre class="cpp">
std::ostream& operator&gt;&gt;(std::istream& is, ClientInfo& cli)
{
    // read a line from "is" and parse its contents into "cli"
    return is;
}
</pre>
<p>
And the <tt>WATCH_RW()</tt> line:

<pre class="cpp">
WATCH_RW(currentClientInfo);
</pre>
<p>

<p><h3><a name="sec:sim-lib:structured-watches"/>7.10.3 Structured Watches<a class="headerlink" href="#sec:sim-lib:structured-watches" title="Permalink to this headline"></a></h3>

<p><tt>WATCH()</tt> and <tt>WATCH_RW()</tt> are basic watches; they allow one
line of (unstructured) text to be displayed. However, if you have a
data structure generated from message definitions (see Chapter <a href="#cha:messages">[5]</a>),
then there is a better approach. The message compiler automatically generates
meta-information describing individual fields of the class or struct,
which makes it possible to display the contents on field level.

<p>The <tt>WATCH</tt> macros to be used for this purpose are <tt>WATCH_OBJ()</tt>
and <tt>WATCH_PTR()</tt>. Both expect the object to be subclassed from
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>; <tt>WATCH_OBJ()</tt> expects a reference to such class,
and <tt>WATCH_PTR()</tt> expects a pointer variable.

<pre class="cpp">
ExtensionHeader hdr;
ExtensionHeader *hdrPtr;
...
WATCH_OBJ(hdr);
WATCH_PTR(hdrPtr);
</pre>
<p>
CAUTION: With <tt>WATCH_PTR()</tt>, the pointer variable must point to a valid
object or be <tt>nullptr</tt> at all times, otherwise the GUI may crash
while trying to display the object. This practically means that
the pointer should be initialized to <tt>nullptr</tt> even if not used, and
should be set to <tt>nullptr</tt> when the object to which it points is deleted.

<pre class="cpp">
delete watchedPtr;
watchedPtr = nullptr;  // set to nullptr when object gets deleted
</pre>
<p>

<p><h3><a name="sec:sim-lib:stl-watches"/>7.10.4 STL Watches<a class="headerlink" href="#sec:sim-lib:stl-watches" title="Permalink to this headline"></a></h3>

<p>The standard C++ container classes (<tt>vector</tt>, <tt>map</tt>, <tt>set</tt>, etc)
also have structured watches, available via the following macros:

<p><tt>WATCH_VECTOR()</tt>, <tt>WATCH_PTRVECTOR()</tt>,
<tt>WATCH_LIST()</tt>, <tt>WATCH_PTRLIST()</tt>,
<tt>WATCH_SET()</tt>, <tt>WATCH_PTRSET()</tt>,
<tt>WATCH_MAP()</tt>, <tt>WATCH_PTRMAP()</tt>.

<p>The <tt>PTR</tt>-less versions expect the data items ("T") to have
stream output operators (<tt>operator &lt;&lt;</tt>), because that is how
they will display them. The <tt>PTR</tt> versions assume that
data items are pointers to some type which has <tt>operator &lt;&lt;</tt>.
<tt>WATCH_PTRMAP()</tt> assumes that only the value type (&#8220;second&#8221;)
is a pointer, the key type (&#8220;first&#8221;) is not. (If you happen to use
pointers as key, then define <tt>operator &lt;&lt;</tt> for the pointer type
itself.)

<p>Examples:

<pre class="cpp">
std::vector&lt;int&gt; intvec;
WATCH_VECTOR(intvec);

std::map&lt;std::string,Command*&gt; commandMap;
WATCH_PTRMAP(commandMap);
</pre>
<p>

<p>
<h3><a name="sec:sim-lib:snapshots"/>7.10.5 Snapshots<a class="headerlink" href="#sec:sim-lib:snapshots" title="Permalink to this headline"></a></h3>

<p>The <tt>snapshot()</tt> function outputs textual information about all
or selected objects of the simulation (including the objects created
in module functions by the user) into the snapshot file<!--snapshot file-->.

<pre class="cpp">
bool snapshot(<a href="../api/classomnetpp_1_1cObject.html">cObject</a> *obj=nullptr, const char *label=nullptr);
</pre>
<p>
The function can be called from module functions, like this:

<pre class="cpp">
snapshot();     // dump the network
snapshot(this); // dump this simple module and all its objects
snapshot(getSimulation()-&gt;getFES()); // dump the future events set
</pre>
<p>
<tt>snapshot()</tt> will append to the end of the snapshot file. The snapshot
file name has an extension of <tt>.sna</tt>.

<p>The snapshot file output is detailed enough to be used for debugging
the simulation: by regularly calling <tt>snapshot()</tt>, one can trace
how the values of variables, objects changed over the simulation.
The arguments: label is a string that will appear in the output
file; obj is the object whose inside is of interest. By default,
the whole simulation (all modules etc) will be written out.

<p>If you run the simulation with Tkenv or Qtenv, you can also create a
snapshot from the menu.

<p>An example snapshot file (some abbreviations have been applied):

<pre class="filelisting">
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;snapshot object="simulation" label="Long queue" simtime="9.038229311343"
network="FifoNet"&gt;
  &lt;object class="<a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>" fullpath="simulation"&gt;
    &lt;info&gt;&lt;/info&gt;
    &lt;object class="<a href="../api/classomnetpp_1_1cModule.html">cModule</a>" fullpath="FifoNet"&gt;
      &lt;info&gt;id=1&lt;/info&gt;
      &lt;object class="fifo::Source" fullpath="FifoNet.gen"&gt;
        &lt;info&gt;id=2&lt;/info&gt;
        &lt;object class="<a href="../api/classomnetpp_1_1cPar.html">cPar</a>" fullpath="FifoNet.gen.sendIaTime"&gt;
          &lt;info&gt;exponential(0.01s)&lt;/info&gt;
        &lt;/object&gt;
        &lt;object class="<a href="../api/classomnetpp_1_1cGate.html">cGate</a>" fullpath="FifoNet.gen.out"&gt;
          &lt;info&gt;--&gt; fifo.in&lt;/info&gt;
        &lt;/object&gt;
      &lt;/object&gt;
      &lt;object class="fifo::Fifo" fullpath="FifoNet.fifo"&gt;
        &lt;info&gt;id=3&lt;/info&gt;
        &lt;object class="<a href="../api/classomnetpp_1_1cPar.html">cPar</a>" fullpath="FifoNet.fifo.serviceTime"&gt;
          &lt;info&gt;0.01&lt;/info&gt;
        &lt;/object&gt;
        &lt;object class="<a href="../api/classomnetpp_1_1cGate.html">cGate</a>" fullpath="FifoNet.fifo.in"&gt;
          &lt;info&gt;&lt;-- gen.out&lt;/info&gt;
        &lt;/object&gt;
        &lt;object class="<a href="../api/classomnetpp_1_1cGate.html">cGate</a>" fullpath="FifoNet.fifo.out"&gt;
          &lt;info&gt;--&gt; sink.in&lt;/info&gt;
        &lt;/object&gt;
        &lt;object class="<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>" fullpath="FifoNet.fifo.queue"&gt;
          &lt;info&gt;length=13&lt;/info&gt;
          &lt;object class="<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>" fullpath="FifoNet.fifo.queue.job"&gt;
            &lt;info&gt;src=FifoNet.gen (id=2)  dest=FifoNet.fifo (id=3)&lt;/info&gt;
          &lt;/object&gt;
          &lt;object class="<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>" fullpath="FifoNet.fifo.queue.job"&gt;
            &lt;info&gt;src=FifoNet.gen (id=2)  dest=FifoNet.fifo (id=3)&lt;/info&gt;
          &lt;/object&gt;
        &lt;/object&gt;
      &lt;object class="fifo::Sink" fullpath="FifoNet.sink"&gt;
        &lt;info&gt;id=4&lt;/info&gt;
        &lt;object class="<a href="../api/classomnetpp_1_1cGate.html">cGate</a>" fullpath="FifoNet.sink.in"&gt;
          &lt;info&gt;&lt;-- fifo.out&lt;/info&gt;
        &lt;/object&gt;
      &lt;/object&gt;
    &lt;/object&gt;
    &lt;object class="<a href="../api/classomnetpp_1_1cEventHeap.html">cEventHeap</a>" fullpath="simulation.scheduled-events"&gt;
      &lt;info&gt;length=3&lt;/info&gt;
      &lt;object class="<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>" fullpath="simulation.scheduled-events.job"&gt;
        &lt;info&gt;src=FifoNet.fifo (id=3)  dest=FifoNet.sink (id=4)&lt;/info&gt;
      &lt;/object&gt;
      &lt;object class="<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>" fullpath="...sendMessageEvent"&gt;
        &lt;info&gt;at T=9.0464.., in dt=0.00817..; selfmsg for FifoNet.gen (id=2)&lt;/info&gt;
      &lt;/object&gt;
      &lt;object class="<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>" fullpath="...end-service"&gt;
        &lt;info&gt;at T=9.0482.., in dt=0.01; selfmsg for FifoNet.fifo (id=3)&lt;/info&gt;
      &lt;/object&gt;
    &lt;/object&gt;
  &lt;/object&gt;
&lt;/snapshot&gt;

</pre>
<p>

<p>


<p>

<p>
<h3><a name="sec:sim-lib:getting-coroutine-stack-usage"/>7.10.6 Getting Coroutine Stack Usage<a class="headerlink" href="#sec:sim-lib:getting-coroutine-stack-usage" title="Permalink to this headline"></a></h3>

<p>It is important to choose the correct stack size for
modules<!--module!stack size--><!--stack!size-->.  If the stack is
too large, it unnecessarily consumes memory; if it is too small, stack
violation occurs.

<p>OMNeT++ contains a mechanism that detects stack
overflows<!--stack!overflow-->. It checks the intactness of a
predefined byte pattern (<tt>0xdeadbeef</tt>) at the stack boundary,
and reports &#8220;stack violation&#8221;<!--stack!violation--> if it was
overwritten. The mechanism usually works fine, but occasionally it can
be fooled by large -- and not fully used -- local variables (e.g. char
buffer[256]): if the byte pattern happens to fall in the middle of
such a local variable, it may be preserved intact and OMNeT++ does not
detect the stack violation.

<p>To be able to make a good guess about stack size, you can use
the <tt>getStackUsage()</tt> call which tells you how much stack the module
actually uses. It is most conveniently called from <tt>finish()</tt>:

<pre class="cpp">
void FooModule::finish()
{
  EV &lt;&lt; getStackUsage() &lt;&lt; " bytes of stack used\n";
}
</pre>
<p>

<p>The value includes the extra stack added by the user interface library
(see <i>extraStackforEnvir</i><!--extraStackforEnvir--> in
envir/omnetapp.h), which is currently 8K for Cmdenv and at least 16K
for Tkenv.
  <br><ul><font size=-1>[The actual value is platform-dependent.]</font></ul>

<p><tt>getStackUsage()</tt> also works by checking the existence of predefined
byte patterns in the stack area, so it is also subject to the above
effect with local variables.

<p>
<h2><a name="sec:sim-lib:defining-ned-functions"/>7.11 Defining New NED Functions<a class="headerlink" href="#sec:sim-lib:defining-ned-functions" title="Permalink to this headline"></a></h2>

<p>It is possible to extend the NED language with new functions beyond the
built-in ones. New functions are implemented in C++, and then compiled into
the simulation model. When a simulation program starts up, the new
functions are registered in the NED runtime, and become available for use
in NED and ini files.

<p>There are two methods to define NED functions. The
<tt>Define_NED_Function()</tt> macro is the more flexible, preferred method
of the two. <tt>Define_NED_Math_Function()</tt> is the older one, and it
supports only certain cases. Both macros have several variants.
  <br><ul><font size=-1>[Before OMNeT++ 4.2, <tt>Define_NED_Math_Function()</tt> was
  called <tt>Define_Function()</tt>.]</font></ul>

<p><h3><a name="sec:sim-lib:define-ned-function-macro"/>7.11.1 Define_NED_Function()<a class="headerlink" href="#sec:sim-lib:define-ned-function-macro" title="Permalink to this headline"></a></h3>

<p>The <tt>Define_NED_Function()</tt> macro lets you define new functions that
can accept arguments of various data types (<tt>bool</tt>, <tt>double</tt>,
<tt>string</tt>, etc.), supports optional arguments and also variable
argument lists (variadic functions).

<p>The macro has two variants:

<pre class="cpp">
Define_NED_Function(FUNCTION,SIGNATURE);
Define_NED_Function2(FUNCTION,SIGNATURE,CATEGORY,DESCRIPTION);
</pre>
<p>
The two variants are basically equivalent; the only difference is that the
second one allows you to specify two more parameters, <tt>CATEGORY</tt> and
<tt>DESCRIPTION</tt>. These two parameters expect human-readable strings that
are displayed when listing the available NED functions.

<p>The common parameters, <tt>FUNCTION</tt> and <tt>SIGNATURE</tt> are the important
ones. <tt>FUNCTION</tt> is the name of (or pointer to) the C++ function that
implements the NED function, and <tt>SIGNATURE</tt> is the function signature
as a string; it defines the name, argument types and return type of the NED
function.

<p>You can list the available NED functions by running <tt>opp_run</tt> or
any simulation executable with the <tt>-h nedfunctions</tt> option.
The result will be similar to what you can see in Appendix
<a href="#cha:ned-functions">[22]</a>.

<pre class="commandline">
$ opp_run -h nedfunctions
OMNeT++ Discrete Event Simulation...
Functions that can be used in NED expressions and in omnetpp.ini:

 Category "conversion":
  double : double double(any x)
    Converts x to double, and returns the result. A boolean argument becomes
    0 or 1; a string is interpreted as number; an XML argument causes an error.
 ...
</pre>
<p>
Seeing the above output, it should now be obvious what the <tt>CATEGORY</tt>
and <tt>DESCRIPTION</tt> macro arguments are for. OMNeT++ uses the following
category names: <tt>"conversion"</tt>, <tt>"math"</tt>, <tt>"misc"</tt>,
<tt>"ned"</tt>, <tt>"random/continuous"</tt>, <tt>"random/discrete"</tt>,
<tt>"strings"</tt>, <tt>"units"</tt>, <tt>"xml"</tt>. You can use these category names
for your own functions as well, when appropriate.

<p>
<h4><a name="sec:sim-lib:ned-function-signature"/>7.11.1.1 The Signature<a class="headerlink" href="#sec:sim-lib:ned-function-signature" title="Permalink to this headline"></a></h4>

<p>The signature string has the following syntax:

<p><pre class="verbatim">
<i>returntype functionname(argtype1 argname1, argtype2 argname2, ...)</i>
</pre>

<p>The <i>functionname</i> part defines the name of the NED function, and it
must meet the syntactical requirements for NED identifiers (start with a
letter or underscore, not be a reserved NED keyword, etc.)

<p>The argument types and return type can be one of the following:
<b><tt>bool</tt></b>, <b><tt>int</tt></b> (maps to C/C++ <tt>long</tt>),
<b><tt>double</tt></b>, <b><tt>quantity</tt></b>, <b><tt>string</tt></b>, <b><tt>xml</tt></b>
or <b><tt>any</tt></b>; that is, any NED parameter type plus <b><tt>quantity</tt></b>
and <b><tt>any</tt></b>. <b><tt>quantity</tt></b> means <i>double with an
optional measurement unit</i> (<b><tt>double</tt></b> and <b><tt>int</tt></b> only
accept dimensionless numbers), and <b><tt>any</tt></b> stands for any type. The
argument names are presently ignored.

<p>To make arguments optional, append a question mark to the argument name.
Like in C++, optional arguments may only occur at the end of the argument
list, i.e. all arguments after an optional argument must also be optional.
The signature string does not have syntax for supplying default values for
optional arguments; that is, default values have to be built into the C++
code that implements the NED function. To let the NED function accept any
number of additional arguments of arbitrary types, add an ellipsis
(<tt>...</tt>) to the signature as the last argument.

<p>Some examples:

<pre class="cpp">
"int factorial(int n)"
"bool isprime(int n)"
"double sin(double x)"
"string repeat(string what, int times)"
"quantity uniform(quantity a, quantity b, long rng?)"
"any choose(int index, ...)"
</pre>
<p>
The first three examples define NED functions with the names <tt>factorial</tt>,
<tt>isprime</tt> and <tt>sin</tt>, with the obvious meanings. The fourth example
can be the signature for a function that repeats a string <i>n</i> times, and
returns the concatenated result. The fifth example is the signature of the
existing <tt>uniform()</tt> NED function; it accepts numbers both with and without
measurement units (of course, when invoked with measurement units, both <tt>a</tt>
and <tt>b</tt> must have one, and the two must be compatible -- this should be checked
by the C++ implementation). <tt>uniform()</tt> also accepts an optional third argument,
an RNG index. The sixth example can be the signature of a <tt>choose()</tt>
NED function that accepts an integer plus any number of additional arguments
of any type, and returns the <i>index</i>th one among them.

<p><h4><a name="sec:sim-lib:implementing-ned-function"/>7.11.1.2 Implementing the NED Function<a class="headerlink" href="#sec:sim-lib:implementing-ned-function" title="Permalink to this headline"></a></h4>

<p>The C++ function that implements the NED function must have the following
signature, as defined by the <tt>NEDFunction</tt> typedef:

<pre class="cpp">
cNEDValue function(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *context, cNEDValue argv[], int argc);
</pre>
<p>
As you can see, the function accepts an array of <tt>cNEDValue</tt>
objects, and returns a <tt>cNEDValue</tt>; the <i>argc-argv</i> style
argument list should be familiar to you from the declaration of the C/C++
<tt>main()</tt> function. <tt>cNEDValue</tt> is a class that is used during
the evaluation of NED expressions, and represents a value together with its
type.  The <tt>context</tt> argument contains the module or channel in the
context of which the NED expression is being evaluated; it is useful for
implementing NED functions like <tt>getParentModuleIndex()</tt>.

<p>The function implementation does not need to worry too much about checking
the number and types of the incoming arguments, because the NED expression
evaluator already does that: inside the function you can be sure that the
number and types of arguments correspond to the function signature string.
Thus, <tt>argc</tt> is mostly useful only if you have optional arguments or a
variable argument list. The NED expression evaluator also checks that the
value you return from the function corresponds to the signature.

<p><tt>cNEDValue</tt> can store all the needed data types (<tt>bool</tt>,
<tt>double</tt>, <tt>string</tt>, etc.), and is equipped with the functions
necessary to conveniently read and manipulate the stored value. The value can
be read via functions like <tt>boolValue()</tt>, <tt>longValue()</tt>,
<tt>doubleValue()</tt>, <tt>stringValue()</tt> (returns <tt>const char *</tt>),
<tt>stdstringValue()</tt> (returns <tt>const std::string&amp;</tt>) and
<tt>xmlValue()</tt> (returns <tt><a href="../api/classomnetpp_1_1cXMLElement.html">cXMLElement</a>*</tt>), or by simply casting the
object to the desired data type, making use of the provided typecast
operators. Invoking a getter or typecast operator that does not match the
stored data type will result in a runtime error. For setting the stored
value, <tt>cNEDValue</tt> provides a number of overloaded <tt>set()</tt>
functions, assignment operators and constructors.

<p>Further <tt>cNEDValue</tt> member functions provide access to the stored
data type; yet other functions are associated with handling quantities,
i.e. doubles with measurement units. There are member functions for getting
and setting the number part and the measurement unit part separately; for
setting the two components together; and for performing unit conversion.

<p>Equipped with the above information, we can already write a simple NED function
that returns the length of a string:

<pre class="cpp">
static cNEDValue ned_strlen(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *context, cNEDValue argv[], int argc)
{
    return (long)argv[0].stdstringValue().size();
}

Define_NED_Function(ned_strlen, "int length(string s)");
</pre>
<p>
Note that since <tt>Define_NED_Function()</tt> expects the C++ function to
be already declared, we place the function implementation in front of the
<tt>Define_NED_Function()</tt> line. We also declare the function to be
<tt>static</tt>, because its name doesn't need to be visible for the linker.
In the function body, we use <tt>std::string</tt>'s <tt>size()</tt> method to
obtain the length of the string, and cast the result to <tt>long</tt>; the C++
compiler will convert that into a <tt>cNEDValue</tt> using <tt>cNEDValue</tt>'s
<tt>long</tt> constructor. Note that the <b><tt>int</tt></b> keyword in the signature
maps to the C++ type <tt>long</tt>.

<p>The following example defines a <tt>choose()</tt> NED function that returns
its <i>k</i>th argument that follows the <tt>index</tt> (<i>k</i>) argument.

<pre class="cpp">
static cNEDValue ned_choose(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *context, cNEDValue argv[], int argc)
{
    int index = (int)argv[0];
    if (index &lt; 0 || index &gt;= argc-1)
        throw <a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a>("choose(): index %d is out of range", index);
    return argv[index+1];
}

Define_NED_Function(ned_choose, "any choose(int index, ...)");
</pre>
<p>
Here, the value of <tt>argv[0]</tt> is read using the typecast operator that
maps to <tt>longValue()</tt>. (Note that if the value of the <tt>index</tt>
argument does not fit into an <tt>int</tt>, the conversion will result
in data loss!) The code also shows how to report errors (by throwing a
<tt><a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a></tt>.)

<p>The third example shows how the built-in <tt>uniform()</tt> NED function could
be reimplemented by the user:

<pre class="cpp">
static cNEDValue ned_uniform(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *context, cNEDValue argv[], int argc)
{
    int rng = argc==3 ? (int)argv[2] : 0;
    double argv1converted = argv[1].doubleValueInUnit(argv[0].getUnit());
    double result = uniform((double)argv[0], argv1converted, rng);
    return cNEDValue(result, argv[0].getUnit());
    // or: argv[0].setPreservingUnit(result); return argv[0];
}

Define_NED_Function(ned_uniform, "quantity uniform(quantity a, quantity b, int rng?)");
</pre>
<p>
The first line of the function body shows how to supply default values for
optional arguments; for the <tt>rng</tt> argument in this case. The next line
deals with unit conversion. This is necessary because the <tt>a</tt> and
<tt>b</tt> arguments are both quantities and may come in with different
measurement units. We use the <tt>doubleValueInUnit()</tt> function to
obtain the numeric value of <tt>b</tt> in <tt>a</tt>'s measurement unit. If the
two units are incompatible or only one of the parameters have a unit, an
error will be raised. If neither parameters have a unit,
<tt>doubleValueInUnit()</tt> simply returns the stored <tt>double</tt>. Then we
call the <tt>uniform()</tt> C++ function to actually generate a random number,
and return it in a temporary object with <tt>a</tt>'s measurement unit.
Alternatively, we could have overwritten the numeric part of <tt>a</tt> with
the result using <tt>setPreservingUnit()</tt>, and returned just that. If
there is no measurement unit, <tt>getUnit()</tt> will return <tt>nullptr</tt>,
which is understood by both <tt>doubleValueInUnit()</tt> and the
<tt>cNEDValue</tt> constructor.

<p><ul class="note"><b>NOTE</b><br>
Note that it is OK to change the elements of the <tt>argv[]</tt> vector: they
will be discarded (popped off the evaluation stack) by the NED expression
evaluator anyway when your function returns.
</ul>

<p>
<h4><a name="sec:sim-lib:cnedvalue-in-more-detail"/>7.11.1.3 cNEDValue In More Detail<a class="headerlink" href="#sec:sim-lib:cnedvalue-in-more-detail" title="Permalink to this headline"></a></h4>

<p>In the previous section we have given an overview and demonstrated the basic
use of the <tt>cNEDValue</tt> class; here we go into further details.

<p>The stored data type can be obtained with the <tt>getType()</tt> function.
It returns an enum (<tt>cNEDValue::Type</tt>) that has the following values:
<tt>UNDEF</tt>, <tt>BOOL</tt>, <tt>DBL</tt>, <tt>STR</tt>, <tt>XML</tt>. <tt>UNDEF</tt> is
synonymous with <i>unset</i>; the others have the obvious meanings. There
is no separate <tt>QUANTITY</tt> type: quantities are also represented with
the <tt>DBL</tt> type, which has an optional associated measurement unit. Note
that <tt>LONG</tt> is also missing; the reason is that the NED expression
evaluator currently (as of OMNeT++ 4.2) stores all numbers as <tt>double</tt>s.
  <br><ul><font size=-1>[The IEEE <i>double</i>'s mantissa is 53 bits, so <tt>double</tt>
  can accurately represent 32-bit integers, the usual size of <tt>long</tt> on
  32-bit architectures. On 64-bit architectures the usual size of <tt>long</tt>
  is 64 bits, so precision loss will occur when converting very large integers
  to <tt>double</tt>. Note, however, that simulations that trigger this precision
  loss would not be able to run on 32-bit architectures at all!]</font></ul>

<p>The <tt>getTypeName()</tt> static function returns the string equivalent of
a <tt>cNEDValue::Type</tt>. The utility functions <tt>isSet()</tt> and
<tt>isNumeric()</tt> check that the type is (not) <tt>UNDEF</tt> and <tt>DBL</tt>,
respectively.

<pre class="cpp">
cNEDValue value = 5.0;
cNEDValue::Type type = value.getType(); // ==&gt; DBL
EV &lt;&lt; cNEDValue::getTypeName(type) &lt;&lt; endl; // ==&gt; "double"
</pre>
<p>
We have already seen that the <tt>DBL</tt> type serves both the
<b><tt>double</tt></b> and <b><tt>quantity</tt></b> types of the NED function
signature, by storing an optional measurement unit (a string)
in addition to the <tt>double</tt> variable. A <tt>cNEDValue</tt> can be set
to a quantity by creating it with a two-argument constructor that accepts
a <tt>double</tt> and a <tt>const char *</tt> for unit, or by invoking a similar
two-argument <tt>set()</tt> function. The measurement unit can be read with
<tt>getUnit()</tt>, and overwritten with <tt>setUnit()</tt>. If you assign a
<tt>double</tt> to a <tt>cNEDValue</tt> or invoke the one-argument
<tt>set(double)</tt> method on it, that will clear the measurement unit. If you
want to overwrite the number part but preserve the original unit, you need
to use the <tt>setPreservingUnit(double)</tt> method.

<p>There are several functions that perform unit conversion. The
<tt>doubleValueInUnit()</tt> method accepts a measurement unit, and attempts
to return the number in that unit. The <tt>convertTo()</tt> method also
accepts a measurement unit, and tries to permanently convert the value to
that unit; that is, if successful, it changes both the number and the
measurement unit part of the object. The <tt>convertUnit()</tt> static
<tt>cNEDValue</tt> member function accepts three arguments: a quantity as a
<tt>double</tt> and a unit, and a target unit; and returns the number in the
target unit. A <tt>parseQuantity()</tt> static member function parses
a string that contains a quantity (e.g. <tt>"5min 48s"</tt>), and return
both the numeric value and the measurement unit. Another version of
<tt>parseQuantity()</tt> tries to return the value in a unit you specify.
All functions raise an error if the unit conversion is not possible, e.g.
due to incompatible units.

<p>For performance reasons, <tt>setUnit()</tt>, <tt>convertTo()</tt> and all other
functions that accept and store a measurement unit will only store the
<tt>const char*</tt> pointer, but do <i>not</i> copy the string itself.
Consequently, the passed measurement unit pointers must stay valid for at
least the lifetime of the <tt>cNEDValue</tt> object, or even longer if the
same pointer propagates to other <tt>cNEDValue</tt> objects. It is
recommended that you only pass pointers that stay valid during the entire
simulation. It is safe to use: (1) string constants from the code; (2) unit
strings from other <tt>cNEDValue</tt>s; and (3) pooled strings e.g. from a
<tt><a href="../api/classomnetpp_1_1cStringPool.html">cStringPool</a></tt> or from <tt>cNEDValue</tt>'s static <tt>getPooled()</tt>
function.

<p>Example code:

<pre class="cpp">
// manipulating the number and the measurement unit
cNEDValue value(250,"ms");    // initialize to 250ms
value = 300.0;                // ==&gt; 300 (clears the unit!)
value.set(500,"ms");          // ==&gt; 500ms
value.setUnit("s");           // ==&gt; 500s (overwrites the unit)
value.setPreservingUnit(180); // ==&gt; 180s (overwrites the number)
value.setUnit(nullptr);       // ==&gt; 180 (clears the unit)

// unit conversion
value.set(500, "ms");         // ==&gt; 500ms
value.convertTo("s");         // ==&gt; 0.5s
double us = value.doubleValueInUnit("us"); // ==&gt; 500000 (value is unchanged)
double bps = cNEDValue::convertUnit(128, "kbps", "bps"); // ==&gt; 128000
double ms = cNEDValue::convertUnit("2min 15.1s", "ms"); // ==&gt; 135100

// getting persistent measurement unit strings
const char *unit = argv[0].stringValue(); // cannot be trusted to persist
value.setUnit(cNEDValue::getPooled(unit)); // use a persistent copy for setUnit()
</pre>
<p>

<p><h3><a name="sec:sim-lib:define-ned-math-function"/>7.11.2 Define_NED_Math_Function()<a class="headerlink" href="#sec:sim-lib:define-ned-math-function" title="Permalink to this headline"></a></h3>

<p>The <tt>Define_NED_Math_Function()</tt> macro lets you register a C/C++
&#8220;mathematical&#8221; function as a NED function. The registered C/C++ function
may take up to four <tt>double</tt> arguments, and must return a <tt>double</tt>;
the NED signature will be the same. In other words, functions registered
this way cannot accept any NED data type other than <tt>double</tt>; cannot
return anything else than <tt>double</tt>; cannot accept or return values with
measurement units; cannot have optional arguments or variable argument
lists; and are restricted to four arguments at most. In exchange for these
restrictions, the C++ implementation of the functions is a lot simpler.

<p>Accepted function signatures for <tt>Define_NED_Math_Function()</tt>:

<pre class="cpp">
double f();
double f(double);
double f(double, double);
double f(double, double, double);
double f(double, double, double, double);
</pre>
<p>
The simulation kernel uses <tt>Define_NED_Math_Function()</tt> to expose
commonly used <tt>&lt;math.h&gt;</tt> functions in the NED language. Most <tt>&lt;math.h&gt;</tt>
functions (<tt>sin()</tt>, <tt>cos()</tt>, <tt>fabs()</tt>, <tt>fmod()</tt>, etc.)
can be directly registered without any need for wrapper code, because their
signatures is already one of the accepted ones listed above.

<p>The macro has the following variants:

<pre class="cpp">
Define_NED_Math_Function(NAME,ARGCOUNT);
Define_NED_Math_Function2(NAME,FUNCTION,ARGCOUNT);
Define_NED_Math_Function3(NAME,ARGCOUNT,CATEGORY,DESCRIPTION);
Define_NED_Math_Function4(NAME,FUNCTION,ARGCOUNT,CATEGORY,DESCRIPTION);
</pre>
<p>
All macros accept the <tt>NAME</tt> and <tt>ARGCOUNT</tt> parameters; they are
the intended name of the NED function and the number of <tt>double</tt>
arguments the function takes (0..3). <tt>NAME</tt> should be provided without
quotation marks (they will be added inside the macro.) Two macros also
accept a <tt>FUNCTION</tt> parameter, which is the name of (or pointer to) the
implementation C/C++ function. The macros that don't have a <tt>FUNCTION</tt>
parameter simply use the <tt>NAME</tt> parameter for that as well. The last
two macros accept <tt>CATEGORY</tt> and <tt>DESCRIPTION</tt>, which have exactly
the same role as with <tt>Define_NED_Function()</tt>.

<p>Examples:

<pre class="cpp">
Define_NED_Math_Function3(sin, 1, "math", "Trigonometric function; see &lt;math.h&gt;");
Define_NED_Math_Function3(cos, 1, "math", "Trigonometric function; see &lt;math.h&gt;");
Define_NED_Math_Function3(pow, 2, "math", "Power-of function; see &lt;math.h&gt;");
</pre>
<p>

<p>
<h2><a name="sec:sim-lib:deriving-new-classes"/>7.12 Deriving New Classes<a class="headerlink" href="#sec:sim-lib:deriving-new-classes" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:sim-lib:cobject-or-not"/>7.12.1 <a href="../api/classomnetpp_1_1cObject.html">cObject</a> or Not?<a class="headerlink" href="#sec:sim-lib:cobject-or-not" title="Permalink to this headline"></a></h3>

<p>If you plan to implement a completely new class (as opposed to
subclassing something already present in OMNeT++), you have
to ask yourself whether you want the new class to be based
on <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> or not.
Note that we are <i>not</i> saying you should always
subclass from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.
Both solutions have advantages and disadvantages, which you
have to consider individually for each class.

<p><tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> already carries (or provides a framework for)
significant functionality that is either relevant to
your particular purpose or not. Subclassing <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>
generally means you have more code to write (as you <i>have to</i>
redefine certain virtual functions and adhere to conventions)
and your class will be a bit more heavy-weight.
However, if you need to store your objects in OMNeT++ objects like <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>
or you want to store OMNeT++ classes in your object,
then you <i>must</i> subclass from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.
  <br><ul><font size=-1>[For simplicity, in these sections &#8220;OMNeT++ object&#8221;
  should be understood as &#8220;object of a class subclassed from
  <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>&#8221;]</font></ul>

<p>The most significant features of <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> are
the name string (which has to be stored somewhere, so it has
its overhead) and ownership management (see section
<a href="#sec:sim-lib:ownership-management">[7.13]</a>), which
also provides advantages at some cost.

<p>As a general rule, small <tt>struct</tt>-like classes like <tt>IPAddress</tt> or
<tt>MACAddress</tt> are better <i>not</i> subclassed from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>.
If your class has at least one virtual member function, consider
subclassing from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>, which does not impose any
extra cost because it doesn't have data members at all, only
virtual functions.

<p>
<h3><a name="sec:sim-lib:cobject-virtual-methods"/>7.12.2 <a href="../api/classomnetpp_1_1cObject.html">cObject</a> Virtual Methods<a class="headerlink" href="#sec:sim-lib:cobject-virtual-methods" title="Permalink to this headline"></a></h3>

<p>Most classes in the simulation class library are descendants of
<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>. When deriving a new class from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>
or a <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> descendant, one must redefine certain member
functions so that objects of the new class can fully co-operate
with the simulation library classes. A list of those methods is
presented below.

<p><ul class="note"><b>NOTE</b><br>
You don't need to worry about the length of the list: most functions
are not always required to implement. For example, <tt>forEachChild()</tt>
is only important if the new class is a container.
</ul>

<p>The following methods <b>must</b> be implemented:

<p><ul>
  <li> <i>Constructor</i>. At least two constructors should be provided:
        one that takes the object name string as <tt>const char *</tt>
        (recommended by convention), and another one with no arguments
        (must be present). The two are usually implemented as a single
        method, with <tt>nullptr</tt> as default name string.
  <li> <i>Copy constructor</i>, which must have the following signature
        for a class <tt>X</tt>: <tt>X(const X&amp;)</tt>.
  <li> <i>Destructor</i>.
  <li> <i>Duplication function,</i> <tt>X *dup() const</tt>.
        It should create and return an exact duplicate of the object.
        It is usually a one-line function that delegates to the copy constructor.
  <li> <i>Assignment operator</i>, that is, <tt>X&amp; operator=(const X&amp;)</tt>
        for a class <tt>X</tt>. It should copy the contents of the other
        object into this one, <i>except</i> the name string. See later what to do
        if the object contains pointers to other objects.
</ul>

<p>If the new class contains other objects subclassed from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>,
either via pointers or as a data member, the following function <b>should</b>
be implemented:

<p><ul>
  <li> <i>Iteration function,</i> <tt>void forEachChild(<a href="../api/classomnetpp_1_1cVisitor.html">cVisitor</a> *v)</tt>.
        The implementation should call the function passed
        for each object it contains via pointer or as a data member;
        see the API Reference on <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> on how to implement
        <tt>forEachChild()</tt>. <tt>forEachChild()</tt> makes it possible
        for Tkenv and Qtenv to display the object tree, to perform searches on it, etc.
        It is also used by <tt>snapshot()</tt> and some other library functions.
</ul>

<p>Implementation of the following methods is <b>recommended</b>:

<p><ul>
  <li> <i>Object info,</i> <tt>str()</tt>. The <tt>str()</tt> function
        should return a one-line string describing the object's contents or state.
        The text returned by <tt>str()</tt> is displayed at several places in Tkenv
        and Qtenv.
        <br><ul><font size=-1>[Until OMNeT++ version 5.1, <tt>str()</tt> was called <tt>info()</tt>.
        There was also a <tt>detailedInfo()</tt> method that was removed in the
        same version for lack of real usefulness.]</font></ul>
  <li> <i>Serialization</i>, <tt>parsimPack()</tt> and <tt>parsimUnpack()</tt> methods.
        These methods are needed for parallel simulation, if you want
        objects of this type to be transmitted across partitions.
</ul>

<p>It is customary to implement the copy constructor and the assignment operator
so that they delegate to the same function of the base class, and invoke a common
private <tt>copy()</tt> function to copy the local members.

<p><h3><a name="sec:sim-lib:class-registration"/>7.12.3 Class Registration<a class="headerlink" href="#sec:sim-lib:class-registration" title="Permalink to this headline"></a></h3>

<p>You should also use the <tt>Register_Class()</tt> macro to register the
new class. It is used by the <tt>createOne()</tt> factory function, which can
create any object given the class name as a string. <tt>createOne()</tt>
is used by the Envir library to implement <tt>omnetpp.ini</tt> options
such as <tt>rng-class="..."</tt> or <tt>scheduler-class="..."</tt>.
(see Chapter <a href="#cha:plugin-exts">[17]</a>)

<p>For example, an <tt>omnetpp.ini</tt> entry such as

<pre class="inifile">
rng-class = "<a href="../api/classomnetpp_1_1cMersenneTwister.html">cMersenneTwister</a>"
</pre>
<p>
would result in something like the following code to be executed
for creating the RNG objects:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cRNG.html">cRNG</a> *rng = check_and_cast&lt;<a href="../api/classomnetpp_1_1cRNG.html">cRNG</a>*&gt;(createOne("<a href="../api/classomnetpp_1_1cMersenneTwister.html">cMersenneTwister</a>"));
</pre>
<p>
But for that to work, we needed to have the following line somewhere in the code:

<pre class="cpp">
Register_Class(<a href="../api/classomnetpp_1_1cMersenneTwister.html">cMersenneTwister</a>);
</pre>
<p>
<tt>createOne()</tt> is also needed by the parallel distributed simulation feature
(Chapter <a href="#cha:parallel-exec">[16]</a>) to create blank objects to unmarshal into
on the receiving side.

<p>
<h3><a name="sec:sim-lib:subclassing-cobject-details"/>7.12.4 Details<a class="headerlink" href="#sec:sim-lib:subclassing-cobject-details" title="Permalink to this headline"></a></h3>

<p>We'll go through the details using an example. We create a new
class <tt>NewClass</tt>, redefine all above mentioned <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>
member functions, and explain the conventions, rules and tips
associated with them.
To demonstrate as much as possible, the class will contain
an <tt>int</tt> data member, dynamically allocated non-<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> data
(an array of <tt>double</tt>s),
an OMNeT++ object as data member (a <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>), and
a dynamically allocated OMNeT++ object (a <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>).

<p>The class declaration is the following. It contains the declarations
of all methods discussed in the previous section.

<pre class="cpp">
//
// file: NewClass.h
//
#include &lt;omnetpp.h&gt;

class NewClass : public <a href="../api/classomnetpp_1_1cObject.html">cObject</a>
{
  protected:
    int size;
    double *array;
    <a href="../api/classomnetpp_1_1cQueue.html">cQueue</a> queue;
    <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> *msg;
    ...
  private:
    void copy(const NewClass& other); // local utility function
  public:
    NewClass(const char *name=nullptr, int d=0);
    NewClass(const NewClass& other);
    virtual ~NewClass();
    virtual NewClass *dup() const;
    NewClass& operator=(const NewClass& other);

    virtual void forEachChild(<a href="../api/classomnetpp_1_1cVisitor.html">cVisitor</a> *v);
    virtual std::string info();
};
</pre>
<p>
We'll discuss the implementation method by method.
Here is the top of the <tt>.cc</tt> file:

<pre class="cpp">
//
// file: NewClass.cc
//
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream.h&gt;
#include "newclass.h"

Register_Class(NewClass);

NewClass::NewClass(const char *name, int sz) : <a href="../api/classomnetpp_1_1cObject.html">cObject</a>(name)
{
    size = sz;
    array = new double[size];
    take(&queue);
    msg = nullptr;
}
</pre>
<p>
The constructor (above) calls the base class constructor with
the name of the object, then initializes its own data members.
You need to call <tt>take()</tt> for <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>-based data members.

<pre class="cpp">
NewClass::NewClass(const NewClass& other) : <a href="../api/classomnetpp_1_1cObject.html">cObject</a>(other)
{
    size = -1; // needed by copy()
    array = nullptr;
    msg = nullptr;
    take(&queue);
    copy(other);
}
</pre>
<p>
The copy constructor relies on the private <tt>copy()</tt> function.
Note that pointer members have to be initialized (to <tt>nullptr</tt> or to an
allocated object/memory) before calling the <tt>copy()</tt> function.

<p>You need to call <tt>take()</tt> for <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>-based data members.

<pre class="cpp">
NewClass::~NewClass()
{
    delete [] array;
    if (msg-&gt;getOwner()==this)
        delete msg;
}
</pre>
<p>
The destructor should delete all data structures the object allocated.
<tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>-based objects should <i>only</i> be deleted if they
are owned by the object -- details will be covered in section
<a href="#sec:sim-lib:ownership-management">[7.13]</a>.

<pre class="cpp">
NewClass *NewClass::dup() const
{
    return new NewClass(*this);
}
</pre>
<p>
The <tt>dup()</tt> function  is usually just one line, like the one above.

<pre class="cpp">
NewClass& NewClass::operator=(const NewClass& other)
{
    if (&other==this)
        return *this;

    <a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a>::operator=(other);
    copy(other);
    return *this;
}
</pre>
<p>
The assignment operator (above) first makes sure that will not try to copy
the object to itself, because that can be disastrous. If so (that is,
<tt>&amp;other==this</tt>), the function returns immediately without doing anything.

<p>The base class part is copied via invoking the assignment operator of
the base class. Then the method copies over the local members using the
<tt>copy()</tt> private utility function.

<pre class="cpp">
void NewClass::copy(const NewClass& other)
{
    if (size != other.size) {
        size = other.size;
        delete array;
        array = new double[size];
    }
    for (int i = 0; i &lt; size; i++)
        array[i] = other.array[i];

    queue = other.queue;
    queue.setName(other.queue.getName());

    if (msg && msg-&gt;getOwner()==this)
        delete msg;

    if (other.msg && other.msg-&gt;getOwner()==const_cast&lt;<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>*&gt;(&other))
        take(msg = other.msg-&gt;dup());
    else
        msg = other.msg;
}
</pre>
<p>
Complexity associated with copying and duplicating the object
is concentrated in the <tt>copy()</tt> utility function.

<p>Data members are copied in the normal C++ way. If the class
contains pointers, you will most probably want to make a deep copy of
the data where they point, and not just copy the pointer values.

<p>If the class contains pointers to OMNeT++ objects, you need
to take ownership into account. If the contained object is <i>not owned</i>
then we assume it is a pointer to an &#8220;external&#8221; object, consequently
we only copy the pointer. If it is <i>owned</i>, we duplicate
it and become the owner of the new object. Details of ownership
management will be covered in section <a href="#sec:sim-lib:ownership-management">[7.13]</a>.

<p>
<pre class="cpp">
void NewClass::forEachChild(<a href="../api/classomnetpp_1_1cVisitor.html">cVisitor</a> *v)
{
    v-&gt;visit(queue);
    if (msg)
        v-&gt;visit(msg);
}
</pre>

<p>The <tt>forEachChild()</tt> function should call <tt>v-&gt;visit(obj)</tt>
for each <tt>obj</tt> member of the class. See the API Reference for more
information about <tt>forEachChild()</tt>.

<pre class="cpp">
std::string NewClass::info()
{
    std::stringstream out;
    out &lt;&lt; "data=" &lt;&lt; data &lt;&lt; ", array[0]=" &lt;&lt; array[0];
    return out.str();

}
</pre>
<p>
The <tt>info()</tt> method should produce a concise, one-line string
about the object. You should try not to exceed 40-80 characters, since the
string will be shown in tooltips and listboxes.

<p>See the virtual functions of <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> and <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>
in the class library reference for more information. The sources of the
Sim library (<tt>include/</tt>, <tt>src/sim/</tt>) can serve as further examples.

<p>

<p><h2><a name="sec:sim-lib:ownership-management"/>7.13 Object Ownership Management<a class="headerlink" href="#sec:sim-lib:ownership-management" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:sim-lib:ownership-tree"/>7.13.1 The Ownership Tree<a class="headerlink" href="#sec:sim-lib:ownership-tree" title="Permalink to this headline"></a></h3>

<p>OMNeT++ has a built-in ownership management mechanism which
is used for sanity checks, and as part of the infrastructure
supporting Tkenv/Qtenv inspectors.

<p>Container classes like <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> own the objects inserted
into them, but this is not limited to objects inserted into a container:
<i>every <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>-based object has an owner all the time</i>.
From the user's point of view, ownership is managed transparently.
For example, when you create a new <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>,
it will be owned by the simple module. When you send it, it will
first be handed over to (i.e. change ownership to) the FES<!--FES-->, and,
upon arrival, to the destination simple module. When you encapsulate
the message in another one, the encapsulating message will become
the owner. When you decapsulate it again, the currently active
simple module becomes the owner.

<p>The <tt>getOwner()</tt> method, defined in <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>, returns the
owner of the object:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a> *o = msg-&gt;getOwner();
EV &lt;&lt; "Owner of " &lt;&lt; msg-&gt;getName() &lt;&lt; " is: " &lt;&lt;
   &lt;&lt; "(" &lt;&lt; o-&gt;getClassName() &lt;&lt; ") " &lt;&lt; o-&gt;getFullPath() &lt;&lt; endl;
</pre>
<p>
The other direction, enumerating the objects owned can be implemented with
the <tt>forEachChild()</tt> method by it looping through all
contained objects and checking the owner of each object.

<p><h4><a name="sec:sim-lib:why-we-need-ownership"/>7.13.1.1 Why Do We Need This?<a class="headerlink" href="#sec:sim-lib:why-we-need-ownership" title="Permalink to this headline"></a></h4>

<p>The traditional concept of object ownership is associated with
the &#8220;right to delete&#8221; objects. In addition to that,
keeping track of the owner and the list of objects owned also
serves other purposes in OMNeT++:

<p><ul>
    <li> enables methods like <tt>getFullPath()</tt> to be implemented.

<p>    <li> prevents certain types of programming errors, namely,
    those associated with wrong ownership handling.

<p>    <li> enables Tkenv and Qtenv to display the list of simulation objects
    present within a simple module. This is extremely useful for finding
    memory leaks caused by forgetting to delete messages that are
    no longer needed.
</ul>

<p>Some examples of programming errors that can be caught
by the ownership facility:

<p><ul>
    <li> attempts to send a message while it is still in a queue,
    encapsulated in another message, etc.

<p>    <li> attempts to send/schedule a message while it is still owned
    by the simulation kernel (i.e. scheduled as a future event)

<p>    <li> attempts to send the very same message object to multiple
    destinations at the same time (ie. to all connected modules)
</ul>

<p>For example, the <tt>send()</tt> and <tt>scheduleAt()</tt> functions check
that the message being sent/scheduled is owned by the module.
If it is not, then it signals a programming error: the message is probably
owned by another module (already sent earlier?), or currently scheduled, or
inside a queue, a message or some other object -- in either case, the
module does not have any authority over it. When you get the error message
(<tt>"not owner of object"</tt>), you need to carefully examine the error
message to determine which object has ownership of the message, and correct
the logic that caused the error.

<p>The above errors are easy to make in the code, and if not detected
automatically, they could cause random crashes which are usually very
difficult to track down. Of course, some errors of the same kind still
cannot be detected automatically, like calling member functions of a
message object which has been sent to (and so is currently owned by) another
module.

<p>
<h3><a name="sec:sim-lib:managing-ownership"/>7.13.2 Managing Ownership<a class="headerlink" href="#sec:sim-lib:managing-ownership" title="Permalink to this headline"></a></h3>

<p>Ownership is managed transparently for the user, but this mechanism
has to be supported by the participating classes themselves.
It will be useful to look inside <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> and <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt>,
because they might give you a hint what behavior you need
to implement when you want to use non-OMNeT++ container classes
to store messages or other <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>-based objects.

<p>
<h4><a name="sec:sim-lib:ownership-and-insertion-into-container"/>7.13.2.1 Insertion<a class="headerlink" href="#sec:sim-lib:ownership-and-insertion-into-container" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> and <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> have internal data structures
(array and linked list) to store the objects which are inserted
into them. However, they do <i>not</i> necessarily own all of these
objects.  (Whether they own an object or not can be determined
from that object's <tt>getOwner()</tt> pointer.)

<p>The default behaviour of <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> and <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> is
to take ownership of the objects inserted.
This behavior can be changed via the <i>takeOwnership</i> flag.

<p>Here is what the <i>insert</i> operation of <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> (or <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt>) does:
<ul>
    <li> insert the object into the internal array/list data structure

<p>    <li> if the <i>takeOwnership</i> flag is true, take ownership
    of the object, otherwise just leave it with its original owner
</ul>

<p>The corresponding source code:

<pre class="cpp">
void <a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>::insert(<a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a> *obj)
{
    // insert into queue data structure
    ...

    // take ownership if needed
    if (getTakeOwnership())
        take(obj);

}
</pre>
<p>

<p><h4><a name="sec:sim-lib:ownership-and-removal-from-container"/>7.13.2.2 Removal<a class="headerlink" href="#sec:sim-lib:ownership-and-removal-from-container" title="Permalink to this headline"></a></h4>

<p>Here is what the <i>remove</i> family of operations in <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>
(or <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt>) does:

<p><ul>
    <li> remove the object from the internal array/list data structure

<p>    <li> if the object is actually owned by this <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>/<tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt>,
    release ownership of the object, otherwise just leave it with
    its current owner
</ul>

<p>After the object was removed from a <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>/<tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt>,
you may further use it, or if it is not needed any more, you can delete it.

<p>The <i>release ownership</i> phrase requires further explanation.
When you remove an object from a queue or array, the ownership
is expected to be transferred to the simple module's local objects list.
This is accomplished by the <tt>drop()</tt> function, which transfers the
ownership to the object's default owner.
<tt>getDefaultOwner()</tt> is a virtual method defined in <tt><a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a></tt>,
and its implementation returns
the currently executing simple module's local object list.

<p>As an example, the <tt>remove()</tt> method of <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> is
implemented like this:
  <br><ul><font size=-1>[Actual code in <tt>src/sim</tt> is structured somewhat
  differently, but the meaning is the same.]</font></ul>

<pre class="cpp">
<a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a> *<a href="../api/classomnetpp_1_1cQueue.html">cQueue</a>::remove(<a href="../api/classomnetpp_1_1cOwnedObject.html">cOwnedObject</a> *obj)
{
    // remove object from queue data structure
    ...

    // release ownership if needed
    if (obj-&gt;getOwner()==this)
        drop(obj);

    return obj;
}
</pre>
<p>

<p><h4><a name="sec:sim-lib:ownership-and-container-destructor"/>7.13.2.3 Destructor<a class="headerlink" href="#sec:sim-lib:ownership-and-container-destructor" title="Permalink to this headline"></a></h4>

<p>The concept of <tt>ownership</tt> is that <i>the owner has the
exclusive right and duty to delete the objects it owns</i>.
For example, if you delete a <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> containing <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>s,
all messages it contains <i>and</i> owns will also be deleted.

<p>The destructor should delete all data structures the object allocated.
From the contained objects, only the owned ones are deleted -- that is,
where <tt>obj-&gt;getOwner()==this</tt>.

<p>
<h4><a name="sec:sim-lib:ownership-and-object-copying"/>7.13.2.4 Object Copying<a class="headerlink" href="#sec:sim-lib:ownership-and-object-copying" title="Permalink to this headline"></a></h4>

<p>The ownership mechanism also has to be taken into consideration
when a <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> or <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> object is duplicated
(using <tt>dup()</tt> or the copy constructor.)
The duplicate is supposed to have the same content as the
original; however, the question is whether the contained objects
should also be duplicated or only their pointers taken over
to the duplicate <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt> or <tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>. A similar
question arises when an object is copied using the assignment operator
(<tt>operator=()</tt>).

<p>The convention followed by <tt><a href="../api/classomnetpp_1_1cArray.html">cArray</a></tt>/<tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt> is that
only owned objects are copied, and the contained but not owned ones
will have their pointers taken over and their original owners
left unchanged.

<p>


<hr class='pgbr'><h1><a name="cha:graphics"/>8 Graphics and Visualization<a class="headerlink" href="#cha:graphics" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:graphics:overview"/>8.1 Overview<a class="headerlink" href="#sec:graphics:overview" title="Permalink to this headline"></a></h2>

<p>OMNeT++ simulations can be run under graphical user interfaces like Qtenv
that offer visualization and animation in addition to interactive
execution and other features. This chapter deals with model visualization.

<p>OMNeT++ essentially provides four main tools for defining and enhancing
model visualization:

<p><ol>

<p>    <li> <i>Display strings</i> is the traditional way. It is a
    per-component string that encodes how the component (module or channel)
    will show up in the graphical user interface. Display strings can be
    specified in NED files, and can also be manipulated programmatically at
    runtime.

<p>    <li> <i>The canvas.</i> The same user interface area that contains
    submodules and connections (i.e. the <i>canvas</i>) can also display
    additional graphical elements that OMNeT++ calls <i>figures</i>. Using
    figures, one can display lines, curves, polygons, images and text items,
    and anything that can be built by combining them and applying effects like
    rotation and scaling. Like display strings, figures can also be specified
    in NED files, but it is generally more useful to create and manipulate them
    programmatically. Every module has its own default canvas, and extra canvases 
    can also be created at runtime.

<p>    <li> <i>3D visualization</i> of the simulation's virtual world is a
    third possiblity. OMNeT++'s 3D visualization capabilities come from the
    open-source OpenSceneGraph library and its osgEarth extension. These
    libraries build on top of OpenGL, and beyond basic graphics functionality 
    they also offer high-level capabilities, such as reading 3D model files
    directly from disk, or displaying maps, 3D terrain or Earth as a planet
    using online map and satellite imagery data sources.

<p>    <li> <i>Support for smooth custom animation</i> allows models to visualize
    their operation using sophisticated animations. The key idea is that the
    simulation model is called back from the runtime GUI (Qtenv) repeatedly
    at a reasonable &#8220;frame rate,&#8221; allowing it to continually update the
    canvas (2D) and/or the 3D scene to produce fluid animations.

<p></ol>

<p>The following sections will cover the above topics in more detail. But first,
let us get acquainted with a new <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> virtual method that one
can redefine and place visualization-related code into.

<p>
<h2><a name="sec:graphics:refreshdisplay"/>8.2 Placement of Visualization Code<a class="headerlink" href="#sec:graphics:refreshdisplay" title="Permalink to this headline"></a></h2>

<p>Traditionally, when C++ code was needed to enhance visualization, for
example to update a displayed status label or to refresh the position of a
mobile node, it was embedded in <tt>handleMessage()</tt> functions, enclosed
in <tt>if (ev.isGUI())</tt> blocks. This was less than ideal, because the
visualization code would run for all events in that module and not just
before display updates when it was actually needed. In <i>Express</i> mode,
for example, Qtenv would only refresh the display once every second or so,
with a large number of events processed between updates, so visualization
code placed inside <tt>handleMessage()</tt> could potentially waste a
significant amount of CPU cycles. Also, visualization code embedded in 
<tt>handleMessage()</tt> is not suitable for creating smooth animations.

<p>
<h3><a name="sec:graphics:refreshdisplay-usage-and-semantics"/>8.2.1 The refreshDisplay() Method<a class="headerlink" href="#sec:graphics:refreshdisplay-usage-and-semantics" title="Permalink to this headline"></a></h3>

<p>Starting from OMNeT++ version 5.0, visualization code can be placed into a
dedicated method. It is called much more economically, that is, exactly 
as often as needed.

<p>This method is <tt>refreshDisplay()</tt>, and is declared on
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> as:

<pre class="cpp">
virtual void refreshDisplay() const {}
</pre>
<p>
Components that contain visualization-related code are expected to override
<tt>refreshDisplay()</tt>, and move visualization code such as display string
manipulation, canvas figure maintenance and OSG scene graph updates into it.

<p>When and how is <tt>refreshDisplay()</tt> invoked? Generally, right before
the GUI performs a display update. With some additional rules, that boils
down to the following:

<p><ol>
<li> It is invoked only under graphical user interfaces, currently Qtenv
     and Tkenv. It is never invoked under Cmdenv.

<p><li> When invoked, it will be called on <i>all</i> components of the
      simulation. It does not matter if a module has a graphical inspector
      open or not. This design decision simplifies the handling
      of cross-module visualization dependencies. Runtime overhead is
      still not an issue, because display updates are only done at most
      a few times per second in <i>Express</i> mode, while in other modes,
      raw event processing performance is of somewhat lesser importance.
      <br><ul><font size=-1>[At any rate, only a small portion of components are expected to
      have (nontrivial) <tt>refreshDisplay()</tt> overrides in complex models.
      If it still becomes too resource-consuming, local caching of related
      data and the use of a <i>displayInvalid</i> flag might help.]</font></ul>

<p><li> It is invoked right before display updates. This includes the following:
      after network setup; in <i>Step</i> and <i>Run</i> modes, before and
      after every event; in <i>Fast</i> and <i>Express</i> modes, after
      every "batch" of events; every time a new graphical inspector is opened,
      zoomed, navigated in, or closed; after model data (<a href="../api/classomnetpp_1_1cPar.html">cPar</a>, <a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a>
      values, etc.) is edited, and after finalization.

<p><li> If smooth animation is used, it is invoked continuously with a reasonably
      high frequency in <i>Step</i>, <i>Run</i> and <i>Fast</i> modes.
      This can mean anything from many times between processing two consecutive
      events to not even once until after the processing of a couple of events,
      depending on the current animation speed and event density.

<p></ol>

<p>Here is an example of how one would use it:

<pre class="cpp">
void FooModule::refreshDisplay() const
{
    // refresh statistics
    char buf[80];
    sprintf(buf, "Sent:%d  Rcvd:%d", numSent, numReceived);
    getDisplayString()-&gt;setTagArg("t", 0, buf);

    // update the mobile node's position
    Point pos = ...  // e.g. invoke a computePosition() method
    getDisplayString()-&gt;setTagArg("p", 0, pos.x);
    getDisplayString()-&gt;setTagArg("p", 1, pos.y);
}
</pre>
<p>
One useful accessory to <tt>refreshDisplay()</tt> is the
<tt>isExpressMode()</tt> method of <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>. It returns true if the
simulation is running under a GUI in <i>Express</i> mode. Visualization
code may check this flag and adapt the visualization accordingly. An example:

<pre class="cpp">
if (getEnvir()-&gt;isExpressMode()) {
    // display throughput statistics
}
else {
    // visualize current frame transmission
}
</pre>
<p>

<p><h3><a name="sec:graphics:refreshdisplay-advantages"/>8.2.2 Advantages<a class="headerlink" href="#sec:graphics:refreshdisplay-advantages" title="Permalink to this headline"></a></h3>

<p>Overriding <tt>refreshDisplay()</tt> has several advantages over putting the
simulation code into <tt>handleMessage()</tt>. The first one is clearly
<i>performance</i>. When running under Cmdenv,
the runtime cost of visualization code is literally zero, and when running
in <i>Express</i> mode under Tkenv/Qtenv, it is practically zero because
the cost of one update is amortized over several hundred thousand or
million events.

<p>The second advantage is also very practical: <i>consistency</i> of the
visualization. If the simulation has cross-module dependencies such that
an event processed by one module affects the information displayed
by another module, with <tt>handleMessage()</tt>-based visualization
the model may have inconsistent visualization until the second module
also processes an event and updates its displayed state. With
<tt>refreshDisplay()</tt> this does not happen, because all modules
are refreshed together.

<p>The third advantage is <i>separation of concerns.</i> It is generally
not a good idea to intermix simulation logic with visualization code,
and <tt>refreshDisplay()</tt> allows one to completely separate the two.

<p>
<h3><a name="sec:graphics:refreshdisplay-constness"/>8.2.3 Why is <tt>refreshDisplay()</tt> const?<a class="headerlink" href="#sec:graphics:refreshdisplay-constness" title="Permalink to this headline"></a></h3>

<p>Code in <tt>refreshDisplay()</tt> should never alter the state of the
simulation because that would destroy repeatability, due to the 
fact that the timing and frequency of <tt>refreshDisplay()</tt>
calls is completely unpredictable from the simulation model's point of view.
The fact that the method is declared <tt>const</tt> gently encourages this behavior.

<p>If visualization code makes use of internal caches or maintains some
other mutable state, such data members can be declared <tt>mutable</tt>
to allow <tt>refreshDisplay()</tt> to change them.

<p>
<h2><a name="sec:graphics:smooth-animation"/>8.3 Smooth Animation<a class="headerlink" href="#sec:graphics:smooth-animation" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:graphics:animation-concepts"/>8.3.1 Concepts<a class="headerlink" href="#sec:graphics:animation-concepts" title="Permalink to this headline"></a></h3>

<p>Support for smooth custom animation allows models to visualize their operation 
using sophisticated animations. The key idea is that the simulation model 
is called back from the runtime GUI (Qtenv) repeatedly at a reasonable 
&#8220;frame rate,&#8221; allowing it to continually update the canvas (2D) and/or the 
3D scene to produce fluid animations. Callback means that the 
<tt>refreshDisplay()</tt> methods of modules and figures are invoked.

<p><tt>refreshDisplay()</tt> knows the animation position from the simulation time
and the <i>animation time</i>, a variable also made accessible to the model.
If you think about the animation as a movie, animation time is simply the 
position in seconds in the movie. By default, the movie is played in Qtenv at normal (1x) 
speed, and then animation time is simply the number of seconds since the
start of the movie. The speed control slider in Qtenv's toolbar allows 
you to play it at higher (2x, 10x, etc.) and lower (0.5x, 0.1x, etc.)
speeds; so if you play the movie at 2x speed, animation time will
pass twice as fast as real time.

<p>When smooth animation is turned on (more about that later), simulation 
time progresses in the model (piecewise) linearly. The speed at which the simulation
progresses in the movie is called <i>animation speed</i>. Sticking to the
movie analogy, when the simulation progresses in the movie 100 times
faster than animation time, animation speed is 100.

<p>Certain actions take zero simulation time, but we still want to animate
them. Examples of such actions are the sending of a message over a zero-delay link,
or a visualized C++ method call between two modules. When these animations play
out, simulation is paused and simulation time stays constant 
until the animation is over. Such periods are called <i>holds</i>.

<p><h3><a name="sec:graphics:animation-modes"/>8.3.2 Smooth vs. Traditional Animation<a class="headerlink" href="#sec:graphics:animation-modes" title="Permalink to this headline"></a></h3>

<p>Smooth animation is a relatively new feature in OMNeT++, and not all simulations
need it. Smooth and traditonal, &#8220;non-smooth&#8221; animation in Qtenv are
two distinct modes which operate very differently:

<p><ul>
  <li> In <b>Traditional animation</b>, simulation events are essentially 
    processed <i>as fast as possible</i>, and meanwhile, <tt>refreshDisplay()</tt>
    is called with some policy (e.g. once before/after each event, or at
    1s intervals real-time) to keep the displayed  graphics up to date.
  <li> <b>Smooth animation</b> is essentially a <i>scaled realtime simulation</i>,
    where <tt>refreshDisplay()</tt> is continually called with a reasonably
    high frame rate.
</ul>

<p>The factor that decides which operation mode is active is the <i>presence
of an animation speed</i>. If there is no animation speed, traditional
animation is performed; if there is one, smooth animation is done.

<p>The Qtenv GUI has a dialog (<i>Animation Parameters</i>) which displays 
the current animation speed, among other things. This dialog allows the
user to check at any time which operation mode is currently active.<br><ul><font size=-1>[
Note that even during traditional animation, some built-in animation effects
request animation speeds and holds, so there may be periods when smooth animation
is performed.]</font></ul>

<p><h3><a name="sec:graphics:animation-speed"/>8.3.3 The Choice of Animation Speed<a class="headerlink" href="#sec:graphics:animation-speed" title="Permalink to this headline"></a></h3>

<p>Different animation speeds may be appropriate for different animation effects.
For example, when animating WiFi traffic where various time slots are on the microsecond scale,
an animation speed on the order of <i>10^-5</i> might be appropriate; when animating the 
movement of cars or pedestrians, an animation speed of <i>1</i> is a reasonable choice.
When several animations requiring different animation speeds occur in the same
scene, one solution is to animate the scene using the lowest animation speed
so that even the fastest actions can be visually followed by the human viewer.
 
<p>The solution provided by OMNeT++ for the above problem is the following.
Animation speed cannot be controlled explicitly, only requests may be submitted.
Several parts of the models may request different animation speeds. 
The effective animation speed is computed as the minimum of the animation 
speeds of visible canvases, unless the user interactively overrides it in the UI, 
for example by imposing a lower or upper limit.

<p>An animation speed requests may be submitted using the <tt>setAnimationSpeed()</tt> 
method of <tt><a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a></tt>.<br><ul><font size=-1>[The class that represents the canvas for
2D graphics, see <a href="#sec:graphics:creating-accessing-and-viewing-canvases">[8.6.2]</a> for more
info.]</font></ul> The <tt>setAnimationSpeed()</tt> method takes two arguments: 
the animation speed value (a <tt>double</tt>) and an object pointer (<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a>*</tt>)
that identifies the part of the model that requests it. The second, object parameter
is used as a key that allows the request to be updated or withdrawn later. 
Typically, the pointer of the module that makes the request (i.e. <tt>this</tt>) is 
used for that purpose. Calling <tt>setAnimationSpeed()</tt> with zero animation 
speed cancels the request.

<p>An example:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a> *canvas = getSystemModule()-&gt;getCanvas(); // toplevel canvas
canvas-&gt;setAnimationSpeed(2.0, this); // one request
canvas-&gt;setAnimationSpeed(1e-6, macModule); // another request
...
canvas-&gt;setAnimationSpeed(1.0, this); // overwrite first request
canvas-&gt;setAnimationSpeed(0, macModule); // cancel second request
</pre>
<p>
In practice, built-in animation effects such as message sending animation
also submit their own animation speed requests internally, so they also 
affect the effective animation speed chosen by Qtenv.

<p>The current effective animation speed can be obtained from the environment of the
simulation (<tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>, see chapter <a href="#cha:embedding">[18]</a> for context): 

<pre class="cpp">
double animSpeed = getEnvir()-&gt;getAnimationSpeed(); 
</pre>
<p>
Animation time can be accessed like this:

<pre class="cpp">
double animTime = getEnvir()-&gt;getAnimationTime();
</pre>
<p>
Animation time starts from zero, and monotonically increases with simulation 
time and also during &#8220;holds&#8221;.

<p>
<h3><a name="sec:graphics:animation-hold"/>8.3.4 Holds<a class="headerlink" href="#sec:graphics:animation-hold" title="Permalink to this headline"></a></h3>

<p>As mentioned earlier, a hold interval is an interval when only animation
takes place, but simulation time does not progress and no events
are processed. Hold intervals are intended for animating actions
that take zero simulation time.

<p>A hold can be requested with the <tt>holdSimulationFor()</tt> method
of <tt><a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a></tt>, which accepts an animation time delta as parameter.
If a hold request is issued when there is one already in progress,
the current hold will be extended as needed to incorporate the
request. A hold request cannot be cancelled or shrunk.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a> *canvas = getSystemModule()-&gt;getCanvas(); // toplevel canvas
canvas-&gt;holdSimulationFor(0.5); // request a 0.5s (animation time) hold
</pre>
<p>
When rendering frames in <tt>refreshDisplay()</tt>) during a hold, the code
can use animation time to determine the position in the animation.
If the code needs to know the animation time elapsed since the start of
the hold, it should query and remember the animation time when issuing
the hold request.

<p>If the code needs to know the animation time remaining until the end
of the hold, it can use the <tt>getRemainingAnimationHoldTime()</tt> 
method of <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>. Note that this is not necessarily the
time remaining from its own hold request, because other parts of the
simulation might extend the hold.

<p>
<h3><a name="sec:graphics:disabling-built-in-anims"/>8.3.5 Disabling Built-In Animations<a class="headerlink" href="#sec:graphics:disabling-built-in-anims" title="Permalink to this headline"></a></h3>

<p>If a model implements such full-blown animations for a compound module that
OMNeT++'s default animations (message sending/method call animations) become
a liability, they can be programmatically turned off for that module with
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>setBuiltinAnimationsAllowed()</tt> method:

<pre class="cpp">
// disable animations for the toplevel module
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *network = getSimulation()-&gt;getSystemModule();
network-&gt;setBuiltinAnimationsAllowed(false);
</pre>
<p>

<p>
<h2><a name="sec:graphics:display-strings"/>8.4 Display Strings<a class="headerlink" href="#sec:graphics:display-strings" title="Permalink to this headline"></a></h2>

<p>Display strings<!--display strings--> are compact textual descriptions
that specify the arrangement and appearance of the graphical
representations of modules and connections in graphical user interfaces
(currently Tkenv and Qtenv).

<p>Display strings are usually specified in NED's <b><tt>@display</tt></b> property,
but it is also possible to modify them programmatically at runtime.

<p>Display strings can be used in the following contexts:
<ul>
  <li> <i>submodules</i> -- display strings may contain position, arrangement
        (for module vectors), icon, icon color, auxiliary icon, status text,
        communication range (as circle or filled circle), tooltip, etc.
  <li> <i>compound modules, networks</i> -- display strings can specify
        background color, border color, border width,
        background image, scaling, grid, unit of measurement, etc.
  <li> <i>connections</i> -- display strings can specify positioning, color,
        line width, line style, text and tooltip
  <li> <i>messages</i> -- display strings can specify icon, icon color, etc.
</ul>

<p>
<h3><a name="sec:graphics:displaystring-syntax-and-placement"/>8.4.1 Syntax and Placement<a class="headerlink" href="#sec:graphics:displaystring-syntax-and-placement" title="Permalink to this headline"></a></h3>

<p>Display strings are specified in <b><tt>@display</tt></b> properties. The property
must contain a single string as value. The string should contain a
semicolon-separated list of tags. Each tag consists of a key, an equal sign
and a comma-separated list of arguments:

<pre class="ned">
@display("p=100,100;b=60,10,rect,blue,black,2")
</pre>
<p>
Tag arguments may be omitted both at the end and inside the parameter list.
If an argument is omitted, a sensible default value is used. In the following
example, the first and second arguments of the <tt>b</tt> tag are omitted.

<pre class="ned">
@display("p=100,100;b=,,rect,blue")
</pre>
<p>
Display strings can be placed in the <i>parameters</i> section of module
and channel type definitions, and in submodules and connections. The
following NED sample illustrates the placement of display strings in the
code:

<pre class="ned">
simple Server
{
    parameters:
        @display("i=device/server");
    ...
}

network Example
{
    parameters:
        @display("bgi=maps/europe");
    submodules:
        server: Server {
            @display("p=273,101");
        }
        ...
    connections:
        client1.out --&gt; { @display("ls=red,3"); } --&gt; server.in++;
}
</pre>
<p>

<p><h3><a name="sec:graphics:displaystring-inheritance"/>8.4.2 Inheritance<a class="headerlink" href="#sec:graphics:displaystring-inheritance" title="Permalink to this headline"></a></h3>

<p>At runtime, every module and channel object has one single display string object,
which controls its appearance in various contexts. The initial value of
this display string object comes from merging the <b><tt>@display</tt></b>
properties occurring at various places in NED files.
This section describes the rules for merging <b><tt>@display</tt></b> properties
to create the module or channel's display string.

<p><ul>
  <li> Derived NED types inherit their display string from their base NED type.
  <li> Submodules inherit their display string from their type.
  <li> Connections inherit their display string from their channel type.
</ul>

<p>The base NED type's display string is merged into the current display string
using the following rules:

<p><ol>
<li> <b>Inheriting.</b> If a tag or tag argument is present in the base
    display string but not in the current one, it will be added to the
    result. Example: <br>
    <tt>"i=block/sink"</tt> <i>(base)</i> + <tt>"p=20,40;i=,red"</tt> <i>(current)</i> <i>--></i> <tt>"p=20,40;i=block/sink,red"</tt>
<li> <b>Overwriting.</b> If a tag argument is present both in the base
    and in the current display string, the tag argument in the current
    display string will win. Example: <br>
    <tt>"b=40,20,oval"</tt> + <tt>"b=,30"</tt> <i>--></i> <tt>"b=40,30,oval"</tt>
<li> <b>Erasing.</b> If the current display string contains a tag argument
    with the value &#8220;-&#8221; (hyphen), that tag argument will be empty in
    the result. Example: <br>
    <tt>"i=block/sink,red"</tt> + <tt>"i=,-"</tt> <i>--></i> <tt>"i=block/sink"</tt>
</ol>

<p>The result of merging the <b><tt>@display</tt></b> properties will be used to
initialize the display string object (<tt><a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a></tt>) of the
module or channel. The display string object can then still be modified
programmatically at runtime.

<p><ul class="note"><b>NOTE</b><br>
If a tag argument is empty, the GUI may use a suitable default value. For
example, if the border color for a rectangle is not specified in the
display string, the GUI may use black. This default value cannot be
queried programmatically.
</ul>

<p>Example of display string inheritance:

<pre class="ned">
simple Base {
    @display("i=block/queue"); // use a queue icon in all instances
}

simple Derived extends Base {
    @display("i=,red,60");  // ==&gt; "i=block/queue,red,60"
}

network SimpleQueue {
    submodules:
        submod: Derived {
            @display("i=,yellow,-;p=273,101;r=70");
                     // ==&gt; "i=block/queue,yellow;p=273,101;r=70"
        }
        ...
}
</pre>
<p>

<p><h3><a name="sec:graphics:submodule-displaystring-tags"/>8.4.3 Submodule Tags<a class="headerlink" href="#sec:graphics:submodule-displaystring-tags" title="Permalink to this headline"></a></h3>

<p>The following tags of the module display string are in effect in submodule
context, that is, when the module is displayed as a submodule of another
module:

<p><ul>
  <li> <tt>p</tt> -- positioning and layout
  <li> <tt>b</tt> -- shape (box, oval, etc.)
  <li> <tt>i</tt> -- icon
  <li> <tt>is</tt> -- icon size
  <li> <tt>i2</tt> -- auxiliary or status icon
  <li> <tt>r</tt> -- range indicator
  <li> <tt>q</tt> -- queue information text
  <li> <tt>t</tt> -- text
  <li> <tt>tt</tt> -- tooltip
</ul>

<p>The following sections provide an overview and examples for each tag. More
detailed information, such as what each tag argument means, is available in
Appendix <a href="#cha:display-strings">[24]</a>.

<p><h4><a name="sec:graphics:submodule-icons"/>8.4.3.1 Icons<a class="headerlink" href="#sec:graphics:submodule-icons" title="Permalink to this headline"></a></h4>

<p>By default, modules are displayed with a simple default icon, but OMNeT++
comes with a large set of categorized icons that one can choose from.
To see what icons are available, look into the <tt>images/</tt> folder
in the OMNeT++ installation. The stock icons installed with OMNeT++ have
several size variants. Most of them have very small (vs), small (s),
large (l) and very large (vl) versions.

<p>One can specify the icon with the <tt>i</tt> tag. The icon name should be
given with the name of the subfolder under <tt>images/</tt>, but without the
file name extension. The size may be specified with the icon name suffix
(<tt>_s</tt> for very small, <tt>_vl</tt> for very large, etc.), or
in a separate <tt>is</tt> tag.

<p>An example that displays the <i>block/source</i> in large size:

<pre class="ned">
@display("i=block/source;is=l");
</pre>
<p>
Icons may also be colorized, which can often be useful. Color can indicate
the status or grouping of the module, or simply serve aesthetic purposes.
The following example makes the icon 20% red:

<pre class="ned">
@display("i=block/source,red,20")
</pre>
<p>
<center>
<img src="graphics-itag.png">
</center>

<p><h4><a name="sec:graphics:submodule-status-icon"/>8.4.3.2 Status Icon<a class="headerlink" href="#sec:graphics:submodule-status-icon" title="Permalink to this headline"></a></h4>

<p>Modules may also display a small auxiliary icon in the top-right corner of
the main icon. This icon can be useful for displaying the status of the
module, for example, and can be set with the <tt>i2</tt> tag. Icons suitable
for use with <tt>i2</tt> are in the <tt>status/</tt> category.

<p>An example:

<pre class="ned">
@display("i=block/queue;i2=status/busy")
</pre>
<p>
<center>
<img src="graphics-i2tag.png">
</center>

<p><h4><a name="sec:graphics:submodule-shapes"/>8.4.3.3 Shapes<a class="headerlink" href="#sec:graphics:submodule-shapes" title="Permalink to this headline"></a></h4>

<p>To have a simple but resizable representation for a module, one can use
the <tt>b</tt> tag to create geometric shapes. Currently, <tt>oval</tt> and
<tt>rectangle</tt> are supported.

<p>The following example displays an oval shape of the size 70x30 with a 4-pixel
black border and red fill:

<pre class="ned">
@display("b=70,30,oval,red,black,4")
</pre>
<p>
<center>
<img src="graphics-btag.png">
</center>

<p><h4><a name="sec:graphics:submodule-positioning"/>8.4.3.4 Positioning<a class="headerlink" href="#sec:graphics:submodule-positioning" title="Permalink to this headline"></a></h4>

<p>The <tt>p</tt> tag allows one to define the position of a submodule or
otherwise affect its placement.

<p><ul class="note"><b>NOTE</b><br>
If the <tt>p</tt> tag is missing or doesn't specify the position, OMNeT++ will
use a layouting algorithm to place the module automatically. The layouting
algorithm is covered in section <a href="#sec:graphics:compound-module-layouting">[8.4.10]</a>.
</ul>

<p>The following example will place the module at the given position:

<pre class="ned">
@display("p=50,79");
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
Coordinates and distances in <tt>p</tt>, <tt>b</tt> or <tt>r</tt> tags need not
be integers. Fractional numbers make sense because runtime GUIs (Tkenv,
Qtenv) support zooming.
</ul>

<p>If the submodule is a module vector, one can also specify in the <tt>p</tt>
tag how to arrange the elements of the vector. They can be arranged in a
row, a column, a matrix or a ring. The rest of the arguments in the <tt>p</tt>
tag depend on the layout type:

<p><ul>
  <li> <tt>row -- p=100,100,r,<i>deltaX</i></tt> (A row of modules with <i>deltaX</i> units between the modules)
  <li> <tt>column -- p=100,100,c,<i>deltaY</i></tt> (A column of modules with <i>deltaX</i> units between the modules)
  <li> <tt>matrix -- p=100,100,m,<i>noOfCols</i>,<i>deltaX</i>,<i>deltaY</i></tt> (A matrix with <i>noOfCols</i> columns.
            <i>deltaX</i> and <i>deltaY</i> units between rows and columns)
  <li> <tt>ring -- p=100,100,ri,<i>rx</i>,<i>ry</i></tt> (A ring (oval) with <i>rx</i> and <i>ry</i> as the horizontal and vertical radius.)
  <li> <tt>exact (default) -- p=100,100,x,<i>deltaX</i>,<i>deltaY</i></tt> (Place each module at <i>(100+deltaX, 100+deltaY)</i>.
            The coordinates are usually set at runtime.)
</ul>

<p>A matrix layout for a module vector (note that the first two arguments, <i>x</i>
and <i>y</i> are omitted, so the submodule matrix as a whole will be placed by
the layouter algorithm):

<pre class="ned">
host[20]: Host {
    @display("p=,,m,4,50,50");
}
</pre>
<p>

<p>  <center>
    <img src="graphics-ptag.png">
    <center><div class="caption"><i>Figure: Matrix arrangement using the <i>p</i> tag</i></div></center>
    <a name="fig:graphics-ptag"></a>
  </center>

<p>
<h4><a name="sec:graphics:submodule-wireless-range"/>8.4.3.5 Wireless Range<a class="headerlink" href="#sec:graphics:submodule-wireless-range" title="Permalink to this headline"></a></h4>

<p>In wireless simulations, it is often useful to be able to display a circle
or disc around the module to indicate transmission range, reception range,
or interference range. This can be done with the <tt>r</tt> tag.

<p>In the following example, the module will have a circle with a 90-unit radius
around it as a range indicator:

<pre class="ned">
submodules:
    ap: AccessPoint {
        @display("p=50,79;r=90");
    }
</pre>
<p>

<p>  <center>
    <img src="graphics-rtag.png">
    <center><div class="caption"><i>Figure: Range indicator using the <i>r</i> tag</i></div></center>
    <a name="fig:graphics-rtag"></a>
  </center>

<p>
<h4><a name="sec:graphics:submodule-queue-length"/>8.4.3.6 Queue Length<a class="headerlink" href="#sec:graphics:submodule-queue-length" title="Permalink to this headline"></a></h4>

<p>If a module contains a queue object (<tt><a href="../api/classomnetpp_1_1cQueue.html">cQueue</a></tt>), it is possible to
let the graphical user interface display the queue length next to the
module icon. To achieve that, one needs to specify the queue object's name
(the string set via the <tt>setName()</tt> method) in the <tt>q</tt> display string tag.
OMNeT++ finds the queue object by traversing the object tree inside
the module.

<p>The following example displays the length of the queue named <tt>"jobQueue"</tt>:

<pre class="ned">
@display("q=jobQueue");
</pre>
<p>
<center>
<img src="graphics-qtag.png">
</center>

<p><h4><a name="sec:graphics:submdule-text-and-tooltip"/>8.4.3.7 Text and Tooltip<a class="headerlink" href="#sec:graphics:submdule-text-and-tooltip" title="Permalink to this headline"></a></h4>

<p>It is possible to have a short text displayed next to or above the module icon
or shape using the <tt>t</tt> tag. The tag lets one specify the placement (left,
right, above) and the color of the text. To display text in a tooltip, use
the <tt>tt</tt> tag.

<p>The following example displays text above the module icon, and also adds
tooltip text that can be seen by hovering over the module icon with the
mouse.

<pre class="ned">
@display("t=Packets sent: 18;tt=Additional tooltip information");
</pre>
<p>
<center>
<img src="graphics-ttag.png">
</center>

<p><ul class="note"><b>NOTE</b><br>
  The <tt>t</tt> and <tt>tt</tt> tags, when set at runtime, can be used to display
  information about the module's state. The <tt>setTagArg()</tt> method
  of <tt><a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a></tt> can be used to update the text:
  <tt>getDisplayString().setTagArg("t", 0, str);</tt>
</ul>

<p>For a detailed descripton of the display string tags, check
Appendix <a href="#cha:display-strings">[24]</a>.

<p>
<h3><a name="sec:graphics:background-displaystring-tags"/>8.4.4 Background Tags<a class="headerlink" href="#sec:graphics:background-displaystring-tags" title="Permalink to this headline"></a></h3>

<p>The following tags of the module display string are in effect when the
module itself is opened in a GUI. These tags mostly deal with the visual
properties of the background rectangle.

<p><ul>
  <li> <tt>bgb</tt> -- size, color and border of the background rectangle
  <li> <tt>bgi</tt> -- background image and its display mode
  <li> <tt>bgtt</tt> -- tooltip above the background
  <li> <tt>bgg</tt> -- background grid: color, spacing, etc.
  <li> <tt>bgu</tt> -- measurement unit of coordinates/distances
</ul>

<p>In the following example, the background area is defined to be 6000x4500
units, and the map of Europe is used as a background, stretched to fill the
whole area. A grid is also drawn, with 1000 units between major ticks,
and 2 minor ticks per major tick.

<pre class="ned">
network EuropePlayground
{
    @display("bgb=6000,4500;bgi=maps/europe,s;bgg=1000,2,grey95;bgu=km");
</pre>
<p>

<p>  <center>
    <img src="graphics-bgtags.png">
    <center><div class="caption"><i>Figure: Background image and grid</i></div></center>
    <a name="fig:graphics-bgtags"></a>
  </center>

<p>
The <tt>bgu</tt> tag deserves special attention. It does not affect
the visual appearance, but instead it is a hint for model code
on how to interpret coordinates and distances in this compound
module. The above example specifies <tt>bgu=km</tt>, which means
that if the model attaches physical meaning to coordinates and
distances, then those numbers should be interpreted as kilometers.

<p>More detailed information, such as what each tag argument means, is
available in Appendix <a href="#cha:display-strings">[24]</a>.

<p>
<h3><a name="sec:graphics:connection-displaystrings"/>8.4.5 Connection Display Strings<a class="headerlink" href="#sec:graphics:connection-displaystrings" title="Permalink to this headline"></a></h3>

<p>Connections may also have display strings. Connections inherit the
display string property from their channel types, in the same way as
submodules inherit theirs from module types. The default display
strings are empty.

<p>Connections support the following tags:

<p><ul>
  <li> <tt>ls</tt> -- line style and color
  <li> <tt>t</tt> -- text
  <li> <tt>tt</tt> -- tooltip
  <li> <tt>m</tt> -- orientation and positioning
</ul>

<p>Example of a thick, red connection:
<pre class="ned">
source1.out --&gt; { @display("ls=red,3"); } --&gt; queue1.in++;
</pre>

<p><center>
<img src="graphics-lstag.png">
</center>

<p><ul class="note"><b>NOTE</b><br>
To hide a connection, specify zero line width in the display string:
<tt>"ls=,0"</tt>.
</ul>

<p>More detailed information, such as what each tag argument means, is
available in Appendix <a href="#cha:display-strings">[24]</a>.

<p>
<h3><a name="sec:graphics:message-displaystrings"/>8.4.6 Message Display Strings<a class="headerlink" href="#sec:graphics:message-displaystrings" title="Permalink to this headline"></a></h3>

<p>Message display strings affect how messages are shown during animation.
By default, they are displayed as a small filled circle, in one of
8 basic colors (the color is determined as <i>message kind modulo 8</i>),
and with the message class and/or name displayed under it.
The latter is configurable in the Options dialog of Tkenv and Qtenv,
and message kind dependent coloring can also be turned off there.

<p><h4><a name="sec:graphics:specifying-message-displaystrings"/>8.4.6.1 How to Specify<a class="headerlink" href="#sec:graphics:specifying-message-displaystrings" title="Permalink to this headline"></a></h4>

<p>Message objects do not store a display string by default. Instead,
<tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> defines a virtual <tt>getDisplayString()</tt> method
that one can override in subclasses to return an arbitrary string.
The following example adds a display string to a new message class:

<pre class="cpp">
class Job : public <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>
{
  public:
    const char *getDisplayString() const {return "i=msg/packet;is=vs";}
    //...
};
</pre>
<p>
Since message classes are often defined in <tt>msg</tt> files (see chapter
<a href="#cha:msg-def">[6]</a>), it is often convenient to let the message compiler
generate the <tt>getDisplayString()</tt> method. To achieve that, add a
string field named <tt>displayString</tt> with an initializer to the message
definition. The message compiler will generate <tt>setDisplayString()</tt>
and <tt>getDisplayString()</tt> methods into the new class, and also set the
initial value in the constructor.

<p>An example message file:

<pre class="msg">
message Job
{
    string displayString = "i=msg/package_s,kind";
    //...
}
</pre>
<p>
<h4><a name="sec:graphics:message-displaystring-tags"/>8.4.6.2 Tags<a class="headerlink" href="#sec:graphics:message-displaystring-tags" title="Permalink to this headline"></a></h4>

<p>The following tags can be used in message display strings:

<p><ul>
  <li> <tt>b</tt> -- shape, color
  <li> <tt>i</tt> -- icon
  <li> <tt>is</tt> -- icon size
</ul>

<p><ul class="note"><b>NOTE</b><br>
   In message display strings, <tt>kind</tt> is accepted as a special color name.
   It will cause the color to be derived from <i>message kind</i> field in the message.
</ul>

<p>The following example displays a small red box icon:

<pre class="ned">
@display("i=msg/box,red;is=s");
</pre>
<p>
The next one displays a 15x15 rectangle, with while fill, and with a border
color dependent on the message kind:

<pre class="ned">
@display("b=15,15,rect,white,kind,5");
</pre>
<p>
More detailed information, such as what each tag argument means, is
available in Appendix <a href="#cha:display-strings">[24]</a>.

<p>
<h3><a name="sec:graphics:displaystring-parameter-substitution"/>8.4.7 Parameter Substitution<a class="headerlink" href="#sec:graphics:displaystring-parameter-substitution" title="Permalink to this headline"></a></h3>

<p>Parameters of the module or channel containing the
display string can be substituted into the display string
with the <tt>$parameterName</tt> notation:

<p>Example:

<pre class="ned">
simple MobileNode
{
    parameters:
        double xpos;
        double ypos;
        string fillColor;
        // get the values from the module parameters xpos,ypos,fillcolor
        @display("p=$xpos,$ypos;b=60,10,rect,$fillColor,black,2");
}
</pre>
<p>
<h3><a name="sec:graphics:displaystring-colors"/>8.4.8 Colors<a class="headerlink" href="#sec:graphics:displaystring-colors" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:graphics:displaystring-color-names"/>8.4.8.1 Color Names<a class="headerlink" href="#sec:graphics:displaystring-color-names" title="Permalink to this headline"></a></h4>

<p>A color may be given in several forms. One is English names: <tt>blue</tt>,
<tt>lightgrey</tt>, <tt>wheat</tt>, etc.; the list includes all standard SVG
color names.

<p>Another acceptable form is the HTML RGB syntax: <i>#rgb</i> or
<i>#rrggbb</i>, where <i>r</i>,<i>g</i>,<i>b</i> are hex digits.

<p>It is also possible to specify colors in HSB (hue-saturation-brightness) as
<i>@hhssbb</i> (with <i>h</i>, <i>s</i>, <i>b</i> being hex digits).
HSB makes it easier to scale colors e.g. from white to bright red.

<p>One can produce a transparent background by specifying a hyphen (<i>"-"</i>)
as background color.

<p>In message display strings, <tt>kind</tt> can also be used as a special color
name. It will map message kind to a color. (See the <tt>getKind()</tt>
method of <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>.)

<p><h4><a name="sec:graphics:displaystring-icon-colorization"/>8.4.8.2 Icon Colorization<a class="headerlink" href="#sec:graphics:displaystring-icon-colorization" title="Permalink to this headline"></a></h4>

<p>The <tt>"i="</tt> display string tag allows for colorization of icons.
It accepts a target color and a percentage as the degree of colorization.
Percentage has no effect if the target color is missing.
Brightness of the icon is also affected -- to keep the original brightness,
specify a color with about 50% brightness (e.g. <tt>#808080</tt> mid-grey,
<tt>#008000</tt> mid-green).

<p>Examples:

<p><ul>
  <li> <tt>"i=device/server,gold"</tt> creates a gold server icon
  <li> <tt>"i=misc/globe,#808080,100"</tt> makes the icon greyscale
  <li> <tt>"i=block/queue,white,100"</tt> yields a "burnt-in" black-and-white icon
</ul>

<p>Colorization works with both submodule and message icons.

<p>
<h3><a name="sec:graphics:icon-library"/>8.4.9 Icons<a class="headerlink" href="#sec:graphics:icon-library" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:graphics:image-path"/>8.4.9.1 The Image Path<a class="headerlink" href="#sec:graphics:image-path" title="Permalink to this headline"></a></h4>

<p>In the current OMNeT++ version, module icons are PNG or GIF files. The icons shipped
with OMNeT++ are in the <tt>images/</tt> subdirectory. The IDE, Tkenv and Qtenv all
need the exact location of this directory to be able to load the icons.

<p>Icons are loaded from all directories in the <i>image path</i>,
a semicolon-separated list of directories.
The default image path is compiled into Tkenv and Qtenv with the value
<tt>"<i>&lt;omnetpp&gt;</i>/images;./images"</tt>. This works fine (unless the
OMNeT++ installation is moved), and the <tt>./images</tt> part also allows
icons to be loaded from the <tt>images/</tt> subdirectory of the current
directory. As users typically run simulation models from the model's
directory, this practically means that custom icons placed in the
<tt>images/</tt> subdirectory of the model's directory are automatically
loaded.

<p>The compiled-in image path can be overridden with the <tt>OMNETPP_IMAGE_PATH</tt>
environment variable. The way of setting environment variables is system
specific: in Unix, if one is using the bash shell, adding a line

<pre class="commandline">
export OMNETPP_IMAGE_PATH="$HOME/omnetpp/images;./images"
</pre>
<p>
to <tt>~/.bashrc</tt> or <tt>~/.bash_profile</tt> will do;
on Windows, environment variables can be set via the <i>My Computer --&gt; Properties</i> dialog.

<p>One can extend the image path from <tt>omnetpp.ini</tt> with the
<tt>image-path</tt> option, which is prepended to the environment
variable's value.

<pre class="inifile">
[General]
image-path = "/home/you/model-framework/images;/home/you/extra-images"
</pre>
<p>

<p><h4><a name="sec:graphics:categorized-icons"/>8.4.9.2 Categorized Icons<a class="headerlink" href="#sec:graphics:categorized-icons" title="Permalink to this headline"></a></h4>

<p>Icons are organized into several categories, represented by folders.
These categories include:

<p><ul>
  <li> <tt>abstract/</tt> - symbolic icons for various devices
  <li> <tt>background/</tt> - images useful as background, such as terrain map
  <li> <tt>block/</tt> - icons for subcomponents (queues, protocols, etc).
  <li> <tt>device/</tt> - network device icons: servers, hosts, routers, etc.
  <li> <tt>misc/</tt> - node, subnet, cloud, building, town, city, etc.
  <li> <tt>msg/</tt> - icons that can be used for messages
  <li> <tt>status/</tt> - status icons such as up, down, busy, etc.
</ul>

<p>Icon names to be used with the <tt>i</tt>, <tt>bgi</tt> and other tags should
contain the subfolder (category) name but not the file extension. For
example, <tt>/opt/omnetpp/images/block/sink.png</tt> should be referred to as
<tt>block/sink</tt>.

<p>
<h4><a name="sec:graphics:icon-size"/>8.4.9.3 Icon Size<a class="headerlink" href="#sec:graphics:icon-size" title="Permalink to this headline"></a></h4>

<p>Icons come in various sizes: normal, large, small, very small, very large.
Sizes are encoded into the icon name's suffix: <tt>_vl</tt>, <tt>_l</tt>,
<tt>_s</tt>, <tt>_vs</tt>. In display strings, one can either use the suffix
(<tt>"i=device/router_l"</tt>), or the <tt>"is</tt>" (<i>icon size</i>)
display string tag (<tt>"i=device/router;is=l"</tt>), but not both at the same
time (we recommend using the <tt>is</tt> tag.)

<p>
<h3><a name="sec:graphics:compound-module-layouting"/>8.4.10 Layouting<a class="headerlink" href="#sec:graphics:compound-module-layouting" title="Permalink to this headline"></a></h3>

<p>OMNeT++ implements an automatic layouting feature, using a variation of the
Spring Embedder algorithm. Modules which have not been assigned explicit
positions via the <tt>"p="</tt> tag will be automatically placed by the
algorithm.

<p>Spring Embedder is a graph layouting algorithm based on a physical model.
Graph nodes (modules) repel each other like electric charges of the same
sign, and connections act as springs that pull nodes together. There is
also friction built in, in order to prevent oscillation of the nodes. The
layouting algorithm simulates this physical system until it reaches
equilibrium (or times out). The physical rules above have been slightly
tweaked to achieve better results.

<p>The algorithm doesn't move any module which has fixed coordinates. Modules
that are part of a predefined arrangement (row, matrix, ring, etc., defined
via the 3rd and further args of the <tt>"p="</tt> tag) will be moved together,
to preserve their relative positions.

<p><ul class="note"><b>NOTE</b><br>
The positions of modules placed by the layouting algorithm are not
available from simulation models. Think about it: what positions should
OMNeT++ report if the model is run under Cmdenv, or under Tkenv/Qtenv but
the compound module was never opened in the GUI? The absence of explicit
coordinates in the NED file conceptually means that the modeler
<i>doesn't care</i> about the position of that module.
</ul>

<p>Caveats:

<p><ul>
  <li> If the full graph is too big after layouting, it is scaled
    back so that it fits on the screen, <i>unless it contains
    any fixed-position module</i>. (For obvious reasons: if there is a module
    with manually specified position, we don't want to move that one).
    To prevent rescaling, one can specify a sufficiently large bounding
    box in the background display string, e.g. <tt>"b=2000,3000"</tt>.
  <li> Submodule size is ignored by the present layouter, so modules
    with elongated shapes may not be placed ideally.
  <li> The algorithm may produce erratic results, especially for small graphs
    when the number of submodules is small, or when using predefined
    (matrix, row, ring, etc) layouts. The <i>Relayout</i> toolbar button
    can then be very useful. Larger networks usually produce
    satisfactory results.
  <li> The algorithm starts by placing the nodes randomly, and this initial
    arrangement greatly affects the end result. The algorithm has its
    own RNG that starts from a default seed. The <i>Relayout</i> button
    changes this seed, and this seed is persistently stored so later runs
    of the model will produce the same layout.
</ul>

<p>
<h3><a name="sec:graphics:changing-displaystrings-at-runtime"/>8.4.11 Changing Display Strings at Runtime<a class="headerlink" href="#sec:graphics:changing-displaystrings-at-runtime" title="Permalink to this headline"></a></h3>

<p>It is often useful to manipulate the display string at runtime.
Changing colors, icon, or text may convey status change, and
changing a module's position is useful when simulating mobile
networks.

<p>Display strings are stored in <tt><a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a></tt> objects inside
channels, modules and gates. <tt><a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a></tt> also lets one
manipulate the string.

<p>As far as <tt><a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a></tt> is concerned, a display string
(e.g. <tt>"p=100,125;i=cloud"</tt>) is a string that consist of several
<i>tags</i> separated by semicolons, and each tag has a <i>name</i>
and after an equal sign, zero or more <i>arguments</i> separated by commas.

<p>The class facilitates tasks such as finding out what tags a display string
has, adding new tags, adding arguments to existing tags, removing tags or
replacing arguments. The internal storage method allows very fast
operation; it will generally be faster than direct string manipulation. The
class doesn't try to interpret the display string in any way, nor does it
know the meaning of the different tags; it merely parses the string as data
elements separated by semicolons, equal signs and commas.

<p>To get a pointer to a <tt><a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a></tt> object, one can call
the components's <tt>getDisplayString()</tt> method.

<p><ul class="note"><b>NOTE</b><br>
The connection display string is stored in the channel object, but it
can also be accessed via the source gate of the connection.
</ul>

<p>The display string can be overwritten using the <tt>parse()</tt> method.
Tag arguments can be set with <tt>setTagArg()</tt>, and tags removed
with <tt>removeTag()</tt>.

<p>The following example sets a module's position, icon and status icon
in one step:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a>& dispStr = getDisplayString();
dispStr.parse("p=40,20;i=device/cellphone;i2=status/disconnect");
</pre>
<p>
Setting an outgoing connection's color to red:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a>& connDispStr = gate("out")-&gt;getDisplayString();
connDispStr.parse("ls=red");
</pre>
<p>
Setting module background and grid with background display string tags:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cDisplayString.html">cDisplayString</a>& parentDispStr = getParentModule()-&gt;getDisplayString();
parentDispStr.parse("bgi=maps/europe;bgg=100,2");
</pre>
<p>
The following example updates a display string so that it contains
the <tt>p=40,20</tt> and <tt>i=device/cellphone</tt> tags:

<pre class="cpp">
dispStr.setTagArg("p", 0, 40);
dispStr.setTagArg("p", 1, 20);
dispStr.setTagArg("i", 0, "device/cellphone");
</pre>
<p>
<h2><a name="sec:graphics:bubbles"/>8.5 Bubbles<a class="headerlink" href="#sec:graphics:bubbles" title="Permalink to this headline"></a></h2>

<p>Modules can display a transient bubble with a short message (e.g. "Going
down" or "Connection estalished") by calling the <tt>bubble()</tt> method of
<tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a></tt>. The method takes the string to be displayed as a
<tt>const char *</tt> pointer.

<p>An example:
<pre class="cpp">
bubble("Going down!");
</pre>

<p><center>
<img src="graphics-bubble.png">
</center>

<p>If the module often displays bubbles, it is recommended to make the
corresponding code conditional on <tt>hasGUI()</tt>. The <tt>hasGUI()</tt>
method returns <i>false</i> if the simulation is running under Cmdenv.

<pre class="cpp">
if (hasGUI()) {
    char text[32];
    sprintf(text, "Collision! (%s frames)", numCollidingFrames);
    bubble(text);
}
</pre>
<p>

<p>
<h2><a name="sec:graphics:canvas"/>8.6 The Canvas<a class="headerlink" href="#sec:graphics:canvas" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:graphics:canvas-overview"/>8.6.1 Overview<a class="headerlink" href="#sec:graphics:canvas-overview" title="Permalink to this headline"></a></h3>

<p>The canvas is the 2D drawing API of OMNeT++. Using the canvas, one can
display lines, curves, polygons, images, text items and their combinations,
using colors, transparency, geometric transformations, antialiasing and
more. Drawings created with the canvas API can be viewed when the simulation
is run under a graphical user interface (Tkenv or Qtenv).

<p>Use cases for the canvas API include displaying textual annotations,
status information, live statistics in the form of plots, charts, gauges,
counters, etc. Other types of simulations may call for different types of
graphical presentation. For example, in mobile and wireless simulations,
the canvas API can be used to draw the scene including a background (like a
street map or floor plan), mobile objects (vehicles, people), obstacles
(trees, buildings, hills), antennas with orientation, and also extra
information like connectivity graph, movement trails, individual
transmissions and so on.

<p>An arbitrary number of drawings (canvases) can be created, and every module
already has one by default. A module's default canvas is the one on which
the module's submodules and internal connections are also displayed, so the
canvas API can be used to enrich the default, display string based
presentation of a compound module.

<p>OMNeT++ calls the items that appear on a canvas <i>figures</i>. The
corresponding C++ types are <tt><a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a></tt> and <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt>. In fact,
<tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt> is an abstract base class, and different kinds of figures
are represented by various subclasses of <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt>.

<p>Figures can be declared statically in NED files using <b><tt>@figure</tt></b>
properties, and can also be accessed, created and manipulated
programmatically at runtime.

<p>
<h3><a name="sec:graphics:creating-accessing-and-viewing-canvases"/>8.6.2 Creating, Accessing and Viewing Canvases<a class="headerlink" href="#sec:graphics:creating-accessing-and-viewing-canvases" title="Permalink to this headline"></a></h3>

<p>A canvas is represented by the <tt><a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a></tt> C++ class. A module's
default canvas can be accessed with the <tt>getCanvas()</tt> method of
<tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>. For example, a toplevel submodule can get hold of the
network's canvas with the following line:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a> *canvas = getParentModule()-&gt;getCanvas();
</pre>
<p>
Using the canvas pointer, it is possible to check what figures it
contains, add new figures, manipulate existing ones, and so on.

<p>New canvases can be created by simply creating new <tt><a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a></tt>
objects, like so:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a> *canvas = new <a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a>("liveStatistics"); // arbitrary name string
</pre>
<p>
To view the contents of these additional canvases in Tkenv or Qtenv, one
needs to navigate to the canvas' owner object (which will usually be the
module that created the canvas), view the list of objects it contains, and
double-click the canvas in the list. Giving meaningful names to extra
canvas objects like in the example above can simplify the process of
locating them in the Tkenv/Qtenv GUI.

<p>
<h3><a name="sec:graphics:figure-classes"/>8.6.3 Figure Classes<a class="headerlink" href="#sec:graphics:figure-classes" title="Permalink to this headline"></a></h3>

<p>The base class of all figure classes is <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt>. The class hierarchy
is shown in figure <a href="#fig:figure-inheritance">below</a>.

<p>
  <center>
    <img src="figure-inheritance.svg">
    <center><div class="caption"><i>Figure: <a href="../api/classomnetpp_1_1cFigure.html">cFigure</a> class hierarchy</i></div></center>
    <a name="fig:figure-inheritance"></a>
  </center>

<p>
In subsequent sections, we'll first describe features that are common
to all figures, then we'll briefly cover each figure class. Finally,
we'll look into how one can define new figure types.

<p><ul class="note"><b>NOTE</b><br>
Figures are only data storage classes. The real drawing code is inside
Tkenv/Qtenv; it might involve a parallel data structure, figure renderer
classes, etc. When the canvas is not viewed, corresponding objects in
Tkenv/Qtenv do not exist. Therefore, data flow is largely one-directional --
figures-to-GUI.
</ul>

<p>
<h3><a name="sec:graphics:figure-tree"/>8.6.4 The Figure Tree<a class="headerlink" href="#sec:graphics:figure-tree" title="Permalink to this headline"></a></h3>

<p>Figures on a canvas are organized into a tree. The canvas has a
(hidden) <i>root figure</i>, and all toplevel figures are
children of the root figure. Any figure may contain child figures,
not only dedicated ones like <tt><a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a></tt>.

<p>Every figure also has a name string, inherited from <tt><a href="../api/classomnetpp_1_1cNamedObject.html">cNamedObject</a></tt>.
Since figures are in a tree, every figure also has a <i>hierarchical name</i>.
It consists of the names of figures in the path from the root figure down to the
the figure, joined with dots. (The name of the root figure itself is omitted.)

<p>Child figures can be added to a figure with the <tt>addFigure()</tt> method, or
inserted into the child list of a figure relative to a sibling with the
<tt>insertBefore()</tt> / <tt>insertAfter()</tt> methods.
<tt>addFigure()</tt> has two flavours: one for appending, and one for inserting
at a numeric position. Child figures can be accessed by name
(<tt>getFigure(name)</tt>), or enumerated by index in the child list
(<tt>getFigure(k)</tt>, <tt>getNumFigures()</tt>). One can obtain the index of a
child figure using  <tt>findFigure()</tt>. The <tt>removeFromParent()</tt> method
can be used to remove a figure from its parent.

<p>For convenience, <tt><a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a></tt> also has <tt>addFigure()</tt>,
<tt>getFigure()</tt>, <tt>getNumFigures()</tt> and other methods for managing
toplevel figures without the need to go via the root figure.

<p>The following code enumerates the children of a figure named <tt>"group1"</tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a> *parent = canvas-&gt;getFigure("group1");
ASSERT(parent != nullptr);
for (int i = 0; i &lt; parent-&gt;getNumFigures(); i++)
    EV &lt;&lt; parent-&gt;getFigure(i)-&gt;getName() &lt;&lt; endl;
</pre>
<p>
It is also possible to locate a figure by its hierarchical name
(<tt>getFigureByPath()</tt>), and to find figure by its (non-hierarchical)
name anywhere in a figure subtree (<tt>findFigureRecursively()</tt>).

<p>The <tt>dup()</tt> method of figure classes only duplicates the very figure
on which it was called. (The duplicate will not have ay children.) To clone
a figure including children, use the <tt>dupTree()</tt> method.

<p>
<h3><a name="sec:graphics:creating-and-manipulating-figures"/>8.6.5 Creating and Manipulating Figures from NED and C++<a class="headerlink" href="#sec:graphics:creating-and-manipulating-figures" title="Permalink to this headline"></a></h3>

<p>As mentioned earlier, figures can be defined in the NED file, so they
don't always need to be created programmatically. This possibility is
useful for creating static backgrounds or statically defining placeholders
for dinamically displayed items, among others. Figures defined from NED can
be accessed and manipulated from C++ code in the same way as dynamically
created ones.

<p>Figures are defined in NED by adding <b><tt>@figure</tt></b> properties to a module definition.
The hierarchical name of the figure goes into the property index, that is, in
square brackets right after <tt>@figure</tt>. The parent of the figure must
already exist, that is, when defining <tt>foo.bar.baz</tt>, both <tt>foo</tt> and
<tt>foo.bar</tt> must have already been defined (in NED).

<p>Type and various attributes of the figure go into property body, as
<i>key-valuelist</i> pairs. <tt>type=line</tt> creates a
<tt><a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a></tt>, <tt>type=rectangle</tt> creates a
<tt><a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a></tt>, <tt>type=text</tt> creates a <tt><a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a></tt>,
and so on; the list of accepted types is given in appendix
<a href="#cha:figure-definitions">[25]</a>. Further attributes largely correspond to
getters and setters of the C++ class denoted by the <tt>type</tt> attribute.

<p>The following example creates a green rectangle and the text
<i>"placeholder"</i> in it in NED, and the subsequent C++ code changes
the same text to <i>"Hello World!"</i>.

<p>NED part:

<pre class="ned">
module Foo
{
    @display("bgb=800,500");
    @figure[box](type=rectangle; coords=10,50; size=200,100; fillColor=green);
    @figure[box.label](type=text; coords=20,80; text=placeholder);
}
</pre>
<p>
And the C++ part:

<pre class="cpp">
// we assume this code runs in a submodule of the above "Foo" module
<a href="../api/classomnetpp_1_1cCanvas.html">cCanvas</a> *canvas = getParentModule()-&gt;getCanvas();

// obtain the figure pointer by hierarchical name, and change the text:
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a> *figure = canvas-&gt;getFigureByPath("box.label")
<a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a> *textFigure = check_and_cast&lt;<a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a> *&gt;(figure);
textFigure-&gt;setText("Hello World!");
</pre>
<p>

<h3><a name="sec:graphics:canvas-stacking-order"/>8.6.6 Stacking Order<a class="headerlink" href="#sec:graphics:canvas-stacking-order" title="Permalink to this headline"></a></h3>

<p>The stacking order (a.k.a. Z-order) of figures is jointly determined by the
child order and the <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt> attribute called Z-index, with
the latter taking priority. Z-index is not used  directly, but an 
<i>effective Z-index</i> is computed instead, as the <i>sum</i> 
of the Z-index values of the figure and all its ancestors up to the root figure.

<p>A figure with a larger effective Z-index will be displayed above figures with
smaller effective Z-indices, regardless of their positions in the figure tree.
Among figures whose effective Z-indices are equal, child order determines 
the stacking order. If two such figures are siblings, the one that occurs
<i>later</i> in the child list will be drawn above the other.
For figures that are not siblings, the child order within the first
common ancestor matters.


There are several methods for managing stacking order:
<tt>setZIndex()</tt>, <tt>getZIndex()</tt>, <tt>getEffectiveZIndex()</tt>,
<tt>insertAbove()</tt>, <tt>insertBelow()</tt>, 
<tt>isAbove()</tt>, <tt>isBelow()</tt>, 
<tt>raiseAbove()</tt>, <tt>lowerBelow()</tt>,
<tt>raiseToTop()</tt>, <tt>lowerToBottom()</tt>.

<p>
<h3><a name="sec:graphics:canvas-transforms"/>8.6.7 Transforms<a class="headerlink" href="#sec:graphics:canvas-transforms" title="Permalink to this headline"></a></h3>

<p>One of the most powerful features of the Canvas API is being able to assign
geometric transformations to figures. OMNeT++ uses 2D homogeneous
transformation matrices, which are able to express affine transforms such
as translation, scaling, rotation and skew (shearing). The
transformation matrix used by OMNeT++ has the following format:


<center>
<div>
<span style="vertical-align: middle;">T&nbsp;=</span>
<table class="matrix">
  <tr><td>a</td><td>c</td><td>t<sub>1</sub></td></tr>
  <tr><td>b</td><td>d</td><td>t<sub>2</sub></td></tr>
  <tr><td>0</td><td>0</td><td>1</td></tr>
</table>
</div>
</center>

<p>


<p>In a nutshell, given a point with its <i>(x, y)</i> coodinates, one can obtain the
transformed version of it by multiplying the transformation matrix by the
<i>(x \ y \ 1)</i> column vector (a.k.a. homogeneous coordinates), and dropping the
third component:


<center>
<div>
<table class="matrix">
  <tr><td>x'</td></tr>
  <tr><td>y'</td></tr>
  <tr><td>1</td></tr>
</table>
<span style="vertical-align: middle;">&nbsp;=&nbsp;</span>
<table class="matrix">
  <tr><td>a</td><td>c</td><td>t<sub>1</sub></td></tr>
  <tr><td>b</td><td>d</td><td>t<sub>2</sub></td></tr>
  <tr><td>0</td><td>0</td><td>1</td></tr>
</table>
<span>&nbsp;</span>
<table class="matrix">
  <tr><td>x</td></tr>
  <tr><td>y</td></tr>
  <tr><td>1</td></tr>
</table>
</div>
</center>

<p>


<p>The result is the point <i>(ax+cy+t<sub>1</sub>, bx+dy+t<sub>2</sub>)</i>. As one can deduce, <i>a</i>,
<i>b</i>, <i>c</i>, <i>d</i> are responsible for rotation, scaling and skew, and <i>t<sub>1</sub></i> and
<i>t<sub>2</sub></i> for translation. Also, transforming a point by matrix <i>T<sub>1</sub></i> and then by
<i>T<sub>2</sub></i> is equivalent to transforming the point by the matrix <i>T<sub>2</sub> T<sub>1</sub></i> due to
the associativity of matrix multiplication.

<p>
<h4><a name="sec:graphics:the-transform-class"/>8.6.7.1 The Transform Class<a class="headerlink" href="#sec:graphics:the-transform-class" title="Permalink to this headline"></a></h4>

<p>Transformation matrices are represented in OMNeT++ by the <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Transform</tt>
class.

<p>A <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Transform</tt> transformation matrix can be initialized in
several ways. First, it is possible to assign its <tt>a</tt>, <tt>b</tt>,
<tt>c</tt>, <tt>d</tt>, <tt>t1</tt>, <tt>t2</tt> members directly (they are public), or
via a six-argument constructor. However, it is usually more convenient to
start from the identity transform (as created by the default constructor), and
invoke one or more of its several <tt>scale()</tt>, <tt>rotate()</tt>,
<tt>skewx()</tt>, <tt>skewy()</tt> and <tt>translate()</tt> member functions.
They update the matrix to (also) perform the given operation (scaling,
rotation, skewing or translation), as if left-multiplied by a temporary
matrix that corresponds to the operation.

<p>The <tt>multiply()</tt> method allows one to combine transformations:
<tt>t1.multiply(t2)</tt> sets <tt>t1</tt> to the product <tt>t2*t1</tt>.

<p>To transform a point (represented by the class <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point</tt>),
one can use the <tt>applyTo()</tt> method of <tt>Transform</tt>. The
following code fragment should clarify this:

<pre class="cpp">
// allow Transform and Point to be referenced without the <a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>:: prefix
typedef <a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Transform Transform;
typedef <a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point Point;

// create a matrix that scales by 2, rotates by 45 degrees, and translates by (100,0)
Transform t = Transform().scale(2.0).rotate(M_PI/4).translate(100,0);

// apply the transform to the point (10, 20)
Point p(10, 20);
Point p2 = t.applyTo(p);
</pre>
<p>

<p><h4><a name="sec:graphics:figure-transforms"/>8.6.7.2 Figure Transforms<a class="headerlink" href="#sec:graphics:figure-transforms" title="Permalink to this headline"></a></h4>

<p>Every figure has an associated transformation matrix, which
affects how the figure and its figure subtree are displayed.
In other words, the way a figure displayed is affected by its own
transformation matrix and the transformation matrices of all of its
ancestors, up to the root figure of the canvas. The effective transform
will be the product of those transformation matrices.

<p>A figure's transformation matrix is directly accessible via <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt>'s
<tt>getTransform()</tt>, <tt>setTransform()</tt> member functions.
For convenience, <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt> also has several <tt>scale()</tt>, <tt>rotate()</tt>,
<tt>skewx()</tt>, <tt>skewy()</tt> and <tt>translate()</tt> member functions,
which directly operate on the internal transformation matrix.

<p>Some figures have visual aspects that are not, or only optionally affected
by the transform. For example, the size and orientation of the text
displayed by <tt><a href="../api/classomnetpp_1_1cLabelFigure.html">cLabelFigure</a></tt>, in contrast to that of
<tt><a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a></tt>, is unaffected by transforms (and of manual zoom as
well). Only the position is transformed.

<p><h4><a name="sec:graphics:figure-transform-vs-move"/>8.6.7.3 Transform vs move()<a class="headerlink" href="#sec:graphics:figure-transform-vs-move" title="Permalink to this headline"></a></h4>

<p>In addition to the <tt>translate()</tt>, <tt>scale()</tt>, <tt>rotate()</tt>,
etc. functions that update the figure's transformation matrix, figures also
have a <tt>move()</tt> method. <tt>move()</tt>, like <tt>translate()</tt>,
also moves the figure by a <i>dx</i>, <i>dy</i> offset. However, <tt>move()</tt> works
by changing the figure's coordinates, and not by changing the
transformation matrix.

<p>Since every figure class stores and interprets its position differently,
<tt>move()</tt> is defined for each figure class independently. For example,
<tt><a href="../api/classomnetpp_1_1cPolylineFigure.html">cPolylineFigure</a></tt>'s <tt>move()</tt> changes the coordinates of each point.

<p><tt>move()</tt> is recursive, that is, it not only moves the figure on which
it was called, but also its children. There is also a non-recursive variant,
called <tt>moveLocal()</tt>.

<p>
<h3><a name="sec:graphics:showing-hiding-figures"/>8.6.8 Showing/Hiding Figures<a class="headerlink" href="#sec:graphics:showing-hiding-figures" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:graphics:figure-visibility-flag"/>8.6.8.1 Visibility Flag<a class="headerlink" href="#sec:graphics:figure-visibility-flag" title="Permalink to this headline"></a></h4>

<p>Figures have a visibility flag that controls whether the figure is
displayed. Hiding a figure via the flag will hide the whole figure subtree,
not just the figure itself. The flag can be accessed via the
<tt>isVisible()</tt>, <tt>setVisible()</tt> member functions of
<tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt>.

<p><h4><a name="sec:graphics:figure-tags"/>8.6.8.2 Tags<a class="headerlink" href="#sec:graphics:figure-tags" title="Permalink to this headline"></a></h4>

<p>Figures can also be assigned a number of textual tags. Tags do not directly
affect rendering, but graphical user interfaces that display canvas
content, namely Tkenv and Qtenv, offer functionality to interactively
show/hide figures based on tags they contain. This GUI figure filter allows
one to express conditions like <i>"Show only figures that have tag
<tt>foo</tt> or <tt>bar</tt>, but among them, hide those that also contain
tag <tt>baz</tt>".</i> Tag-based filtering and the visibility flag are in AND
relationship -- figures hidden via <tt>setVisible(false)</tt> cannot be
displayed using tags. Also when a figure is hidden using the tag filter,
its figure subtree will also be hidden.

<p>The tag list of a figure can be accessed with the <tt>getTags()</tt> and
<tt>setTags()</tt> <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt> methods. They return/accept a single
string that contains the tags separated by spaces (a tag itself cannot
contain a space.)

<p>Tags functionality, when used carefully, allows one to define "layers"
that can be turned on/off from Tkenv/Qtenv.

<p>

<p><h3><a name="sec:graphics:figure-tooltip-associated-object"/>8.6.9 Figure Tooltip, Associated Object<a class="headerlink" href="#sec:graphics:figure-tooltip-associated-object" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:graphics:figure-tooltip"/>8.6.9.1  Tooltip<a class="headerlink" href="#sec:graphics:figure-tooltip" title="Permalink to this headline"></a></h4>

<p>Figures may be assigned a tooltip text using the <tt>setTooltip()</tt> method. 
The tooltip is shown in the runtime GUI when one hovers with the mouse over the
figure.

<p><h4><a name="sec:graphics:figure-associated-object"/>8.6.9.2 Associated Object<a class="headerlink" href="#sec:graphics:figure-associated-object" title="Permalink to this headline"></a></h4>

<p>In the visualization of many simulations, some figures correspond to
certain objects in the simulation model. For example, a truck image
may correspond to a module that represents the mobile node
in the simulation. Or, an inflating disc that represents a wireless
signal may correspond to a message (<tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt>) in the simulation.

<p>One can set the associated object on a figure using the 
<tt>setAssociatedObject()</tt> method. The GUI can use this information
provide a shortcut access to the associated object, for example select the
object in an inspector when the user clicks the figure, or display
the object's tooltip over the figure if it does not have its own.

<p><ul class="caution"><b>CAUTION</b><br>
The object must exist (i.e. must not be deleted) while it is
associated with the figure. When the object is deleted, the user
is responsible for letting  the figure forget the pointer,  
e.g. by a  <tt>setAssociatedObject(nullptr)</tt> call.
</ul> 
  
<p>
<h3><a name="sec:graphics:figure-positions-colors-fonts-etc"/>8.6.10 Specifying Positions, Colors, Fonts and Other Properties<a class="headerlink" href="#sec:graphics:figure-positions-colors-fonts-etc" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:graphics:canvas-points"/>8.6.10.1 Points<a class="headerlink" href="#sec:graphics:canvas-points" title="Permalink to this headline"></a></h4>

<p>Points are represented by the <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point</tt> struct:

<pre class="cpp">
struct Point {
    double x, y;
    ...
};
</pre>
<p>
In addition to the public <tt>x</tt>, <tt>y</tt> members and a two-argument
constructor for convenient initialization, the struct provides overloaded
operators (+,-,*,/) and some utility functions like <tt>translate()</tt>,
<tt>distanceTo()</tt> and <tt>str()</tt>.

<p><h4><a name="sec:graphics:canvas-rectangles"/>8.6.10.2 Rectangles<a class="headerlink" href="#sec:graphics:canvas-rectangles" title="Permalink to this headline"></a></h4>

<p>Rectangles are represented by the <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle</tt> struct:

<pre class="cpp">
struct Rectangle {
    double x, y,
    double width, height;
    ...
};
</pre>
<p>
A rectangle is specified with the coordinates of their top-left corner,
their width and height. The latter two are expected to be nonnegative. In
addition to the public <tt>x</tt>, <tt>y</tt>, <tt>width</tt>, <tt>height</tt> members
and a four-argument constructor for convenient initialization, the struct
also has utility functions like <tt>getCenter()</tt>, <tt>getSize()</tt>,
<tt>translate()</tt> and <tt>str()</tt>.

<p><h4><a name="sec:graphics:canvas-colors"/>8.6.10.3 Colors<a class="headerlink" href="#sec:graphics:canvas-colors" title="Permalink to this headline"></a></h4>

<p>Colors are represented by the <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Color</tt> struct as 24-bit RGB colors:

<pre class="cpp">
struct Color {
    uint8_t red, green, blue;
    ...
};
</pre>
<p>
In addition to the public <tt>red</tt>, <tt>green</tt>, <tt>blue</tt> members
and a three-argument constructor for convenient initialization, the struct
also has a string-based constructor and <tt>str()</tt> function.
The string form accepts various notations: HTML colors (<tt>#rrggbb</tt>),
HSB colors in a similar notation (<tt>@hhssbb</tt>), and English color names
(SVG and X11 color names, to be more precise.)

<p>However, one doesn't need to use <tt>Color</tt> directly.
There are also predefined constants for the basic colors (<tt>BLACK</tt>,
<tt>WHITE</tt>, <tt>GREY</tt>, <tt>RED</tt>, <tt>GREEN</tt>, <tt>BLUE</tt>, <tt>YELLOW</tt>,
<tt>CYAN</tt>, <tt>MAGENTA</tt>), as well as a collection of carefully chosen
dark and light colors, suitable for e.g. chart drawing, in the arrays
<tt>GOOD_DARK_COLORS[]</tt> and <tt>GOOD_LIGHT_COLORS[]</tt>; for convenience,
the number of colors in each are in the <tt>NUM_GOOD_DARK_COLORS</tt>
and <tt>NUM_GOOD_LIGHT_COLORS</tt> constants).

<p>The following ways of specifying colors are all valid:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::BLACK;
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Color("steelblue");
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Color("#3d7a8f");
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Color("@20ff80");
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::GOOD_DARK_COLORS[2];
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::GOOD_LIGHT_COLORS[intrand(NUM_GOOD_LIGHT_COLORS)];
</pre>
<p>

<p><h4><a name="sec:graphics:canvas-fonts"/>8.6.10.4 Fonts<a class="headerlink" href="#sec:graphics:canvas-fonts" title="Permalink to this headline"></a></h4>

<p>The requested font for text figures is represented by the <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Font</tt>
struct. It stores the typeface, font style and font size in one.

<pre class="cpp">
struct Font {
    std::string typeface;
    int pointSize;
    uint8_t style;
    ...
};
</pre>
<p>
The font does not need to be fully specified, there are some defaults. When
<tt>typeface</tt> is set to the empty string or when <tt>pointSize</tt> is zero
or a negative value, that means that the default font or the default size
should be used, respectively.

<p>The <tt>style</tt> field can be either <tt>FONT_NONE</tt>, or the binary OR of
the following constants: <tt>FONT_BOLD</tt>, <tt>FONT_ITALIC</tt>,
<tt>FONT_UNDERLINE</tt>.

<p>The struct also has a three-argument constructor for convenient
initialization, and an <tt>str()</tt> function that returns a human-readable
text representation of the contents.

<p>Some examples:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Font("Arial");  // default size, normal
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Font("Arial", 12);  // 12pt, normal
<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Font("Arial", 12, <a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::FONT_BOLD | <a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::FONT_ITALIC);
</pre>
<p>

<p><h4><a name="sec:graphics:canvas-line-and-shape-properties"/>8.6.10.5 Other Line and Shape Properties<a class="headerlink" href="#sec:graphics:canvas-line-and-shape-properties" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt> also contains a number of enums as inner types to describe
various line, shape, text and image properties. Here they are:

<p><b>LineStyle</b>

<p>Values: <tt>LINE_SOLID</tt>, <tt>LINE_DOTTED</tt>, <tt>LINE_DASHED</tt>

<p>This enum (<tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::LineStyle</tt>) is used by line and shape figures
to determine their line/border style. The precise graphical interpretation,
e.g. dash lengths for the <i>dashed</i> style, depends on the graphics
library that the GUI was implemented with.

<p><b>CapStyle</b>

<p>Values: <tt>CAP_BUTT</tt>, <tt>CAP_ROUND</tt>, <tt>CAP_SQUARE</tt>

<p>This enum is used by line and path figures, and it indicates the shape to
be used at the end of the lines or open subpaths.

<p><center>
<img src="graphics-linecaps.png">
</center>

<p><b>JoinStyle</b>

<p>Values: <tt>JOIN_BEVEL</tt>, <tt>JOIN_ROUND</tt>, <tt>JOIN_MITER</tt>

<p>This enum indicates the shape to be used when two line segments are joined,
in line or shape figures.

<p><center>
<img src="graphics-linejoins.png">
</center>

<p><b>FillRule</b>

<p>Values: <tt>FILL_EVENODD</tt>, <tt>FILL_NONZERO</tt>.

<p>This enum determines which regions of a self-intersecting shape
should be considered to be inside the shape, and thus be filled.

<p><center>
<img src="graphics-fillrule.png">
</center>

<p><b>Arrowhead</b>

<p>Values: <tt>ARROW_NONE</tt>, <tt>ARROW_SIMPLE</tt>, <tt>ARROW_TRIANGLE</tt>, <tt>ARROW_BARBED</tt>.

<p>Some figures support displaying arrowheads at one or both ends of a line.
This enum determines the style of the arrowhead to be used.

<p><center>
<img src="graphics-arrowheads.png">
</center>

<p><b>Interpolation</b>

<p>Values: <tt>INTERPOLATION_NONE</tt>, <tt>INTERPOLATION_FAST</tt>, <tt>INTERPOLATION_BEST</tt>.

<p>Interpolation is used for rendering an image when it is not displayed at
its native resolution. This enum indicates the algorithm to be used for
interpolation.

<p>The mode <i>none</i> selects the "nearest neighbor" algorithm.
<i>Fast</i> emphasizes speed, and <i>best</i> emphasizes quality;
however, the exact choice of algorithm (bilinear, bicubic, quadratic, etc.)
depends on features of the graphics library that the GUI was implemented with.

<p><b>Anchor</b>

<p>Values:
<tt>ANCHOR_CENTER</tt>, <tt>ANCHOR_N</tt>, <tt>ANCHOR_E</tt>, <tt>ANCHOR_S</tt>, <tt>ANCHOR_W</tt>,
<tt>ANCHOR_NW</tt>, <tt>ANCHOR_NE</tt>, <tt>ANCHOR_SE</tt>, <tt>ANCHOR_SW</tt>;
<tt>ANCHOR_BASELINE_START</tt>, <tt>ANCHOR_BASELINE_MIDDLE</tt>, <br> <tt>ANCHOR_BASELINE_END</tt>.

<p>Some figures like text and image figures are placed by specifying a single
point (<i>position</i>) plus an anchor mode, a value from this enum. The
anchor mode indicates which point of the bounding box of the figure should
be positioned over the specified point. For example, when using
<tt>ANCHOR_N</tt>, the figure is placed so that its top-middle point falls at
the specified point.

<p>The last three, <i>baseline</i> constants are only used with text
figures, and indicate that the start, middle or end of the text's baseline
is the anchor point.

<p>
<h3><a name="sec:graphics:primitive-figures"/>8.6.11 Primitive Figures<a class="headerlink" href="#sec:graphics:primitive-figures" title="Permalink to this headline"></a></h3>

<p>Now that we know all about figures in general, we can look into the
specific figure classes provided by OMNeT++.

<p><h4><a name="sec:graphics:abstractlinefigure"/>8.6.11.1 <a href="../api/classomnetpp_1_1cAbstractLineFigure.html">cAbstractLineFigure</a><a class="headerlink" href="#sec:graphics:abstractlinefigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cAbstractLineFigure.html">cAbstractLineFigure</a></tt> is the common base class for various line
figures, providing line color, style, width, opacity, arrowhead and other
properties for them.

<p>Line color can be set with <tt>setLineColor()</tt>, and line width with
<tt>setLineWidth()</tt>. Lines can be solid, dashed, dotted, etc.; line
style can be set with <tt>setLineStyle()</tt>. The default line color is
black.

<p>Lines can be partially transparent. This property can be controlled with
<tt>setLineOpacity()</tt> that takes a <tt>double</tt> between 0 and 1: a zero
argument means fully transparent, and one means fully opaque.

<p>Lines can have various cap styles: butt, square, round, etc., which can be
selected with <tt>setCapStyle()</tt>. Join style, which is a related
property, is not part of <tt><a href="../api/classomnetpp_1_1cAbstractLineFigure.html">cAbstractLineFigure</a></tt> but instead added to
specific subclasses where it makes sense.

<p>Lines may also be augmented with arrowheads at either or both ends.
Arrowheads can be selected with <tt>setStartArrowhead()</tt> and
<tt>setEndArrowhead()</tt>.

<p>Transformations such as scaling or skew do affect the width of the line as it
is rendered on the canvas. Whether zooming (by the user) should also affect
it can be controlled by setting a flag (<tt>setZoomLineWidth()</tt>).
The default is non-zooming lines.

<p>Specifying zero for line width is currently not allowed. To hide the line,
use <tt>setVisible(false)</tt>.<br><ul><font size=-1>[It would make sense to display
zero-width lines as hairlines that are always rendered as one pixel wide
regardless of transforms and zoom level, but that is not possible on all
platforms.]</font></ul>

<p>
<h4><a name="sec:graphics:linefigure"/>8.6.11.2 <a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a><a class="headerlink" href="#sec:graphics:linefigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a></tt> displays a single straight line segment. The endpoints
of the line can be set with the <tt>setStart()</tt>/<tt>setEnd()</tt>
methods. Other properties such as color and line style are inherited from
<tt><a href="../api/classomnetpp_1_1cAbstractLineFigure.html">cAbstractLineFigure</a></tt>.

<p>An example that draws an arrow from (0,0) to (100,100):

<pre class="cpp">
<a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a> *line = new <a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a>("line");
line-&gt;setStart(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(0,0));
line-&gt;setEnd(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(100,50));
line-&gt;setLineWidth(2);
line-&gt;setEndArrowhead(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::ARROW_BARBED);
</pre>
<p>
The result:

<p><center>
<img src="figure-line.svg">
</center>

<p>
<h4><a name="sec:graphics:arcfigure"/>8.6.11.3 <a href="../api/classomnetpp_1_1cArcFigure.html">cArcFigure</a><a class="headerlink" href="#sec:graphics:arcfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cArcFigure.html">cArcFigure</a></tt> displays an axis-aligned arc. (To display a
non-axis-aligned arc, apply a transform to <tt><a href="../api/classomnetpp_1_1cArcFigure.html">cArcFigure</a></tt>, or use
<tt><a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a></tt>.) The arc's geometry is determined by the bounding box
of the circle or ellipse, and a start and end angle; they can be set with
the <tt>setBounds()</tt>, <tt>setStartAngle()</tt> and <tt>setEndAngle()</tt>
methods. Other properties such as color and line style are inherited from
<tt><a href="../api/classomnetpp_1_1cAbstractLineFigure.html">cAbstractLineFigure</a></tt>.

<p>For angles, zero points east. Angles that go counterclockwise are
positive, and those that go clockwise are negative.

<p><ul class="note"><b>NOTE</b><br>
Angles are in radians in the C++ API, but in degrees when the figure is
defined in the NED file via <b><tt>@figure</tt></b>.
</ul>

<p>Here is an example that draws a blue arc with an arrowhead that goes
counter-clockwise from 3 hours to 12 hours on the clock:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cArcFigure.html">cArcFigure</a> *arc = new <a href="../api/classomnetpp_1_1cArcFigure.html">cArcFigure</a>("arc");
arc-&gt;setBounds(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle(10,10,100,100));
arc-&gt;setStartAngle(0);
arc-&gt;setEndAngle(M_PI/2);
arc-&gt;setLineColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::BLUE);
arc-&gt;setEndArrowhead(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::ARROW_BARBED);
</pre>
<p>

The result:

<p><center>
<img src="figure-arc.svg">
</center>

<p>
<h4><a name="sec:graphics:polylinefigure"/>8.6.11.4 <a href="../api/classomnetpp_1_1cPolylineFigure.html">cPolylineFigure</a><a class="headerlink" href="#sec:graphics:polylinefigure" title="Permalink to this headline"></a></h4>

<p>By default, <tt><a href="../api/classomnetpp_1_1cPolylineFigure.html">cPolylineFigure</a></tt> displays multiple connecting straight
line segments. The class stores geometry information as a sequence of
points. The line may be <i>smoothed</i>, so the figure can also display
complex curves.

<p>The points can be set with <tt>setPoints()</tt> that takes <tt>std::vector&lt;Point&gt;</tt>,
or added one-by-one using <tt>addPoint()</tt>. Elements in the point list can be
read and overwritten (<tt>getPoint()</tt>, <tt>setPoint()</tt>). One can also
insert and remove points (<tt>insertPoint()</tt> and <tt>removePoint()</tt>.

<p>A smoothed line is drawn as a series of Bezier curves, which touch the
start point of the first line segment, the end point of the last line
segment, and the midpoints of intermediate line segments, while
intermediate points serve as control points. Smoothing can be turned on/off
using <tt>setSmooth()</tt>.

<p>Additional properties such as color and line style are inherited from
<tt><a href="../api/classomnetpp_1_1cAbstractLineFigure.html">cAbstractLineFigure</a></tt>. Line join style (which is not part of
<tt><a href="../api/classomnetpp_1_1cAbstractLineFigure.html">cAbstractLineFigure</a></tt>) can be set with <tt>setJoinStyle()</tt>.

<p>Here is an example that uses a smoothed polyline to draw a spiral:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPolylineFigure.html">cPolylineFigure</a> *polyline = new <a href="../api/classomnetpp_1_1cPolylineFigure.html">cPolylineFigure</a>("polyline");
const double C = 1.1;
for (int i = 0; i &lt; 10; i++)
    polyline-&gt;addPoint(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(5*i*cos(C*i), 5*i*sin(C*i)));
polyline-&gt;move(100, 100);
polyline-&gt;setSmooth(true);
</pre>
<p>

The result, with both <i>smooth=false</i> and <i>smooth=true</i>:

<p><center>
<img src="figure-polylines.svg">
</center>

<p>
<h4><a name="sec:graphics:abstractshapefigure"/>8.6.11.5 <a href="../api/classomnetpp_1_1cAbstractShapeFigure.html">cAbstractShapeFigure</a><a class="headerlink" href="#sec:graphics:abstractshapefigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cAbstractShapeFigure.html">cAbstractShapeFigure</a></tt> is an abstract base class for various shapes,
providing line and fill color, line and fill opacity, line style, line
width, and other properties for them.

<p>Both outline and fill are optional, they can be turned on and off
independently with the <tt>setOutlined()</tt> and <tt>setFilled()</tt>
methods. The default is outlined but unfilled shapes.

<p>Similar to <tt><a href="../api/classomnetpp_1_1cAbstractLineFigure.html">cAbstractLineFigure</a></tt>, line color can be set with
<tt>setLineColor()</tt>, and line width with <tt>setLineWidth()</tt>.
Lines can be solid, dashed, dotted, etc.; line style can be set with
<tt>setLineStyle()</tt>. The default line color is black.

<p>Fill color can be set with <tt>setFillColor()</tt>. The default fill color
is blue (although it is indifferent until one calls <tt>setFilled(true)</tt>).

<p><ul class="note"><b>NOTE</b><br>
Invoking <tt>setFillColor()</tt> alone does not make the shape filled,
one also needs to call <tt>setFilled(true)</tt> for that.
</ul>

<p>Shapes can be partially transparent, and opacity can be set individually
for the outline and the fill, using <tt>setLineOpacity()</tt> and
<tt>setFillOpacity()</tt>. These functions accept a <tt>double</tt> between 0
and 1: a zero argument means fully transparent, and one means fully opaque.

<p>When the outline is drawn with a width larger than one pixel, it will be
drawn symmetrically, i.e. approximately 50-50% of its width will fall
inside and outside the shape. (This also means that the fill and a wide
outline will partially overlap, but that is only apparent if the
outline is also partially transparent.)

<p>Transformations such as scaling or skew do affect the width of the line as it
is rendered on the canvas. Whether zooming (by the user) should also affect
it can be controlled by setting a flag (<tt>setZoomLineWidth()</tt>).
The default is non-zooming lines.

<p>Specifying zero for line width is currently not allowed. To hide the outline,
<tt>setOutlined(false)</tt> can be used.

<p>
<h4><a name="sec:graphics:rectanglefigure"/>8.6.11.6 <a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a><a class="headerlink" href="#sec:graphics:rectanglefigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a></tt> displays an axis-aligned rectangle with
optionally rounded corners. As with all shape figures, drawing of both the
outline and the fill are optional. Line and fill color, and several other
properties are inherited from <tt><a href="../api/classomnetpp_1_1cAbstractShapeFigure.html">cAbstractShapeFigure</a></tt>.

<p>The figure's geometry can be set with the <tt>setBounds()</tt> method that
takes a <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle</tt>. The radii for the rounded corners can
be set independently for the <i>x</i> and <i>y</i> direction using
<tt>setCornerRx()</tt> and <tt>setCornerRy()</tt>, or together with
<tt>setCornerRadius()</tt>.

<p>The following example draws a rounded rectangle of size 160x100, filled with
a "good dark color".

<pre class="cpp">
<a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a> *rect = new <a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a>("rect");
rect-&gt;setBounds(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle(100,100,160,100));
rect-&gt;setCornerRadius(5);
rect-&gt;setFilled(true);
rect-&gt;setFillColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::GOOD_LIGHT_COLORS[0]);
</pre>
<p>

The result:

<p><center>
<img src="figure-rectangle.svg">
</center>

<p>
<h4><a name="sec:graphics:ovalfigure"/>8.6.11.7 <a href="../api/classomnetpp_1_1cOvalFigure.html">cOvalFigure</a><a class="headerlink" href="#sec:graphics:ovalfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cOvalFigure.html">cOvalFigure</a></tt> displays a circle or an axis-aligned ellipse. As with
all shape figures, drawing of both the outline and the fill are optional.
Line and fill color, and several other properties are inherited from
<tt><a href="../api/classomnetpp_1_1cAbstractShapeFigure.html">cAbstractShapeFigure</a></tt>.

<p>The geometry is specified with the bounding box, and it can be set with the
<tt>setBounds()</tt> method that takes a <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle</tt>.

<p>The following example draws a circle of diameter 120 with a wide dotted line.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cOvalFigure.html">cOvalFigure</a> *circle = new <a href="../api/classomnetpp_1_1cOvalFigure.html">cOvalFigure</a>("circle");
circle-&gt;setBounds(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle(100,100,120,120));
circle-&gt;setLineWidth(2);
circle-&gt;setLineStyle(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::LINE_DOTTED);
</pre>
<p>

The result:

<p><center>
<img src="figure-oval.svg">
</center>

<p>
<h4><a name="sec:graphics:ringfigure"/>8.6.11.8 <a href="../api/classomnetpp_1_1cRingFigure.html">cRingFigure</a><a class="headerlink" href="#sec:graphics:ringfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cRingFigure.html">cRingFigure</a></tt> displays a ring, with explicitly controllable
inner/outer radii. The inner and outer circles (or ellipses) form the
outline, and the area between them is filled. As with all shape figures,
drawing of both the outline and the fill are optional. Line and fill color,
and several other properties are inherited from
<tt><a href="../api/classomnetpp_1_1cAbstractShapeFigure.html">cAbstractShapeFigure</a></tt>.

<p>The geometry is determined by the bounding box that defines the outer
circle, and the <i>x</i> and <i>y</i> radii of the inner oval. They can be set with
the <tt>setBounds()</tt>, <tt>setInnerRx()</tt> and <tt>setInnerRy()</tt>
member functions. There is also a utility method for setting both
inner radii together, named <tt>setInnerRadius()</tt>.

<p>The following example draws a ring with an outer diameter of 50 and
inner diameter of 20.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cRingFigure.html">cRingFigure</a> *ring = new <a href="../api/classomnetpp_1_1cRingFigure.html">cRingFigure</a>("ring");
ring-&gt;setBounds(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle(100,100,50,50));
ring-&gt;setInnerRadius(10);
ring-&gt;setFilled(true);
ring-&gt;setFillColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::YELLOW);
</pre>
<p>

<center>
<img src="figure-ring.svg">
</center>

<p>
<h4><a name="sec:graphics:pieslicefigure"/>8.6.11.9 <a href="../api/classomnetpp_1_1cPieSliceFigure.html">cPieSliceFigure</a><a class="headerlink" href="#sec:graphics:pieslicefigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cPieSliceFigure.html">cPieSliceFigure</a></tt> displays a pie slice, that is, a section of an
axis-aligned disc or filled ellipse.  The outline of the pie slice consists
of an arc and two radii. As with all shape figures, drawing of both the
outline and the fill are optional.

<p>Similar to an arc, a pie slice is determined by the bounding box of the
full disc or ellipse, and a start and an end angle. They can be set with
the <tt>setBounds()</tt>, <tt>setStartAngle()</tt> and <tt>setEndAngle()</tt>
methods.

<p>For angles, zero points east. Angles that go counterclockwise are
positive, and those that go clockwise are negative.

<p><ul class="note"><b>NOTE</b><br>
Angles are in radians in the C++ API, but in degrees when the figure is
defined in the NED file via <b><tt>@figure</tt></b>.
</ul>

<p>Line and fill color, and several other properties are inherited from
<tt><a href="../api/classomnetpp_1_1cAbstractShapeFigure.html">cAbstractShapeFigure</a></tt>.

<p>The following example draws pie slice that's one third of a whole pie:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPieSliceFigure.html">cPieSliceFigure</a> *pieslice = new <a href="../api/classomnetpp_1_1cPieSliceFigure.html">cPieSliceFigure</a>("pieslice");
pieslice-&gt;setBounds(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle(100,100,100,100));
pieslice-&gt;setStartAngle(0);
pieslice-&gt;setEndAngle(2*M_PI/3);
pieslice-&gt;setFilled(true);
pieslice-&gt;setLineColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::BLUE);
pieslice-&gt;setFillColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::YELLOW);
</pre>
<p>

The result:

<p><center>
<img src="figure-pieslice.svg">
</center>

<p>
<h4><a name="sec:graphics:polygonfigure"/>8.6.11.10 <a href="../api/classomnetpp_1_1cPolygonFigure.html">cPolygonFigure</a><a class="headerlink" href="#sec:graphics:polygonfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cPolygonFigure.html">cPolygonFigure</a></tt> displays a (closed) polygon, determined by a sequence of points.
The polygon may be <i>smoothed</i>. A smoothed polygon is drawn as a series
of cubic Bezier curves, where the curves touch the midpoints of the sides,
and vertices serve as control points. Smoothing can be turned on/off
using <tt>setSmooth()</tt>.

<p>The points can be set with <tt>setPoints()</tt> that takes <tt>std::vector&lt;Point&gt;</tt>,
or added one-by-one using <tt>addPoint()</tt>. Elements in the point list can be
read and overwritten (<tt>getPoint()</tt>, <tt>setPoint()</tt>). One can also
insert and remove points (<tt>insertPoint()</tt> and <tt>removePoint()</tt>.

<p>As with all shape figures, drawing of both the outline and the fill
are optional. The drawing of filled self-intersecting polygons is controlled
by the fill rule, which defaults to even-odd (<tt>FILL_EVENODD</tt>), and
can be set with <tt>setFillRule()</tt>. Line join style can be set with
the <tt>setJoinStyle()</tt>.

<p>Line and fill color, and several other properties are inherited from
<tt><a href="../api/classomnetpp_1_1cAbstractShapeFigure.html">cAbstractShapeFigure</a></tt>.

<p>Here is an example of a smoothed polygon that also demonstrates
the use of <tt>setPoints()</tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPolygonFigure.html">cPolygonFigure</a> *polygon = new <a href="../api/classomnetpp_1_1cPolygonFigure.html">cPolygonFigure</a>("polygon");
std::vector&lt;<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point&gt; points;
points.push_back(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(0, 100));
points.push_back(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(50, 100));
points.push_back(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(100, 100));
points.push_back(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(50, 50));
polygon-&gt;setPoints(points);
polygon-&gt;setLineColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::BLUE);
polygon-&gt;setLineWidth(3);
polygon-&gt;setSmooth(true);
</pre>
<p>

The result, with both <i>smooth=false</i> and <i>smooth=true</i>:

<p><center>
<img src="figure-polygons.svg">
</center>

<p>
<h4><a name="sec:graphics:pathfigure"/>8.6.11.11 <a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a><a class="headerlink" href="#sec:graphics:pathfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a></tt> displays a "path", a complex shape or line modeled after SVG
paths. A path may consist of any number of straight line segments, Bezier
curves and arcs. The path can be disjoint as well. Closed paths may be filled.
The drawing of filled self-intersecting polygons is controlled by the
<i>fill rule</i> property. Line and fill color, and several other properties
are inherited from <tt><a href="../api/classomnetpp_1_1cAbstractShapeFigure.html">cAbstractShapeFigure</a></tt>.

<p>A path, when given as a string, looks like this one that draws a triangle:

<p><i>M 150 0 L 75 200 L 225 200 Z</i>

<p>It consists of a sequence of commands (<i>M</i> for <i>moveto</i>,
<i>L</i> for <i>lineto</i>, etc.) that are each followed by numeric
parameters (except <i>Z</i>). All commands can be expressed with
lowercase letter, too. A capital letter means that the target point is
given with <i>absolute</i> coordinates, a lowercase letter means they are
given <i>relative</i> to the target point of the previous command.

<p><tt><a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a></tt> can accept the path in string form (<tt>setPath()</tt>),
or one can assemble the path with a series of method calls like
<tt>addMoveTo()</tt>. The path can be cleared with the <tt>clearPath()</tt>
method.

<p>The commands with argument list and the corresponding <i>add</i> methods:

<p><ul>
<li> <b>M</b> <i>x y</i>: move; <tt>addMoveTo()</tt>, <tt>addMoveRel()</tt>
<li> <b>L</b> <i>x y</i>: line; <tt>addLineTo()</tt>, <tt>addLineRel()</tt>
<li> <b>H</b> <i>x</i>: horizontal line; <tt>addHorizontalLineTo()</tt>, <tt>addHorizontalLineRel()</tt>
<li> <b>V</b> <i>y</i>: vertical line; <tt>addVerticalLineTo()</tt>, <tt>addVerticalLineRel()</tt>
<li> <b>A</b> <i>rx ry phi largeArc sweep x y</i>: arc; <tt>addArcTo()</tt>, <tt>addArcRel()</tt>
<li> <b>Q</b> <i>x1 y1 x y</i>: curve; <tt>addCurveTo()</tt>, <tt>addCurveRel()</tt>
<li> <b>T</b> <i>x y</i>: smooth curve; <tt>addSmoothCurveTo()</tt>, <tt>addSmoothCurveRel()</tt>
<li> <b>C</b> <i>x1 y1 x2 y2 x y</i>: cubic Bezier curve; <tt>addCubicBezierCurveTo()</tt>, <tt>addCubicBezierCurveRel()</tt>
<li> <b>S</b> <i>x1 y1 x y</i>: smooth cubic Bezier curve; <tt>addSmoothCubicBezierCurveTo()</tt>, <tt>addSmoothCubicBezierCurveRel()</tt>
<li> <b>Z</b>: close path; <tt>addClosePath()</tt>
</ul>

<p>In the parameter lists, <i>(x,y)</i> are the target points (substitute <i>(dx,dy)</i> for
the lowercase, relative versions.) For the Bezier curves, <i>x1,y1</i> and
<i>(x2,y2)</i> are control points. For the arc, <i>rx</i> and <i>ry</i> are the radii of the
ellipse, <i>phi</i> is a rotation angle in degrees for the ellipse, and
<i>largeArc</i> and <i>sweep</i> are both booleans (0 or 1) that select which portion
of the ellipse should be taken.<br><ul><font size=-1>[For more details, consult the SVG
specification.]</font></ul>

<p>No matter how the path was created, the string form can be obtained with the
<tt>getPath()</tt> method, and the parsed form with the <tt>getNumPathItems()</tt>,
<tt>getPathItem(k)</tt> methods. The latter returns pointer to a
<tt><a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a>::PathItem</tt>, which is a base class with subclasses for every
item type.

<p>Line join style, cap style (for open subpaths), and fill rule (for closed
subpaths) can be set with the <tt>setJoinStyle()</tt>,
<tt>setCapStyle()</tt>, <tt>setFillRule()</tt> methods.

<p><tt><a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a></tt> has one more property, a <i>(dx,dy)</i> offset, which
exists to simplify the implementation of the <tt>move()</tt> method. Offset
causes the figure to be translated by the given amount for drawing. For
other figure types, <tt>move()</tt> directly updates the coordinates, so it
is effectively a wrapper for <tt>setPosition()</tt> or <tt>setBounds()</tt>.
For path figures, implementing <tt>move()</tt> so that it updates every path
item would be cumbersome and potentially also confusing for users. Instead,
<tt>move()</tt> updates the offset. Offset can be set with
<tt>setOffset()</tt>,

<p>In the first example, the path is given as a string:

<p>
<pre class="cpp">
<a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a> *path = new <a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a>("path");
path-&gt;setPath("M 0 150 L 50 50 Q 20 120 100 150 Z");
path-&gt;setFilled(true);
path-&gt;setLineColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::BLUE);
path-&gt;setFillColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::YELLOW);
</pre>

<p>
The second example creates the equivalent path programmatically.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a> *path2 = new <a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a>("path");
path2-&gt;addMoveTo(0,150);
path2-&gt;addLineTo(50,50);
path2-&gt;addCurveTo(20,120,100,150);
path2-&gt;addClosePath();
path2-&gt;setFilled(true);
path2-&gt;setLineColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::BLUE);
path2-&gt;setFillColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::YELLOW);
</pre>
<p>

The result:

<p><center>
<img src="figure-path.svg">
</center>

<p><h4><a name="sec:graphics:abstracttextfigure"/>8.6.11.12 <a href="../api/classomnetpp_1_1cAbstractTextFigure.html">cAbstractTextFigure</a><a class="headerlink" href="#sec:graphics:abstracttextfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cAbstractTextFigure.html">cAbstractTextFigure</a></tt> is an abstract base class for figures that
display (potentially multi-line) text.

<p>The location of the text on the canvas is determined jointly by a
<i>position</i> and an <i>anchor</i>. The anchor tells how to
place the text relative to the positioning point. For example,
if anchor is <tt>ANCHOR_CENTER</tt> then the text is centered on the point;
if anchor is <tt>ANCHOR_N</tt> then the text will be drawn so that its top
center point is at the positioning point. The values
<tt>ANCHOR_BASELINE_START</tt>, <tt>ANCHOR_BASELINE_MIDDLE</tt>,
<tt>ANCHOR_BASELINE_END</tt> refer to the beginning, middle and end of the
baseline of the (first line of the) text as anchor point. The member
functions to set the positioning point and the anchor are
<tt>setPosition()</tt> and <tt>setAnchor()</tt>. Anchor defaults to
<tt>ANCHOR_CENTER</tt>.

<p>The font can be set with the <tt>setFont()</tt> member function that takes
<tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Font</tt>, a class that encapsulates typeface, font style and
size. Color can be set with <tt>setColor()</tt>. The displayed text can
also be partially transparent. This is controlled with the <tt>setOpacity()</tt>
member function that accepts an <tt>double</tt> in the <i>[0,1]</i> range, <i>0</i> meaning
fully transparent (invisible), and <i>1</i> meaning fully opaque. 

<p>It is also possible to have a partially transparent &#8220;halo&#8221; displayed around
the text. The halo improves readability when the text is displayed over a
background that has a similar color as the text, or when it overlaps with other
text items. The halo can be turned on with <tt>setHalo()</tt>. 

<p>
<h4><a name="sec:graphics:textfigure"/>8.6.11.13 <a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a><a class="headerlink" href="#sec:graphics:textfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a></tt> displays text which is affected by zooming and
transformations. Font, color, position, anchoring and other properties are
inherited from <tt><a href="../api/classomnetpp_1_1cAbstractTextFigure.html">cAbstractTextFigure</a></tt>.

<p>The following example displays a text in dark blue 12-point bold Arial
font.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a> *text = new <a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a>("text");
text-&gt;setText("This is some text.");
text-&gt;setPosition(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(100,100));
text-&gt;setAnchor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::ANCHOR_BASELINE_MIDDLE);
text-&gt;setColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Color("#000040"));
text-&gt;setFont(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Font("Arial", 12, <a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::FONT_BOLD));
</pre>
<p>

The result:

<p><center>
<img src="figure-text.svg">
</center>

<p>
<h4><a name="sec:graphics:labelfigure"/>8.6.11.14 <a href="../api/classomnetpp_1_1cLabelFigure.html">cLabelFigure</a><a class="headerlink" href="#sec:graphics:labelfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cLabelFigure.html">cLabelFigure</a></tt> displays text which is unaffected by zooming or
transformations, except its position. Font, color, position, anchoring and
other properties are inherited from <tt><a href="../api/classomnetpp_1_1cAbstractTextFigure.html">cAbstractTextFigure</a></tt>.
The angle of the label can be set with the <tt>setAngle()</tt> method. Zero
angle means horizontal (unrotated) text. Positive values rotate
counterclockwise, while negative values rotate clockwise.

<p><ul class="note"><b>NOTE</b><br>
Angles are in radians in the C++ API, but in degrees when the figure is
defined in the NED file via <b><tt>@figure</tt></b>.
</ul>

<p>The following example displays a label in Courier New with the default
size, slightly transparent.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cLabelFigure.html">cLabelFigure</a> *label = new <a href="../api/classomnetpp_1_1cLabelFigure.html">cLabelFigure</a>("label");
label-&gt;setText("This is a label.");
label-&gt;setPosition(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(100,100));
label-&gt;setAnchor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::ANCHOR_NW);
label-&gt;setFont(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Font("Courier New"));
label-&gt;setOpacity(0.9);
</pre>
<p>

The result:

<p><center>
<img src="figure-label.svg">
</center>

<p>
<h4><a name="sec:graphics:abstractimagefigure"/>8.6.11.15 <a href="../api/classomnetpp_1_1cAbstractImageFigure.html">cAbstractImageFigure</a><a class="headerlink" href="#sec:graphics:abstractimagefigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cAbstractImageFigure.html">cAbstractImageFigure</a></tt> is an abstract base class for image figures.

<p>The location of the image on the canvas is determined jointly by a
<i>position</i> and an <i>anchor</i>. The anchor tells how to
place the image relative to the positioning point. For example,
if anchor is <tt>ANCHOR_CENTER</tt> then the image is centered on the point;
if anchor is <tt>ANCHOR_N</tt> then the image will be drawn so that its top
center point is at the positioning point. The member functions to set the
positioning point and the anchor are <tt>setPosition()</tt> and
<tt>setAnchor()</tt>. Anchor defaults to <tt>ANCHOR_CENTER</tt>.

<p>By default, the figure's width/height will be taken from the image's
dimensions in pixels. This can be overridden with the<tt>setWidth()</tt> /
<tt>setHeight()</tt> methods, causing the image to be scaled.
<tt>setWidth(0)</tt> / <tt>setHeight(0)</tt> reset the default (automatic) width
and height.

<p>One can choose from several interpolation modes that control how the image
is rendered when it is not drawn in its natural size. Interpolation mode
can be set with <tt>setInterpolation()</tt>, and defaults to
<tt>INTERPOLATION_FAST</tt>.

<p>Images can be tinted; this feature is controlled by a tint color and a tint
amount, a <i>[0,1]</i> real number. They can be set with the
<tt>setTintColor()</tt> and <tt>setTintAmount()</tt> methods, respectively.

<p>Images may also be rendered as partially transparent, which is controlled by
the opacity property, a <i>[0,1]</i> real number. Opacity can be set with the
<tt>setOpacity()</tt> method. The rendering process will combine this
property with the transparency information contained within the image, i.e.
the alpha channel.

<p>
<h4><a name="sec:graphics:imagefigure"/>8.6.11.16 <a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a><a class="headerlink" href="#sec:graphics:imagefigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a></tt> displays an image, typically an icon or a background
image, loaded from the OMNeT++ image path. Positioning and other properties
are inherited from <tt><a href="../api/classomnetpp_1_1cAbstractImageFigure.html">cAbstractImageFigure</a></tt>. Unlike <tt><a href="../api/classomnetpp_1_1cIconFigure.html">cIconFigure</a></tt>,
<tt><a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a></tt> fully obeys transforms and zoom.

<p>The following example displays a map:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a> *image = new <a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a>("map");
image-&gt;setPosition(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(0,0));
image-&gt;setAnchor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::ANCHOR_NW);
image-&gt;setImageName("maps/europe");
image-&gt;setWidth(600);
image-&gt;setHeight(500);
</pre>
<p>


<p><h4><a name="sec:graphics:iconfigure"/>8.6.11.17 <a href="../api/classomnetpp_1_1cIconFigure.html">cIconFigure</a><a class="headerlink" href="#sec:graphics:iconfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cIconFigure.html">cIconFigure</a></tt> displays a non-zooming image, loaded from the OMNeT++
image path. Positioning and other properties are inherited from
<tt><a href="../api/classomnetpp_1_1cAbstractImageFigure.html">cAbstractImageFigure</a></tt>.

<p><tt><a href="../api/classomnetpp_1_1cIconFigure.html">cIconFigure</a></tt> is not affected by transforms or zoom, except its position.
(It can still be resized, though, via <tt>setWidth()</tt> / <tt>setHeight()</tt>.)

<p>The following example displays an icon similar to the way the
<tt>"i=block/sink,gold,30"</tt> display string tag would, and makes
it slightly transparent:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cIconFigure.html">cIconFigure</a> *icon = new <a href="../api/classomnetpp_1_1cIconFigure.html">cIconFigure</a>("icon");
icon-&gt;setPosition(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(100,100));
icon-&gt;setImageName("block/sink");
icon-&gt;setTintColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Color("gold"));
icon-&gt;setTintAmount(0.6);
icon-&gt;setOpacity(0.8);
</pre>
<p>

The result:

<p><center>
<img src="figure-icon.png">
</center>

<p>
<h4><a name="sec:graphics:pixmapfigure"/>8.6.11.18 <a href="../api/classomnetpp_1_1cPixmapFigure.html">cPixmapFigure</a><a class="headerlink" href="#sec:graphics:pixmapfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cPixmapFigure.html">cPixmapFigure</a></tt> displays a user-defined raster image. A pixmap
figure may be used to display e.g. a heat map. Support for scaling and
various interpolation modes are useful here. Positioning and other
properties are inherited from <tt><a href="../api/classomnetpp_1_1cAbstractImageFigure.html">cAbstractImageFigure</a></tt>.

<p>A pixmap itself is represented by the <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::<a href="../api/classomnetpp_1_1cFigure_1_1Pixmap.html">Pixmap</a></tt> class.

<p><tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::<a href="../api/classomnetpp_1_1cFigure_1_1Pixmap.html">Pixmap</a></tt> stores a rectangular array of 32-bit RGBA pixels,
and allows pixels to be manipulated directly. The size ($width x
height$) as well as the default fill can be specified in the constructor.
The pixmap can be resized (i.e. pixels added/removed at the right and/or bottom)
using <tt>setSize()</tt>, and it can be filled with a color using <tt>fill()</tt>.
Pixels can be directly accessed with <tt>pixel(x,y)</tt>.

<p>A pixel is returned as type <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::RGBA</tt>, which is a convenience
struct that, in addition to having the four public <tt>uint8_t</tt> fields
(<tt>red</tt>, <tt>green</tt>, <tt>blue</tt>, <tt>alpha</tt>), is augmented with several
utility methods.

<p>Many <tt><a href="../api/classomnetpp_1_1cFigure_1_1Pixmap.html">Pixmap</a></tt> and <tt>RGBA</tt> methods accept or return
<tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Color</tt> and opacity, converting between them and
<tt>RGBA</tt>. (Opacity is a <i>[0,1]</i> real number that is mapped to the
0..255 alpha channel. <i>0</i> means fully transparent, and <i>1</i> means fully
opaque.)

<p>One can set up and manipulate the image that <tt><a href="../api/classomnetpp_1_1cPixmapFigure.html">cPixmapFigure</a></tt> displays
in two ways. First, one can create and fill a <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::<a href="../api/classomnetpp_1_1cFigure_1_1Pixmap.html">Pixmap</a></tt>
separately, and set it on <tt><a href="../api/classomnetpp_1_1cPixmapFigure.html">cPixmapFigure</a></tt> using <tt>setPixmap()</tt>.
This will overwrite the figure's internal pixmap instance that it displays.
The second way is to utilize <tt><a href="../api/classomnetpp_1_1cPixmapFigure.html">cPixmapFigure</a></tt>'s methods such as
<tt>setPixmapSize()</tt>, <tt>fill()</tt>, <tt>setPixel()</tt>,
<tt>setPixelColor()</tt>, <tt>setPixelOpacity()</tt>, etc. that delegate to
the internal pixmap instance.

<p>The following example displays a small heat map by manipulating the
transparency of the pixels. The 9-by-9 pixel image is stretched to
100 units each direction on the screen.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cPixmapFigure.html">cPixmapFigure</a> *pixmapFigure = new <a href="../api/classomnetpp_1_1cPixmapFigure.html">cPixmapFigure</a>("pixmap");
pixmapFigure-&gt;setPosition(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(100,100));
pixmapFigure-&gt;setSize(100, 100);
pixmapFigure-&gt;setPixmapSize(9, 9, <a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::BLUE, 1);
for (int y = 0; y &lt; pixmapFigure-&gt;getPixmapHeight(); y++) {
    for (int x = 0; x &lt; pixmapFigure-&gt;getPixmapWidth(); x++) {
        double opacity = 1 - sqrt((x-4)*(x-4) + (y-4)*(y-4))/4;
        if (opacity &lt; 0) opacity = 0;
        pixmapFigure-&gt;setPixelOpacity(x, y, opacity);
    }
}
pixmapFigure-&gt;setInterpolation(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::INTERPOLATION_FAST);
</pre>
<p>

The result, both with <i>interpolation=NONE</i> and <i>interpolation=FAST</i>:

<p><center>
<img src="figure-pixmaps.png">
</center>

<p>
<h4><a name="sec:graphics:groupfigure"/>8.6.11.19 <a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a><a class="headerlink" href="#sec:graphics:groupfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a></tt> is for the sole purpose of grouping its children. It
has no visual appearance. The usefulness of a group figure comes from the
fact that elements of a group can be hidden / shown together, and also
transformations are inherited from parent to child, thus, children of a
group can be moved, scaled, rotated, etc. together by updating the group's
transformation matrix.

<p>The following example creates a group with two subfigures, then moves and
rotates them as one unit.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a> *group = new <a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a>("group");

<a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a> *rect = new <a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a>("rect");
rect-&gt;setBounds(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle(-50,0,100,40));
rect-&gt;setCornerRadius(5);
rect-&gt;setFilled(true);
rect-&gt;setFillColor(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::YELLOW);

<a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a> *line = new <a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a>("line");
line-&gt;setStart(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(-80,50));
line-&gt;setEnd(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(80,50));
line-&gt;setLineWidth(3);

group-&gt;addFigure(rect);
group-&gt;addFigure(line);
group-&gt;translate(100, 100);
group-&gt;rotate(M_PI/6, 100, 100);
</pre>
<p>

The result:

<p><center>
<img src="figure-group.svg">
</center>

<p>
<h4><a name="sec:graphics:panelfigure"/>8.6.11.20 <a href="../api/classomnetpp_1_1cPanelFigure.html">cPanelFigure</a><a class="headerlink" href="#sec:graphics:panelfigure" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cPanelFigure.html">cPanelFigure</a></tt> is similar to <tt><a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a></tt> in that it is also
intended for grouping its children and has no visual appearance of its own.
However, it has a special behavior regarding transformations and especially zooming.
 
<p><tt><a href="../api/classomnetpp_1_1cPanelFigure.html">cPanelFigure</a></tt> sets up an axis-aligned, unscaled coordinate system for
its children, canceling the effect of any transformation (scaling, rotation,
etc.) inherited from ancestor figures. This allows for pixel-based positioning
of children, and makes them immune to zooming.

<p>Unlike <tt><a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a></tt> which itself has position attribute,
<tt><a href="../api/classomnetpp_1_1cPanelFigure.html">cPanelFigure</a></tt> uses two points for positioning, a <i>position</i> and
an <i>anchor point</i>. Position is interpreted in the coordinate system of
the panel figure's parent, while the anchor point is interpreted in the
coordinate system of the panel figure itself. To place the panel figure on the
canvas, the panel's anchor point is mapped to <i>position</i> in the
parent.

<p>Setting a transformation on the panel figure itself allows for rotation,
scaling, and skewing of its children. The anchor point is also affected by this
transformation.

<p>The following example demonstrates <tt><a href="../api/classomnetpp_1_1cPanelFigure.html">cPanelFigure</a></tt> behavior. It
creates a normal group figure as parent for the panel, and sets up a
skewed coordinate system on it. A reference image is also added to it,
in order to make the effect of skew visible. The panel figure is also
added to it as a child. The panel contains an image (showing the same icon
as the reference image), and a border around it. 

<pre class="cpp">
<a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a> *layer = new <a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a>("parent");
layer-&gt;skewx(-0.3);

<a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a> *referenceImg = new <a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a>("ref");
referenceImg-&gt;setImageName("block/broadcast");
referenceImg-&gt;setPosition(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(200,200));
referenceImg-&gt;setOpacity(0.3);
layer-&gt;addFigure(referenceImg);

<a href="../api/classomnetpp_1_1cPanelFigure.html">cPanelFigure</a> *panel = new <a href="../api/classomnetpp_1_1cPanelFigure.html">cPanelFigure</a>("panel");

<a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a> *img = new <a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a>("img");
img-&gt;setImageName("block/broadcast");
img-&gt;setPosition(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(0,0));
panel-&gt;addFigure(img);

<a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a> *border = new <a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a>("border");
border-&gt;setBounds(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Rectangle(-25,-25,50,50));
border-&gt;setLineWidth(3);
panel-&gt;addFigure(border);

layer-&gt;addFigure(panel);
panel-&gt;setAnchorPoint(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(0,0));
panel-&gt;setPosition(<a href="../api/classomnetpp_1_1cFigure.html">cFigure</a>::Point(210,200));
</pre>
<p>

The screenshot shows the result at an approx. 4x zoom level. The large
semi-transparent image is the reference image, the smaller one is the image within the panel
figure. Note that neither the skew nor the zoom has affected the panel figure's children.

<p><center>
<img src="figure-panel.svg">
</center>

<p>
<h3><a name="sec:graphics:compound-figures"/>8.6.12 Compound Figures<a class="headerlink" href="#sec:graphics:compound-figures" title="Permalink to this headline"></a></h3>

<p>Any graphics can be built using primitive (i.e. elementary) figures
alone. However, when the graphical presentation of a simulation
grows complex, it is often convenient to be able to group certain
figures and treat them as a single unit. For example, although
a bar chart can be displayed using several independent rectangle,
line and text items, there are clearly benefits to being able to
handle them together as a single bar chart object.

<p><i>Compound figures</i> are <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt> sublasses that
are themselves composed of several figures, but can be instantiated
and manipulated as a single figure. Compound figure classes
can be used from C++ code like normal figures, and can also
be made to be able to be instatiated from <b><tt>@figure</tt></b> properties.

<p>Compound figure classes usually subclass from <tt><a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a></tt>.
The class would typically maintain pointers to its subfigures in
class members, and its methods (getters, setters, etc.) would operate
on the subfigures.

<p>To be able to use the new C++ class with <b><tt>@figure</tt></b>,
it needs to be registered using the <tt>Register_Figure()</tt> macro.
The macro expects two arguments: one is the type name by which the figure
is known to <b><tt>@figure</tt></b> (the string to be used with the <tt>type</tt> property key),
and the other is the C++ class name. For example, to be able to instantiate
a class named <tt>FooFigure</tt> with <tt>@figure[...](type=foo;...)</tt>,
the following line needs to be added into the C++ source:

<pre class="cpp">
Register_Figure("foo", FooFigure);
</pre>
<p>
If the figure needs to be able take values from <b><tt>@figure</tt></b> properties,
the class needs to override the <tt>parse(<a href="../api/classomnetpp_1_1cProperty.html">cProperty</a>*)</tt> method,
and proably also <tt>getAllowedPropertyKeys()</tt>. We recommend that
you examine the code of the figure classes built into OMNeT++ for
implementation hints.

<p>

<p><h3><a name="sec:graphics:self-refreshing-figures"/>8.6.13 Self-Refreshing Figures<a class="headerlink" href="#sec:graphics:self-refreshing-figures" title="Permalink to this headline"></a></h3>

<p>Most figures are entirely passive objects. When they need to be moved
or updated during the course of the simulation, there must be an
active component in the simulation that does it for them. Usually it is the
<tt>refreshDisplay()</tt> method of some simple module (or modules) that
contain the code that updates various properties of the figures.

<p>However, certain figures can benefit from being able to refresh themselves
during the simulation. Picture, for example, a compound figure (see
previous section) that displays a line chart which is continually
updated with new data as the simulation progresses. The <tt>LineChartFigure</tt>
class may contain an <tt>addDataPoint(x,y)</tt> method which is called
from other parts of the simulation to add new data to the chart.
The question is when to update the subfigures that make up the chart: the
line(s), axis ticks and labels, etc. It is clearly not very efficient
to do it in every <tt>addDataPoint(x,y)</tt> call, especially when the
simulation is running in Express mode when the screen is not refreshed
very often. Luckily, our hypothetical <tt>LineChartFigure</tt> class
can do better, and only refresh its subfigures when it matters, i.e.
when the result can actually be seen in the GUI. To do that, the class
needs to override <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt>'s <tt>refreshDisplay()</tt> method, and
place the subfigure updating code there.

<p>Figure classes that override <tt>refreshDisplay()</tt> to refresh their
own contents are called <i>self-refreshing figures</i>. Self-refreshing
figures as a feature are available since OMNeT++ version 5.1.

<p><tt>refreshDisplay()</tt> is declared on <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt> as:

<pre class="cpp">
virtual void refreshDisplay();
</pre>
<p>
The default implementation does nothing.

<p>Like <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>refreshDisplay()</tt>, <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt>'s
<tt>refreshDisplay()</tt> is invoked only under graphical user interfaces
(Qtenv/Tkenv), and right before display updates. However, it is only invoked for
figures on canvases that are currently displayed. This makes it possible for
canvases that are never viewed to have zero refresh overhead.

<p>Since <tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt>'s <tt>refreshDisplay()</tt> is only invoked when the
canvas is visible, it should only be used to update local state, i.e. only
local members and local subfigures. The code should certainly not access
other canvases, let alone change the state of the simulation.

<p>
<h3><a name="sec:graphics:figures-with-custom-renderers"/>8.6.14 Figures with Custom Renderers<a class="headerlink" href="#sec:graphics:figures-with-custom-renderers" title="Permalink to this headline"></a></h3>

<p>In rare cases it might be necessary to create figure types where the rendering
is entirely custom, and not based on already existing figures. The
difficulty arises from the point that figures are only data storage classes,
actual drawing takes place in the GUI library such as Tkenv and Qtenv.
Thus, in addition to writing the new figure class, one also needs to extend
Tkenv and/or Qtenv with the corresponding rendering code.
We won't go into full details on how to extend Tkenv/Qtenv here, just give
you a few pointers in case you need it.

<p>In both Tkenv and Qtenv, rendering is done with the help of figure renderer
classes that have a class hierarchy roughly parallel to the
<tt><a href="../api/classomnetpp_1_1cFigure.html">cFigure</a></tt> inheritance tree. The base classes are incidentally called
<tt>FigureRenderer</tt>. How figure renderers do their job is different in
Tkenv and Qtenv: in Tkenv, rendering occurs by creating and maintaining
canvas items on a Tkpath canvas; on Qtenv, they create and manipulate
<tt>QGraphicsItem</tt>s on a <tt>QGraphicsView</tt>. To be able to render a
new figure type, one needs to create the appropriate figure renderer
classes for Tkenv, Qtenv, or both.

<p>The names of the renderer classes are provided by the figures themselves,
by their <tt>getRendererClassName()</tt> methods. For example,
<tt><a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a></tt>'s <tt>getRendererClassName()</tt> returns
<tt>LineFigureRenderer</tt>. Qtenv qualifies that with its own namespace, and
looks for a registered class named
<tt>omnetpp::qtenv::LineFigureRenderer</tt>. If such class exists and is a
Qtenv figure renderer (the appropriate <tt>dynamic_cast</tt> succeeds), an
instance of that class will be used to render the figure, otherwise an
error message will be issued. Tkenv does something similar.

<p>
<h2><a name="sec:graphics:osg"/>8.7 3D Visualization<a class="headerlink" href="#sec:graphics:osg" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:graphics:osg-introduction"/>8.7.1 Introduction<a class="headerlink" href="#sec:graphics:osg-introduction" title="Permalink to this headline"></a></h3>

<p>OMNeT++ lets one build advanced 3D visualization for simulation models.
3D visualization is useful for wide range of simulations, including
mobile wireless networks, transportation models, factory floorplan
simulations and more. One can visualize terrain, roads, urban street
networks, indoor environments, satellites, and more. It is possible to
augment the 3D scene with various annotations. For wireless network
simulations, for example, one can create a scene that, in addition to
the faithful representation of the physical world, also displays the
transmission range of wireless nodes, their connectivity graph
and various statistics, indicates individual wireless transmissions
or traffic intensity, and so on.

<p>In OMNeT++, 3D visualization is completely distinct from display
string-based and canvas-based visualization. The scene appears on a
separate GUI area. Visualizing 3D scenes is currently only supported
in Qtenv (i.e. it is unavailable in Tkenv.)

<p>OMNeT++'s 3D visualization is based on the open-source OpenSceneGraph
and osgEarth libraries. These libraries offer high-level functionality,
such as the ability of using 3D model files directly, accessing and
rendering online map and satellite imagery data sources, and so on.

<p><h4><a name="sec:graphics:osg-and-osgearth"/>8.7.1.1 OpenSceneGraph and osgEarth<a class="headerlink" href="#sec:graphics:osg-and-osgearth" title="Permalink to this headline"></a></h4>

<p>OpenSceneGraph (openscenegraph.org), or OSG for short, is the base library.
It is best to quote their web site:

<p><blockquote>
&#8220;OpenSceneGraph is an open source high performance 3D graphics toolkit,
used by application developers in fields such as visual simulation, games,
virtual reality, scientific visualization and modeling. Written entirely in
Standard C++ and OpenGL, it runs on all Windows platforms, OS X, GNU/Linux,
IRIX, Solaris, HP-UX, AIX and FreeBSD operating systems. OpenSceneGraph is
now well established as the world leading scene graph technology, used
widely in the vis-sim, space, scientific, oil-gas, games and virtual
reality industries.&#8221;
</blockquote>

<p>In turn, osgEarth (osgearth.org) is a geospatial SDK and terrain engine built on top
of OpenSceneGraph, not quite unlike Google Earth. It has many attractive features:

<p><ul>
<li> Able to use various street map providers, satellite imaging providers,
      elevation data sources, both online and offline
<li> Data from online sources may be exported into a file suitable for offline use
<li> Scene may be annotated with various types of graphical objects
<li> Includes conversion between various geographical coordinate systems
</ul>

<p>In OMNeT++, osgEarth can be very useful for simulations involving maps, terrain,
or satellites.

<p><h3><a name="sec:graphics:opp-api-for-osg"/>8.7.2 The OMNeT++ API for OpenSceneGraph<a class="headerlink" href="#sec:graphics:opp-api-for-osg" title="Permalink to this headline"></a></h3>

<p>For 3D visualization, OMNeT++ basically exposes the OpenSceneGraph API. One
needs to assemble an OSG scene graph in the model, and give it to OMNeT++
for display. The scene graph can be updated at runtime, and changes will be
reflected in the display.

<p><ul class="note"><b>NOTE</b><br>
<b>What is a scene graph?</b> A scene graph is a tree-like directed graph
data structure that describes a 3D scene. The root node represents the
whole virtual world. The world is then broken down into a hierarchy of
nodes representing either spatial groupings of objects, settings of
the position of objects, animations of objects, or definitions of
logical relationships between objects. The leaves of the graph
represent the physical objects themselves, the drawable geometry and
their material properties.
</ul>

<p>When a scene graph has been built by the simulation model, it needs to be
given to a <tt><a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a></tt> object to let the OMNeT++ GUI know about it.
<tt><a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a></tt> wraps a scene graph, plus hints for the GUI on how to
best display the scene, for example the default camera position. In the
GUI, the user can use the mouse to manipulate the camera to view the scene
from various angles and distances, look at various parts of the scene,
and so on.

<p>It is important to note that the simulation model may only
manipulate the scene graph, but it cannot directly access the viewer
in the GUI. There is a very specific technical reason for that.
The viewer may not even exist or may be displaying a different
scene graph at the time the model tries to access it. The model
may even be running under a non-GUI user interface (e.g. Cmdenv)
where a viewer is not even part of the program. The viewer may
only be influenced in the form of viewer hints in
<tt><a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a></tt>.

<p>
<h4><a name="sec:graphics:creating-and-accessing-osgcanvas-objects"/>8.7.2.1 Creating and Accessing <a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a> Objects<a class="headerlink" href="#sec:graphics:creating-and-accessing-osgcanvas-objects" title="Permalink to this headline"></a></h4>

<p>Every module has a built-in (default) <tt><a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a></tt>, which can be
accessed with the <tt>getOsgCanvas()</tt> method of <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>.
For example, a toplevel submodule can get hold of the network's
OSG canvas with the following line:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a> *osgCanvas = getParentModule()-&gt;getOsgCanvas();
</pre>
<p>
Additional <tt><a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a></tt> instances may be created simply with <tt>new</tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a> *osgCanvas = new <a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>("scene2");
</pre>
<p>
<h4><a name="sec:graphics:osgcanvas-and-scene-graphs"/>8.7.2.2 <a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a> and Scene Graphs<a class="headerlink" href="#sec:graphics:osgcanvas-and-scene-graphs" title="Permalink to this headline"></a></h4>

<p>Once a scene graph has been assembled, it can be set on <tt><a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a></tt>
with the <tt>setScene()</tt> method.

<pre class="cpp">
osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *scene = ...
osgCanvas-&gt;setScene(scene);
</pre>
<p>
Subsequent changes in the scene graph will be automatically reflected in
the visualization, there is no need to call <tt>setScene()</tt> again or
otherwise let OMNeT++ know about the changes.

<p>
<h4><a name="sec:graphics:osgcanvas-viewer-hints"/>8.7.2.3 Viewer Hints<a class="headerlink" href="#sec:graphics:osgcanvas-viewer-hints" title="Permalink to this headline"></a></h4>

<p>There are several hints that the 3D viewer may take into account when displaying
the scene graph. Note that hints are only hints, so the viewer may choose to
ignore them, and the user may also be able to override them interactively,
(using the mouse, via the context menu, hotkeys or by other means).

<p><ul>

<p><li> <b>Viewer style.</b>
    The viewer style can be set with <tt>setViewerStyle()</tt> and it determines
    the default hints for a scene. Choices are <tt>STYLE_GENERIC</tt> that should
    be set for generic (non-osgEarth) scenes (default), and <tt>STYLE_EARTH</tt>
    for osgEarth scenes. As a rule of thumb, <tt>STYLE_EARTH</tt> should be used
    only when the model is loading <tt>.earth</tt> files.

<p><li> <b>Camera manipulators.</b>
    The OSG viewer makes use of camera manipulators that map mouse and keyboard
    gestures to camera movement. Use <tt>setCameraManipulatorType()</tt> to
    specify a manipulator. Several camera manipulators are available:
    <tt>CAM_TERRAIN</tt> is suitable for flying above an object or terrain;
    <tt>CAM_OVERVIEW</tt> which is similar to the terrain manipulator, but does
    not allow rolling or looking up (one can only see the object from above);
    <tt>CAM_TRACKBALL</tt> that allows unrestricted movement centered around an
    object; and <tt>CAM_EARTH</tt> that should be used when viewing the whole
    Earth is useful (i.e. modeling satellites). The default setting is to
    choose the manipulator automatically (<tt>CAM_AUTO</tt>) based on the viewer
    style (<tt>CAM_OVERVIEW</tt> or <tt>CAM_EARTH</tt>).

<p><li> <b>Scene rendering.</b> One can set the default background color for
    non-osgEarth scenes using <tt>setClearColor()</tt>. It is also possible
    to set the distances of the near and far clipping planes
    (<tt>setZNear()</tt> and <tt>setZFar()</tt>). Everything in the scene will
    be truncated to fit between these two planes. If you see parts of objects
    being clipped away from the scene, try to adjust these values.
    <br><ul><font size=-1>[OSG renders the scene using a <i>Z-buffer</i>. This means
    that upon drawing, the distance of every pixel of every object from the
    camera (called its depth) will be compared to the distance of the last
    drawn pixel in the same position, which is stored in the Z-buffer. The
    pixel will only be updated with the new color if it is found to be closer
    than the previous. Using a Z-buffer simplifies the rendering process,
    but the limited precision of the depth values will cause some pixels to
    be considered equidistant from the camera even if they are not. In this
    case, the result of the comparison, and thus the final color of the pixel
    is undefined, causing visual glitches called <i>Z-fighting</i>
    (flashing objects). <i>zNear</i> and <i>zFar</i> should be chosen such that no
    important objects are left out of the rendering, and in the same time
    Z-fighting is minimized. As a rule of thumb, the <i>zFar/zNear</i>
    ratio should not exceed about 10,000, regardless of their absolute value.]</font></ul>

<p><li> <b>Viewpoint and field of view.</b>
    Default viewpoints can be set by <tt>setGenericViewpoint(<a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::Viewpoint&amp;)</tt>
    by specifying the <i>x</i>, <i>y</i>, <i>z</i> coordinates of the camera, the focal
    point and the "up" direction. For osgEarth scenarios,
    <tt>setEarthViewpoint(osgEarth::Viewpoint&amp;)</tt> can be used to set the
    location of the observer and focal point using geographic coordinates. It
    is also possible to set the camera's field of view angle, with
    <tt>setFieldOfViewAngle()</tt>.

<p></ul>

<p>An example code fragment that sets some viewer hints:

<pre class="cpp">
osgCanvas-&gt;setViewerStyle(<a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::STYLE_GENERIC);
osgCanvas-&gt;setCameraManipulatorType(<a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::CAM_OVERVIEW);
osgCanvas-&gt;setClearColor(<a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::Color("skyblue"));
osgCanvas-&gt;setGenericViewpoint(<a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::Viewpoint(
        <a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::Vec3d(20, -30, 30), // observer
        <a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::Vec3d(30, 20, 0),   // focal point
        <a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::Vec3d(0, 0, 1)));   // UP
</pre>
<p>

<p><h4><a name="sec:graphics:making-osg-nodes-selectable"/>8.7.2.4 Making Nodes Selectable<a class="headerlink" href="#sec:graphics:making-osg-nodes-selectable" title="Permalink to this headline"></a></h4>

<p>If a 3D object in the scene represents a C++ object in the simulation, it
would often be very convenient to be able to select that object for
inspection by clicking it with the mouse.

<p>OMNeT++ provides a wrapper node that associates its children with a particular OMNeT++
object (<tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt> descendant), making them selectable in the 3D viewer.
The wrapper class is called <tt><a href="../api/classomnetpp_1_1cObjectOsgNode.html">cObjectOsgNode</a></tt>, and it subclasses
from <tt>osg::Group</tt>.

<pre class="cpp">
auto objectNode = new <a href="../api/classomnetpp_1_1cObjectOsgNode.html">cObjectOsgNode</a>(myModule);
objectNode-&gt;addChild(myNode);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
The OMNeT++ object should exist as long as the wrapper node exists. Otherwise,
clicking child nodes with the mouse is likely to result in a crash.
</ul>

<p><h4><a name="sec:graphics:finding-resources"/>8.7.2.5 Finding Resources<a class="headerlink" href="#sec:graphics:finding-resources" title="Permalink to this headline"></a></h4>

<p>3D visualizations often need to load external resources from disk, for
example images or 3D models. By default, OSG tries to load these files
from the current working directory (unless they are given with absolute path).
However, loading from the folder of the current OMNeT++ module, from the folder
of the ini file, or from the image path would often be more convenient.
OMNeT++ contains a function for that purpose.

<p>The <tt>resolveResourcePath()</tt> method of modules and channels accepts a
file name (or relative path) as input, and looks into a number of convenient
locations to find the file. The list of the search folders includes
the current working directory, the folder of the main ini file, and the folder
of the NED file that defined the module or channel.
If the resource is found, the function returns the full path; otherwise
it returns the empty string.

<p>The function also looks into folders on the NED path and the image
path, i.e. the roots of the NED and image folder trees. These search
locations allow one to load files by full NED package name (but using
slashes instead of dots), or access an icon with its full name (e.g.
<tt>block/sink</tt>).

<p>An example that attempts to load a <tt>car.osgb</tt> model file:

<pre class="cpp">
std::string fileLoc = resolveResourcePath("car.osgb");
if (fileLoc == "")
    throw <a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a>("car.osgb not found");
auto node = osgDB::readNodeFile(fileLoc); // use the resolved path
</pre>
<p>

<p><h4><a name="sec:graphics:osg-conditional-compilation"/>8.7.2.6 Conditional Compilation<a class="headerlink" href="#sec:graphics:osg-conditional-compilation" title="Permalink to this headline"></a></h4>

<p>OSG and osgEarth are optional in OMNeT++, and may not be available in all
installations. However, one probably wants simulation models to compile
even if the particular OMNeT++ installation doesn't contain the OSG and
osgEarth libraries. This can be achieved by conditional compilation.

<p>OMNeT++ detects the OSG and osgEarth libraries and defines the <tt>WITH_OSG</tt> macro
if they are present. OSG-specific code needs to be surrounded with <tt>#ifdef WITH_OSG</tt>.

<p>An example:

<pre class="cpp">
...
#ifdef WITH_OSG
#include &lt;osgDB/ReadFile&gt;
#endif

void DemoModule::initialize()
{
#ifdef WITH_OSG
    <a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a> *osgCanvas = getParentModule()-&gt;getOsgCanvas();
    osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *scene = ... // assemble scene graph here
    osgCanvas-&gt;setScene(scene);
    osgCanvas-&gt;setClearColor(<a href="../api/classomnetpp_1_1cOsgCanvas.html">cOsgCanvas</a>::Color(0,0,64)); // hint
#endif
}
</pre>
<p>
<h4><a name="sec:graphics:using-additional-osg-libraries"/>8.7.2.7 Using Additional Libraries<a class="headerlink" href="#sec:graphics:using-additional-osg-libraries" title="Permalink to this headline"></a></h4>

<p>OSG and osgEarth are comprised of several libraries. By default, OMNeT++
links simulations with only a subset of them: <tt>osg</tt>, <tt>osgGA</tt>,
<tt>osgViewer</tt>, <tt>osgQt</tt>, <tt>osgEarth</tt>, <tt>osgEarthUtil</tt>. When
additional OSG and osgEarth libraries are needed, one needs to ensure that
those libraries are linked to the model as well. The best way to achieve that
is to use the following code fragment in the <tt>makefrag</tt> file of the
project:

<pre class="filelisting">
ifneq ($(OSG_LIBS),)
LIBS += $(OSG_LIBS) -losgDB -losgAnimation ... # additional OSG libs
endif
ifneq ($(OSGEARTH_LIBS),)
LIBS += $(OSGEARTH_LIBS) -losgEarthFeatures -losgEarthSymbology ...
endif
</pre>
<p>
The <tt>ifneq()</tt> statements ensure that <tt>LIBS</tt> is only updated if OMNeT++ has detected
the presence of OSG/osgEarth in the first place.

<p>
<h3><a name="sec:graphics:using-osg"/>8.7.3 Using OSG<a class="headerlink" href="#sec:graphics:using-osg" title="Permalink to this headline"></a></h3>

<p>OpenScenegraph is a sizable library with 16+ namespaces and 40+ <tt>osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>
subclasses, and we cannot fully document it here due to size constraints. Instead,
in the next sections we have collected some practical advice and useful code snippets
to help the reader get started. More information can be found on the openscenegraph.org
web site, in dedicated OpenSceneGraph books (some of which are freely available),
and in other online resources. We list some OSG-related resources at the end of this
chapter.

<p><h4><a name="sec:graphics:osg-loading-models"/>8.7.3.1 Loading Models<a class="headerlink" href="#sec:graphics:osg-loading-models" title="Permalink to this headline"></a></h4>

<p>To display a 3D model in the canvas of a compound module, an <tt>osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> has
to be provided as the root of the scene.

<p>One method of getting such a <tt><a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> is to load it from a file containing the
model. This can be done with the <tt>osgDB::readNodeFile()</tt> method (or with one
of its variants). This method takes a string as argument, and based on the
protocol specification and extension(s), finds a suitable loader for it,
loads it, finally returns with a pointer to the newly created <tt>osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>
instance.

<p>This node can now be set on the canvas for display with the <tt>setScene()</tt>
method, as seen in the osg-intro sample (among others):

<pre class="cpp">
osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *model = osgDB::readNodeFile("model.osgb");
getParentModule()-&gt;getOsgCanvas()-&gt;setScene(model);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
<b>Where to get model files?</b> While OpenSceneGraph recognizes and can
load a wide range of formats, many 3D modeling tools can also export the
edited scene or part of it in OSG's native file format, osgt, with the
help of exporter plugins. One such plugin for Blender has been used to
develop some of the OSG demos for OMNeT++, and it was found to be working
well.
</ul>

<p>There is support for so-called "pseudo loaders" in OSG, which provide
additional options for loading models. Those allow for some basic
operations to be performed on the model after it is loaded. To use them,
simply append the parameters for the modifier followed by the name of it to
the end of the file name upon loading the model.

<p>Take this line from the osg-earth sample for example:

<pre class="inifile">
*.cow[*].modelURL = "cow.osgb.2.scale.0,0,90.rot.0,0,-15e-1.trans"
</pre>
<p>
This string will first scale the original cow model in <tt>cow.osgb</tt> to
200%, then rotate it 90 degrees around the Z axis and finally translate it
1.5 units downwards. The floating point numbers have to be represented in
scientific notation to avoid the usage of decimal points or commas in the
number as those are already used as operator and parameter separators.

<p>Note that these modifiers operate directly on the model data and are
independent of any further dynamic transformations applied to the node when
it is placed in the scene. For further information refer to the OSG
knowledge base.

<p><h4><a name="sec:graphics:osg-creating-shapes"/>8.7.3.2 Creating Shapes<a class="headerlink" href="#sec:graphics:osg-creating-shapes" title="Permalink to this headline"></a></h4>

<p>Shapes can also be built programatically. For that, one needs to use the
<tt>osg::Geode</tt>, <tt>osg::ShapeDrawable</tt> and <tt>osg::Shape</tt>
classes.

<p>To create a shape, one first needs to create an <tt>osg::Shape</tt>.
<tt>osg::Shape</tt> is an abstract class and it has several subclasses, like
<tt>osg::Box</tt>, <tt>osg::Sphere</tt>, <tt>osg::Cone</tt>,
<tt>osg::Cylinder</tt> or <tt>osg::Capsule</tt>. That object is only an abstract
definition of the shape, and cannot be drawn on its own. To make it drawable,
one needs to create an <tt>osg::ShapeDrawable</tt> for it. However, an
<tt>osg::ShapeDrawable</tt> still cannot be attached to the scene, as it is still
not an <tt>osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>. The <tt>osg::ShapeDrawable</tt> must be added to an
<tt>osg::Geode</tt> (<i>geometry node</i>) to be able to insert it into the
scene. This object can then be added to the scene and positioned and oriented
freely, just like any other <tt>osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>.

<p>For an example of this see the following snippet from the osg-satellites
sample. This code creates an <tt>osg::Cone</tt> and adds it to the scene.

<pre class="cpp">
auto cone = new osg::Cone(osg::Vec3(0, 0, -coneRadius*0.75),
                          coneHeight, coneRadius);
auto coneDrawable = new osg::ShapeDrawable(cone);
auto coneGeode = new osg::Geode;
coneGeode-&gt;addDrawable(coneDrawable);
locatorNode-&gt;addChild(coneGeode);
</pre>
<p>
Note that a single <tt>ost::Shape</tt> instance can be used to construct many
<tt>osg::ShapeDrawable</tt>s, and a single <tt>osg::ShapeDrawable</tt> can be
added to any number of <tt>osg::Geode</tt>s to make it appear in multiple
places or sizes in the scene. This can in fact improve rendering performance.

<p><h4><a name="sec:graphics:osg-placing-and-orienting-models"/>8.7.3.3 Placing and Orienting Models in a Scene<a class="headerlink" href="#sec:graphics:osg-placing-and-orienting-models" title="Permalink to this headline"></a></h4>

<p>One way to position and orient nodes is by making them children of an
<tt>osg::PositionAttitudeTransform</tt>. This node provides methods to
set the position, orientation and scale of its children. Orientation is done
with quaternions (<tt>osg::Quat</tt>). Quaternions can be constructed from
an axis of rotation and a rotation angle around the axis.

<p>The following example places a node at the (x, y, z) coordinates and rotates it
around the Z axis by <tt>heading</tt> radians to make it point in the right
direction.

<pre class="cpp">
osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *objectNode = ...;
auto transformNode = new osg::PositionAttitudeTransform();
transformNode-&gt;addChild(objectNode);
transformNode-&gt;setPosition(osg::Vec3d(x, y, z));
double heading = ...; // (in radians)
transformNode-&gt;setAttitude(osg::Quat(heading, osg::Vec3d(0, 0, 1)));
</pre>
<p>
<h4><a name="sec:graphics:osg-adding-labels-and-annotations"/>8.7.3.4 Adding Labels and Annotations<a class="headerlink" href="#sec:graphics:osg-adding-labels-and-annotations" title="Permalink to this headline"></a></h4>

<p>OSG makes it possible to display text or image labels in the scene. Labels
are rotated to be always parallel to the screen, and scaled to appear in a
constant size. In the following we'll show an example where we create
a label and display it relative to an arbitrary node.

<p>First, the label has to be created:

<pre class="cpp">
auto label = new osgText::Text();
label-&gt;setCharacterSize(18);
label-&gt;setBoundingBoxColor(osg::Vec4(1.0, 1.0, 1.0, 0.5)); // RGBA
label-&gt;setColor(osg::Vec4(0.0, 0.0, 0.0, 1.0)); // RGBA
label-&gt;setAlignment(osgText::Text::CENTER_BOTTOM);
label-&gt;setText("Hello World");
label-&gt;setDrawMode(osgText::Text::FILLEDBOUNDINGBOX | osgText::Text::TEXT);
</pre>
<p>
Or if desired, a textured rectangle with an image:

<pre class="cpp">
auto image = osgDB::readImageFile("myicon.png");
auto texture = new osg::Texture2D();
texture-&gt;setImage(image);
auto icon = osg::createTexturedQuadGeometry(osg::Vec3(0.0, 0.0, 0.0),
    osg::Vec3(image-&gt;s(), 0.0, 0.0), osg::Vec3(0.0, image-&gt;t(), 0.0),
    0.0, 0.0, 1.0, 1.0);
icon-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture);
icon-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON);
</pre>
<p>
If the image has transparent parts, one also needs the following lines:<br><ul><font size=-1>[These lines
enable blending, and places <tt>icon</tt> in the <tt>TRANSPARENT_BIN</tt>. Normally there are
two bins, <i>opaque</i> and <i>transparent</i>. When a scene is rendered, OSG first
renders the objects in the opaque bin, then the objects in the transparent bin. More bits
can be created, but that is rarely necessary.]</font></ul>

<pre class="cpp">
icon-&gt;getOrCreateStateSet()-&gt;setMode(GL_BLEND, osg::StateAttribute::ON);
icon-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
</pre>
<p>
The icon and/or label needs an <tt>osg::Geode</tt> to be placed in the scene.
Lighting is best disabled for the label.

<pre class="cpp">
auto geode = new osg::Geode();
geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING,
            osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
double labelSpacing = 2;
label-&gt;setPosition(osg::Vec3(0.0, labelSpacing, 0.0));
geode-&gt;addDrawable(label);
geode-&gt;addDrawable(icon);
</pre>
<p>
This <tt>osg::Geode</tt> should be made a child of an <tt>osg::AutoTransform</tt>
node, which applies the correct transformations to it for the label-like behaviour
to happen:

<pre class="cpp">
auto autoTransform = new osg::AutoTransform();
autoTransform-&gt;setAutoScaleToScreen(true);
autoTransform-&gt;setAutoRotateMode(osg::AutoTransform::ROTATE_TO_SCREEN);
autoTransform-&gt;addChild(geode);
</pre>
<p>
This <tt>autoTransform</tt> can now be made a child of the <tt>modelToTransform</tt>,
and moved with it.Alternatively, both can be added to a new <tt>osg::Group</tt>,
as siblings, and handled together using that.

<p>We want the label to appear relative to an object called <tt>modelNode</tt>.
One way would be to make <tt>autoTransform</tt> the child of <tt>modelNode</tt>,
but here we rather place both of them under an <tt>osg::Group</tt>. The group should
be inserted

<pre class="cpp">
auto modelNode = ... ;
auto group = new osg::Group();
group-&gt;addChild(modelNode);
group-&gt;addChild(autoTransform);
</pre>
<p>
To place the label above the object, we set its position to <i>(0,0,z)</i>, where <i>z</i>
is the radius of the object's bounding sphere.

<pre class="cpp">
auto boundingSphere = modelNode-&gt;getBound();
autoTransform-&gt;setPosition(osg::Vec3d(0.0, 0.0, boundingSphere.radius()));
</pre>
<p>

<p>
<h4><a name="sec:graphics:osg-drawing-lines"/>8.7.3.5 Drawing Lines<a class="headerlink" href="#sec:graphics:osg-drawing-lines" title="Permalink to this headline"></a></h4>

<p>To draw a line between two points in the scene, first the two points
have to be added into an <tt>osg::Vec3Array</tt>. Then an <tt>osg::DrawArrays</tt>
should be created to specify which part of the array needs to be drawn.
In this case, it is obviously two points, starting from the one at index 0.
Finally, an <tt>osg::Geometry</tt> is necessary to join the two together.

<pre class="cpp">
auto vertices = new osg::Vec3Array();
vertices-&gt;push_back(osg::Vec3(begin_x, begin_y, begin_z));
vertices-&gt;push_back(osg::Vec3(end_x, end_y, end_z));

auto drawArrays = new osg::DrawArrays(osg::PrimitiveSet::LINE_STRIP);
drawArrays-&gt;setFirst(0);
drawArrays-&gt;setCount(vertices-&gt;size());

auto geometry = new osg::Geometry();
geometry-&gt;setVertexArray(vertices);
geometry-&gt;addPrimitiveSet(drawArrays);
</pre>
<p>
The resulting <tt>osg::Geometry</tt> must be added to an <tt>osg::Geode</tt>
(<i>geometry node</i>), which makes it possible to add it to the scene.

<pre class="cpp">
auto geode = new osg::Geode();
geode-&gt;addDrawable(geometry);
</pre>
<p>
To change some visual properties of the line, the <tt>osg::StateSet</tt> of the
<tt>osg::Geode</tt> has to be modified. The width of the line, for example, is
controlled by a <tt>osg::StateAttribute</tt> called <tt>osg::LineWidth</tt>.

<pre class="cpp">
float width = ...;
auto stateSet = geode-&gt;getOrCreateStateSet();
auto lineWidth = new osg::LineWidth();
lineWidth-&gt;setWidth(width);
stateSet-&gt;setAttributeAndModes(lineWidth, osg::StateAttribute::ON);
</pre>
<p>
Because of how <tt>osg::Geometry</tt> is rendered, the specified line width
will always be constant on the screen (measured in pixels), and will not vary
based on the distance from the camera. To achieve that effect, a long and thin
<tt>osg::Cylinder</tt> could be used instead.

<p>Changing the color of the line can be achieved by setting an appropriate
<tt>osg::Material</tt> on the <tt>osg::StateSet</tt>. It is recommended to
disable lighting for the line, otherwise it might appear in a different color,
depending on where it is viewed from or what was rendered just before
it.<br><ul><font size=-1>[Since no normals were specified for the vertices upon creation,
they are undefined (and wouldn't make much sense for a one-dimensional object),
but still would be used for lighting.]</font></ul>

<pre class="cpp">
auto material = new osg::Material();
osg::Vec4 colorVec(red, green, blue, opacity); // all between 0.0 and 1.0
material-&gt;setAmbient(Material::FRONT_AND_BACK, colorVec);
material-&gt;setDiffuse(Material::FRONT_AND_BACK, colorVec);
material-&gt;setAlpha(Material::FRONT_AND_BACK, opacity);
stateSet-&gt;setAttribute(material);
stateSet-&gt;setMode(GL_LIGHTING,
            osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
</pre>
<p>
<h4><a name="sec:graphics:osg-organizing-a-scene"/>8.7.3.6 How to Organize a Scene<a class="headerlink" href="#sec:graphics:osg-organizing-a-scene" title="Permalink to this headline"></a></h4>

<p>Independent of how the scene has been constructed, it is always important
to keep track of how the individual nodes are related to each other in the
scene graph. This is because every modification of an <tt>osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> is by
default propagated to all of its children, let it be a transformation, a
render state variable, or some other flag.

<p>For really simple scenes it might be enough to have an <tt>osg::Group</tt> as the
root node, and make every other object a direct child of that. This reduces
the complications and avoids any strange surprises regarding state
inheritance. For more complex scenes it is advisable to follow the logical
hierarchy of the displayed objects in the scene graph.

<p>Once the desired object has been created and added to the scene, it can be easily
moved and oriented to represent the state of the simulation by making it a
child of an <tt>osg::PositionAttitudeTransform</tt> node.

<p><h4><a name="sec:graphics:osg-using-animations"/>8.7.3.7 Using Animations<a class="headerlink" href="#sec:graphics:osg-using-animations" title="Permalink to this headline"></a></h4>


If the node loaded by <tt>readNodeFile()</tt> contains animations (sometimes called
actions), the <tt>osgAnimation</tt> module is capable of playing them back.

<p>In simple cases, when there is only a single animation, and it is set up to play
in a loop automatically (like the walking man in the osg-indoor sample simulation),
there is no need to explicitly control it (provided it is the desired behaviour.)

<p>Otherwise, the individual actions can be controlled by an
<tt>osgAnimation::AnimationManager</tt>, with methods like <tt>playAnimation()</tt>,
<tt>stopAnimation()</tt>, <tt>isPlaying()</tt>, etc. Animation managers can be
found among the descendants of the loaded <tt>osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt>s which are animated,
for example using a custom <tt>osg::NodeVisitor</tt>:

<pre class="cpp">
osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a> *objectNode = osgDB::readNodeFile( ... );

struct AnimationManagerFinder : public osg::NodeVisitor {
    osgAnimation::BasicAnimationManager *result = nullptr;
    AnimationManagerFinder()
      : osg::NodeVisitor(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN) {}
    void apply(osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a>& node) {
        if (result) return; // already found it
        if (osgAnimation::AnimationManagerBase* b =
              dynamic_cast&lt;osgAnimation::AnimationManagerBase*&gt;(
                node.getUpdateCallback())) {
            result = new osgAnimation::BasicAnimationManager(*b);
            return;
        }
        traverse(node);
    }
} finder;

objectNode-&gt;accept(finder);
animationManager = finder.result;
</pre>
<p>
This visitor simply finds the first node in the subtree which has an update
callback of type <tt>osgAnimation::AnimationManagerBase</tt>. Its result is
a new <tt>osgAnimation::BasicAnimationManager</tt> created from the
base.

<p>This new <tt>animationManager</tt> now has to be set as an update callback on the
<tt>objectNode</tt> to be able to actually drive the animations.
Then any animation in the list returned by <tt>getAnimationList()</tt> can be set
up as needed and played.

<pre class="cpp">
objectNode-&gt;setUpdateCallback(animationManager);
auto animation = animationManager-&gt;getAnimationList().front();
animation-&gt;setPlayMode(osgAnimation::Animation::STAY);
animation-&gt;setDuration(2);
animationManager-&gt;playAnimation(animation);
</pre>
<p>
<h4><a name="sec:graphics:osg-state-sets"/>8.7.3.8 State Sets<a class="headerlink" href="#sec:graphics:osg-state-sets" title="Permalink to this headline"></a></h4>

<p>Every <tt>osg::Drawable</tt> can have an <tt>osg::StateSet</tt> attached to it.
An easy way of accessing it is via the <tt>getOrCreateStateSet()</tt> method of
the drawable node. An <tt>osg::StateSet</tt> encapsulates a subset of the OpenGL
state, and can be used to modify various rendering parameters, for example the
used textures, shader programs and their parameters, color and material,
face culling, depth and stencil options, and many more
<tt>osg::StateAttributes</tt>.

<p>The following example enables blending for a node and sets up a
transparent, colored material to be used for rendering it, through its
<tt>osg::StateSet</tt>.

<pre class="cpp">
auto stateSet = node-&gt;getOrCreateStateSet();
stateSet-&gt;setMode(GL_BLEND, osg::StateAttribute::ON);
auto matColor = osg::Vec4(red, green, blue, alpha); // all between 0.0 and 1.0
auto material = new osg::Material;
material-&gt;setEmission(osg::Material::FRONT, matColor);
material-&gt;setDiffuse(osg::Material::FRONT, matColor);
material-&gt;setAmbient(osg::Material::FRONT, matColor);
material-&gt;setAlpha(osg::Material::FRONT, alpha);
stateSet-&gt;setAttributeAndModes(material, osg::StateAttribute::OVERRIDE);
</pre>
<p>
To help OSG with the correct rendering of objects with transparency, they
should be placed in the <tt>TRANSPARENT_BIN</tt> by setting up a rendering hint
on their <tt>osg::StateSet</tt>. This ensures that they will be drawn after all
fully opaque objects, and in decreasing order of their distance from the camera.
When there are multiple transparent objects intersecting each other in the scene
(like the transmission &#8220;bubbles&#8221; in the BostonPark configuration of the
osg-earth sample simulation), there is no order in which they would appear correctly. A
solution for these cases is to disable writing to the depth buffer during their
rendering using the <tt>osg::Depth</tt> attribute.

<pre class="cpp">
stateSet-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
osg::Depth* depth = new osg::Depth;
depth-&gt;setWriteMask(false);
stateSet-&gt;setAttributeAndModes(depth, osg::StateAttribute::ON);
</pre>
<p>
Please note that this still does not guarentee a completely physically accurate
look, since that is a much harder problem to solve, but at least minimizes the
obvious visual artifacts. Also, too many transparent objects might decrease
performance, so wildly overusing them is to be avoided.

<p>
<h3><a name="sec:graphics:using-osgearth"/>8.7.4 Using osgEarth<a class="headerlink" href="#sec:graphics:using-osgearth" title="Permalink to this headline"></a></h3>

<p>osgEarth is a cross-platform terrain and mapping SDK built on top of OpenSceneGraph.
The most visible feature of osgEarth is that it adds support for loading <tt>.earth</tt>
files to <tt>osgDB::readNodeFile()</tt>. An <tt>.earth</tt> file specifies contents and
appearance of the displayed globe. This can be as simple as a single image
textured over a sphere or as complex as realistic terrain data and
satellite images complete with street and building information dynamically
streamed over the internet from a publicly available provider, thanks to
the flexibility of osgEarth. osgEarth also defines additional APIs
to help with coordinate conversions and other tasks. Other than that,
one's OSG knowledge is also applicable when building osgEarth scenes.

<p>The next sections contain some tips and code fragments to help the reader get
started with osgEarth. As with OSG, there are numerous other sources of
information, both printed and online, when the info contained herein
is insufficient.

<p>
<h4><a name="sec:graphics:earth-files"/>8.7.4.1 Earth Files<a class="headerlink" href="#sec:graphics:earth-files" title="Permalink to this headline"></a></h4>

<p>When the osgEarth plugin is used to display a map as the visual environment
of the simulation, its appearance can be described in a .earth file.

<p>It can be loaded using the <tt>osgDB::readNodeFile()</tt> method, just like any
other regular model. The resulting <tt>osg::<a href="../api/classomnetpp_1_1cTopology_1_1Node.html">Node</a></tt> will contain a node with a
type of <tt>osgEarth::MapNode</tt>, which can be easily found using the
<tt>osgEarth::MapNode::findMapNode()</tt> function. This node serves as the
data model that contains all the data specified in the <tt>.earth</tt> file.

<pre class="cpp">
auto earth = osgDB::readNodeFile("example.earth");
auto mapNode = osgEarth::MapNode::findMapNode(earth);
</pre>
<p>
An .earth file can specify a wide variety of options. The <tt>type</tt> attribute
of the <tt>map</tt> tag (which is always the root of the document) lets the user
select whether the terrain should be projected onto a flat plane (<tt>projected</tt>),
or rendered as a geoid (<tt>geocentric</tt>).

<p>Where the texture of the terrain is acquired from is specified by <tt>image</tt>
tags. Many different kinds of sources are supported, including local files and
popular online map sources with open access like MapQuest or OpenStreetMap.
These can display different kinds of graphics, like satellite imagery, street
or terrain maps, or other features the given on-line service provides.

<p>The following example .earth file will set up a spherical rendering of Earth
with textures from openstreetmap.org:

<pre class="filelisting">
&lt;map name="OpenStreetMap" type="geocentric" version="2" &gt;
    &lt;image name="osm_mapnik" driver="xyz" &gt;
        &lt;url&gt;http://[abc].tile.openstreetmap.org/{z}/{x}/{y}.png&lt;/url&gt;
    &lt;/image&gt;
&lt;/map&gt;
</pre>
<p>
Elevation data can also be acquired in a similarly simple fashion using the
<tt>elevation</tt> tag. The next snippet demonstrates this:

<pre class="filelisting">
&lt;map name="readymap.org" type="geocentric" version="2" &gt;
    &lt;image name="readymap_imagery" driver="tms" &gt;
        &lt;url&gt;http://readymap.org/readymap/tiles/1.0.0/7/&lt;/url&gt;
    &lt;/image&gt;
    &lt;elevation name="readymap_elevation" driver="tms" &gt;
        &lt;url&gt;http://readymap.org/readymap/tiles/1.0.0/9/&lt;/url&gt;
    &lt;/elevation&gt;
&lt;/map&gt;
</pre>
<p>
For a detailed description of the available image and elevation source drivers,
refer to the online references of osgEarth, or use one of the sample .earth
files shipped with it.

<p>The following partial .earth file places a label over Los Angeles, an extruded
ellipse (a hollow cylinder) next to it, and a big red flag nearby.

<pre class="filelisting">
&lt;map ... &gt;
    ...
    &lt;external&gt;
        &lt;annotations&gt;
            &lt;label text="Los Angeles" &gt;
                &lt;position lat="34.051" long="-117.974" alt="100" mode="relative"/&gt;
            &lt;/label&gt;

            &lt;ellipse name="ellipse extruded" &gt;
                &lt;position lat="32.73" long="-119.0"/&gt;
                &lt;radius_major value="50" units="km"/&gt;
                &lt;radius_minor value="20" units="km"/&gt;
                &lt;style type="text/css" &gt;
                    fill:             #ff7f007f;
                    stroke:           #ff0000ff;
                    extrusion-height: 5000;
                &lt;/style&gt;
            &lt;/ellipse&gt;

            &lt;model name="flag model" &gt;
                &lt;url&gt;flag.osg.18000.scale&lt;/url&gt;
                &lt;position lat="33" long="-117.75" hat="0"/&gt;
            &lt;/model&gt;
        &lt;/annotations&gt;
    &lt;/external&gt;
&lt;/map&gt;
</pre>
<p>

<p><h4><a name="sec:graphics:offline-tiles"/>8.7.4.2 Creating Offline Tile Packages<a class="headerlink" href="#sec:graphics:offline-tiles" title="Permalink to this headline"></a></h4>

<p>Being able to use online map providers is very convenient, but it is
often more desirable to use an offline map resource. Doing so not only makes
the simulation usable without internet access, but also speeds up map
loading and insulates the simulation against changes in the online environment
(availablity, content and configuration changes of map servers). 

<p>There are two ways map data may come from the local disk: caching, and 
using a self-contained offline map package. In this section we'll cover the
latter, and show how you can create an offline map package from online sources,
using the command line tool called <tt>osgearth_package</tt>. The resulting
package, unlike map cache, will also be redistributable.

<p>Given the right arguments, <tt>osgearth_package</tt> will download the tiles
that make up the map, and arrange them in a fairly standardized, self-contained
package. It will also create a corresponding <tt>.earth</tt> file that can be later
used just like any other. 

<p>For example, the osg-earth sample simulation uses a tile package which has been
created with a command similar to this one:

<pre class="commandline">
$ osgearth_package --tms boston.earth --out offline-tiles \
    --bounds -71.0705566406 42.350425122434 -71.05957031 42.358543917497 \
    --max-level 18 --out-earth boston_offline.earth --mt --concurrency 8
</pre>
<p>
The <tt>--tms boston.earth</tt> arguments mean that we want to create a package
in TMS format from the input file boston.earth. The <tt>--out offline-tiles</tt>
argument specifies the output directory.

<p>The <tt>--bounds</tt> argument specifies the rectangle of the map we want to include
in the package, in the order <i>xmin ymin xmax ymax</i> order, as standard WGS84
datum (longitude/latitude). These example coordinates include the Boston Common
area, used in some samples. The size of this rectangle obviously has a big impact
on the size of the resulting package.

<p>The <tt>--max-level 18</tt> argument is the maximum level of detail to be saved. This
is a simple way of adjusting the tradeoff between quality and required disk space.
Values between 15 and 20 are generally suitable, depending on the size of the
target area and the available storage capacity.

<p>The <tt>--out-earth boston_offline.earth</tt> option tells the utility to generate
an .earth file with the given name in the output directory that references the
prepared tile package as image source.

<p>The <tt>--mt --concurrency 8</tt> arguments will make the process run in multithreaded
mode, using 8 threads, potentially speeding it up.

<p>The tool has a few more options for controlling the image format and compression
mode among others. Consult the documentation for details, or the short usage help
accessible with the <tt>-h</tt> switch.

<p><ul class="hint"><b>HINT</b><br>
There is also a GUI front-end for <tt>osgearth_package</tt>, called 
<tt>osgearth_package_qt</tt>. This tool provides an easy way to select
the bounding rectangle on the actual map using the mouse, lets the user
choose the input and output files and the export options, and performs the
exporting, all without having to resort to a command line interface.
</ul>

<p>
<h4><a name="sec:graphics:osgearth-placing-objects"/>8.7.4.3 Placing Objects on a Map<a class="headerlink" href="#sec:graphics:osgearth-placing-objects" title="Permalink to this headline"></a></h4>

<p>To easily position a part of the scene together on a given geographical
location, an <tt>osgEarth::GeoTransform</tt> is of great help. It takes
geographical coordinates (longitude/latitude/altitude), and creates a simple
Cartesian coordinate system centered on the given location, in which all of
its children can be positioned painlessly, without having to worry about
further coordinate transformations between Cartesian and geographic systems.
To move and orient the children within this local system,
<tt>osg::PositionAttitudeTransform</tt> can be used.

<pre class="cpp">
osgEarth::GeoTransform *geoTransform = new osgEarth::GeoTransform();
osg::PositionAttitudeTransform *localTransform = new osg::PositionAttitudeTransform();

mapNode-&gt;getModelLayerGroup()-&gt;addChild(geoTransform);
geoTransform-&gt;addChild(localTransform);
localTransform-&gt;addChild(objectNode);

geoTransform-&gt;setPosition(osgEarth::GeoPoint(mapNode-&gt;getMapSRS(), longitude, latitude, altitude));
localTransform-&gt;setAttitude(osg::Quat(heading, osg::Vec3d(0, 0, 1)));
</pre>
<p>
<h4><a name="sec:graphics:osgearth-adding-annotations"/>8.7.4.4 Adding Annotations on a Map<a class="headerlink" href="#sec:graphics:osgearth-adding-annotations" title="Permalink to this headline"></a></h4>

<p>To display additional information on top of the terrain, annotations can be
used. These are special objects that can adapt to the shape of the surface.
Annotations can be of many kinds, for example simple geometric shapes like circles,
ellipses, rectangles, lines, polygons (which can be extruded upwards to make
solids); texts or labels, arbitrary 3D models, or images projected onto the
surface.

<p>All the annotations that can be created declaratively from an .earth file,
can also be programatically generated at runtime.

<p>This example shows how the circular transmission ranges of the cows in the
osg-earth sample are created in the form of a
<tt>osgEarth::Annotation::CircleNode</tt> annotation. Some basic styling is
applied to it using an <tt>osgEarth::Style</tt>, and the rendering technique to
be used is specified.

<pre class="cpp">
auto scene = ...;
auto mapNode = osgEarth::MapNode::findMapNode(scene);
auto geoSRS = mapNode-&gt;getMapSRS()-&gt;getGeographicSRS();
osgEarth::Style rangeStyle;
rangeStyle.getOrCreate&lt;PolygonSymbol&gt;()-&gt;fill()-&gt;color() =
                                        osgEarth::Color(rangeColor);
rangeStyle.getOrCreate&lt;AltitudeSymbol&gt;()-&gt;clamping() =
                                        AltitudeSymbol::CLAMP_TO_TERRAIN;
rangeStyle.getOrCreate&lt;AltitudeSymbol&gt;()-&gt;technique() =
                                        AltitudeSymbol::TECHNIQUE_DRAPE;
rangeNode = new osgEarth::Annotation::CircleNode(mapNode.get(),
    osgEarth::GeoPoint:(geoSRS, longitude, latitude),
    osgEarth::Linear(radius, osgEarth::Units::METERS), rangeStyle);
mapNode-&gt;getModelLayerGroup()-&gt;addChild(rangeNode);
</pre>
<p>

<p><h3><a name="sec:graphics:osg-osgearth-programming-resources"/>8.7.5 OpenSceneGraph/osgEarth Programming Resources<a class="headerlink" href="#sec:graphics:osg-osgearth-programming-resources" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:graphics:osg-osgearth-online-resources"/>8.7.5.1 Online resources<a class="headerlink" href="#sec:graphics:osg-osgearth-online-resources" title="Permalink to this headline"></a></h4>

<p>Loading and manipulating OSG models:
<ul>
<li> http://trac.openscenegraph.org/projects/osg/wiki/Support/UserGuides/Plugins
<li> http://trac.openscenegraph.org/projects/osg/wiki/Support/Tutorials/FileLoadingAndTransforms
<li> http://trac.openscenegraph.org/projects/osg/wiki/Support/KnowledgeBase/PseudoLoader
</ul>

<p>Creating 3D models for OpenSceneGraph using Blender:
<ul>
<li> https://github.com/cedricpinson/osgexport
</ul>

<p>osgEarth online documentation:
<ul>
<li> http://docs.osgearth.org/en/latest/references/earthfile.html
<li> http://docs.osgearth.org/en/latest/index.html
</ul>

<p><h4><a name="sec:graphics:osg-osgearth-samples"/>8.7.5.2 Sample code<a class="headerlink" href="#sec:graphics:osg-osgearth-samples" title="Permalink to this headline"></a></h4>

<p>Be sure to check the samples coming with the OpenSceneGraph installation, as
they contain invaluable information.
<ul>
<li> https://github.com/openscenegraph/osg/tree/master/examples
<li> https://github.com/openscenegraph/osg-data
</ul>

<p><h4><a name="sec:graphics:osg-osgearth-books"/>8.7.5.3 Books<a class="headerlink" href="#sec:graphics:osg-osgearth-books" title="Permalink to this headline"></a></h4>

<p>The following books can be useful for more complex visualization tasks:

<p><ul>
<li> <i>OpenSceneGraph Quick Start Guide</i>, by Paul Martz.

<p>This book is a concise introduction to the OpenSceneGraph API. It can be
purchased from http://www.osgbooks.com, and it is also available as
a free pdf download.

<p><li> <i>OpenSceneGraph 3.0: Beginners Guide</i>, by Wang Rui. Packt Publishing, 2010.

<p>This book is a concise introduction to the main features of OpenSceneGraph
which then leads the reader into the fundamentals of developing virtual reality
applications. Practical instructions and explanations accompany every step.

<p><li> <i>OpenSceneGraph 3.0 Cookbook</i>, by Wang Rui and Qian Xuelei. Packt Publishing, 2010.

<p>This book contains 100 recipes in 9 chapters, focusing on different
fields including the installation, nodes, geometries, camera manipulation,
animations, effects, terrain building, data management, GUI integration.

<p></ul>

<p>
<hr class='pgbr'><h1><a name="cha:build-sim-progs"/>9 Building Simulation Programs<a class="headerlink" href="#cha:build-sim-progs" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:build-sim-progs:overview"/>9.1 Overview<a class="headerlink" href="#sec:build-sim-progs:overview" title="Permalink to this headline"></a></h2>

<p>This chapter describes the process and tools for building executable simulation
models from their source code.

<p>As described in the the previous chapters, the source of an OMNeT++ model usually
contains the following files:

<p><ul>
  <li> C++ (<tt>.cc</tt> and <tt>.h</tt>) files, containing simple module
        implementations and other code;
  <li> Message (<tt>.msg</tt>) files, containing message definitions to be
        translated into C++ classes;
  <li> NED (<tt>.ned</tt>) files with component declarations and topology
        descriptions;
  <li> Configuration (<tt>.ini</tt>) files with model parameter assignments and 
        other settings.
</ul>

<p>The process to turn the source into an executable form is this, in nutshell:

<p><ol>
  <li> Message files are translated into C++ using the message compiler,
        <tt>opp_msgc</tt>
  <li> C++ sources are compiled into object form (<tt>.o</tt> files)
  <li> Object files are linked with the simulation kernel and other 
        libraries to get an executable or a shared library
</ol>

<p>Note that apart from the first step, the process is the same as building any 
C/C++ program. Also note that NED and ini files do not play a part in this
process, as they are loaded by the simulation program at runtime.

<p>One needs to link with the following libraries:

<p><ul>
  <li> The simulation kernel and class library<!--simulation!kernel--> (the
        <i>oppsim</i> library) and its dependencies (<i>oppenvir</i>,
        <i>oppcommon</i>, <i>oppnedxml</i>, etc).
  <li> Optionally, with one or more user interface libraries
  (<i>opptkenv</i>, <i>oppqtenv</i> and <i>oppcmdenv</i>.) 
  Note that these libraries themselves may depend on other libraries.
</ul>

<p>The exact files names of libraries depend on the platform and a number of
additional factors.<br><ul><font size=-1>[On Unix-like platforms, file names are
prefixed with <tt>lib</tt>. For debug versions, a <tt>d</tt> is appended to the
name. Static libraries have the <tt>.a</tt> suffix (except on Windows where
the file extension is <tt>.lib</tt>). Shared libraries end in <tt>.so</tt> on
Unix-like platforms (but <tt>.dylib</tt> on OS X), and <tt>.dll</tt> on Windows.]</font></ul>

<p>Figure <a href="#fig:ch-build:workflow">below</a> shows an overview of the process of
building (and running) simulation programs.

<p>
  <center>
    <img src="build-workflow.svg">
    <center><div class="caption"><i>Figure: Building and running simulation</i></div></center>
    <a name="fig:ch-build:workflow"></a>
  </center>

<p>
You can see that the build process is not complicated. Tools such as
<tt>make</tt> and <tt>opp_makemake</tt>, to be described in the rest of the
chapter, are primarily needed to optimize rebuilds (if a message file has been
translated already, there is no need to repeat the translation for every build
unless the file has changed), and for automation.
 
<p>
<h2><a name="sec:build-sim-progs:opp-makemake"/>9.2 Using opp_makemake and Makefiles<a class="headerlink" href="#sec:build-sim-progs:opp-makemake" title="Permalink to this headline"></a></h2>

<p>There are several tools available for managing the build of C/C++ programs.
OMNeT++ uses the traditional way, Makefiles. Writing a Makefile is usually a
tedious task. However, OMNeT++ provides a tool that can generate the
Makefile for the user, saving manual labour.

<p><tt>opp_makemake</tt> can automatically generate a Makefile for simulation
programs, based on the source files in the current directory and (optionally)
in subdirectories.

<p><h3><a name="sec:build-sim-progs:makemake-options"/>9.2.1 Command-line Options<a class="headerlink" href="#sec:build-sim-progs:makemake-options" title="Permalink to this headline"></a></h3>

<p>The most important options accepted by <tt>opp_makemake</tt> are:

<p><ul>
    <li> <tt>-f</tt>, <tt>-</tt>-force : Force overwriting existing Makefile
    <li> <tt>-o &lt;filename&gt;</tt> : Name of simulation executable or library to be built.
    <li> <tt>-O &lt;directory&gt;</tt>, <tt>-</tt>-out &lt;directory&gt; :
                          Specifies the name of the output directory tree for out-of-directory build
    <li> <tt>-</tt>-deep : Generates a "deep" Makefile. A deep Makefile will
                          cover the whole source tree under the make directory,
                          not just files in that directory.
    <li> <tt>-r</tt>, <tt>-</tt>-recurse : Causes make to recursively descend into all subdirectories;
                          subdirectories are expected to contain Makefiles themselves.
    <li> <tt>-X &lt;directory&gt;</tt>, <tt>-X&lt;directory&gt;</tt>, <tt>-</tt>-except &lt;directory&gt; :
                          With <tt>-r</tt> or <tt>-</tt>-deep: ignore the given directory.
    <li> <tt>-d&lt;subdir&gt;</tt>, <tt>-d &lt;subdir&gt;</tt>, <tt>-</tt>-subdir &lt;subdir&gt; :
                          Causes make to switch to the given directory and invoke
                          a Makefile in that directory.
    <li> <tt>-n</tt>, <tt>-</tt>-nolink : Produce object files but do not create an executable or library.
    <li> <tt>-s</tt>, <tt>-</tt>-make-so : Build shared library (<tt>.so</tt>, <tt>.dll</tt> or <tt>.dylib</tt>).
    <li> <tt>-a</tt>, <tt>-</tt>-make-lib : Create static library (<tt>.a</tt> or <tt>.lib</tt>).
    <li> <tt>-I&lt;dir&gt;</tt> : Add the given directory to the C++ include path.
    <li> <tt>-D&lt;name&gt;[=&lt;value&gt;]</tt>, <tt>-D &lt;name&gt;[=v&lt;alue&gt;]</tt>, <tt>--define &lt;name&gt;[=&lt;value&gt;]</tt> : 
                          Define the given symbol in the C++ compiler.
    <li> <tt>-L&lt;dir&gt;</tt> : Add the given directory to the library path.
    <li> <tt>-l&lt;library&gt;</tt> : Additional library to link against.
</ul>

<p>There are several other options; run <tt>opp_makemake -h</tt> to see the complete
list.

<p>
<h3><a name="sec:build-sim-progs:makemake-basic-use"/>9.2.2 Basic Use<a class="headerlink" href="#sec:build-sim-progs:makemake-basic-use" title="Permalink to this headline"></a></h3>

<p>Assuming the source files (<tt>*.ned</tt>, <tt>*.msg</tt>, <tt>*.cc</tt>, <tt>*.h</tt>)
are located in a single directory, one can change to that directory and type:

<pre class="commandline">
$ opp_makemake
</pre>
<p>
This will create a file named <tt>Makefile</tt><!--Makefile-->. Now, running the
<tt>make</tt> program will build a simulation executable.

<pre class="commandline">
$ make
</pre>
<p>
<ul class="important"><b>IMPORTANT</b><br>
The generated <tt>Makefile</tt> will contain the names of the sources files,
so you need to re-run <tt>opp_makemake</tt> every time new files are added to 
or removed from the project. 
</ul>
 
<p>To regenerate an existing <tt>Makefile</tt>, add the <tt>-f</tt> option to the
command line, otherwise <tt>opp_makemake</tt> will refuse overwriting it.

<pre class="commandline">
$ opp_makemake -f
</pre>
<p>
The name of the output file<!--output!file--> will be derived from
the name of the project directory (see later). It can be overridden
with the <tt>-o</tt> option:

<pre class="commandline">
$ opp_makemake -f -o aloha
</pre>
<p>
The generated <tt>Makefile</tt> supports the following targets:

<p><ul>
  <li> <tt>all</tt> : Builds the simulation; this is also the default target.
  <li> <tt>clean</tt> : Deletes files that were produced by the make process.
</ul>

<p>
<h3><a name="sec:build-sim-progs:debug-and-release-builds"/>9.2.3 Debug and Release Builds<a class="headerlink" href="#sec:build-sim-progs:debug-and-release-builds" title="Permalink to this headline"></a></h3>

<p><tt>opp_makemake</tt> generates a Makefile that can create both release and debug builds.
By default it creates release version, but it is easy to override this behavior by
defining the <tt>MODE</tt> variable on the <tt>make</tt> command line.

<pre class="commandline">
$ make MODE=debug
</pre>
<p>
It is also possible to generate a Makefile that defaults to debug builds.
This can be achieved by adding the <tt>-</tt>-mode option to the <tt>opp_makemake</tt>
command line.

<pre class="commandline">
$ opp_makemake --mode debug
</pre>
<p>
<h3><a name="sec:build-sim-progs:debugging-makefile"/>9.2.4 Debugging the Makefile<a class="headerlink" href="#sec:build-sim-progs:debugging-makefile" title="Permalink to this headline"></a></h3>

<p><tt>opp_makemake</tt> generates a Makefile that prints only minimal information
during the build process (only the name of the compiled file.) To see the full
compiler commands executed by the Makefile, add the <tt>V=1</tt> parameter to
the <tt>make</tt> command line.

<pre class="commandline">
$ make V=1
</pre>
<p>

<p><h3><a name="sec:build-sim-progs:using-external-libraries"/>9.2.5 Using External C/C++ Libraries<a class="headerlink" href="#sec:build-sim-progs:using-external-libraries" title="Permalink to this headline"></a></h3>

<p>If the simulation model relies on an external library, the following
<tt>opp_makemake</tt> options can be used to make the simulation
link with the library.

<p><ul>
  <li> Use the <tt>-I&lt;dir&gt;</tt> option to specify the location of
        the header files. The directory will be added to the compiler's
        include path. This option is not needed if the header files are
        at a standard location, e.g. installed under <tt>/usr/include</tt>
        on Linux.
  <li> Use the <tt>-L&lt;dir&gt;</tt> to specify the location of the binaries
        (static or shared library files.) Again, this option is not needed
        if the binaries are at a standard place, e.g. under <tt>/usr/lib</tt>.
  <li> Use the <tt>-l&lt;libname&gt;</tt> to specify the name of the library.
        The name is normally the file name without the <tt>lib</tt> prefix and
        the file name extension (e.g. <tt>.a</tt>, <tt>.so</tt>, <tt>.dylib</tt>).
</ul>

<p>For example, linking with a hypothetical <i>Foo</i> library installed under
<tt>opt/</tt> might require the following additional <tt>opp_makemake</tt> options:
<tt>-I/opt/foo/include -L/opt/foo/lib -lfoo</tt>.

<p>
<h3><a name="sec:build-sim-progs:building-directory-trees"/>9.2.6 Building Directory Trees<a class="headerlink" href="#sec:build-sim-progs:building-directory-trees" title="Permalink to this headline"></a></h3>

<p>It is possible to build a whole source directory tree with a single Makefile.
A source tree will generate a single output file (executable or library).
A source directory tree will always have a <tt>Makefile</tt> in its root,
and source files may be placed anywhere in the tree.

<p>To turn on this option, use the <tt>opp_makemake --deep</tt> option.
<tt>opp_makemake</tt> will collect all <tt>.cc</tt> and <tt>.msg</tt> files from
the whole subdirectory tree, and generate a Makefile that covers all.
To exclude a specific directory, use the <tt>-X exclude/dir/path</tt>
option. (Multiple <tt>-X</tt> options are accepted.)

<p>An example:

<pre class="commandline">
$ opp_makemake -f --deep -X experimental -X obsolete
</pre>
<p>
In the C++ code, include statements should contain the location of the file
relative to the Makefile's location.<br><ul><font size=-1>[
  Support for deep includes (automatically adding each subdirectory
  to the include path so that includes can be written without specifying
  the location of the file) has been dropped in OMNeT++ version 5.1, due to
  being error-prone in large projects, and having limited usefulness for
  small projects.]</font></ul>
For example, if <tt>Foo.h</tt> is under <tt>utils/common/</tt> in the source
tree, it needs to be included as

<pre class="cpp">
#include "utils/common/Foo.h"
</pre>
<p>

<p><h3><a name="sec:build-sim-progs:dependency-handling"/>9.2.7 Dependency Handling<a class="headerlink" href="#sec:build-sim-progs:dependency-handling" title="Permalink to this headline"></a></h3>

<p>The <tt>make</tt> program can utilize dependency information in the Makefile
to shorten build times by omitting build steps whose input has not changed
since the last build. Dependency information is automatically created and kept
up-to-date during the build process.

<p>Dependency information is kept in <tt>.d</tt> files in the output directory.

<p>
<h3><a name="sec:build-sim-progs:out-of-directory-build"/>9.2.8 Out-of-Directory Build<a class="headerlink" href="#sec:build-sim-progs:out-of-directory-build" title="Permalink to this headline"></a></h3>

<p>The build system creates object and executable files in a separate directory, called the
<i>output directory</i>. By default, the output directory is <tt>out/&lt;configname&gt;</tt>,
where the <tt>&lt;configname&gt;</tt> part depends on the compiler toolchain and build mode settings.
(For example, the result of a debug build with GCC will be placed in <tt>out/gcc-debug</tt>.)
The subdirectory tree inside the output directory will mirror the source directory
structure.

<p><ul class="note"><b>NOTE</b><br>
Generated source files (i.e. those created by <tt>opp_msgc</tt>) will be placed in the
source tree rather than the output directory.
</ul>

<p>By default, the <tt>out</tt> directory is placed in the project root directory. This location
can be changed with <tt>opp_makemake</tt>'s <tt>-O</tt> option.

<pre class="commandline">
$ opp_makemake -O ../tmp/obj
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
The project directory is identified as the first ancestor of the current directory
that contains a <tt>.project</tt> file.
</ul>

<p>
<h3><a name="sec:build-sim-progs:building-shared-and-static-libraries"/>9.2.9 Building Shared and Static Libraries<a class="headerlink" href="#sec:build-sim-progs:building-shared-and-static-libraries" title="Permalink to this headline"></a></h3>

<p>By default the Makefile will create an executable file, but it is also
possible to build shared or static libraries. Shared libraries
are usually a better choice.

<p>Use <tt>-</tt>-make-so to create shared libraries, and <tt>-</tt>-make-lib
to build static libraries. The <tt>-</tt>-nolink option completely omits
the linking step, which is useful for top-level Makefiles that only invoke
other Makefiles, or when custom linking commands are needed.

<p>

<p>
<h3><a name="sec:build-sim-progs:recursive-builds"/>9.2.10 Recursive Builds<a class="headerlink" href="#sec:build-sim-progs:recursive-builds" title="Permalink to this headline"></a></h3>

<p>
The <tt>-</tt>-recurse option enables recursive make; when you build the simulation, make
descends into the subdirectories and runs make in them too.
By default, <tt>-</tt>-recurse decends into all subdirectories; the <tt>-X &lt;dir&gt;</tt> option
can be used to make it ignore certain subdirectories. This option is especially useful
for top level Makefiles.

<p>
The <tt>-</tt>-recurse option automatically discovers subdirectories, but this
is sometimes inconvenient. Your source directory tree may contain
parts which need their own hand written Makefile. This can happen if
you include source files from an other non OMNeT++ project. With the <tt>-d &lt;dir&gt;</tt>
or <tt>-</tt>-subdir &lt;dir&gt; option, you can explicitly specify which directories to
recurse into, and also, the directories need not be direct children of the
current directory.

<p>
The recursive make options (<tt>-</tt>-recurse, <tt>-d</tt>, <tt>-</tt>-subdir)
imply <tt>-X</tt>, that is, the directories recursed into will be
automatically excluded from deep Makefiles.

<p>
You can control the order of traversal by adding dependencies into
the <tt>makefrag</tt> file (see <a href="#sec:makefrag">[9.2.11]</a>)

<p><ul class="note"><b>NOTE</b><br>
With <tt>-d</tt>, it is also possible to create infinite recursions.
<tt>opp_makemake</tt> cannot detect them, it is your responsibility that
cycles do not occur.
</ul>

<p>
Motivation for recursive builds:
<ul>
 <li> toplevel Makefile
 <li> integrating sources that have their own Makefile
</ul>

<p>
<h3><a name="sec:makefrag"/>9.2.11 Customizing the Makefile<a class="headerlink" href="#sec:makefrag" title="Permalink to this headline"></a></h3>

<p>It is possible to add rules or otherwise customize the generated Makefile
by providing a <tt>makefrag</tt> file. When you run <tt>opp_makemake</tt>, it
will automatically insert the content of the <tt>makefrag</tt> file into the
resulting <tt>Makefile</tt>. With the <tt>-i</tt> option, you can also name other
files to be included into the <tt>Makefile</tt>.

<p><tt>makefrag</tt> will be inserted after the definitions but before the first
rule, so it is possible to override existing definitions and add new
ones, and also to override the default target.

<p><tt>makefrag</tt> can be useful if some of your source files are generated
from other files (for example, you use generated NED files), or you need
additional targets in your Makefile or just simply want to override the
default target in the Makefile.

<p><ul class="note"><b>NOTE</b><br>
If you change the content of the <tt>makefrag</tt> file, you must recreate the
Makefile using the <tt>opp_makemake</tt> command.
</ul>

<p><h3><a name="sec:build-sim-progs:projects-with-multiple-source-trees"/>9.2.12 Projects with Multiple Source Trees<a class="headerlink" href="#sec:build-sim-progs:projects-with-multiple-source-trees" title="Permalink to this headline"></a></h3>

<p>In the case of a large project, your source files may be spread across
several directories and your project may generate more than one executable
file (i.e. several shared libraries, examples etc.).

<p>Once you have created your Makefiles with <tt>opp_makemake</tt> in
every source directory tree, you will need a toplevel Makefile.
The toplevel Makefile usually calls only the Makefiles
recursively in the source directory trees.

<p>
<h3><a name="sec:build-sim-progs:multi-directory-example"/>9.2.13 A Multi-Directory Example<a class="headerlink" href="#sec:build-sim-progs:multi-directory-example" title="Permalink to this headline"></a></h3>

<p>For a complex example of using <tt>opp_makemake</tt>, we will show how to create
the Makefiles for a large project. First, take a look at the
project's directory structure and find the directories that should be used as
source trees:

<pre class="verbatim">
project/
    doc/
    images/
    simulations/
    contrib/ &lt;-- source tree (build libmfcontrib.so from this dir)
    core/ &lt;-- source tree (build libmfcore.so from this dir)
    test/ &lt;-- source tree (build testSuite executable from this dir)
</pre>
<p>
Additionally, there are dependencies between these output files: <tt>mfcontrib</tt>
requires <tt>mfcore</tt> and <tt>testSuite</tt> requires <tt>mfcontrib</tt> (and indirectly
<tt>mfcore</tt>).

<p>First, we create the Makefile for the core directory. The Makefile will build
a shared lib from all .cc files in the <tt>core</tt> subtree, and will name it <tt>mfcore</tt>:

<pre class="commandline">
$ cd core && opp_makemake -f --deep --make-so -o mfcore -O out
</pre>
<p>
The <tt>contrib</tt> directory depends on <tt>mfcore</tt>, so we use the <tt>-L</tt> and
<tt>-l</tt> options to specify the library we should link with.

<pre class="commandline">
$ cd contrib && opp_makemake -f --deep --make-so -o mfcontrib -O out \
  -I../core -L../out/\$\(CONFIGNAME\)/core -lmfcore
</pre>
<p>
The <tt>testSuite</tt> will be created as an executable file which depends on both
<tt>mfcontrib</tt> and <tt>mfcore</tt>.

<pre class="commandline">
$ cd test && opp_makemake -f --deep -o testSuite -O out \
    -I../core -I../contrib -L../out/\$\(CONFIGNAME\)/contrib -lmfcontrib
</pre>
<p>
Now, let us specify the dependencies among the above directories.
Add the lines below to the <tt>makefrag</tt> file in the project root directory.

<pre class="filelisting">
contrib_dir: core_dir
test_dir: contrib_dir
</pre>
<p>
Now the last step is to create a top-level Makefile in the root of the project that
calls the previously created Makefiles in the correct order. We will use the
<tt>-</tt>-nolink option, exclude every subdirectory from the build (<tt>-X.</tt>),
and explicitly call the above Makefiles using <tt>-d &lt;dir&gt;</tt>.
<tt>opp_makemake</tt> will automatically include the above created <tt>makefrag</tt> file.

<pre class="commandline">
$ opp_makemake -f --nolink -O out -d test -d core -d contrib -X.
</pre>
<p>
<h2><a name="sec:build-sim-progs:project-features"/>9.3 Project Features<a class="headerlink" href="#sec:build-sim-progs:project-features" title="Permalink to this headline"></a></h2>

<p>Long compile times are often an inconvenience when working with large
OMNeT++-based model frameworks. OMNeT++ has a facility named <i>project
features</i> that lets you reduce build times by excluding or disabling parts
of a large model library. For example, you can disable modules that you do
not use for the current simulation study. The word <i>feature</i> refers
to a piece of the project codebase that can be turned off as a whole.

<p>Additional benefits of project features include enforcing cleaner
separation of unrelated parts in the model framework, being able to exclude
code written for other platforms, and a less cluttered model palette in the
NED editor.

<p><ul class="note"><b>NOTE</b><br>
  Modularization could also be achieved via breaking up the model framework
  into several smaller projects, but that would cause other kinds of
  inconveniences for model developers and users alike.
</ul>

<p>Project features can be enabled/disabled from both the IDE and the command line.
It is possible to query the list of enabled project features, and use this
information in creating a Makefile for the project.

<p>
<h3><a name="sec:build-sim-progs:project-feature"/>9.3.1 What is a Project Feature<a class="headerlink" href="#sec:build-sim-progs:project-feature" title="Permalink to this headline"></a></h3>

<p>Features can be defined per project. As already mentioned, a feature is a piece of the
project codebase that can be turned off as a whole, that is, excluded from the C++ sources
(and thus from the build) and also from NED. Feature definitions are typically written
and distributed by the author of the project; end users are only presented with the
option of enabling/disabling those features. A feature definition contains:

<p><ul>
  <li> Feature name; for example "UDP" or "Mobility examples".
  <li> Feature description; This is a few sentences of text describing what the feature
    is or does; for example "Implementation of the UDP protocol".
  <li> Labels; This is a list of labels or keywords that facilitate grouping or finding features.
  <li> Initially enabled. This is a boolean flag that determines the initial enablement
    of the feature.
<li> Required features; Some features may be built on top of others; for example, a HMIPv6
    protocol implementation relies on MIPv6, which in turn relies on IPv6. Thus, HMIPv6 can
    only be enabled if MIPv6 and IPv6 are enabled as well.
<li> NED packages; This is a list of NED package names that identify the code that implements
    the feature. When you disable the feature, NED types defined in those packages and their
    subpackages will be excluded; also, C++ code in the folders that correspond to the packages
    (i.e. in the same folders as excluded NED files) will also be excluded.
<li> Extra C++ source folders; If the feature contains C++ code that lives outside NED source
    folders (nontypical), those folders are listed here.
<li> Compile options. When the feature is enabled, the compiler options listed
    here are added to the compiler command line of all C++ files in the project.
    Defines (<tt>-D</tt> options) are treated somewhat specially: the project can
    be set up so that defines go into a generated header file as <tt>#define</tt>
    lines instead of being added to the compiler command line. It is
    customary for each feature to have a corresponding symbol
    (<tt>WITH_FOO</tt> for a feature called <i>Foo</i>), so that other parts of
    the code can contain conditional blocks that are only compiled in when the
    given feature is enabled (or disabled). 
<li> Linker options. When the feature is enabled, the linker options listed here are added
    to the linker command line. A typical use of this field is linking with additional
    libraries that the feature's code requires, for example libavcodec.
    Currently only the <tt>-l</tt> option (<i>link with library</i>) is supported here.
</ul>

<p>
<h3><a name="sec:build-sim-progs:opp-featuretool"/>9.3.2 The opp_featuretool Program<a class="headerlink" href="#sec:build-sim-progs:opp-featuretool" title="Permalink to this headline"></a></h3>

<p>Project features can be queried and manipulated using the <tt>opp_featuretool</tt>
program. The first argument to the program must be a command; the most frequently
used ones are <tt>list</tt>, <tt>enable</tt> and <tt>disable</tt>. The operation of commands
can be refined with further options. One can obtain the full list of commands
and options using the <tt>-h</tt> option.

<p>Here are some examples of using the program.

<p>Listing all features in the project:
<pre class="commandline">
$ opp_featuretool list
</pre>

<p>Listing all enabled features in the project:
<pre class="commandline">
$ opp_featuretool list -e
</pre>

<p>Enabling all features:
<pre class="commandline">
$ opp_featuretool enable all
</pre>

<p>Disabling a specific feature:
<pre class="commandline">
$ opp_featuretool disable Foo
</pre>

<p>The following command prints the command line options that should be used
with <tt>opp_makemake</tt> to create a Makefile that builds the project with the
currently enabled features:

<pre class="commandline">
$ opp_featuretool options
</pre>
<p>
The easiest way to pass the output of the above command to <tt>opp_makemake</tt>
is the <tt>$(...)</tt> shell construct:

<pre class="commandline">
$ opp_makemake --deep $(opp_featuretool options)
</pre>
<p>
Often it is convenient to put feature defines (e.g. <tt>WITH_FOO</tt>) into a
header file instead of passing them to the compiler via <tt>-D</tt> options.
This makes it easier to detect feature enablements from derived projects,
and also makes it easier for C++ code editors to correctly highlight
conditional code blocks that depend on project features.

<p>The header file can be generated with <tt>opp_featuretool</tt> using the
following command:

<pre class="commandline">
$ opp_featuretool defines &gt;feature_defines.h
</pre>
<p>
At the same time, <tt>-D</tt> options must be removed from the compiler
command line. <tt>opp_featuretool options</tt> has switches to filter them out.
The modified command for Makefile generation:

<pre class="commandline">
$ opp_makemake --deep $(opp_featuretool options -fl)
</pre>
<p>
It is advisable to create a Makefile rule that regenerates the header file
when feature enablements change:

<pre class="filelisting">
feature_defines.h: $(wildcard .oppfeaturestate) .oppfeatures
        opp_featuretool defines &gt;feature_defines.h
</pre>
<p>

<p>
<h3><a name="sec:build-sim-progs:oppfeatures-file"/>9.3.3 The .oppfeatures File<a class="headerlink" href="#sec:build-sim-progs:oppfeatures-file" title="Permalink to this headline"></a></h3>

<p>Project features are defined in the <tt>.oppfeatures</tt> file in your project's
root directory. This is an XML file, and it has to be written by hand
(there is no specialized editor for it).

<p>The root element is <tt>&lt;features&gt;</tt>, and it may have several <tt>&lt;feature&gt;</tt>
child elements, each defining a project feature. The fields of a feature
are represented with XML attributes; attribute names are <tt>id, name,
description, initiallyEnabled, requires, labels, nedPackages,
extraSourceFolders, compileFlags</tt> and <tt>linkerFlags</tt>. Items within attributes
that represent lists (<tt>requires</tt>, <tt>labels</tt>, etc.) are separated by spaces.

<p>Here is an example feature from the INET Framework:
<pre class="filelisting">
&lt;feature
  id="TCP_common"
  name="TCP Common"
  description = "The common part of TCP implementations"
  initiallyEnabled = "true"
  requires = "IPv4"
  labels = "Transport"
  nedPackages = "inet.transport.tcp_common
                 inet.applications.tcpapp
                 inet.util.headerserializers.tcp"
  extraSourceFolders = ""
  compileFlags = "-DWITH_TCP_COMMON"
  linkerFlags = ""
  /&gt;
</pre>

<p>Project feature enablements are stored in the <tt>.featurestate</tt> file.

<p>
<h3><a name="sec:build-sim-progs:introducing-project-features"/>9.3.4 How to Introduce a Project Feature<a class="headerlink" href="#sec:build-sim-progs:introducing-project-features" title="Permalink to this headline"></a></h3>

<p>If you plan to introduce a project feature in your project, here's what you'll need
to do:

<p><ul>
  <li> Isolate the code that implements the feature into a separate source directory
        (or several directories). This is because only whole folders can be
        declared as part of a feature, individual source files cannot.

<p>  <li> Check the remainder of the project. If you find source lines that reference
        code from the new feature, use conditional compilation (<tt>#ifdef WITH_YOURFEATURE</tt>)
        to make sure that code compiles (and either works sensibly or throws an error)
        when the new feature is disabled. (Your feature should define the <tt>WITH_YOURFEATURE</tt>
        symbol, i.e. <tt>-DWITH_YOURFEATURE</tt> will need to be added to the feature compile flags.)

<p>  <li> Add the feature description into the <tt>.oppfeatures</tt> file of your project.

<p>  <li> Test. A rudimentary test is to verify that the project compiles at all,
        both with the new feature enabled and disabled. For projects with many
        features, automated build tests that compile the project using various
        feature configurations can be very useful. Such build tests can be
        written on top of <tt>opp_featuretool</tt>.
        
<p></ul>

<hr class='pgbr'><h1><a name="cha:config-sim"/>10 Configuring Simulations<a class="headerlink" href="#cha:config-sim" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:config-sim:config-file"/>10.1 The Configuration File<a class="headerlink" href="#sec:config-sim:config-file" title="Permalink to this headline"></a></h2>

<p>Configuration and input data for the simulation are in
a configuration file usually called <tt>omnetpp.ini</tt>.

<p><h3><a name="sec:config-sim:example-inifile"/>10.1.1 An Example<a class="headerlink" href="#sec:config-sim:example-inifile" title="Permalink to this headline"></a></h3>

<p>For a start, let us see a simple <tt>omnetpp.ini</tt> file which
can be used to run the Fifo example simulation.

<pre class="inifile">
[General]
network = FifoNet
sim-time-limit = 100h
cpu-time-limit = 300s
#debug-on-errors = true
#record-eventlog = true

[Config Fifo1]
description = "low job arrival rate"
**.gen.sendIaTime = exponential(0.2s)
**.gen.msgLength = 100b
**.fifo.bitsPerSec = 1000bps

[Config Fifo2]
description = "high job arrival rate"
**.gen.sendIaTime = exponential(0.01s)
**.gen.msgLength = 10b
**.fifo.bitsPerSec = 1000bps
</pre>
<p>
The file is grouped into <i>sections</i> named <tt>[General]</tt>, <tt>[Config Fifo1]</tt>
and <tt>[Config Fifo2]</tt>, each one containing several <i>entries</i>.

<p>
<h3><a name="sec:config-sim:inifile-syntax"/>10.1.2 File Syntax<a class="headerlink" href="#sec:config-sim:inifile-syntax" title="Permalink to this headline"></a></h3>

<p>An OMNeT++ configuration file is an ASCII text file, but non-ASCII
characters are permitted in comments and string literals. This allows for
using encodings that are a superset of ASCII, for example ISO 8859-1 and
UTF-8. There is no limit on the file size or on the line length.

<p>Comments may be placed at the end of any line after a hash mark, &#8220;#&#8221;.
Comments extend to the end of the line, and are ignored during processing.
Blank lines are also allowed and ignored.

<p>The file is line oriented, and consists of <i>section heading lines</i>,
<i>key-value lines</i>, and <i>directive lines</i>:

<p><ol>
<li> <i>Section heading lines</i> contain a section name enclosed in square brackets.
<li> <i>Key-value lines</i> have the <i>&lt;key&gt;=&lt;value&gt;</i> syntax; spaces
      are allowed (but not required) on both sides of the equal sign.
      If a line contains more than one equal sign, the leftmost one is taken
      as the key-value separator.
<li> Currently there is only one kind of directive line, <i>include</i>. An
      include line starts with the <tt>include</tt> word, followed by the name of
      the file to be included.
</ol>

<p>Key-value lines may not occur above the first section heading line (except
in included files, see later).

<p>Keys may be further classified based on syntax alone:

<p><ol>
<li> Keys that do not contain dots represent global or per-run <i>configuration options</i>.
<li> If a key contains a dot, its last component (substring after the last dot)
      is considered. If the last component contains a hyphen or is equal to
      <tt>typename</tt>, the key represents a <i>per-object configuration option</i>.
<li> Otherwise, the key represents a <i>parameter assignment</i>. Thus, parameter
      assignment keys contain a dot, and no hyphen after the last dot.
</ol>

<p>Long lines can be broken up using the backslash notation: if the last
character of a line is &#8220;\&#8221;, it will be merged with the next
line.

<p>An example:

<pre class="inifile">
# This is a comment line
[General]                       # section heading
network = Foo                   # configuration option
debug-on-errors = false         # another configuration option

**.vector-recording = false     # per-object configuration option
**.app*.typename = "HttpClient" # per-object configuration option

**.app*.interval = 3s           # parameter value
**.app*.requestURL = "http://www.example.com/this-is-a-very-very-very-very\
-very-long-url?q=123456789"     # a two-line parameter value
</pre>
<p>
<h3><a name="sec:config-sim:inifile-inclusion"/>10.1.3 File Inclusion<a class="headerlink" href="#sec:config-sim:inifile-inclusion" title="Permalink to this headline"></a></h3>

<p>OMNeT++ supports including an ini file in another<!--ini file!file inclusion-->,
via the <tt>include</tt> keyword. This feature allows one to partition a large ini
file into logical units, fixed and varying part, etc.

<p>An example:

<pre class="inifile">
# omnetpp.ini
...
include params1.ini
include params2.ini
include ../common/config.ini
...
</pre>
<p>
One can also include files from other directories. If the included ini file
further includes others, their path names will be understood as relative to
the location of the file which contains the reference, rather than relative
to the current working directory of the simulation.

<p>This rule also applies to other file names occurring in ini files (such as
the <b><tt>load-libs</tt></b>, <b><tt>output-vector-file</tt></b>,
<b><tt>output-scalar-file</tt></b>, etc. options, and <tt>xmldoc()</tt> module
parameter values.)

<p>In included files, it is allowed to have key-value lines without first having a
section heading line. File inclusion is conceptually handled as text
substitution, except that a section heading in an included file will not
change the current section the main file. The following example illustrates
the rules:

<pre class="inifile">
# incl.ini
foo1 = 1          # no preceding section heading: these lines will go into
foo2 = 2          # whichever section the file is included into
[Config Bar]
bar = 3           # this will always go to into [Config Bar]
</pre>
<p>
<pre class="inifile">
# omnetpp.ini
[General]
include incl.ini  # adds foo1/foo2 to [General], and defines [Config Bar] w/ bar
baz1 = 4          # include files don't change the current section, so these
baz2 = 4          # lines still belong to [General]
</pre>

<p><ul class="note"><b>NOTE</b><br>
The concept of file inclusion implies that include files may not make sense
on their own. Thus, when an included ini file is opened in the ini editor
in the IDE, file contents may be flagged with errors and warnings. These
errors/warnings disappear when the file is viewed as part of its main file.
</ul>

<p>
<h2><a name="sec:config-sim:sections"/>10.2 Sections<a class="headerlink" href="#sec:config-sim:sections" title="Permalink to this headline"></a></h2>

<p>An ini file may contain a <tt>[General]</tt> section and several <tt>[Config &lt;configname&gt;]</tt>
sections. The order of the sections doesn't matter.

<p><h3><a name="sec:config-sim:general-section"/>10.2.1 The [General] Section<a class="headerlink" href="#sec:config-sim:general-section" title="Permalink to this headline"></a></h3>

<p>The most commonly used options of the <tt>[General]</tt> section are the
following.

<p><ul>
  <li> The <b><tt>network</tt></b> option selects the model to be set up and run.
  <li> The length of the simulation can be set with the
    <b><tt>sim-time-limit</tt></b> and the <b><tt>cpu-time-limit</tt></b> options (the
    usual time units such as ms, s, m, h, etc. can be used).
</ul>

<p>Note that the NED files loaded by the simulation may contain several
networks, and any of them may be specified in the <b><tt>network</tt></b>
option.

<p>
<h3><a name="sec:config-sim:named-configurations"/>10.2.2 Named Configurations<a class="headerlink" href="#sec:config-sim:named-configurations" title="Permalink to this headline"></a></h3>

<p>Named configurations are sections of the form <tt>[Config &lt;configname&gt;]</tt>, where
<i>&lt;configname&gt;</i> is by convention a camel-case string that starts with a capital letter:
<tt>Config1</tt>, <tt>WirelessPing</tt>, <tt>OverloadedFifo</tt>, etc. For example,
<tt>omnetpp.ini</tt> for an Aloha simulation might have the following skeleton:

<pre class="inifile">
[General]
...
[Config PureAloha]
...
[Config SlottedAloha1]
...
[Config SlottedAloha2]
...
</pre>
<p>
Some configuration options (such as user interface selection) are only
accepted in the <tt>[General]</tt> section, but most of them can go into <tt>Config</tt>
sections as well.

<p>When a simulation is run, one needs to select one of the configurations
to be activated. In Cmdenv, this is done with the <tt>-c</tt> command-line option:

<pre class="commandline">
$ aloha -c PureAloha
</pre>
<p>
The simulation will then use the contents of the <tt>[Config PureAloha]</tt>
section to set up the simulation. (Tkenv, of course, lets the user choose
the configuration from a dialog.)

<p>
<h3><a name="sec:config-sim:section-inheritance"/>10.2.3 Section Inheritance<a class="headerlink" href="#sec:config-sim:section-inheritance" title="Permalink to this headline"></a></h3>

<p>When the PureAloha configuration is activated, the contents of
the <tt>[General]</tt> section will also be taken into account: if some
configuration option or parameter value is not found in <tt>[Config PureAloha]</tt>,
then the search will continue in the <tt>[General]</tt> section. In
other words, lookups in <tt>[Config PureAloha]</tt> will fall back to <tt>[General]</tt>.
The <tt>[General]</tt> section itself is optional; when it is absent, it is
treated like an empty <tt>[General]</tt> section.

<p>All named configurations fall back to <tt>[General]</tt> by default. However, for
each configuration it is possible to specify the fall-back section or a list of
fallback sections explicitly, using the <b><tt>extends</tt></b> key. Consider the
following ini file skeleton:

<pre class="inifile">
[General]
...
[Config SlottedAlohaBase]
...
[Config LowTrafficSettings]
...
[Config HighTrafficSettings]
...

[Config SlottedAloha1]
extends = SlottedAlohaBase, LowTrafficSettings
...
[Config SlottedAloha2]
extends = SlottedAlohaBase, HighTrafficSettings
...
[Config SlottedAloha2a]
extends = SlottedAloha2
...
[Config SlottedAloha2b]
extends = SlottedAloha2
...
</pre>
<p>

<p>When <tt>SlottedAloha2b</tt> is activated, lookups will consider sections in the
following order (this is also called the <i>section fallback chain</i>):
<tt>SlottedAloha2b</tt>, <tt>SlottedAloha2</tt>, <tt>SlottedAlohaBase</tt>,
<tt>HighTrafficSettings</tt>, <tt>General</tt>.

<p>The effect is the same as if the contents of the sections
SlottedAloha2b, SlottedAloha2, SlottedAlohaBase, HighTrafficSettings and
General were copied together into one section, one after another,
<tt>[Config SlottedAloha2b]</tt> being at the top, and <tt>[General]</tt>
at the bottom. Lookups always start at the top, and stop at the first
matching entry.

<p>The order of the sections in the <i>fallback chain</i> is computed
using the <i>C3 linearization algorithm</i> ([<a href="#bib-Barrett1996">Barrett1996</a>]):

<p>The <i>fallback chain</i> of a configuration <tt>A</tt> is
<ul>
  <li> if <tt>A</tt> does not have an <b><tt>extends</tt></b> key then
        <tt>A</tt>, <tt>General</tt>
  <li> otherwise the merge of the configurations enumerated in the
        <b><tt>extends</tt></b> key, and all of their <i>fallback section chains</i>.
        The merge is <i>monotonic</i>: if some configuration <tt>X</tt>
        precedes configuration <tt>Y</tt> in one of the input chains,
        it will precede it in the output chain too.
</ul>

<p>The <i>section fallback chain</i> can be printed by the <tt>-X</tt> option
of the command line of the simulation program:

<pre class="commandline">
$ aloha -X SlottedAloha2b
OMNeT++ Discrete Event Simulation
...
Config SlottedAloha2b
Config SlottedAloha2
Config SlottedAlohaBase
Config HighTrafficSettings
General
</pre>
<p>
The <i>section fallback</i> concept is similar to multiple inheritance in
object-oriented languages, and benefits are similar too; one can factor out
the common parts of several configurations into a &#8220;base&#8221; configuration,
and additionally, one can reuse existing configurations without copying, by
using them as a base. In practice one will often have &#8220;abstract&#8221;
configurations too (in the C++/Java sense), which assign only a subset of
parameters and leave the others open, to be assigned in derived
configurations.

<p>When experimenting with a lot of different parameter settings for a
simulation model, file inclusion and section inheritance can make it much
easier to manage ini files.

<p>
<h2><a name="sec:config-sim:parameter-settings"/>10.3 Assigning Module Parameters<a class="headerlink" href="#sec:config-sim:parameter-settings" title="Permalink to this headline"></a></h2>

<p>Simulations get input via module parameters, which can be assigned a
value in NED files or in <tt>omnetpp.ini</tt> -- in this order. Since parameters
assigned in NED files cannot be overridden in <tt>omnetpp.ini</tt>, one can
think about them as being &#8220;hardcoded&#8221;. In contrast, it is easier
and more flexible to maintain module parameter settings in <tt>omnetpp.ini</tt>.

<p>In <tt>omnetpp.ini</tt>, module parameters are referred to by their full paths
(hierarchical names). This name consists of the dot-separated list of
the module names (from the top-level module down to the module containing
the parameter), plus the parameter name (see section <a href="#sec:sim-lib:object-fullpath">[7.1.2.2]</a>).

<p>An example <tt>omnetpp.ini</tt> which sets the <tt>numHosts</tt> parameter of
the toplevel module and the <tt>transactionsPerSecond</tt> parameter of the
<tt>server</tt> module:

<pre class="inifile">
[General]
Network.numHosts = 15
Network.server.transactionsPerSecond = 100
</pre>
<p>
Typename pattern assignments are also accepted:

<pre class="inifile">
[General]
Network.host[*].app.typename = "PingApp"
</pre>
<p>

<p><h3><a name="sec:config-sim:wildcards"/>10.3.1 Using Wildcard Patterns<a class="headerlink" href="#sec:config-sim:wildcards" title="Permalink to this headline"></a></h3>

<p>Models can have a large number of parameters to be configured, and it would
be tedious to set them one-by-one in <tt>omnetpp.ini</tt>. OMNeT++ supports
<i>wildcard patterns</i> which allow for setting several model parameters
at once. The same pattern syntax is used for per-object configuration options;
for example <tt>&lt;object-path-pattern&gt;.record-scalar</tt>, or <tt>&lt;module-path-pattern&gt;.rng-&lt;N&gt;</tt>.

<p>The pattern syntax is a variation on Unix <i>glob</i>-style
patterns. The most apparent differences to globbing rules are the
distinction between <tt>*</tt> and <tt>**</tt>, and that character ranges should
be written with curly braces instead of square brackets; that is,
<i>any-letter</i> is expressed as <tt>{a-zA-Z}</tt> and not as
<tt>[a-zA-Z]</tt>, because square brackets are reserved for the notation of
module vector indices.

<p>Pattern syntax:

<p><ul>
  <li> <tt>?</tt> : matches any character except dot (.)
  <li> <tt>*</tt> : matches zero or more characters except dot (.)
  <li> <tt>**</tt> : matches zero or more characters (any character)
  <li> <tt>{a-f}</tt> : <i>set</i>: matches a character in the range a-f
  <li> <tt>{^a-f}</tt>: <i>negated set</i>: matches a character
    NOT in the range a-f
  <li> <tt>{38..150}</tt> : <i>numeric range</i>: any number (i.e. sequence of digits)
    in the range 38..150, inclusive; both limits are optional
  <li> <tt>[38..150]</tt> : <i>index range</i>: any number in square brackets in the
    range 38..150, inclusive; both limits are optional
  <li> backslash (\) : takes away the special meaning of the
    subsequent character
</ul>

<p><h4><a name="sec:config-sim:precedence-of-entries"/>10.3.1.1 Precedence<a class="headerlink" href="#sec:config-sim:precedence-of-entries" title="Permalink to this headline"></a></h4>

<p>The order of entries is very important with wildcards. When a key matches
several wildcard patterns, the <i>first</i> matching occurrence
is used. This means that one needs to list specific settings first, and
more general ones later. Catch-all settings should come last.

<p>An example ini file:

<pre class="inifile">
[General]
*.host[0].waitTime = 5ms   # specifics come first
*.host[3].waitTime = 6ms
*.host[*].waitTime = 10ms  # catch-all comes last
</pre>
<p>

<p><h4><a name="sec:config-sim:asterisk-vs-double-asterisk"/>10.3.1.2 Asterisk vs Double Asterisk<a class="headerlink" href="#sec:config-sim:asterisk-vs-double-asterisk" title="Permalink to this headline"></a></h4>

<p>The <tt>*</tt> wildcard is for matching a single module or parameter name in the
path name, while <tt>**</tt> can be used to match several components in the path.
For example, <tt>**.queue*.bufSize</tt> matches the <tt>bufSize</tt> parameter of any module
whose name begins with <tt>queue</tt> in the model, while <tt>*.queue*.bufSize</tt>
or <tt>net.queue*.bufSize</tt> selects only queues immediately on network level.
Also note that <tt>**.queue**.bufSize</tt> would match <tt>net.queue1.foo.bar.bufSize</tt>
as well!

<p><h4><a name="sec:config-sim:sets-negated-sets"/>10.3.1.3 Sets, Negated Sets<a class="headerlink" href="#sec:config-sim:sets-negated-sets" title="Permalink to this headline"></a></h4>

<p>Sets and negated sets can contain several character ranges and also
enumeration of characters. For example, <tt>{_a-zA-Z0-9}</tt> matches any letter
or digit, plus the underscore; <tt>{xyzc-f}</tt> matches any of the characters
x, y, z, c, d, e, f.
To include '-' in the set, put it at a position where it cannot be
interpreted as character range, for example: <tt>{a-z-}</tt> or <tt>{-a-z}</tt>.
To include '}' in the set, it must be the first character: <tt>{}a-z}</tt>,
or as a negated set: <tt>{^}a-z}</tt>.
A backslash is always taken as a literal backslash (and not as an escape
character) within set definitions.

<p>
<h4><a name="sec:config-sim:numeric-ranges-and-index-ranges"/>10.3.1.4 Numeric Ranges and Index Ranges<a class="headerlink" href="#sec:config-sim:numeric-ranges-and-index-ranges" title="Permalink to this headline"></a></h4>

<p>Only nonnegative integers can be matched.  The start or the end of the range
(or both) can be omitted: <tt>{10..}</tt>, <tt>{..99}</tt> or <tt>{..}</tt>
are valid numeric ranges (the last one matches any number).
The specification must use exactly two dots.
Caveat: <tt>*{17..19}</tt> will match <tt>a17</tt>, <tt>117</tt> and <tt>963217</tt> as well,
because the <tt>*</tt> can also match digits!

<p>An example for numeric ranges:

<pre class="inifile">
[General]
*.*.queue[3..5].bufSize = 10
*.*.queue[12..].bufSize = 18
*.*.queue[*].bufSize = 6  # this will only affect queues 0,1,2 and 6..11
</pre>
<p>

<p><h3><a name="sec:config-sim:using-default-values"/>10.3.2 Using the Default Values<a class="headerlink" href="#sec:config-sim:using-default-values" title="Permalink to this headline"></a></h3>

<p>It is also possible to utilize the default values specified in the NED files.
The <i>&lt;parameter-fullpath&gt;</i><tt>=default</tt> setting assigns
the default value to a parameter if it has one.

<p>The <i>&lt;parameter-fullpath&gt;</i><tt>=ask</tt> setting will try to get the parameter
value interactively from the user.

<p>If a parameter was not set but has a default value, that value will be
assigned. This is like having a <tt>**=default</tt> line at the
bottom of the <tt>[General]</tt> section.

<p>If a parameter was not set and has no default value, that will either
cause an error or will be interactively prompted for, depending
on the particular user interface.

<p><ul class="note"><b>NOTE</b><br>
In Cmdenv, one must explicitly enable interactive mode with the
<tt>-</tt>-cmdenv-interactive=true option, otherwise the simulation
program will stop with an error in the setup phase.
</ul>

<p>More precisely, parameter resolution takes place as follows:

<p><ol>
<li> If the parameter is assigned in NED, it cannot be overridden in the
    configuration. The value is applied and the process finishes.
<li> If the first match is a value line (matches
    <i>&lt;parameter-fullpath&gt;</i><tt>=</tt><i>&lt;value&gt;</i>), the value is
    applied and the process finishes.
<li> If the first match is a <i>&lt;parameter-fullpath&gt;</i><tt>=default</tt> line,
    the default value is applied and the process finishes.
<li> If the first match is a <i>&lt;parameter-fullpath&gt;</i><tt>=ask</tt> line,
    the parameter will be asked from the user interactively (UI dependent).
<li> If there was no match and the parameter has a default value, it is applied
    and the process finishes.
<li> Otherwise the parameter is declared unassigned, and handled accordingly
    by the user interface. It may be reported as an error, or may be
    asked from the user interactively.
</ol>

<p>
<h2><a name="sec:config-sim:parameter-studies"/>10.4 Parameter Studies<a class="headerlink" href="#sec:config-sim:parameter-studies" title="Permalink to this headline"></a></h2>

<p>It is quite common in simulation studies that the simulation model is
run several times with different parameter settings, and the results
are analyzed in relation to the input parameters. OMNeT++ 3.x had no
direct support for batch runs, and users had to resort to writing shell
(or Python, Ruby, etc.) scripts that iterated over the required
parameter space, to generate a (partial) ini file and run the
simulation program in each iteration.

<p>OMNeT++ 4.x largely automates this process, and eliminates the need for
writing batch execution scripts. It is the ini file where the user can
specify iterations over various parameter settings.
Here is an example:

<pre class="inifile">
[Config AlohaStudy]
*.numHosts = ${1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential(${0.2, 0.4, 0.6}s)
</pre>
<p>
This parameter study expands to 8*3 = 24 simulation runs, where the number of
hosts iterates over the numbers 1, 2, 5, 10, 20, 30, 40, 50, and for
each host count three simulation runs will be done, with the generation
interval being exponential(0.2), exponential(0.4), and
exponential(0.6).

<p>How does it work? First of all, Cmdenv with the <tt>-x</tt> option will print
how many simulation runs a given section expands to. (One should of course
use Cmdenv for batch runs, not a GUI one like Tkenv or Qtenv.)

<pre class="commandline">
$ aloha -u Cmdenv -x AlohaStudy

OMNeT++ Discrete Event Simulation
...
Config: AlohaStudy
Number of runs: 24
</pre>
<p>
When the <tt>-g</tt> option is also added, the program also prints the values
of the iteration variables for each run. (Use <tt>-G</tt> for even more info.)
Note that the parameter study actually maps to nested loops, with the last
<tt>${...}</tt> becoming the innermost loop. The iteration variables are
just named <tt>$0</tt> and <tt>$1</tt> -- we'll see that it is possible to give
meaningful names to them. Please ignore the <tt>$repetition=0</tt> part in
the printout for now.

<pre class="commandline">
$ aloha -u Cmdenv -x AlohaStudy -g
OMNeT++ Discrete Event Simulation
...
Config: AlohaStudy
Number of runs: 24
Run 0: $0=1, $1=0.2, $repetition=0
Run 1: $0=1, $1=0.4, $repetition=0
Run 2: $0=1, $1=0.6, $repetition=0
Run 3: $0=2, $1=0.2, $repetition=0
Run 4: $0=2, $1=0.4, $repetition=0
Run 5: $0=2, $1=0.6, $repetition=0
Run 6: $0=5, $1=0.2, $repetition=0
Run 7: $0=5, $1=0.4, $repetition=0
...
Run 19: $0=40, $1=0.4, $repetition=0
Run 20: $0=40, $1=0.6, $repetition=0
Run 21: $0=50, $1=0.2, $repetition=0
Run 22: $0=50, $1=0.4, $repetition=0
Run 23: $0=50, $1=0.6, $repetition=0
</pre>
<p>
Any of these runs can be executed by passing the <tt>-r &lt;runnumber&gt;</tt>
option to Cmdenv. So, the task is now to run the simulation program 24
times, with <tt>-r</tt> running from 0 through 23:

<pre class="commandline">
$ aloha -u Cmdenv -c AlohaStudy -r 0
$ aloha -u Cmdenv -c AlohaStudy -r 1
$ aloha -u Cmdenv -c AlohaStudy -r 2
...
$ aloha -u Cmdenv -c AlohaStudy -r 23
</pre>
<p>
This batch can be executed either from the OMNeT++ IDE (where you are
prompted to pick an executable and an ini file, choose the configuration
from a list, and just click Run), or using a little command-line
batch execution tool (<tt>opp_runall</tt>) supplied with OMNeT++.

<p>Actually, it is also possible to get Cmdenv execute all runs in one go,
by simply omitting the <tt>-r</tt> option.

<pre class="commandline">
$ aloha -u Cmdenv -c AlohaStudy

OMNeT++ Discrete Event Simulation
Preparing for running configuration AlohaStudy, run #0...
...
Preparing for running configuration AlohaStudy, run #1...
...
...
Preparing for running configuration AlohaStudy, run #23...
</pre>
<p>

<p>However, this approach is not recommended, because it is more
susceptible to C++ programming errors in the model. (For example, if
any of the runs crashes, the whole batch stops -- which may
not be what the user wants.)

<p>
<h3><a name="sec:config-sim:iterations"/>10.4.1 Iterations<a class="headerlink" href="#sec:config-sim:iterations" title="Permalink to this headline"></a></h3>

<p>Let us return to the example ini file in the previous section:

<pre class="inifile">
[Config AlohaStudy]
*.numHosts = ${1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${0.2, 0.4, 0.6}s )
</pre>
<p>
The <tt>${...}</tt> syntax specifies an iteration. It is sort of a macro: at
each run, the whole <tt>${...}</tt> string is textually replaced with the
current iteration value. The values to iterate over do not need to be
numbers (although the <i>"a..b"</i> and <i>"a..b step c"</i> forms
only work on numbers), and the substitution takes place even inside
string constants. So, the following examples are all valid (note that
textual substitution is used):

<p><pre class="verbatim">
*.param = 1 + ${1e-6, 1/3, sin(0.5)}
    ==&gt; *.param = 1 + 1e-6
        *.param = 1 + 1/3
        *.param = 1 + sin(0.5)
*.greeting = "We will simulate ${1,2,5} host(s)."
    ==&gt; *.greeting = "We will simulate 1 host(s)."
        *.greeting = "We will simulate 2 host(s)."
        *.greeting = "We will simulate 5 host(s)."
</pre>

<p>To write a literal <tt>${..}</tt> inside a string constant, quote
the left brace with a backslash: <tt>$\{..}</tt>.

<p><ul class="note"><b>NOTE</b><br>
Inside <tt>${..}</tt>, the values are separated with commas. However,
not every comma is taken as a value separator because the parser
tries to be smart about what is meant. Commas inside (nested) parentheses,
brackets or curly braces are ignored so that <tt>${uniform(0,3)}</tt> is
parsed as one value and not as <tt>uniform(0</tt> plus <tt>3)</tt>. Commas, curly
braces and other charachers inside double-quoted string literals are
also ignored, so <tt>${"Hello, world"}</tt> yields a single <tt>"Hello, world"</tt>
string and not <tt>"Hello</tt> plus <tt>world"</tt>. It is assumed that string literals
use backslash as an escape characher, like in C/C++ and NED.

<p>To include a literal comma or close-brace inside a value, one needs
to escape it with a backslash: <tt>${foo\,bar\}baz}</tt>
will parse as a single value, <tt>foo,bar}baz</tt>. Backslashes themselves must be doubled.
As the above examples illustrate, the parser removes one level of backslashes,
except inside string literals where they are left intact.
</ul>

<p>
<h3><a name="sec:config-sim:named-iteration-variables"/>10.4.2 Named Iteration Variables<a class="headerlink" href="#sec:config-sim:named-iteration-variables" title="Permalink to this headline"></a></h3>

<p>One can assign names to iteration variables, which has the advantage
that meaningful names will be displayed in the Cmdenv output instead
of <tt>$0</tt> and <tt>$1</tt>, and also lets one reference iteration
variables at other places in the ini file. The syntax is
<tt>${&lt;varname&gt;=&lt;iteration&gt;}</tt>, and variables can be referred to simply as
<tt>${&lt;varname&gt;}</tt>:

<pre class="inifile">
[Config Aloha]
*.numHosts = ${N=1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${mean=0.2, 0.4, 0.6}s )
**.greeting = "There are ${N} hosts"
</pre>
<p>
The scope of the variable name is the section that defines it, plus
sections based on that section (via <b><tt>extends</tt></b>).

<p><h4><a name="sec:config-sim:referencing-other-iteration-variables"/>10.4.2.1 Referencing Other Iteration Variables<a class="headerlink" href="#sec:config-sim:referencing-other-iteration-variables" title="Permalink to this headline"></a></h4>

<p>Iterations may refer to other iteration variables, using the dollar syntax
(<tt>$var</tt>) or the dollar-brace syntax (<tt>${var}</tt>).

<p>This feature makes it possible to have loops where the inner iteration range
depends on the outer one. An example:

<pre class="inifile">
**.foo = ${i=1..10}  # outer loop
**.bar = ${j=1..$i}  # inner loop depends on $i
</pre>
<p>
When needed, the default top-down nesting order of iteration loops is
modified (loops are reordered) to ensure that expressions only refer to
more outer loop variables, but not to inner ones. When this is not
possible, an error is generated with the &#8220;circular dependency&#8221; message.

<p>For instance, in the following example the loops will be nested in
<i>k - i - j</i> order, <i>k</i> being the outermost and <i>j</i>
the innermost loop:

<pre class="inifile">
**.foo = ${i=0..$k}   # must be inner to $k
**.bar = ${j=$i..$k}  # must be inner to both $i and $k
**.baz = ${k=1..10}   # may be the outermost loop
</pre>
<p>
And the next example will stop with an error because there is no &#8220;good&#8221;
ordering:

<pre class="inifile">
**.foo = ${i=0..$j}
**.bar = ${j=0..$k}
**.baz = ${k=0..$i} # --&gt; error: circular references
</pre>
<p>
Variables are substituted <i>textually</i>, and the result is normally
<i>not</i> evaluated as an arithmetic expression.  The result of the
substitution is only evaluated where needed, namely in the three arguments
of iteration ranges (<i>from</i>, <i>to</i>, <i>step</i>), and in the
value of the <b><tt>constraint</tt></b> configuration option.

<p>To illustrate textual substitution, consider the following contorted example:

<pre class="inifile">
**.foo = ${i=1..3, 1s+, -}001s
</pre>
<p>
Here, the <tt>foo</tt> NED parameter will receiving the following values in subsequent runs:
<tt>1001s</tt>, <tt>2001s</tt>, <tt>3001s</tt>, <tt>1s+001s</tt>, <tt>-001s</tt>.

<p><ul class="caution"><b>CAUTION</b><br>
Due to textual substitution, variables in arithmetic expressions should be
protected with parentheses -- just like in C/C++ function-style macros.
Consider the following example:

<pre class="inifile">
**.foo = ${i=10}
**.bar = ${j=$i+5}
**.baz = ${k=2*$j}   # bogus! $j should be written as ($j)
constraint = $i+50 &lt; 2*$j  # ditto: should use ($i) and ($j)
</pre>
<p>
Here, the <tt>baz</tt> parameter will receive the string <tt>2*10+5</tt> after
the substitutions and hence evaluate to <i>25</i> instead of the correct
<i>2*(10+5)=30</i>; the constraint expression is similarly wrong. Mind the parens!
</ul>

<p>Substitution also works inside string constants within iterations (<tt>${..}</tt>).

<pre class="inifile">
**.foo = "${i=Jo}"  # -&gt; Jo
**.bar = ${"Hi $i", "Hi ${i}hn"}  # -&gt; Hi Jo /John
</pre>
<p>
However, outside iterations the plain dollar syntax is not understood, only
the dollar-brace syntax is:

<pre class="inifile">
**.foo = "${i=Day}"
**.baz = "Good $i"     # -&gt; remains "Good $i"
**.baz = "Good ${i}"   # -&gt; becomes "Good Day"
</pre>
<p>
<ul class="rationale"><b>Rationale</b><br>
The text substitution model was chosen for greater flexibility as well as
the ability to produce more consistent semantics. The advantages outweigh
the inconvenience of having to parenthesize variable references in
arithmetic expressions.
</ul>

<p>
<h3><a name="sec:config-sim:parallel-iteration"/>10.4.3 Parallel Iteration<a class="headerlink" href="#sec:config-sim:parallel-iteration" title="Permalink to this headline"></a></h3>

<p>The body of an iteration may end in an exclamation mark followed by the
name of another iteration variable. This syntax denotes a <i>parallel
iteration</i>. A parallel iteration does not define a loop of its own, but
rather, the sequence is advanced in lockstep with the variable after the
&#8220;!&#8221;. In other words, the &#8220;!&#8221; syntax chooses the <i>kth</i> value from
the iteration, where <i>k</i> is the position (iteration count) of the
iteration variable after the &#8220;!&#8221;.

<p>An example:

<pre class="inifile">
**.plan =     ${plan= "A", "B", "C", "D"}
**.numHosts = ${hosts= 10,  20,  50, 100 ! plan}
**.load =     ${load= 0.2, 0.3, 0.3, 0.4 ! plan}
</pre>
<p>
In the above example, the only loop is defined by the first line, the <tt>plan</tt>
variable. The other two iterations, <tt>hosts</tt> and <tt>load</tt> just follow it;
for the first value of <tt>plan</tt> the first values of <tt>host</tt> and <tt>load</tt>
are selected, and so on.

<p>

<p><h3><a name="sec:config-sim:predefined-variables"/>10.4.4 Predefined Variables, Run ID<a class="headerlink" href="#sec:config-sim:predefined-variables" title="Permalink to this headline"></a></h3>

<p>There are a number of predefined variables: <tt>${configname}</tt> and
<tt>${runnumber}</tt> with the obvious meanings; <tt>${network}</tt> is the
name of the network that is simulated; <tt>${processid}</tt> and
<tt>${datetime}</tt> expand to the OS process id of the simulation and the
time it was started; and there are some more: <tt>${runid},</tt>
<tt>${iterationvars}</tt> and <tt>${repetition}.</tt>

<p><tt>${runid}</tt> holds the <i>run ID</i>. When a simulation is run, a
run ID is assigned that uniquely identifies that instance of running the
simulation: every subsequent run of the same simulation will produce a different
run ID. The run ID is generated as the concatenation of several variables like
<tt>${configname},</tt> <tt>${runnumber},</tt> <tt>${datetime}</tt> and
<tt>${processid}.</tt> This yields an identifier that is unique &#8220;enough&#8221;
for all practical purposes, yet it is meaningful for humans. The run ID is
recorded into result files written during the simulation, and can be used
to match vectors and scalars written by the same simulation run.

<p>
<h3><a name="sec:config-sim:constraint-expression"/>10.4.5 Constraint Expression<a class="headerlink" href="#sec:config-sim:constraint-expression" title="Permalink to this headline"></a></h3>

<p>In cases when not all combinations of the iteration variables make sense
or need to be simulated, it is possible to specify an additional
constraint expression. This expression is interpreted as a conditional
(an "if" statement) within the innermost
loop, and it must evaluate to <tt>true</tt> for
the variable combination to generate a run. The expression should be
given with the <b><tt>constraint</tt></b> configuration option. An example:

<pre class="inifile">
*.numNodes = ${n=10..100 step 10}
**.numNeighbors = ${m=2..10 step 2}
constraint = ($m) &lt;= sqrt($n)  # note: parens needed due to textual substitution
</pre>
<p>
The expression syntax supports most C language operators including boolean,
conditional and binary shift operations, and most <tt>&lt;math.h&gt;</tt> functions;
data types are boolean, double and string. The expression must evaluate to
a boolean.

<p><ul class="note"><b>NOTE</b><br>
Remember that variables are substituted textually into the expresssion, so
they must be protected with parentheses to preserve evaluation order.
</ul>

<p>
<h3><a name="sec:config-sim:repeating-runs-with-different-seeds"/>10.4.6 Repeating Runs with Different Seeds<a class="headerlink" href="#sec:config-sim:repeating-runs-with-different-seeds" title="Permalink to this headline"></a></h3>

<p>It is directly supported to perform several runs with the same
parameters but different random number seeds. There are two
configuration options related to this: <b><tt>repeat</tt></b> and <b><tt>seed-set</tt></b>.
The first one simply specifies how many times a run needs to be repeated. For
example,

<pre class="inifile">
repeat = 10
</pre>
<p>
causes every combination of iteration variables to be repeated 10 times,
and the <tt>${repetition}</tt> predefined variable holds the loop counter.
Indeed, <tt>repeat=10</tt> is equivalent to adding <tt>${repetition=0..9}</tt>
to the ini file. The <tt>${repetition}</tt> loop always becomes the innermost loop.

<p>The <b><tt>seed-set</tt></b> configuration key affects seed selection. Every
simulation uses one or more random number generators (as configured by
the <b><tt>num-rngs</tt></b> key), for which the simulation kernel can automatically
generate seeds. The first simulation run may use one set of seeds (seed
set 0), the second run may use a second set (seed set 1), and so on.
Each set contains as many seeds as there are RNGs configured. All
automatic seeds generate random number sequences that are far apart in
the RNG's cycle, so they will never overlap during
simulations.

<p><ul class="note"><b>NOTE</b><br>
Mersenne Twister, the default RNG of OMNeT++ has a cycle length of
<i>2<sup>19937</sup></i>, which is more than enough for any conceivable purpose.
</ul>

<p>The <b><tt>seed-set</tt></b> key tells the simulation kernel which seed set to use.
It can be set to a concrete number (such as <tt>seed-set=0</tt>), but it
usually does not make sense as it would cause every simulation to run
with exactly the same seeds. It is more practical to set it to either
<tt>${runnumber}</tt> or to <tt>${repetition}</tt>. The default setting is
<tt>${runnumber}</tt>:

<pre class="inifile">
seed-set = ${runnumber}   # this is the default
</pre>
<p>
This causes every simulation run to execute with a unique seed set. The
second option is:

<pre class="inifile">
seed-set = ${repetition}
</pre>
<p>
where all <tt>$repetition=0</tt> runs will use the same seeds (seed set 0), all
<tt>$repetition=1</tt> runs use another seed set, <tt>$repetition=2</tt> a third seed
set, etc.

<p>To perform runs with manually selected seed sets, one needs to define an
iteration for the <b><tt>seed-set</tt></b> key:

<pre class="inifile">
seed-set = ${5,6,8..11}
</pre>
<p>
In this case, the <b><tt>repeat</tt></b> key should be left out, as <b><tt>seed-set</tt></b>
already defines an iteration and there is no need for an extra loop.

<p>It is of course also possible to manually specify individual seeds for
simulations. The parallel iteration feature is very convenient here:

<pre class="inifile">
repeat = 4
seed-1-mt = ${53542, 45732, 47853, 33434 ! repetition}
seed-2-mt = ${75335, 35463, 24674, 56673 ! repetition}
seed-3-mt = ${34542, 67563, 96433, 23567 ! repetition}
</pre>
<p>
The meaning of the above is this: in the first repetition, the first
column of seeds is chosen, for the second repetition, the second
column, etc. The "!" syntax chooses the
<i>kth</i> value from the iteration, where <i>k</i> is the position
(iteration count) of the iteration variable after the
"!". Thus, the above example is equivalent to the following:

<pre class="inifile">
# no repeat= line!
seed-1-mt = ${seed1 = 53542, 45732, 47853, 33434}
seed-2-mt = ${        75335, 35463, 24674, 56673 ! seed1}
seed-3-mt = ${        34542, 67563, 96433, 23567 ! seed1}
</pre>
<p>
That is, the iterators of <tt>seed-2-mt</tt> and <tt>seed-3-mt</tt> are advanced
in lockstep with the <tt>seed1</tt> iteration.

<p>

<p><h3><a name="sec:config-sim:experiment-measurement-replication"/>10.4.7 Experiment-Measurement-Replication<a class="headerlink" href="#sec:config-sim:experiment-measurement-replication" title="Permalink to this headline"></a></h3>

<p>We have introduced three concepts that are useful for organizing
simulation results generated by batch executions or several batches of
executions.

<p>During a simulation study, a user prepares several
<i>experiments</i>. The purpose of an experiment is to find out the
answer to questions like <i>"how does the number of
nodes affect response times in the network?"</i> For an
experiment, several <i>measurements</i> are performed on the
simulation model, and each measurement runs the simulation model with a
different set of parameters. To eliminate the bias introduced by the
particular random number stream used for the simulation, several
<i>replications</i> of every measurement are run with different
random number seeds, and the results are averaged.

<p>OMNeT++ result analysis tools can take advantage of the <i>experiment</i>,
<i>measurement</i> and <i>replication</i> labels recorded into result
files, and display simulation runs and recorded results accordingly on
the user interface.

<p>These labels can be explicitly specified in the ini file using the
<b><tt>experiment-label</tt></b>, <b><tt>measurement-label</tt></b> and <b><tt>replication-label</tt></b>
config options. If they are missing, the default is the following:

<pre class="inifile">
experiment-label = "${configname}"
measurement-label = "${iterationvars}"
replication-label = "#${repetition},seed-set=&lt;seedset&gt;"
</pre>
<p>
That is, the default experiment label is the configuration name; the
measurement label is concatenated from the iteration variables; and the
replication label contains the repeat loop variable and seed-set.
Thus, for our first example the <i>experiment-measurement-replication</i>
tree would look like this:

<p><pre class="verbatim">
"PureAloha"<i><i>--experiment</i></i>
  $N=1,$mean=0.2<i><i> -- measurement</i></i>
    #0, seed-set=0<i><i> -- replication</i></i>
    #1, seed-set=1
    #2, seed-set=2
    #3, seed-set=3
    #4, seed-set=4
  $N=1,$mean=0.4
    #0, seed-set=5
    #1, seed-set=6
    ...
    #4, seed-set=9
  $N=1,$mean=0.6
    #0, seed-set=10
    #1, seed-set=11
    ...
    #4, seed-set=14
  $N=2,$mean=0.2
    ...
  $N=2,$mean=0.4
    ...
    ...
</pre>

<p>The <i>experiment-measurement-replication</i> labels should be enough to
reproduce the same simulation results, given of course that the ini
files and the model (NED files and C++ code) haven't changed.

<p>Every instance of running the simulation gets a unique run ID. We can
illustrate this by listing the corresponding run IDs under each
repetition in the tree. For example:

<p><pre class="verbatim">
"PureAloha"
  $N=1,$mean=0.2
    #0, seed-set=0
      <i>PureAloha-0-20070704-11:38:21-3241</i>
      <i>PureAloha-0-20070704-11:53:47-3884</i>
      <i>PureAloha-0-20070704-16:50:44-4612</i>
    #1, seed-set=1
      <i>PureAloha-1-20070704-16:50:55-4613</i>
    #2, seed-set=2
      <i>PureAloha-2-20070704-11:55:23-3892</i>
      <i>PureAloha-2-20070704-16:51:17-4615</i>
      ...
</pre>

<p>The tree shows that ("PureAloha", "$N=1,$mean=0.2", "#0, seed-set=0")
was run three times. The results produced
by these three executions should be identical, unless, for example,
some parameter was modified in the ini file, or a bug got fixed in the
C++ code.

<p>The default way of generating the <i>experiment/measurement/replication</i>
labels is useful and sufficient for the majority of simulation studies.
However, it can be customized if needed. For example, here is a way to join two
configurations into one experiment:

<pre class="inifile">
[Config PureAloha_Part1]
experiment-label = "PureAloha"
...
[Config PureAloha_Part2]
experiment-label = "PureAloha"
...
</pre>
<p>
Measurement and replication labels can be customized in a similar way,
making use of named iteration variables, <tt>${repetition}</tt>,
<tt>${runnumber}</tt> and other predefined variables. One possible benefit is
to customize the generated measurement and replication labels. For
example:

<pre class="inifile">
[Config PureAloha_Part1]
measurement = "${N} hosts, exponential(${mean}) packet generation interval"
</pre>
<p>
One should be careful with the above technique though, because if some
iteration variables are left out of the measurement labels, runs with
all values of those variables will be grouped together to the same
replications.

<p>
<h2><a name="sec:config-sim:rng-config"/>10.5 Configuring the Random Number Generators<a class="headerlink" href="#sec:config-sim:rng-config" title="Permalink to this headline"></a></h2>

<p>The random number architecture of OMNeT++ was already outlined
in section <a href="#sec:sim-lib:random-number-generators">[7.3]</a>. Here
we'll cover the configuration of RNGs in <tt>omnetpp.ini</tt>.

<p><h3><a name="sec:config-sim:number-of-rngs"/>10.5.1 Number of RNGs<a class="headerlink" href="#sec:config-sim:number-of-rngs" title="Permalink to this headline"></a></h3>

<p>The <b><tt>num-rngs</tt></b> configuration option sets the number of
random number generator instances (i.e. random number streams)
available for the simulation model (see <a href="#sec:sim-lib:random-number-generators">[7.3]</a>).
Referencing an RNG number greater or equal to this number
(from a simple module or NED file) will cause a runtime error.

<p>
<h3><a name="sec:config-sim:rng-choice"/>10.5.2 RNG Choice<a class="headerlink" href="#sec:config-sim:rng-choice" title="Permalink to this headline"></a></h3>

<p>The <b><tt>rng-class</tt></b> configuration option sets the random number
generator class to be used. It defaults to <tt>"<a href="../api/classomnetpp_1_1cMersenneTwister.html">cMersenneTwister</a>"</tt>,
the Mersenne Twister RNG. Other available classes are <tt>"<a href="../api/classomnetpp_1_1cLCG32.html">cLCG32</a>"</tt>
(the "legacy" RNG of OMNeT++ 2.3 and earlier versions, with a cycle length
of <i>2<sup>31</sup>-2</i>), and <tt>"cAkaroaRNG"</tt> (Akaroa's random number generator,
see section <a href="#sec:run-sim:akaroa">[11.21]</a>).

<p><h3><a name="sec:config-sim:rng-mapping"/>10.5.3 RNG Mapping<a class="headerlink" href="#sec:config-sim:rng-mapping" title="Permalink to this headline"></a></h3>

<p>The RNG numbers used in simple modules may be arbitrarily mapped to the
actual random number streams (actual RNG instances) from <tt>omnetpp.ini</tt>.
The mapping allows for great flexibility in RNG usage and random number
streams configuration -- even for simulation models which were not
written with RNG awareness.

<p>RNG mapping may be specified in <tt>omnetpp.ini</tt>. The syntax of
configuration entries is the following.

<pre class="inifile">
[General]
&lt;modulepath&gt;.rng-N = M  # where N,M are numeric, M &lt; num-rngs
</pre>
<p>
This maps module-local RNG N to physical RNG M. The following
example maps all <tt>gen</tt> module's default (N=0) RNG to physical RNG 1,
and all <tt>noisychannel</tt> module's default (N=0) RNG to physical RNG 2.

<pre class="inifile">
[General]
num-rngs = 3
**.gen[*].rng-0 = 1
**.noisychannel[*].rng-0 = 2
</pre>
<p>
The value also allows expressions, including those containing <b><tt>index</tt></b>,
<b><tt>parentIndex</tt></b>, and <b><tt>ancestorIndex(level)</tt></b>. This allows things
like assigning a separate RNG to each element of a module vector.

<p>This mapping allows variance reduction techniques to be applied to
OMNeT++ models, without any model change or recompilation.

<p>
<h3><a name="sec:config-sim:automatic-seed-selection"/>10.5.4 Automatic Seed Selection<a class="headerlink" href="#sec:config-sim:automatic-seed-selection" title="Permalink to this headline"></a></h3>

<p>Automatic seed selection is used for an RNG if one does not explicitly
specify seeds in <tt>omnetpp.ini</tt>. Automatic and manual seed selection can
co-exist; for a particular simulation, some RNGs can be configured
manually, and some automatically.

<p>The automatic seed selection mechanism uses two inputs: the <i>run number</i>
 and the <i>RNG number</i>. For the same run number and RNG number,
OMNeT++ always selects the same seed value for any simulation model.
If the run number or the RNG number is different, OMNeT++ does its best
to choose different seeds which are also sufficiently separated in the RNG's sequence
so that the generated sequences don't overlap.

<p>The run number can be specified either in in <tt>omnetpp.ini</tt> (e.g. via the
<b><tt>cmdenv-runs-to-execute</tt></b> option) or on the command line:

<pre class="commandline">
$ ./mysim -r 1
$ ./mysim -r 2
$ ./mysim -r 3
</pre>
<p>
For the <tt><a href="../api/classomnetpp_1_1cMersenneTwister.html">cMersenneTwister</a></tt> random number generator, selecting seeds
so that the generated sequences don't overlap is easy,
due to the extremely long sequence of the RNG.
The RNG is initialized from the 32-bit seed value <i>seed = runNumber*numRngs + rngNumber</i>.
(This implies that simulation runs participating in the study should have
the same number of RNGs set).
    <br><ul><font size=-1>[While (to our knowledge) no one has proven that the seeds 0,1,2,...
    are well apart in the sequence, this is probably true, due to the extremely
    long sequence of MT. The author would however be interested in papers
    published about seed selection for MT.]</font></ul>

<p>For the <tt><a href="../api/classomnetpp_1_1cLCG32.html">cLCG32</a></tt> random number generator, the situation is more difficult,
because the range of this RNG is rather short (<i>2<sup>31</sup>-1</i>, about 2 billion).
For this RNG, OMNeT++ uses a table of 256 pre-generated seeds, equally spaced
in the RNG's sequence. Index into the table is calculated with the
<i>runNumber*numRngs + rngNumber</i> formula. Care should be taken that
one doesn't exceed 256 with the index, or it will wrap and the
same seeds will be used again. It is best not to use the <tt><a href="../api/classomnetpp_1_1cLCG32.html">cLCG32</a></tt>
at all -- <tt><a href="../api/classomnetpp_1_1cMersenneTwister.html">cMersenneTwister</a></tt> is superior in every respect.

<p>
<h3><a name="sec:config-sim:manual-seed-configuration"/>10.5.5 Manual Seed Configuration<a class="headerlink" href="#sec:config-sim:manual-seed-configuration" title="Permalink to this headline"></a></h3>

<p>In some cases, one may want to manually configure seed values. The
motivation for doing so may be the use of variance reduction techniques, or
the intention to reuse the same seeds for several simulation runs.

<p>To manually set seeds for the Mersenne Twister RNG, use the <tt>seed-</tt><i>k</i><tt>-mt</tt>
option, where <i>k</i> is the RNG index. An example:

<pre class="inifile">
[General]
num-rngs = 3
seed-0-mt = 12
seed-1-mt = 9
seed-2-mt = 7
</pre>
<p>
<a name="sec:config-sim:seedtool"></a>

<p>For the now obsolete <a href="../api/classomnetpp_1_1cLCG32.html">cLCG32</a> RNG, the name of the corresponding option is
<tt>seed-</tt><i>k</i><tt>-lcg32</tt>.

<p><h2><a name="sec:config-sim:logging"/>10.6 Logging<a class="headerlink" href="#sec:config-sim:logging" title="Permalink to this headline"></a></h2>

<p>The OMNeT++ logging infrastructure provides a few configuration options that
affect what is written to the log output. It supports configuring multiple
filters: global compile-time, global runtime, and per-component runtime log
level filters. For a log statement to actually produce output, it must pass
each filter simulatenously. In addition, one can also specify a log prefix
format string which determines the context information that is written before
each log line. In the following sections, we look how to configure logging.

<p><h3><a name="sec:config-sim:compile-time-log-filtering"/>10.6.1 Compile-Time Filtering<a class="headerlink" href="#sec:config-sim:compile-time-log-filtering" title="Permalink to this headline"></a></h3>

<p>The <tt>COMPILETIME_LOGLEVEL</tt> macro determines which log statements
are compiled into the executable. Any log statment which uses a log level below
the specified compile-time log level is omitted. In other words, no matter how
the runtime log levels are configured, such log statements are not even executed.
This is mainly useful to avoid the performance penalty paid for log statements
which are not needed.

<pre class="cpp">
#define COMPILETIME_LOGLEVEL LOGLEVEL_INFO
EV_INFO &lt;&lt; "Packet received successfully" &lt;&lt; endl;
EV_DEBUG &lt;&lt; "CRC check successful" &lt;&lt; endl;
</pre>
<p>
In the above example, the output of the second log statement is omitted:

<pre class="filelisting">
[INFO] Packet received successfully
</pre>
<p>
If simulation performance is critical, and if there are lots of log statements
in the code, it might be useful to omit all log statements from the executable.
This can be very simply achieved by putting the following macro into effect for
the compilation of all source files.

<pre class="cpp">
#define COMPILETIME_LOGLEVEL LOGLEVEL_OFF
</pre>
<p>
On the other hand, if there's some hard to track down issue, it might be useful
to just do the opposite. Compiling with the lowest log level ensures that the
log output contains as much information as possible.

<pre class="cpp">
#define COMPILETIME_LOGLEVEL LOGLEVEL_TRACE
</pre>
<p>
By default, the <tt>COMPILETIME_LOGLEVEL</tt> macro is set to
<tt>LOGLEVEL_TRACE</tt> if the code is compiled in debug mode (<tt>NDEBUG</tt> is
not set). However, it is set to <tt>LOGLEVEL_DETAIL</tt> if the code is compiled
in release mode (<tt>NDEBUG</tt> is set).

<p>In fact, the <tt>COMPILETIME_LOG_PREDICATE</tt> macro is the most generic compile
time predicate that determines which log statements are compiled into the executable.
Mostly, there's no need to redefine this macro, but it can be useful sometimes.
For example, one can do compile-time filtering for log categories by redefining
this macro. By default, the <tt>COMPILETIME_LOG_PREDICATE</tt> macro is defined
as follows:

<pre class="cpp">
#define COMPILETIME_LOG_PREDICATE(object, loglevel, category) \
        (loglevel &gt;= COMPILETIME_LOGLEVEL)
</pre>
<p>
<h3><a name="sec:config-sim:runtime-log-filtering"/>10.6.2 Runtime Filtering<a class="headerlink" href="#sec:config-sim:runtime-log-filtering" title="Permalink to this headline"></a></h3>

<p>The <tt><a href="../api/classomnetpp_1_1cLog.html">cLog</a>::logLevel</tt> variable restricts during runtime which log statements
produce output. By default, the global runtime log level doesn't filter logging,
it is set to <tt>LOGLEVEL_TRACE</tt>. Although due to its global nature it's not
really modular, nevertheless it's still allowed to change the value of this
variable. It is mainly used in interactive user interfaces to implement efficient
global filtering, but it may also be useful for various debugging purposes.

<p>In addition to the global variable, there's also a per-component runtime log
level which only restricts the output of a particular component of the
simulation. By default, the runtime log level of all components are set to
<tt>LOGLEVEL_TRACE</tt>. Programmatically, these log levels can be retrieved
with <tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a>::getLogLevel()</tt> and changed with
<tt><a href="../api/classomnetpp_1_1cComponent.html">cComponent</a>::setLogLevel()</tt>.

<p>In general, any log statment which uses a log level below the specified global
runtime log level, or below the specified per-component runtime log level, is
omitted. If the log statement appears in a module source, then the module's
per-component runtime log level is checked. In any other C++ code, the context
module's per-component runtime log level is checked.

<p>In fact, the <tt><a href="../api/classomnetpp_1_1cLog.html">cLog</a>::noncomponentLogPredicate</tt> and the <tt><a href="../api/classomnetpp_1_1cLog.html">cLog</a>::componentLogPredicate</tt>
are the most generic runtime predicates that determines which log statements are
executed. Mostly, there's no need to redefine these predicates, but it can be
useful sometimes. For example, one can do runtime filtering for log categories
by redefining them. To cite a real example, the <tt><a href="../api/classomnetpp_1_1cLog.html">cLog</a>::componentLogPredicate</tt> function
contains the following runtime checks:

<pre class="cpp">
return statementLogLevel &gt;= <a href="../api/classomnetpp_1_1cLog.html">cLog</a>::loglevel &&
       statementLogLevel &gt;= sourceComponent-&gt;getLogLevel() &&
       getEnvir()-&gt;isLoggingEnabled(); // for express mode
</pre>
<p>
<h3><a name="sec:config-sim:log-prefix-format"/>10.6.3 Log Prefix Format<a class="headerlink" href="#sec:config-sim:log-prefix-format" title="Permalink to this headline"></a></h3>

<p>The log prefix format is a string which determines the log prefix that is written
before each log line. The format string contains constant parts interleaved with
special format directives. The latter always start with the <tt>%</tt> character
followed by another character that identifies the format directive. Constant
parts are simply written to the output, while format directives are substituted
at runtime with the corresponding data that is captured by the log statement.

<p>The following is the list of predefined log prefix format directives. They are
organized into groups based on what kind of information they provide.

<p>Log statement related format directives:
<ul>
  <li> <tt>%l</tt> log level name
  <li> <tt>%c</tt> log category
</ul>

<p>Current simulation state related format directives:
<ul>
  <li> <tt>%e</tt> current event number
  <li> <tt>%t</tt> current simulation time
  <li> <tt>%g</tt> current fingerprint if fingerprint verification is enabled in the configuration, otherwise empty
  <li> <tt>%v</tt> current message or event name
  <li> <tt>%a</tt> current message or event class name
  <li> <tt>%n</tt> module name of current event
  <li> <tt>%m</tt> module path of current event
  <li> <tt>%o</tt> module class name of current event
  <li> <tt>%s</tt> simple NED type name of module of current event
  <li> <tt>%q</tt> fully qualified NED type name of module of current event
  <li> <tt>%N</tt> context component name
  <li> <tt>%M</tt> context component path
  <li> <tt>%O</tt> context component class name
  <li> <tt>%S</tt> context component NED type simple name
  <li> <tt>%Q</tt> context component NED type fully qualified name
</ul>

<p>Simulation run related format directives:
<ul>
  <li> <tt>%G</tt> config name
  <li> <tt>%R</tt> run number
  <li> <tt>%X</tt> network module class name
  <li> <tt>%Y</tt> network module NED type simple name
  <li> <tt>%Z</tt> network module NED type fully qualified name
</ul>

<p>C++ source related (where the log statement is) format directives:
<ul>
  <li> <tt>%p</tt> source object pointer
  <li> <tt>%b</tt> source object name
  <li> <tt>%d</tt> source object path
  <li> <tt>%z</tt> source class name
  <li> <tt>%u</tt> source function name
  <li> <tt>%x</tt> source component NED type simple name
  <li> <tt>%y</tt> source component NED type fully qualified
  <li> <tt>%f</tt> source file name
  <li> <tt>%i</tt> source line number
</ul>

<p>Operating system related format directives:
<ul>
  <li> <tt>%w</tt> user time in seconds
  <li> <tt>%W</tt> human readable wall time
  <li> <tt>%H</tt> host name
  <li> <tt>%I</tt> process id
</ul>

<p>Compound field format directives:
<ul>
  <li> <tt>%E</tt> event object (class name, name)
  <li> <tt>%U</tt> module of current event (NED type, full path)
  <li> <tt>%C</tt> context component (NED type, full path)
  <li> <tt>%K</tt> context component, if different from current module (NED type, full path)
  <li> <tt>%J</tt> source component or object (NED type or class, full path or pointer)
  <li> <tt>%L</tt> source component or object, if different from context component (NED type or class, full path or pointer)
</ul>

<p>Padding format directives:
<ul>
  <li> <tt>%[0-9]+</tt> add spaces until specified column
  <li> <tt>%|</tt> adaptive tabstop: add padding until longest prefix seen so far
  <li> <tt>%&gt;</tt> function call depth times 2-space indentation (see Enter_Method, Enter_Method_Silent)
  <li> <tt>%&lt;</tt> remove preceding whitespace characters
</ul>

<p>Conditional format directives:
<ul>
  <li> <tt>%?</tt> ignore the following constant part if the preceding directive didn't print anything (useful for separators)
</ul>

<p>Escaping the % character:
<ul>
  <li> <tt>%%</tt> one % character
</ul>

<p><h3><a name="sec:config-sim:configuring-cmdenv"/>10.6.4 Configuring Cmdenv<a class="headerlink" href="#sec:config-sim:configuring-cmdenv" title="Permalink to this headline"></a></h3>

<p>In Cmdenv, logging can be configured using <tt>omnetpp.ini</tt> configuration
options. The configured settings remain in effect during the whole simulation run
unless overridden programatically.

<p><ul>
  <li> <b><tt>cmdenv-output-file</tt></b> redirects standard output to a file
  <li> <b><tt>cmdenv-log-prefix</tt></b> determines the log prefix of each line
  <li> <b><tt>&lt;object-full-path&gt;.cmdenv-log-level</tt></b> restricts output on a per-component basis
</ul>

<p>By default, the log is written to the standard output but it can be redirected to
a file. The output can be completely disabled from <tt>omnetpp.ini</tt>, so
that it doesn't slow down simulation when it is not needed. The per-component
runtime log level option must match the full path of the targeted component. The
supported values for this configuration option are the following:

<p><ul>
  <li> <tt>off</tt> completely disables log output
  <li> <tt>fatal</tt> omits log output below <tt>LOGLEVEL_FATAL</tt>
  <li> <tt>error</tt> omits log output below <tt>LOGLEVEL_ERROR</tt>
  <li> <tt>warn</tt> omits log output below <tt>LOGLEVEL_WARN</tt>
  <li> <tt>info</tt> omits log output below <tt>LOGLEVEL_INFO</tt>
  <li> <tt>detail</tt> omits log output below <tt>LOGLEVEL_DETAIL</tt>
  <li> <tt>debug</tt> omits log output below <tt>LOGLEVEL_DEBUG</tt>
  <li> <tt>trace</tt> completely enables log output
</ul>

<p>By default, the log prefix format is set to <tt>"[%l]\t"</tt>. The
default setting is intentionally quite simple to avoid cluttered standard output,
it produces similar log output:

<pre class="filelisting">
[INFO]  Packet received successfully
[DEBUG] CRC check successful
</pre>
<p>
The log messages are aligned vertically because there's a <tt>TAB</tt> character
in the format string. Setting the log prefix format to an empty string disables
writing a log prefix altogether. Finally, here is a more detailed format string:
<tt>"[%l]\t%C for %E: %|"</tt>, it produces similar output:

<pre class="filelisting">
[INFO]  (IPv4)host.ip for (ICMPMessage)ping0:     Pending (IPv4Datagram)ping0
[INFO]  (ARP)host.arp for (ICMPMessage)ping0:     Starting ARP resolution
[DEBUG] (ARP)host.arp for (ICMPMessage)ping0:     Sending (ARPPacket)arpREQ
[INFO]  (Mac)host.wlan.mac for (ARPPacket)arpREQ: Enqueing (ARPPacket)arpREQ
</pre>
<p>
In express mode, for performance reasons, log output is disabled during the whole
simulation. However, during the simulation finish stage, logging is automatically
re-enabled to allow writing statistical and other results to the log. One can
completely disable all logging by adding following configuration option at the
beginning of <tt>omnetpp.ini</tt>:

<pre class="inifile">
[General]
**.cmdenv-log-level = off
</pre>
<p>
Finally, the following is a more complex example that sets the per-component
runtime log levels for all PHY components to <tt>LOGLEVEL_WARN</tt>, except for
all MAC modules where it is set to <tt>LOGLEVEL_DEBUG</tt>, and for all other
modules it is set <tt>LOGLEVEL_OFF</tt>.

<pre class="inifile">
[General]
**.phy.cmdenv-log-level = warn
**.mac.cmdenv-log-level = debug
**.cmdenv-log-level = off
</pre>
<p>
<h3><a name="sec:config-sim:configuring-tkenv-and-qtenv"/>10.6.5 Configuring Tkenv and Qtenv<a class="headerlink" href="#sec:config-sim:configuring-tkenv-and-qtenv" title="Permalink to this headline"></a></h3>

<p>The graphical user interfaces, Tkenv and Qtenv, provide their own configuration
dialogs where the user can configure logging. These dialogs offer setting the
global runtime log level and the log prefix format string. The per-component
runtime log levels can be set from the context menu of components. As in Cmdenv,
it's also possible to set the log levels to <tt>off</tt>, effectively disabling
logging globally or for specific components only.

<p>In contrast to Cmdenv, setting the runtime log levels is possible even if the
simulation is already running. This feature allows continuous control over the
level of detail of what is written to the log output. For obvious reasons,
changing the log levels has no effect back in time, so already written log
content in the log windows will not change.

<p>By default, the log prefix format is set to <tt>"%l %C: "</tt>, it produces
similar log output:

<pre class="filelisting">
INFO  Network.server.wlan[0].mac: Packet received successfully
DEBUG Network.server.wlan[0].mac: CRC check successful
</pre>
<p>


<hr class='pgbr'><h1><a name="cha:run-sim"/>11 Running Simulations<a class="headerlink" href="#cha:run-sim" title="Permalink to this headline"></a></h1>

<p><h2><a name="cha:run-sim:intro"/>11.1 Introduction<a class="headerlink" href="#cha:run-sim:intro" title="Permalink to this headline"></a></h2>

<p>This chapter describes how to run simulations. It covers basic usage, user
interfaces, running simulation campaigns, and many other topics.

<p><h2><a name="sec:run-sim:running"/>11.2 Simulation Executables vs Libraries<a class="headerlink" href="#sec:run-sim:running" title="Permalink to this headline"></a></h2>

<p>As we have seen in the <i>Build</i> chapter, simulations may be compiled to an
executable or to a shared library. When the build output is an executable,
it can be run directly. For example, the Fifo example simulation can be
run with the following command: 

<pre class="commandline">
$ ./fifo
</pre>
<p>
Simulations compiled to a shared library can be run using the <tt>opp_run</tt>
program. For example, if we compiled the Fifo simulation to a
shared library on Linux, the build output would be a <tt>libfifo.so</tt> file that
could be run with the following command:

<pre class="commandline">
$ opp_run -l fifo
</pre>
<p>
The <tt>-l</tt> option tells <tt>opp_run</tt> to load the given shared library.
The <tt>-l</tt> option will be covered in detail in section
<a href="#sec:run-sim:loading-extra-libraries">[11.9]</a>.
 
<p><ul class="note"><b>NOTE</b><br>
Normal simulation executables like the above <tt>fifo</tt> are also capable of
loading additional shared libraries in the same way. What's more, <tt>opp_run</tt> is
actually nothing else but a specially-named simulation executable with no model
code in it.
</ul>

<p>
<h2><a name="sec:run-sim:command-line-options"/>11.3 Command-Line Options<a class="headerlink" href="#sec:run-sim:command-line-options" title="Permalink to this headline"></a></h2>

<p>The above commands illustrate just the simplest case. Usually you will
need to add extra command-line options, for example to specify what ini file(s)
to use, which configuration to run, which user interface to activate, where
to load NED files from, and so on. The rest of this chapter will cover
these options. 

<p>To get a complete list of command line options accepted by simulations, 
run the <tt>opp_run</tt> program (or any other simulation executable) with
<tt>-h</tt>:

<pre class="commandline">
$ opp_run -h
</pre>
<p>
Or: 
<pre class="commandline">
$ ./fifo -h
</pre>

<p>
<h2><a name="sec:run-sim:config-options-on-cmdline"/>11.4 Configuration Options on the Command Line<a class="headerlink" href="#sec:run-sim:config-options-on-cmdline" title="Permalink to this headline"></a></h2>

<p>Configuration options can also be specified on the command line, not only in
ini files. To do so, prefix the option name with a double dash, and append the
value with an equal sign. Be sure not to have spaces around the equal sign. If
the value contains spaces or shell metacharacters, you'll need to protect the
value (or the whole option) with quotes or apostrophes.

<p>Example:

<pre class="commandline">
$ ./fifo --debug-on-errors=true
</pre>
<p>  
In case an option is specified both on the command line and in an ini file, 
the command line takes precedence.
  
<p>To get the list of all possible configuration options, use the <tt>-h config</tt>
option. (The additional <tt>-s</tt> option below just makes the output less
verbose.)

<pre class="commandline">
$ opp_run -s -h config
Supported configuration options:
  **.bin-recording=&lt;bool&gt;, default:true; per-object setting
  check-signals=&lt;bool&gt;, default:true; per-run setting
  cmdenv-autoflush=&lt;bool&gt;, default:false; per-run setting
  cmdenv-config-name=&lt;string&gt;; global setting
  ...
</pre>
<p>
To see the option descriptions as well, use <tt>-h configdetails</tt>.
    
<pre class="commandline">
$ opp_run -h configdetails
</pre>
<p>

<p><h2><a name="sec:run-sim:specifying-ini-files"/>11.5 Specifying Ini Files<a class="headerlink" href="#sec:run-sim:specifying-ini-files" title="Permalink to this headline"></a></h2>

<p>The default ini file is <tt>omnetpp.ini</tt>, and is
loaded if no other ini file is given on the command line.

<p>Ini files can be specified both as plain arguments and with the <tt>-f</tt>
option, so the following two commands are equivalent:

<pre class="commandline">
$ ./fifo experiment.ini common.ini
$ ./fifo -f experiment.ini -f common.ini
</pre>
<p>
Multiple ini files can be given, and their contents will be merged. This
allows for partitioning the configuration into separate files, for example
to simulation options, module parameters and result recording options.

<p>
<h2><a name="sec:run-sim:specifying-ned-path"/>11.6 Specifying the NED Path<a class="headerlink" href="#sec:run-sim:specifying-ned-path" title="Permalink to this headline"></a></h2>

<p>NED files are loaded from directories listed on the NED path. More precisely,
they are loaded from the listed directories and their whole subdirectory trees.
Directories are separated with a semicolon (<tt>;</tt>).

<p><ul class="note"><b>NOTE</b><br>
Semicolon is used as separator on both Unix and Windows.
</ul>

<p>The NED path can be specified in several ways:
<ul>
  <li> using the <tt>NEDPATH</tt> environment variable
  <li> using the <tt>-n</tt> command-line option
  <li> in ini files, with the <b><tt>ned-path</tt></b> configuration option
</ul>

<p>NED path resolution rules are as follows:

<p><ol>
  <li> OMNeT++ checks for NED path specified on the command line with the <tt>-n</tt> option
  <li> If not found on the command line, it checks for the <tt>NEDPATH</tt> environment variable
  <li> The <b><tt>ned-path</tt></b> option value from the ini file is appended to the result of the above steps
  <li> If the result is still empty, it falls back to "." (the current directory)
</ol>

<p>
<h2><a name="sec:run-sim:selecting-user-interface"/>11.7 Selecting a User Interface<a class="headerlink" href="#sec:run-sim:selecting-user-interface" title="Permalink to this headline"></a></h2>

<p>OMNeT++ simulations can be run under different user interfaces a.k.a. runtime
environments. Currently the following user interfaces are supported:

<p><ul>
  <li> Qtenv: Qt-based graphical user interface, available since OMNeT++ 5.0
  <li> Tkenv: the traditional, Tcl/Tk-based graphical user interface
  <li> Cmdenv: command-line user interface for batch execution
</ul>

<p>You would typically test and debug your simulation under Tkenv or Qtenv,
then run actual simulation experiments from the command line or shell
script, using Cmdenv. Tkenv and Qtenv are also better suited for
educational and demonstration purposes.

<p>User interfaces are provided in the form of libraries that can be linked with
statically, dynamically, or can be loaded at runtime.<br><ul><font size=-1>[Via the <tt>-l</tt>
option, see section <a href="#sec:run-sim:loading-extra-libraries">[11.9]</a>]</font></ul> When several user
interface libraries are available in a simulation program, the user can select
via command-line or ini file options which one to use. In the absence of such an
option, the one with the highest priority will be started. Currently priorities
are set such that Qtenv has the highest priority, then Tkenv, and finally
Cmdenv. By default, simulations are linked with all available user interfaces,
but this can be controlled via <tt>opp_makemake</tt> options or in the OMNeT++
global build configuration as well. The user interfaces available in a
simulation program can be listed by running it the <tt>-h userinterfaces</tt>
option.

<p>You can explicitly select a user interface on the command line with the <tt>-u</tt>
option (specify <tt>Qtenv</tt>, <tt>Tkenv</tt> or <tt>Cmdenv</tt> as its argument), or by
adding the <b><tt>user-interface</tt></b> option to the configuration. If both
the config option and the command line option are present, the command line option
takes precedence.

<p>Since the graphical interfaces are the default (have higher priority), the most
common use of the <tt>-u</tt> option is to select Cmdenv, e.g. for batch execution.
The following example performs all runs of the Aloha example simulation using
Cmdenv:

<pre class="commandline">
$ ./aloha -c PureAlohaExperiment -u Cmdenv
</pre>
<p>

<p><h2><a name="sec:run-sim:selecting-configuration-and-runs"/>11.8 Selecting Configurations and Runs<a class="headerlink" href="#sec:run-sim:selecting-configuration-and-runs" title="Permalink to this headline"></a></h2>

<p>All user interfaces support the <tt>-c &lt;configname&gt;</tt> and <tt>-r &lt;runfilter&gt;</tt>
options for selecting which simulation(s) to run. 

<p>The <tt>-c</tt> option expects the name of an ini file configuration
as an argument. The <tt>-r</tt> option may be needed when the configuration
expands to multiple simulation runs. That is the case when the
configuration defines a <i>parameter study</i> (see section
<a href="#sec:config-sim:parameter-studies">[10.4]</a>), or when it contains 
a <b><tt>repeat</tt></b> configuration option that prescribes 
multiple repetitions with different RNG seeds (see section 
<a href="#sec:config-sim:repeating-runs-with-different-seeds">[10.4.6]</a>).
The <tt>-r</tt> option can then be used to select a subset of all runs (or one
specific run, for that matter). A missing <tt>-r</tt> option selects all runs in
the given configuration.

<p>It depends on the particular user interface how it interprets the 
<tt>-c</tt> and <tt>-r</tt> options. Cmdenv performs all selected simulation runs
(optionally stopping after the first one that finishes with an error).
GUI interfaces like Qtenv and Tkenv may use this information to fill the
run selection dialog (or to set up the simulation automatically if there is
only one matching run.)

<p>
<h3><a name="sec:run-sim:selecting-configuration-and-runs:syntax"/>11.8.1 Run Filter Syntax<a class="headerlink" href="#sec:run-sim:selecting-configuration-and-runs:syntax" title="Permalink to this headline"></a></h3>

<p>The run filter accepts two syntaxes: a comma-separated list of run numbers or
run number ranges (for example <tt>1,2,5-10</tt>), or an arithmetic expression.
The arithmetic expression is similar to constraint expressions in the
configuration (see section <a href="#sec:config-sim:constraint-expression">[10.4.5]</a>).
It may refer to iteration variables and to the repeat counter with the dollar
syntax: <tt>$numHosts</tt>, <tt>$repetition</tt>. An example: <tt>$numHosts&gt;10
&amp;&amp; $mean==2</tt>. 

<p>Note that due to the presence of the dollar sign (and spaces), the expression
should be protected against shell expansion, e.g. using apostrophes:

<pre class="commandline">
$ ./aloha -c PureAlohaExperiment -r '$numHosts&gt;10 && $mean&lt;2'
</pre>
<p>
Or, with double quotes:

<pre class="commandline">
$ ./aloha -c PureAlohaExperiment -r "\$numHosts&gt;10 && \$mean&lt;2"
</pre>
<p>

<p><h3><a name="sec:run-sim:selecting-configuration-and-runs:queryoption"/>11.8.2 The Query Option<a class="headerlink" href="#sec:run-sim:selecting-configuration-and-runs:queryoption" title="Permalink to this headline"></a></h3>

<p>The <tt>-q</tt> (query) option complements <tt>-c</tt> and <tt>-r</tt>, and
allows one to list the runs matched by the run filter.
<tt>-q</tt> expects an argument that defines the format and verbosity of the
output. Several formats are available: <tt>numruns</tt>, <tt>runnumbers</tt>, 
<tt>runs</tt>, <tt>rundetails</tt>, <tt>runconfig</tt>. Use <tt>opp_run -h</tt> to get a
complete list.

<p><tt>-q runs</tt> prints one line of information with the iteration variables 
about each run that the run filter matches. An example:

<pre class="commandline">
$ ./aloha -s -c PureAlohaExperiment -r '$numHosts&gt;10 && $mean&lt;2' -q runs
Run 14: $numHosts=15, $mean=1, $repetition=0
Run 15: $numHosts=15, $mean=1, $repetition=1
Run 28: $numHosts=20, $mean=1, $repetition=0
Run 29: $numHosts=20, $mean=1, $repetition=1
</pre>
<p>
The <tt>-s</tt> option just makes the output less verbose.

<p>If you need more information, use <tt>-q rundetails</tt> or <tt>-q runconfig</tt>.
<tt>rundetails</tt> is like <tt>numruns</tt>, but it also prints the values of the
iteration variables and a summary of the configuration (the expanded
values of configuration entries that contain iteration variables)
for each matching run:

<pre class="commandline">
$ ./aloha -s -c PureAlohaExperiment -r '$numHosts&gt;10 && $mean&lt;2' -q rundetails
Run 14: $numHosts=15, $mean=1, $repetition=0
    Aloha.numHosts = 15
    Aloha.host[*].iaTime = exponential(1s)

Run 15: $numHosts=15, $mean=1, $repetition=1
    Aloha.numHosts = 15
    Aloha.host[*].iaTime = exponential(1s)
...
</pre>
<p>
The <tt>numruns</tt> and <tt>runnumbers</tt> formats are mainly intended for use in
scripts. They just print the number of matching runs and the plain run number
list, respectively.

<pre class="commandline">
$ ./aloha -s -c PureAlohaExperiment -r '$numHosts&gt;10 && $mean&lt;2' -q numruns
4
$ ./aloha -s -c PureAlohaExperiment -r '$numHosts&gt;10 && $mean&lt;2' -q runnumbers
 14 15 28 29
</pre>
<p>
The <tt>-q</tt> option encapsulates some unrelated functionality, as well:
<tt>-q sectioninheritance</tt> ignores <tt>-r</tt>, and prints the inheritance chain
of the  inifile sections (the inheritance graph after linearization) for the
configuration denoted by <tt>-c</tt>.

<p>
<h2><a name="sec:run-sim:loading-extra-libraries"/>11.9 Loading Extra Libraries<a class="headerlink" href="#sec:run-sim:loading-extra-libraries" title="Permalink to this headline"></a></h2>

<p>OMNeT++ allows you to load shared libraries at runtime. These shared libraries
may contain model code (e.g. simple module implementation classes), 
dynamically registered classes that extend the simulator's functionality (for
example NED functions, result filters/recorders, figures types, schedulers,
output vector/scalar writers, Qtenv inspectors, or even custom user interfaces),
or other code.

<p><ul class="hint"><b>HINT</b><br>
Building shared libraries and loading them dynamically has several
advantages over static linking or building executables. Advantages include
modularity, reduced build times (versus statically linking a huge executable),
and better reuse (being able to use the same library in several projects without
change). 
</ul>

<p>Libraries can be specified with the <tt>-l &lt;libraryname&gt;</tt> command line option
(there can be several <tt>-l</tt>'s on the command line), or with the <b><tt>load-libs</tt></b> 
configuration option. The values from the command line and the config file will
be merged.

<p>The prefix and suffix from the library name can be omitted (the extensions
<tt>.dll</tt>, <tt>.so</tt>, <tt>.dylib</tt>, and also the common <tt>lib</tt> prefix
on Unix systems). This means that you can specify the library name in a
platform independent way: if you specify <tt>-l foo</tt>, then OMNeT++ will
look for <tt>foo.dll</tt>, <tt>libfoo.dll</tt>, <tt>libfoo.so</tt> or <tt>libfoo.dylib</tt>,
depending on the platform.

<p>OMNeT++ will use the <tt>dlopen()</tt> or <tt>LoadLibrary()</tt> system call to
load the library. To ensure that the system call finds the file, either
specify the library name with a full path (pre- and postfixes of the library 
file name still can be omitted), or adjust the shared library path environment
variable of your OS: <tt>PATH</tt> on Windows, <tt>LD_LIBRARY_PATH</tt> on Unix,
and <tt>DYLD_LIBRARY_PATH</tt> on Mac OS X.

<p><ul class="note"><b>NOTE</b><br>
  Runtime loading is not needed if your executable or shared lib was
  already linked against the library in question. In that case,
  the platform's dynamic loader will automatically load the library.
</ul>

<p>
<h2><a name="sec:run-sim:stopping-condition"/>11.10 Stopping Condition<a class="headerlink" href="#sec:run-sim:stopping-condition" title="Permalink to this headline"></a></h2>

<p>The most common way of specifying when to finish the simulation is to set a
time limit. There are several time limits that can be set with the following
configuration options:

<p><ul>
  <li> <b><tt>sim-time-limit</tt></b> : Limits how long the simulation should run (in simulation time)
  <li> <b><tt>cpu-time-limit</tt></b> : Limits how much CPU time the simulation can use
  <li> <b><tt>real-time-limit</tt></b> : Limits how long the simulation can run (in real time)
</ul>

<p><ul class="note"><b>NOTE</b><br>
<b><tt>cpu-time-limit</tt></b> and <b><tt>real-time-limit</tt></b> may look
similar, but in practice, you'll almost always need <b><tt>cpu-time-limit</tt></b> of
the two. Its alternative, <b><tt>real-time-limit</tt></b> simply measures elapsed
time (wall-clock interval), so it does not imply how many cycles the CPU has
spent on running your simulation. On a heavily overloaded system where the CPU
is shared among a number of computationally intensive jobs,
<b><tt>real-time-limit</tt></b> may stop your simulation much too early.
</ul>

<p>An example:

<pre class="commandline">
$ ./fifo --sim-time-limit=500s
</pre>
<p>
If several time limits are set together, the simulation will stop when the first
one is hit.

<p>
If needed, the simulation may also be stopped programmatically, for example when
results of a (steady-state) simulation have reached the desired accuracy. 
This can be done by calling the <tt>endSimulation()</tt> method.

<p>
<h2><a name="sec:run-sim:output-control"/>11.11 Controlling the Output<a class="headerlink" href="#sec:run-sim:output-control" title="Permalink to this headline"></a></h2>

<p>The following options can be used to enable/disable the creation of various
output files during simulation.

<p><ul>
  <li> <b><tt>record-eventlog</tt></b> : Turns on the recording of the simulator
        events into an event log file. The resulting <tt>.elog</tt> file can be
        analyzed later in the IDE with the Sequence Chart tool.
       
<p>  <li> <b><tt>scalar-recording</tt></b> : This option is originally a
        per-object setting, intended for selectively turning on or off the
        recording of certain scalar results. However, when it is specified
        globally to turn off all scalars, no output scalar file
        (<tt>.sca</tt>) will be created either.
        
<p>  <li> <b><tt>vector-recording</tt></b> : Similar to <b><tt>scalar-recording</tt></b>,
        this option can be used to turn off creating an output vector file 
        (<tt>.vec</tt>).

<p>  <li> <b><tt>cmdenv-redirect-output</tt></b> : This is a Cmdenv-specific option,
        only mentioned here for completeness. It tells Cmdenv to save its
        standard output to files, one file per run. This option is mainly
        helpful when running simulation batches.

<p></ul>

<p>These configuration options, like any other, can be specified both in ini
files and on the command line. An example:

<pre class="commandline">
$ ./fifo --record-eventlog=true --scalar-recording=false --vector-recording=false
</pre>
<p> 
 
<p><h2><a name="sec:run-sim:debugging-support"/>11.12 Debugging<a class="headerlink" href="#sec:run-sim:debugging-support" title="Permalink to this headline"></a></h2>

<p>Debugging is a task that comes up often during model development. The following
configuration options are related to C++ debugging:

<p><ul>
  <li> <b><tt>debug-on-errors</tt></b> : If the runtime detects any error, it will
        trigger a debugger trap (programmatic breakpoint) so you will be able
        to check the location and the context of the problem in your debugger.
        This option does not start a debugger, the simulation must already
        have been launched under a debugger.

<p>  <li> <b><tt>debugger-attach-on-error</tt></b> : Controls just-in-time debugging.
        When this option is enabled and an error occurs during simulation, the
        simulation program will launch an external debugger, and have it
        attached to the simulation process. Related configuration options are
        <b><tt>debugger-attach-on-startup</tt></b>, <b><tt>debugger-attach-command</tt></b>
        and <b><tt>debugger-attach-wait-time</tt></b>.

<p>        <ul class="hint"><b>HINT</b><br>
        Just-in-time debugging is useful when trying to debug a rarely occurring
        crash in a large simulation batch, or in cases where the simulation is
        started from a script or another program that cannot be easily modified
        to start the simulation in a debugger.
        </ul>

<p></ul>

<p>An example that launches the simulation under the <tt>gdb</tt> debugger: 

<pre class="commandline">
$ gdb --args ./aloha --debug-on-errors=true
</pre>
<p>

<p><h2><a name="sec:run-sim:leaked-messages"/>11.13 Debugging Leaked Messages<a class="headerlink" href="#sec:run-sim:leaked-messages" title="Permalink to this headline"></a></h2>

<p>The most common cause of memory leaks in OMNeT++ simulations is forgetting to
delete messages. When this happens, the simulation process will continually grow
in size as the simulation progresses, and when left to run long enough, it will
eventually cause an out-of-memory condition. 

<p>Luckily, this problem is easy to indentify, as all user interfaces display the
number of message objects currently in the system. Take a look at the following
example Cmdenv output: 

<pre class="commandline">
...
** Event #1908736   t=58914.051870113485   Elapsed: 2.000s (0m 02s)
     Speed:     ev/sec=954368   simsec/sec=29457   ev/simsec=32.3987
     Messages:  created: 561611   `\tbf{present:\ 21}`   in FES: 34
** Event #3433472   t=106067.401570204991   Elapsed: 4.000s (0m 04s)
     Speed:     ev/sec=762368   simsec/sec=23576.7   ev/simsec=32.3357
     Messages:  created: 1010142   `\tbf{present:\ 354}`   in FES: 27
** Event #5338880   t=165025.763387178965   Elapsed: 6.000s (0m 06s)
     Speed:     ev/sec=952704   simsec/sec=29479.2   ev/simsec=32.3179
     Messages:  created: 1570675   `\tbf{present:\ 596}`   in FES: 21
** Event #6850304   t=211763.433233042017   Elapsed: 8.000s (0m 08s)
     Speed:     ev/sec=755712   simsec/sec=23368.8   ev/simsec=32.3385
     Messages:  created: 2015318   `\tbf{present:\ 732}`   in FES: 38
** Event #8753920   t=270587.781554343184   Elapsed: 10.000s (0m 10s)
     Speed:     ev/sec=951808   simsec/sec=29412.2   ev/simsec=32.361
     Messages:  created: 2575634   `\tbf{present:\ 937}`   in FES: 32 
** Event #10270208   t=317495.244698246477   Elapsed: 12.000s (0m 12s)
     Speed:     ev/sec=758144   simsec/sec=23453.7   ev/simsec=32.3251
     Messages:  created: 3021646   `\tbf{present:\ 1213}`   in FES: 20
...
</pre>
<p>
The interesting parts are in bold font. The steadily increasing numbers are an
indication that the simulation model, i.e. one or more modules in it, are
missing some <tt>delete msg</tt> calls. It is best to use Qtenv or Tkenv to narrow
down the issue to specific modules and/or message types.

<p>Qtenv and Tkenv are also able to display the number of messages currently
in the simulation. The numbers are displayed on the status bar. If you find that
the number of messages is steadily increasing, you need to find where the
message objects are located. This can be done with the help of the
<i>Find/Inspect Objects</i> dialog. 

<p>If the number of messages is stable, it is still possible that the simulation
is leaking other <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>-based objects; they can also be found
using the <i>Find/Inspect Objects</i> dialog. 

<p>If the simulation is leaking non-OMNeT++ objects (i.e. not something derived
from <tt><a href="../api/classomnetpp_1_1cObject.html">cObject</a></tt>) or other memory blocks, Cmdenv, Tkenv or Qtenv cannot
help in tracking down the issue.

<p>
<h2><a name="sec:run-sim:memory-leaks-and-crashes"/>11.14 Debugging Other Memory Problems<a class="headerlink" href="#sec:run-sim:memory-leaks-and-crashes" title="Permalink to this headline"></a></h2>

<p>Technically, memory leaks are only a subset of problems associated with memory
allocations, i.e. the usage of <tt>new</tt> and <tt>delete</tt> in C++. 

<p><ul>
   <li> <i>memory leaks,</i> that is, forgetting to delete objects
     or memory blocks no longer used, usually just prevents the user from
     being able to run the simulation program long enough;
   <li> <i>dereferencing dangling pointers</i>, i.e. accessing
    an already deleted object or memory block (or trying to delete one
    for a second time) usually results in a crash;
   <li> <i>heap corruption</i>, caused by e.g. writing past the end of
   an allocated array, usually also results in a crash.
</ul>

<p>
There are specialized tools that can help in tracking down memory allocation
problems (memory leak, double-deletion, referencing deleted blocks, etc). Some
of these tools are listed below.

<p><ul>
  <li> <i>Valgrind</i>, our primary recommendation, is a CPU emulator and
        memory debugger tool for Linux.
  <li> Other memory debugger libraries/tools include <i>MemProf</i>,
        <i>MPatrol</i>, <i>dmalloc</i> and <i>ElectricFence</i>.
        Most of these tools support tracking down memory leaks as well as
        detecting double deletion, writing past the end of an allocated block,
        etc.
  <li> There are several commercial offerings as well, e.g. <i>Purify</i>
        and <i>Insure++</i>.
</ul>

<p>
<h2><a name="sec:run-sim:profiling"/>11.15 Profiling<a class="headerlink" href="#sec:run-sim:profiling" title="Permalink to this headline"></a></h2>

<p>When a simulation runs correctly but is too slow, you might want to
<i>profile</i> it. Profiling basically means collecting runtime
information about how much time is spent at various parts of the
program, in order to find places where optimizing the code would have 
the most impact.

<p>However, there are a few other options you can try before resorting to profiling
and optimizing. First, verify that it  is the simulation itself that is slow.
Make sure features like eventlog recording is not accidentally turned on. Run
the simulation under Cmdenv to eliminate any possible overhead from Qtenv/Tkenv.
If you must run the simulation under Qtenv/Tkenv, you can still gain speed by
disabling animation features, closing all inspectors, hiding UI elements like
the timeline, and so on.

<p>Also, compile your code in release mode (with <tt>make MODE=release</tt>, see
<a href="#sec:build-sim-progs:debug-and-release-builds">[9.2.3]</a>) instead of debug. That
can make a huge difference, especially with heavily templated code.

<p><ul class="hint"><b>HINT</b><br>
If you decide to optimize the program, we recommend that you don't skip the
profiling step. Even for experienced programmers, a profiling session is often
full of surprises, and CPU time is spent at other places than one would
expect.
</ul>

<p>Some profiling software:

<p><ul>
  <li> <b>Debuggers</b>. A very simple but frequently useful way of profiling is
        stopping the program in a debugger from time to time, and looking at the
        stack trace before resuming (manual statistical profiling). If
        the program always stops at the same place in the code, that might be
        the bottleneck.
  <li> <b>Valgrind/KCachegrind</b>. KCachegrind is a graphical visualizer
        for traces generated by <i>valgrind</i> and its <i>callgrind</i>
        tool in Linux. These tools are free and open source software,
        packaged with most Linux distributions. 
  <li> There are also commercial C/C++ profilers like RotateRight's Zoom.
        Profilers are also part of larger packages like PurifyPlus or
        Parasoft Insure++.
</ul>

<p>
<h2><a name="sec:run-sim:checkpointing"/>11.16 Checkpointing<a class="headerlink" href="#sec:run-sim:checkpointing" title="Permalink to this headline"></a></h2>

<p>Debugging long-running simulations can be challenging, because one often needs
to run the simulation for a long time just to get to the point of failure and
be able to start debugging. 

<p>Checkpointing can facilitate debugging such errors. It is a technique that
basically consists of saving a snapshot of the application's state, and being
able to resume execution from there, even multiple times. 
OMNeT++ itself contains no checkpointing functionality, but it is available via
external tools. It depends on the tool whether it is able to restore GUI windows
(usually not.) 

<p>Some checkpointing software that is available on Linux:

<p><ul>
  <li> Berkeley Lab Checkpoint/Restart (BLCR)
  <li> DMTCP (Distributed MultiThreaded Checkpointing)
  <li> CRIU is a user space checkpoint lib
  <li> Docker and the underlying technology contain a checkpoint and restore mechanism
</ul>

<p>
<h2><a name="sec:run-sim:cmdenv"/>11.17 Using Cmdenv<a class="headerlink" href="#sec:run-sim:cmdenv" title="Permalink to this headline"></a></h2>

<p>Cmdenv<!--Cmdenv--> is a lightweight, command line user interface that
compiles and runs on all platforms. Cmdenv is designed primarily for batch
execution.

<p>Cmdenv simply executes some or all simulation runs that are described
in the configuration file. The runs to be executed can be
passed via command-line arguments or configuration options. 

<p>Cmdenv runs simulations in the same process. This means that e.g. if one
simulation run writes a global variable, subsequent runs will also
see the change. This is one reason why global variables in models are
strongly discouraged.

<p><h3><a name="sec:run-sim:cmdenv:sample-output"/>11.17.1 Sample Output<a class="headerlink" href="#sec:run-sim:cmdenv:sample-output" title="Permalink to this headline"></a></h3>

<p>When you run the Fifo example under Cmdenv, you should see
something like this:

<pre class="commandline">
$ ./fifo -u Cmdenv -c Fifo1

OMNeT++ Discrete Event Simulation  (C) 1992-2017 Andras Varga, OpenSim Ltd.
Version: 5.0, edition: Academic Public License -- NOT FOR COMMERCIAL USE
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv...
Loading NED files from .: 5

Preparing for running configuration Fifo1, run #0...
Scenario: $repetition=0
Assigned runID=Fifo1-0-20090104-12:23:25-5792
Setting up network 'FifoNet'...
Initializing...
Initializing module FifoNet, stage 0
Initializing module FifoNet.gen, stage 0
Initializing module FifoNet.fifo, stage 0
Initializing module FifoNet.sink, stage 0

Running simulation...
** Event #1   t=0   Elapsed: 0.000s (0m 00s)  0% completed
     Speed:     ev/sec=0   simsec/sec=0   ev/simsec=0
     Messages:  created: 2   present: 2   in FES: 1
** Event #232448   t=11719.051014922336   Elapsed: 2.003s (0m 02s)  3% completed
     Speed:     ev/sec=116050   simsec/sec=5850.75   ev/simsec=19.8351
     Messages:  created: 58114   present: 3   in FES: 2
...
** Event #7206882   t=360000.52066583684   Elapsed: 78.282s (1m 18s)  100% completed
     Speed:     ev/sec=118860   simsec/sec=5911.9   ev/simsec=20.1053
     Messages:  created: 1801723   present: 3   in FES: 2

&lt;!&gt; Simulation time limit reached -- simulation stopped.

Calling finish() at end of Run #0...
End.
</pre>
<p>
As Cmdenv runs the simulation, it periodically prints the sequence number
of the current event, the simulation time, the elapsed (real) time,
and the performance of the simulation (how many events are processed per
second; the first two values are 0 because there wasn't enough data
for it to calculate yet). At the end of the simulation, the <tt>finish()</tt>
methods of the simple modules are run, and the outputs from them are displayed.

<p>
<h3><a name="sec:run-sim:cmdenv-config-options"/>11.17.2 Selecting Runs, Batch Operation<a class="headerlink" href="#sec:run-sim:cmdenv-config-options" title="Permalink to this headline"></a></h3>

<p>The most important command-line options for Cmdenv are <tt>-c</tt> and
<tt>-r</tt> for selecting which simulations to perform. (They were described
in section <a href="#sec:run-sim:selecting-configuration-and-runs">[11.8]</a>.) They also have
their equivalent configuration options that can be written in files as well:
<b><tt>cmdenv-config-name</tt></b> and <b><tt>cmdenv-runs-to-execute</tt></b>.

<p>Another configuration option, <b><tt>cmdenv-stop-batch-on-error</tt></b> controls
Cmdenv's behavior when performing multiple runs: it determines
whether Cmdenv should stop after the first run that finishes with an
error. By default, it does.

<p>When performing multiple runs, Cmdenv prints run statistics at the end. Example
output:

<pre class="filelisting">
$ ./aloha -c PureAlohaExperiment -u Cmdenv
...
Run statistics: total 42, successful 30, errors 1, skipped 11
</pre>
<p>

<p><h3><a name="sec:run-sim:cmdenv:express-mode"/>11.17.3 Express Mode<a class="headerlink" href="#sec:run-sim:cmdenv:express-mode" title="Permalink to this headline"></a></h3>

<p>Cmdenv can execute simulations in two modes:

<p><ul>
    <li> <b>Normal</b> (non-express) mode is for debugging; detailed information
        will be written to the standard output (event banners, module log,
        etc).
    <li> <b>Express</b> mode can be used for long simulation runs; only
        periodical status updates are displayed about the progress of the
        simulation.
</ul>

<p>The default mode is Express. To turn off Express mode, specify <tt>false</tt> for
the <b><tt>cmdenv-express-mode</tt></b> configuration option:
 
<pre class="commandline">
$ ./fifo -u Cmdenv -c Fifo1 --cmdenv-express-mode=false
</pre>
<p>
There are several other options that also affect Express-mode and Normal
mode behavior:

<p><ul>
  <li> Express: <b><tt>cmdenv-performance-display</tt></b>, <b><tt>cmdenv-status-frequency</tt></b>
  <li> Normal: <b><tt>cmdenv-event-banners</tt></b>, <b><tt>cmdenv-event-banner-details</tt></b>,
        <b><tt>cmdenv-log-level</tt></b>, <b><tt>cmdenv-log-prefix</tt></b>, etc.
</ul>

<p>See Appendix <a href="#cha:config-options">[26]</a> for more information about these options.

<p><h4><a name="sec:run-sim:cmdenv:express-mode:output"/>11.17.3.1 Interpreting Express-Mode Output<a class="headerlink" href="#sec:run-sim:cmdenv:express-mode:output" title="Permalink to this headline"></a></h4>

<p>When the simulation is running in Express mode with detailed
performance display enabled (<tt>cmdenv-performance-display=true</tt>), Cmdenv
periodically outputs a three-line status report about the progress of the simulation.
The output looks like this:

<pre class="commandline">
...
** Event #250000   t=123.74354 ( 2m  3s)    Elapsed: 0m 12s
     Speed:     ev/sec=19731.6   simsec/sec=9.80713   ev/simsec=2011.97
     Messages:  created: 55532   present: 6553   in FES: 8
** Event #300000   t=148.55496 ( 2m 28s)    Elapsed: 0m 15s
     Speed:     ev/sec=19584.8   simsec/sec=9.64698   ev/simsec=2030.15
     Messages:  created: 66605   present: 7815   in FES: 7
...
</pre>
<p>
The first line of the status display (beginning with <tt>**</tt>)
contains:

<p><ul>
   <li> how many events have been processed so far
   <li> the current simulation time (t), and
   <li> the elapsed time (wall clock time) since the beginning of the simulation run.
</ul>

<p>The second line displays simulation performance metrics:

<p><ul>
   <li> <tt>ev/sec</tt> indicates <i>performance</i>: how many events are
     processed in one real-time second.  On one hand it depends on your hardware
     (faster CPUs process more events per second), and on the other hand
     it depends on the complexity (amount of calculations) associated
     with processing one event. For example, protocol simulations tend to require
     more processing per event than e.g. queueing networks, thus the latter
     produce higher ev/sec values. In any case, this value is largely
     independent of the size of your model, i.e. the number of modules in it.
   <li> <tt>simsec/sec</tt> shows <i>relative speed</i> of the simulation, that
     is, how fast the simulation is progressing compared to real time, how many
     simulated seconds can be done in one real second. This value virtually depends
     on everything: on the hardware, on the size of the simulation model,
     on the complexity of events, and the average simulation time between events as well.
   <li> <tt>ev/simsec</tt> is the <i>event density</i>: how many events are
     there per simulated second. Event density only depends on the simulation model,
     regardless of the hardware used to simulate it: in a high-speed
     optical network simulation you will have very high values (<i>10<sup>9</sup></i>), 
     while in a call center simulation this value is probably well
     under 1. It also depends on the size of your model: if you double the
     number of modules in your model, you can expect the event density to
     double, too.
</ul>

<p>The third line displays the number of messages, and it is important
because it may indicate the &#8220;health&#8221; of your simulation.

<p><ul>
   <li><tt>Created</tt>: total number of message objects created since the
     beginning of the simulation run. This does not mean that this many message
     object actually exist, because some (many) of them may have been deleted
     since then. It also does not mean that <i>you</i> created all those
     messages -- the simulation kernel also creates messages for its own use
     (e.g. to implement <tt>wait()</tt> in an <tt>activity()</tt> simple module).
   <li><tt>Present</tt>: the number of message objects currently present
     in the simulation model, that is, the number of messages created (see above)
     minus the number of messages already deleted. This number includes
     the messages in the FES<!--FES-->.
   <li><tt>In FES</tt>: the number of messages currently scheduled in the
     Future Event Set.
</ul>

<p>
The second value, the number of messages present, is more useful than
perhaps one would initially think. It can be an indicator of the &#8220;health&#8221; of the simulation;
if it is growing steadily, then either you have a memory leak and losing
messages (which indicates a programming error), or the network you simulate is
overloaded and queues are steadily filling up (which might indicate wrong input
parameters).

<p>Of course, if the number of messages does not increase, it does not mean
that you do <i>not</i> have a memory leak (other memory leaks are also
possible). Nevertheless the value is still useful, because by far the
most common way of leaking memory in a simulation is by not deleting messages.

<p><h3><a name="sec:run-sim:cmdenv:other-options"/>11.17.4 Other Options<a class="headerlink" href="#sec:run-sim:cmdenv:other-options" title="Permalink to this headline"></a></h3>

<p>Cmdenv has more configuration options than mentioned in this section; see 
the options beginning with <tt>cmdenv-</tt> in Appendix <a href="#cha:config-options">[26]</a>
for the complete list.

<p>
<h2><a name="sec:run-sim:qtenv"/>11.18 The Qtenv Graphical User Interface<a class="headerlink" href="#sec:run-sim:qtenv" title="Permalink to this headline"></a></h2>

<p>Qtenv<!--Qtenv--> is a runtime simulation GUI. Qtenv supports
interactive simulation execution, animation, tracing and debugging.
Qtenv is recommended in the development stage of a simulation and for
presentation purposes, since it allows one to get a detailed picture of the
state  of simulation at any point of execution and to follow what happens
inside the network. Note that 3D visualization support and smooth animation
support are only available in Qtenv. As of version OMNeT++ 5.1, Qtenv is the
default user interface, and Tkenv is in maintenance mode.  

<p><ul class="note"><b>NOTE</b><br>
This section only covers the command-line and configuration options
of Qtenv; the user interface is described in the Qtenv chapter of the
OMNeT++ User Guide.
</ul>

<p><h3><a name="sec:run-sim:qtenv-options"/>11.18.1 Command-Line and Configuration Options<a class="headerlink" href="#sec:run-sim:qtenv-options" title="Permalink to this headline"></a></h3>

<p>Simulations run under Qtenv accept all general command line
and configuration options, including <tt>-c</tt> and <tt>-r</tt>. 
The configuration options specific to Qtenv include:

<p><ul>
  <li> <b><tt>qtenv-default-config</tt></b>:
    Specifies which config Qtenv should set up automatically on
    startup. The default is to ask the user. This option is equivalent to the
    <tt>-c</tt> command-line option.

<p>  <li> <b><tt>qtenv-default-run</tt></b>: Specifies which run (of the default
    config, see qtenv-default-config) Qtenv should set up automatically on startup.
    The default is to ask the user. This option is equivalent to the <tt>-r</tt>
    command-line option.

<p>  <li> <b><tt>qtenv-extra-stack</tt></b>:
    Specifies the extra amount of stack that is reserved for each activity()
    simple module when the simulation is run under Qtenv.
</ul>

<p>Qtenv is also affected by the following option:

<p><ul>
  <li> <b><tt>image-path</tt></b>: Specifies the path for loading module icons.
  This option is shared between Tkenv and Qtenv.
</ul>

<p>See Appendix <a href="#cha:config-options">[26]</a> for the list of possible configuration options.

<p>

<p><h2><a name="sec:run-sim:tkenv"/>11.19 The Tkenv Graphical User Interface<a class="headerlink" href="#sec:run-sim:tkenv" title="Permalink to this headline"></a></h2>

<p>Tkenv<!--Tkenv--> is the traditional Tcl/Tk-based graphical runtime user
interface. Tkenv supports interactive simulation execution, tracing and
debugging. Tkenv is recommended in the development stage of a simulation and for
presentation purposes, since it allows one to get a detailed picture of the state
of simulation at any point of execution and to follow what happens
inside the network.

<p><ul class="note"><b>NOTE</b><br>
  This section only covers the command-line and configuration options
  of Tkenv; the user interface is described in the Tkenv chapter of the
  OMNeT++ User Guide.
</ul>

<p><h3><a name="sec:run-sim:tkenv-options"/>11.19.1 Command-Line and Configuration Options<a class="headerlink" href="#sec:run-sim:tkenv-options" title="Permalink to this headline"></a></h3>

<p>Simulations run under Tkenv accept all general command line
and configuration options, including <tt>-c</tt> and <tt>-r</tt>. 
The configuration options specific to Tkenv include:

<p><ul>
  <li> <b><tt>tkenv-default-config</tt></b>:
    Specifies which config Tkenv should set up automatically on startup. The
    default is to ask the user. This option is equivalent to the <tt>-c</tt>
    command-line option.

<p>  <li> <b><tt>tkenv-default-run</tt></b>: Specifies which run (of the default
    config, see tkenv-default-config) Tkenv should set up automatically on startup.
    The default is to ask the user. This option is equivalent to the <tt>-r</tt>
    command-line option.

<p>  <li> <b><tt>tkenv-extra-stack</tt></b>:
    Specifies the extra amount of stack that is reserved for each activity()
    simple module when the simulation is run under Tkenv.

<p>  <li> <b><tt>tkenv-plugin-path</tt></b>:
    Specifies the search path for Tkenv plugins. Tkenv plugins are .tcl files
    that get evaluated on startup.
</ul>

<p>Tkenv is also affected by the following option:

<p><ul>
  <li> <b><tt>image-path</tt></b>: Specifies the path for loading module icons.
    This one was named <tt>tkenv-image-path</tt> in OMNeT++ 4.x and renamed,
    because from version 5.0 it is shared between Tkenv and Qtenv.
</ul>

<p>See Appendix <a href="#cha:config-options">[26]</a> for the list of possible configuration
options.

<p>
<h2><a name="sec:run-sim:simulation-campaigns"/>11.20 Running Simulation Campaigns<a class="headerlink" href="#sec:run-sim:simulation-campaigns" title="Permalink to this headline"></a></h2>

<p>Once your model works reliably, you will usually want to run several
simulations, either to explore the parameter space via a <i>parameter
study</i> (see section <a href="#sec:config-sim:parameter-studies">[10.4]</a>), or to do 
multiple repetitions with different RNG seeds to increase the statistical
accuracy of the results (see section
<a href="#sec:config-sim:repeating-runs-with-different-seeds">[10.4.6]</a>). 

<p>In this section, we will explore several ways to run batches of
simulations efficently.

<p><h3><a name="sec:run-sim:campaigns-naive-approach"/>11.20.1 The Naive Approach<a class="headerlink" href="#sec:run-sim:campaigns-naive-approach" title="Permalink to this headline"></a></h3>

<p>Assume that you want to run the parameter study in the Aloha example
simulation for the <i>numHosts&gt;15</i> cases. 

<p>The first idea is that Cmdenv is capable of running simulation batches. 
The following command will do the job:

<pre class="commandline">
$ ./aloha -u Cmdenv -c PureAlohaExperiment -r '$numHosts&gt;15'
...
Run statistics: total 14, successful 14
End.
</pre>
<p> 
It works fine. However, this approach has some drawbacks which becomes
apparent when running hundreds or thousands of simulation runs.

<p><ol>
  <li> It uses only one CPU. In the age of multi-core CPUs, this is not 
        very efficient.
  <li> More prone to C++ programming errors in the model. A failure in a single
        run may abort execution (segfault) or corrupt the process
        state, possibly invalidating the results of subsequent runs.
</ol>

<p>To address the second drawback, we can execute each simulation run in its own
Cmdenv instance.

<pre class="commandline">
$ ./aloha -c PureAlohaExperiment -r '$numHosts&gt;15' -s -q runnumbers
28 29 30 31 32 33 34 35 36 37 38 39 40 41
$ ./aloha -u Cmdenv -c PureAlohaExperiment -r 28
$ ./aloha -u Cmdenv -c PureAlohaExperiment -r 29
$ ./aloha -u Cmdenv -c PureAlohaExperiment -r 30
...
$ ./aloha -u Cmdenv -c PureAlohaExperiment -r 41
</pre>
<p>
It's a lot of commands to issue manually, but luckily it can be automated with a
shell script like this:

<pre class="filelisting">
#! /bin/sh
RUNS=$(./aloha -c PureAlohaExperiment -r '$numHosts&gt;15' -s -q runnumbers)
for i in $RUNS; do
    ./aloha -u Cmdenv -c PureAlohaExperiment -r $i
done
</pre>
<p>
Save the above into a text file called e.g. <tt>runAloha</tt>. Then give it
executable permission, and run it:

<pre class="commandline">
$ chmod +x runAloha
$ ./runAloha
</pre>
<p>
It will execute the simulations one-by-one, each in its own Cmdenv instance.

<p>This approach involves a process start overhead for each simulation.
Normally, this overhead is small compared to the time spent simulating. However,
it may become more of a problem when running a large number of very short
simulations (&lt;&lt;1s in CPU time). This effect may be mitigated by letting Cmdenv
do several (e.g. 10) simulations in one go. 

<p>And then, the script still uses only one CPU. It would be better to keep
all CPUs busy. For example, if you have 8 CPUs, there should be eight processes
running all the time -- when one terminates, another would be launched in its place.
You might notice that this behavior is similar to what GNU Make's
<tt>-j&lt;numJobs&gt;</tt> option does. The <tt>opp_runall</tt> utility, to be covered
in the next section, exploits GNU Make to schedule the running of simulations on
multiple CPUs.

<p>
<h3><a name="sec:run-sim:batches-using-opp-runall"/>11.20.2 Using opp_runall<a class="headerlink" href="#sec:run-sim:batches-using-opp-runall" title="Permalink to this headline"></a></h3>

<p>OMNeT++ has a utility program called <tt>opp_runall</tt>, which allows you to
execute simulations using multiple CPUs and multiple processes.

<p><tt>opp_runall</tt> groups simulation runs into batches. Every batch
corresponds to a Cmdenv process, that is, runs of a batch execute sequentially
inside the same Cmdenv process. Batches (i.e. Cmdenv instances) are scheduled
for running so that they keep all CPUs busy. The batch size as well as the
number of CPUs to use have sensible defaults but can be overridden.

<p><h4><a name="sec:run-sim:opp-runall:comandline"/>11.20.2.1 Command Line<a class="headerlink" href="#sec:run-sim:opp-runall:comandline" title="Permalink to this headline"></a></h4>

<p><tt>opp_runall</tt> expects the normal simulation command in its argument list.
The first positional (non-option) argument and all following arguments are
treated as the simulation command (simulation program and its arguments).

<p>Thus, to modify a normal Cmdenv simulation command to make use of multiple
CPUs, simply prefix it with <tt>opp_runall</tt>:    

<pre class="commandline">
$ opp_runall ./aloha -u Cmdenv -c PureAlohaExperiment -r '$numHosts&gt;15'
</pre>
<p>
Options intended for <tt>opp_runall</tt> should come before the the simulation
command. These options include <tt>-b&lt;N&gt;</tt> for specifying the batch size, and 
<tt>-j&lt;N&gt;</tt> to specify the number of CPUs to use.

<pre class="commandline">
$ opp_runall -j8 -b4 ./aloha -u Cmdenv -c PureAlohaExperiment -r '$numHosts&gt;15'
</pre>
<p>

<p><h4><a name="sec:run-sim:opp-runall:operation"/>11.20.2.2 How It Works<a class="headerlink" href="#sec:run-sim:opp-runall:operation" title="Permalink to this headline"></a></h4>

<p>First, <tt>opp_runall</tt> invokes the simulation command with extra command
arguments (<tt>-s -q runnumbers</tt>) to figure out the list of runs it needs to
perform, and groups the run numbers into batches. Then it exploits GNU make and
its <tt>-j&lt;N&gt;</tt> option to do the heavy lifting. Namely, it generates a
temporary makefile that allows <tt>make</tt> to run batches in parallel, and
invokes <tt>make</tt> with the appropriate <tt>-j</tt> option. It is also possible
to export the makefile for inspection and/or running it manually.

<p>To illustrate the above, here is the content of such a makefile:

<pre class="filelisting">
#
# This makefile was generated with the following command:
# opp_runall -j2 -b4 -e tmp ./aloha -u Cmdenv -c PureAlohaExperiment -r $numHosts&gt;15 
#

SIMULATIONCMD = ./aloha -u Cmdenv -c PureAlohaExperiment -s \ 
                --cmdenv-redirect-output=true
TARGETS =  batch0 batch1 batch2 batch3

.PHONY: $(TARGETS)

all: $(TARGETS)
    @echo All runs completed.

batch0:
    $(SIMULATIONCMD) -r 28,29,30,31

batch1:
    $(SIMULATIONCMD) -r 32,33,34,35

batch2:
    $(SIMULATIONCMD) -r 36,37,38,39

batch3:
    $(SIMULATIONCMD) -r 40,41
</pre>
<p>

<p><h3><a name="sec:run-sim:opp-runall:exploiting-clusters"/>11.20.3 Exploiting Clusters<a class="headerlink" href="#sec:run-sim:opp-runall:exploiting-clusters" title="Permalink to this headline"></a></h3>

<p>With large scale simulations, using one's own desktop computer might not be
enough. The solution could be to run the simulation on remote machines,
that is, to employ a computing cluster.

<p>In simple setups, cross-mounting the file system that contains OMNeT++ and the
model, and using <tt>ssh</tt> to run the simulations might already provide a good
solution. 

<p>In other cases, submitting simulation jobs and harvesting the results might be
done via batch-queuing, cluster computing or grid computing middleware. The
following list contains some pointers to such software:
 
<p><ul>

<p>  <li> <b>HTCondor</b>, previously called <b>Condor</b>, is an open source
      software package that enables High Throughput Computing (HTC) 
      on large collections of distributively owned computing resources.
      HTCondor can manage a dedicated cluster of workstations, and it can also
      harness non-dedicated, preexisting resources under distributed ownership.
      A user can submit jobs to HTCondor. HTCondor finds an available machine 
      on the network and begins running the job on that machine. HTCondor also
      supports checkpointing and migrating jobs. 

<p><li> <b>Open Grid Scheduler/Grid Engine</b> is a commercially supported
      open-source batch-queuing system for distributed resource management.
      OGS/GE is based on Sun Grid Engine (SGE), and maintained by the same group
      of external (i.e. non-Sun) developers who started contributing code since
      2001. There is also a commercial SGE successor, <b>Univa Grid Engine</b>,
      formerly called Oracle Grid Engine.

<p><li> <b>Slurm Workload Manager</b>, or Slurm, is a free and open-source job
      scheduler for Linux and Unix-like kernels, used by many of the world's
      supercomputers and computer clusters.

<p><li> <b>Apple's Xgrid</b> has unfortunately been removed from Mac OS X with the
     release of Mountain Lion (2012). Xgrid was distributed computing for
     the masses -- easy, plug and play, not complicated. You could network your
     Mac computers together, and use that power on one computer to do something
     that took a lot of computing power. Currently, Pooch is advertised
     as software providing the easiest way to assemble and operate a
     high-performance parallel computer from Macs.
 
<p></ul>

<p>

<p><h2><a name="sec:run-sim:akaroa"/>11.21 Akaroa Support: Multiple Replications in Parallel<a class="headerlink" href="#sec:run-sim:akaroa" title="Permalink to this headline"></a></h2>
<!--Akaroa-->
<!--Multiple Replications in Parallel-->

<p><h3><a name="sec:run-sim:akaroa-introduction"/>11.21.1 Introduction<a class="headerlink" href="#sec:run-sim:akaroa-introduction" title="Permalink to this headline"></a></h3>

<p>Typical simulations are Monte-Carlo simulations: they use
(pseudo-)random numbers to drive the simulation model.
For the simulation to produce statistically reliable results,
one has to carefully consider the following:

<p><ul>
  <li>When the initial transient is over, when can we start
    collecting data? We usually don't want to include the
    initial transient when the simulation is still &#8220;warming up.&#8221;
  <li>When can we stop the simulation? We want to wait long enough
    so that the statistics we are collecting can &#8220;stabilize&#8221;,
    or reach the required sample size to be statistically trustable.
</ul>

<p>Neither question is trivial to answer. One might just suggest
to wait &#8220;very long&#8221; or &#8220;long enough&#8221;. However, this is neither
simple (how do you know what is &#8220;long enough&#8221;?) nor practical
(even with today's high speed processors simulations of modest complexity
can take hours, and one may not afford multiplying runtimes by,
say, 10, &#8220;just to be safe.&#8221;) If you need further convincing,
please read [<a href="#bib-Pawlikowsky02">Pawlikowsky02</a>] and be horrified.

<p>A possible solution is to look at the statistics while the simulation
is running, and decide at runtime when enough data have been
collected for the results to have reached the required accuracy.
One possible criterion is given by the confidence level,
more precisely, by its width relative to the mean.
But ex ante it is unknown how many observations have to be collected
to achieve this level -- it must be determined at runtime.

<p>
<h3><a name="sec:run-sim:what-is-akaroa"/>11.21.2 What Is Akaroa<a class="headerlink" href="#sec:run-sim:what-is-akaroa" title="Permalink to this headline"></a></h3>

<p>Akaroa [<a href="#bib-Akaroa99">Akaroa99</a>] addresses the above problem.
According to its authors, Akaroa (Akaroa2) is a &#8220;fully automated
simulation tool designed for running distributed stochastic simulations
in MRIP scenario&#8221; in a cluster computing environment.

<p>MRIP stands for <i>Multiple Replications in Parallel</i>.
In MRIP, the computers of the cluster run independent replications
of the whole simulation process (i.e. with the same parameters but
different seed for the RNGs (random number generators)),
generating statistically equivalent streams of simulation output data.
These data streams are fed to a global data analyser responsible for
analysis of the final results and for stopping the simulation
when the results reach a satisfactory accuracy.

<p>The independent simulation processes run independently of one another
and continuously send their observations to the central analyser
and control process. This process <i>combines</i> the independent data streams,
and calculates from these observations an overall estimate of the mean value
of each parameter.
Akaroa2 decides by a given confidence level and precision
whether it has enough observations or not. When it judges that is
has enough observations it halts the simulation.

<p>If <i>n</i> processors are used, the needed simulation execution time
is usually <i>n</i> times smaller compared to a one-processor
simulation (the required number of observations are produced sooner).
Thus, the simulation would be sped up approximately in proportion
to the number of processors used and sometimes even more.

<p>Akaroa was designed at the University of Canterbury in Christchurch, New Zealand
and can be used free of charge for teaching and non-profit research activities.

<p>
<h3><a name="sec:run-sim:using-akaroa"/>11.21.3 Using Akaroa with OMNeT++<a class="headerlink" href="#sec:run-sim:using-akaroa" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:run-sim:starting-up-akaroa"/>11.21.3.1 Starting Akaroa<a class="headerlink" href="#sec:run-sim:starting-up-akaroa" title="Permalink to this headline"></a></h4>

<p>Before the simulation can be run in parallel under Akaroa, you have to
start up the system:

<p><ul>
  <li>Start <tt>akmaster</tt> running in the background on some host.
  <li>On each host where you want to run a simulation engine,
     start <tt>akslave</tt> in the background.
</ul>

<p>Each <tt>akslave</tt> establishes a connection with the <tt>akmaster</tt>.

<p>Then you use <tt>akrun</tt> to start a simulation. <tt>akrun</tt> waits
for the simulation to complete, and writes a report of the results
to the standard output. The basic usage of the <tt>akrun</tt> command is:

<pre class="commandline">
$ akrun -n num_hosts command [argument..]
</pre>
<p>
where <i>command</i> is the name of the simulation you want to start.
Parameters for Akaroa are read from the file named <tt>Akaroa</tt> in
the working directory. Collected data from the processes are
sent to the <tt>akmaster</tt> process, and when the required precision
has been reached, <tt>akmaster</tt> tells the simulation processes to
terminate. The results are written to the standard output.

<p>The above description is not detailed enough to help you
set up and successfully use Akaroa -- for that you need to read the
Akaroa manual.

<p><h4><a name="sec:run-sim:configuring-akaroa"/>11.21.3.2 Configuring OMNeT++ for Akaroa<a class="headerlink" href="#sec:run-sim:configuring-akaroa" title="Permalink to this headline"></a></h4>

<p>First of all, you have to compile OMNeT++ with Akaroa support enabled.

<p>The OMNeT++ simulation must be configured in <tt>omnetpp.ini</tt>
so that it passes the observations to Akaroa. The simulation model itself does
not need to be changed -- it continues to write
the observations into output vectors (<tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> objects,
see chapter <a href="#cha:sim-lib">[7]</a>). You can place some of
the output vectors under Akaroa control.

<p>You need to add the following to <tt>omnetpp.ini</tt>:

<pre class="inifile">
[General]
rng-class = "cAkaroaRNG"
outputvectormanager-class = "cAkOutputVectorManager"
</pre>
<p>
These lines cause the simulation to obtain random numbers from Akaroa,
and allows data written to selected output vectors to be passed to Akaroa's
global data analyser.
    <br><ul><font size=-1>[For more details on the plugin mechanism these settings make use of,
    see <a href="#cha:plugin-exts">[17]</a>.]</font></ul>

<p>Akaroa's RNG is a Combined Multiple Recursive pseudorandom
number generator (CMRG) with a period of approximately <i>2<sup>191</sup></i>
random numbers, and provides a unique stream of random numbers
for every simulation engine.

<p><ul class="note"><b>NOTE</b><br>
It is vital that you obtain random numbers from Akaroa; otherwise,
all simulation processes will run with the same RNG seeds, and
produce exactly the same results.
</ul>

<p>Then you need to specify which output vectors you want to
be under Akaroa control (by default, none of them are).
You can use the <tt>*</tt>, <tt>**</tt> wildcards (see
section <a href="#sec:config-sim:wildcards">[10.3.1]</a>) to
place certain vectors under Akaroa control.

<pre class="inifile">
&lt;modulename&gt;.&lt;vectorname1&gt;.with-akaroa = true
&lt;modulename&gt;.&lt;vectorname2&gt;.with-akaroa = true
</pre>
<p>

<p><h4><a name="sec:run-sim:akaroa-using-shared-filesystems"/>11.21.3.3 Using Shared File Systems<a class="headerlink" href="#sec:run-sim:akaroa-using-shared-filesystems" title="Permalink to this headline"></a></h4>

<p>It is usually practical to have the same physical disk mounted (e.g. via NFS or
Samba) on all computers in the cluster. However, because all OMNeT++ simulation
processes run with the same settings, they would overwrite each other's
output files. Your can prevent this from happening using the
<b><tt>fname-append-host</tt></b> ini file entry:

<pre class="inifile">
[General]
fname-append-host = true
</pre>
<p>
When turned on, it appends the host name to the names of the output
files (output vector, output scalar, snapshot files).

<p>

<hr class='pgbr'><h1><a name="cha:ana-sim"/>12 Result Recording and Analysis<a class="headerlink" href="#cha:ana-sim" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:ana-sim:result-recording"/>12.1 Result Recording<a class="headerlink" href="#sec:ana-sim:result-recording" title="Permalink to this headline"></a></h2>

<p>OMNeT++ provides built-in support for recording simulation results, via
<i>output vectors</i> and <i>output scalars</i>. Output vectors are
time series data, recorded from simple modules or channels. You can use
output vectors to record end-to-end delays or round trip times of packets,
queue lengths, queueing times, module state, link utilization, packet
drops, etc. -- anything that is useful to get a full picture of what
happened in the model during the simulation run.

<p>Output scalars are summary results, computed during the simulation and
written out when the simulation completes. A scalar result may be an
(integer or real) number, or may be a statistical summary comprised of
several fields such as count, mean, standard deviation, sum, minimum,
maximum, etc., and optionally histogram data.

<p>Results may be collected and recorded in two ways:

<p><ol>
  <li> Based on the signal mechanism, using declared statistics;
  <li> Directly from C++ code, using the simulation library
</ol>

<p>The second method has been the traditional way of recording results. The
first method, based on signals and declared statistics, was introduced in
OMNeT++ 4.1, and it is preferable because it allows you to always record the
results in the form you need, without requiring heavy instrumentation or
continuous tweaking of the simulation model.

<p><h3><a name="sec:ana-sim:signals-and-statistics"/>12.1.1 Using Signals and Declared Statistics<a class="headerlink" href="#sec:ana-sim:signals-and-statistics" title="Permalink to this headline"></a></h3>

<p>This approach combines the signal mechanism (see
<a href="#sec:simple-modules:signals">[4.14]</a>) and NED properties (see
<a href="#sec:ned-lang:properties">[3.12]</a>) in order to de-couple the generation of
results from their recording, thereby providing more flexibility in what to
record and in which form. The details of the solution have been described
in section <a href="#sec:simple-modules:signal-based-statistics">[4.15]</a> in detail; here we
just give a short overview.

<p>Statistics are declared in the NED files with the <tt>@statistic</tt> property,
and modules emit values using the signal mechanism. The simulation framework
records data by adding special result file writer listeners to the signals.
By being able to choose what listeners to add, the user can control what to
record in the result files and what computations to apply before recording.
The aforementioned section <a href="#sec:simple-modules:signal-based-statistics">[4.15]</a>
also explains how to instrument simple modules and channels for signals-based
result recording.

<p>The signals approach allows for calculation of aggregate statistics (such as the
total number of packet drops in the network) and for implementing a warm-up
period without support from module code. It also allows you to write
dedicated statistics collection modules for the simulation, also without
touching existing modules.

<p>The same configuration options that were used to control result recording
with <tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> and <tt>recordScalar()</tt> also work when utilizing
the signals approach, and there are extra configuration options to make
the additional possibilities accessible.

<p><h3><a name="sec:ana-sim:direct-result-recording"/>12.1.2 Direct Result Recording<a class="headerlink" href="#sec:ana-sim:direct-result-recording" title="Permalink to this headline"></a></h3>

<p>With this approach, scalar and statistics results are collected in class
variables inside modules, then recorded in the finalization phase via
<tt>recordScalar()</tt> calls. Vectors are recorded using
<tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> objects. Use <tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt> to record summary statistics
like mean, standard deviation, minimum/maximum, and histogram-like classes
(<tt><a href="../api/classomnetpp_1_1cHistogram.html">cHistogram</a></tt>, <tt><a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a></tt>, <tt><a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a></tt>) to record the
distribution. These classes are described in sections
<a href="#sec:sim-lib:statistics">[7.8]</a> and <a href="#sec:sim-lib:result-recording">[7.9]</a>.
Recording of individual vectors, scalars and statistics can be enabled or
disabled via the configuration (ini file), and it is also the place to set
up recording intervals for vectors.

<p>The drawback of recording results directly from modules is that result
recording is hardcoded in modules, and even simple requirement changes
(e.g. record the average delay instead of each delay value, or vice versa)
requires either code change or an excessive amount of result collection
code in the modules.

<p>

<p><h2><a name="sec:ana-sim:config-results"/>12.2 Configuring Result Collection<a class="headerlink" href="#sec:ana-sim:config-results" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:ana-sim:result-file-names"/>12.2.1 Result File Names<a class="headerlink" href="#sec:ana-sim:result-file-names" title="Permalink to this headline"></a></h3>

<p>Simulation results are recorded into <i>output scalar files</i> that
actually hold statistics results as well, and <i>output vector
files</i>. The usual file extension for scalar files is <tt>.sca</tt>, and
for vector files <tt>.vec</tt>.

<p>Every simulation run generates a single scalar file and a vector file.
The file names can be controlled with the <b><tt>output-vector-file</tt></b>
and <b><tt>output-scalar-file</tt></b> options. These options rarely need
to be used, because the default values are usually fine. The defaults
are:

<pre class="inifile">
output-vector-file = "${resultdir}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}-${runnumber}.sca"
</pre>
<p>
Here, <tt>${resultdir}</tt> is the value of the <b><tt>result-dir</tt></b>
configuration option which defaults to <tt>results/</tt>, and
<tt>${configname}</tt> and <tt>${runnumber}</tt> are the name of
the configuration name in the ini file (e.g. <tt>[Config PureAloha]</tt>),
and the run number. Thus, the above defaults generate file names
like <tt>results/PureAloha-0.vec</tt>, <tt>results/PureAloha-1.vec</tt>,
and so on.

<p><ul class="note"><b>NOTE</b><br>
  In OMNeT++ 3.x, the default result file names were <tt>omnetpp.vec</tt> and
  <tt>omnetpp.sca</tt>, and scalar files were always appended to, rather than
  being overwritten as in the 4.x version. When needed, the old behavior
  for scalar files can be turned back on by setting
  <tt>output-scalar-file-append=true</tt> in the configuration.
</ul>

<p>
<h3><a name="sec:ana-sim:disabling-result-items"/>12.2.2 Enabling/Disabling Result Items<a class="headerlink" href="#sec:ana-sim:disabling-result-items" title="Permalink to this headline"></a></h3>

<p>The recording of simulation results can be enabled/disabled at multiple levels
with various configuration options:

<p><ul>
  <li> All recording from a <b><tt>@statistic</tt></b> can be enabled/disabled together
        using the <b><tt>statistic-recording</tt></b> option;
  <li> Recording of a scalar or a statistic object can be controlled with the
        <b><tt>scalar-recording</tt></b> option;
  <li> Recording of an output vector can be controlled with the <b><tt>vector-recording</tt></b>
        option;
  <li> Recording of the bins of a histogram object can be controlled with the
        <b><tt>bin-recording</tt></b> option.
</ul>

<p>All the above options are boolean per-object options, thus, they have similar syntaxes:

<p><ul>
<li> <i>&lt;module-path&gt;.&lt;statistic-name&gt;.</i><b><tt>statistic-recording</tt></b><tt> = true/false</tt>
<li> <i>&lt;module-path&gt;.&lt;scalar-name&gt;.</i><b><tt>scalar-recording</tt></b><tt> = true/false</tt>
<li> <i>&lt;module-path&gt;.&lt;vector-name&gt;.</i><b><tt>vector-recording</tt></b><tt> = true/false</tt>
<li> <i>&lt;module-path&gt;.&lt;histogram-name&gt;.</i><b><tt>bin-recording</tt></b><tt> = true/false</tt>
</ul>

<p>For example, all recording from the following statistic

<pre class="ned">
@statistic[queueLength](record=max,timeavg,vector);
</pre>
<p>
can disabled with this ini file line:

<pre class="inifile">
**.queueLength.statistic-recording = false
</pre>
<p>
When a scalar, vector, or histogram is recorded using a <b><tt>@statistic</tt></b>,
its name is derived from the statistic name, by appending the recording
mode after a semicolon. For example, the above statistic will generate 	the
scalars named <tt>queueLength:max</tt> and <tt>queueLength:timeavg</tt>, and the
vector named <tt>queueLength:vector</tt>. Their recording can be individually
disabled with the following lines:

<pre class="inifile">
**.queueLength:max.scalar-recording = false
**.queueLength:timeavg.scalar-recording = false
**.queueLength:vector.vector-recording = false
</pre>
<p>
The statistic, scalar or vector name part in the key may also contain
wildcards. This can be used, for example, to handle result items with
similar names together, or, by using <tt>*</tt> as name, for filtering by
module or to disable all recording. The following example turns off
recording of all scalar results except those called <tt>latency</tt>, and those
produced by modules named <tt>tcp</tt>:

<pre class="inifile">
**.tcp.*.scalar-recording = true
**.latency.scalar-recording = true
**.scalar-recording = false
</pre>
<p>
To disable all result recording, use the following three lines:

<pre class="inifile">
**.statistic-recording = false
**.scalar-recording = false
**.vector-recording = false
</pre>
<p>
The first line is not strictly necessary. However, it may improve runtime
performance because it causes result recorders not to be added, instead of
adding and then disabling them.

<p>
<h3><a name="sec:ana-sim:configuring-recording-modes"/>12.2.3 Selecting Recording Modes for Signal-Based Statistics<a class="headerlink" href="#sec:ana-sim:configuring-recording-modes" title="Permalink to this headline"></a></h3>

<p>Signal-based statistics recording has been designed so that it can be
easily configured to record a &#8220;default minimal&#8221; set of results, a
&#8220;detailed&#8221; set of results, and a custom set of results (by modifying
the previous ones, or defined from scratch).

<p>Recording can be tuned with the <b><tt>result-recording-modes</tt></b>
per-object configuration option. The &#8220;object&#8221; here is the statistic,
which is identified by the full path (hierarchical name) of the module or
connection channel object in question, plus the name of the statistic
(which is the &#8220;index&#8221; of <b><tt>@statistic</tt></b> property, i.e. the name in
the square brackets). Thus, configuration keys have the syntax
<i>&lt;module-path&gt;.&lt;statistic-name&gt;.</i><tt>result-recording-modes=</tt>.

<p>The <b><tt>result-recording-modes</tt></b> option accepts one or more items as value,
separated by comma. An item may be a result recording mode (surprise!), and
two words with a special meaning, <tt>default</tt> and <tt>all</tt>:

<p><ul>
<li> A <i>result recording mode</i> means any item that may occur in the
      <tt>record</tt> key of the <b><tt>@statistic</tt></b> property; for example,
      <tt>count</tt>, <tt>sum</tt>, <tt>mean</tt>, <tt>vector((count-1)/2)</tt>.
<li> <b><tt>default</tt></b> stands for the set of non-optional items from
      the <b><tt>@statistic</tt></b> property's <tt>record</tt> list, that is, those
      without question marks.
<li> <b><tt>all</tt></b> means all items from the <b><tt>@statistic</tt></b> property's
      <tt>record</tt> list, including the ones with question marks.
</ul>

<p>The default value is <tt>default</tt>.

<p>A lone &#8220;-&#8221; as option value disables all recording modes.

<p><i>Recording mode</i> items in the list may be prefixed with &#8220;+&#8221; or
&#8220;-&#8221; to add/remove them from the set of result recording modes. The
initial set of result recording modes is <tt>default</tt>; if the first item
is prefixed with &#8220;+&#8221; or &#8220;-&#8221;, then that and all subsequent items are
understood as modifying the set; if the first item does not start with with
&#8220;+&#8221; or &#8220;-&#8221;, then it replaces the set, and further items are understood
as modifying the set.

<p>This sounds more complicated than it is; an example will make it clear.
Suppose we are configuring the following statistic:

<pre class="ned">
@statistic[foo](record=count,mean,max?,vector?);
</pre>
<p>
With the following the ini file lines (see results in comments):

<pre class="inifile">
**.result-recording-modes = default  # --&gt; count, mean
**.result-recording-modes = all      # --&gt; count, mean, max, vector
**.result-recording-modes = -        # --&gt; none
**.result-recording-modes = mean     # --&gt; only mean (disables 'default')
**.result-recording-modes = default,-vector,+histogram # --&gt; count,mean,histogram
**.result-recording-modes = -vector,+histogram         # --&gt; same as the previous
**.result-recording-modes = all,-vector,+histogram  # --&gt; count,mean,max,histogram
</pre>
<p>
Here is another example which shows how to write a more specific option
key. The following line applies to <tt>queueLength</tt> statistics of
<tt>fifo[]</tt> submodule vectors anywhere in the network:

<pre class="inifile">
**.fifo[*].queueLength.result-recording-modes = +vector  # default plus vector
</pre>
<p>
In the result file, the recorded scalars will be suffixed with the recording mode,
i.e. the mean of <tt>queueingTime</tt> will be recorded as <tt>queueingTime:mean</tt>.

<p>
<h3><a name="sec:ana-sim:warmup-period"/>12.2.4 Warm-up Period<a class="headerlink" href="#sec:ana-sim:warmup-period" title="Permalink to this headline"></a></h3>

<p>The <b><tt>warmup-period</tt></b> option specifies the length of the initial
warm-up period. When set, results belonging to the first <i>x</i> seconds
of the simulation will not be recorded into output vectors, and will
not be counted into the calculation of output scalars.
This option is useful for steady-state simulations. The default is 0s
(no warmup period).

<p>Example:

<pre class="inifile">
warmup-period = 20s
</pre>
<p>
Results recorded via signal-based statistics automatically obey the warm-up
period setting, but modules that compute and record scalar results
manually (via <tt>recordScalar()</tt>) need to be modified so that they take
the warm-up period into account.

<p><ul class="note"><b>NOTE</b><br>
When configuring a warm-up period, make sure that modules that compute and
record scalar results manually via <tt>recordScalar()</tt> actually obey the
warm-up period in the C++ code.
</ul>

<p>The warm-up period is available via the <tt>getWarmupPeriod()</tt> method of
the simulation manager object, so the C++ code that updates the corresponding
state variables needs to be surrounded with an <i>if</i> statement:

<p>Old:

<pre class="cpp">
dropCount++;
</pre>
<p>
New:

<pre class="cpp">
if (simTime() &gt;= getSimulation()-&gt;getWarmupPeriod())
    dropCount++;
</pre>
<p>

<p><h3><a name="sec:ana-sim:vector-recording-intervals"/>12.2.5 Output Vectors Recording Intervals<a class="headerlink" href="#sec:ana-sim:vector-recording-intervals" title="Permalink to this headline"></a></h3>

<p>The size of output vector files can easily reach several gigabytes,
but very often, only some of the recorded statistics are
interesting to the analyst. In addition to selecting which vectors to
record, OMNeT++ also allows one to specify one or more collection intervals.

<p>The latter can be configured with the <b><tt>vector-recording-intervals</tt></b>
per-object option. The syntax of the configuration option is
<i>&lt;module-path&gt;.&lt;vector-name&gt;.</i><tt>vector-recording-intervals=</tt><i>&lt;intervals&gt;</i>,
where both <i>&lt;module-path&gt;</i> and <i>&lt;vector-name&gt;</i> may
contain wildcards (see <a href="#sec:config-sim:wildcards">[10.3.1]</a>).
<i>&lt;vector-name&gt;</i> is the vector name, or the name string of the
<tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> object. By default, all output vectors are turned
on for the whole duration the simulation.

<p>One can specify one or more intervals in the <i>&lt;startTime&gt;..&lt;stopTime&gt;</i>
syntax, separated by comma. <i>&lt;startTime&gt;</i> or <i>&lt;stopTime&gt;</i> need
to be given with measurement units, and both can be omitted to denote
the beginning and the end of the simulation, respectively.

<p>The following example limits all vectors to three intervals, except
<tt>dropCount</tt> vectors which will be recorded during the whole
simulation run:

<pre class="inifile">
**.dropCount.vector-recording-intervals = 0..
**.vector-recording-intervals = 0..1000s, 5000s..6000s, 9000s..
</pre>
<p>
<h3><a name="sec:ana-sim:vector-eventnum-recording"/>12.2.6 Recording Event Numbers in Output Vectors<a class="headerlink" href="#sec:ana-sim:vector-eventnum-recording" title="Permalink to this headline"></a></h3>

<p>A third per-vector configuration option is <b><tt>vector-record-eventnumbers</tt></b>,
which specifies whether to record event numbers for an output vector.
(Simulation time and value are always recorded. Event numbers are needed
by the Sequence Chart Tool, for example.) Event number recording is enabled
by default; it may be turned off to save disk space.

<pre class="inifile">
**.vector-record-eventnumbers = false
</pre>
<p>
If the (default) <tt>cIndexedFileOutputVectorManager</tt> class is used to
record output vectors, there are two more options to fine-tune its resource
usage. <tt>output-vectors-memory-limit</tt> specifies the total memory that
can be used for buffering output vectors. Larger values produce less
fragmented vector files (i.e. cause vector data to be grouped into larger
chunks), and therefore allow more efficient processing later.
<tt>vector-max-buffered-values</tt> specifies the maximum number of values to
buffer per vector, before writing out a block into the output vector file.
The default is no per-vector limit (i.e. only the total memory limit is in
effect.)

<p>
<h3><a name="sec:ana-sim:saving-parameters-as-scalars"/>12.2.7 Saving Parameters as Scalars<a class="headerlink" href="#sec:ana-sim:saving-parameters-as-scalars" title="Permalink to this headline"></a></h3>

<p>When you are running several simulations with different parameter
settings, you'll usually want to refer to selected
input parameters in the result analysis as well -- for example when
drawing a throughput (or response time) versus load (or network
background traffic) plot. Average throughput or response time numbers
are saved into the output scalar files, and it is useful for the input
parameters to get saved into the same file as well.

<p>For convenience, OMNeT++ automatically saves the iteration variables
into the output scalar file if they have numeric value, so they can
be referred to during result analysis.

<p><ul class="warning"><b>WARNING</b><br>
    If an iteration variable has non-numeric value, it will not be recorded
    automatically and cannot be used during analysis. This can happen
    unintentionally if you specify units inside an iteration variable list:
<pre class="inifile">
**.param = exponential( ${mean=0.2s, 0.4s, 0.6s} )  #WRONG!
**.param = exponential( ${mean=0.2, 0.4, 0.6}s )    #OK
</pre>
</ul>

<p>Module parameters can also be saved, but this has to be
requested by the user, by configuring <tt>param-record-as-scalar=true</tt> for the
parameters in question. The configuration key is a pattern that
identifies the parameter, plus <tt>.param-record-as-scalar</tt>. An example:

<pre class="inifile">
**.host[*].networkLoad.param-record-as-scalar = true
</pre>
<p>
This looks simple enough, however there are three pitfalls:
non-numeric parameters, too many matching parameters, and
random-valued volatile parameters.

<p>First, the scalar file only holds numeric results, so non-numeric
parameters cannot be recorded -- that will result in a runtime
error.

<p>Second, if wildcards in the pattern match too many parameters, that
might unnecessarily increase the size of the scalar file. For example,
if the <tt>host[]</tt> module vector size is 1000 in the example below, then the
same value (3) will be saved 1000 times into the scalar file, once for
each host.

<pre class="inifile">
**.host[*].startTime = 3
**.host[*].startTime.param-record-as-scalar = true  # saves "3" once for each host
</pre>
<p>
Third, recording a random-valued volatile parameter will just save a
random number from that distribution. This is rarely what you need, and
the simulation kernel will also issue a warning if this happens.

<pre class="inifile">
**.interarrivalTime = exponential(1s)
**.interarrivalTime.param-record-as-scalar = true  # wrong: saves random values!
</pre>
<p>
These pitfalls are quite common in practice, so it is usually better
to rely on the iteration variables in the result analysis.
That is, one can rewrite the above example as

<pre class="inifile">
**.interarrivalTime = exponential( ${mean=1}s )
</pre>
<p>
and refer to the <tt>$mean</tt> iteration variable instead of the
interarrivalTime module parameter(s) during result analysis.
<tt>param-record-as-scalar=true</tt> is not needed, because iteration variables are
automatically saved into the result files.

<p>
<h3><a name="sec:ana-sim:outputfile-precision"/>12.2.8 Recording Precision<a class="headerlink" href="#sec:ana-sim:outputfile-precision" title="Permalink to this headline"></a></h3>

<p>Output scalar and output vector files are text files, and floating point
values (<tt>double</tt>s) are recorded into it using <tt>fprintf()</tt>'s
<tt>"%g"</tt> format. The number of significant digits can be configured
using the <b><tt>output-scalar-precision</tt></b> and <b><tt>output-vector-precision</tt></b>
configuration options.

<p>The default precision is 12 digits. The following has to be considered when
setting a different value:

<p>IEEE-754 doubles are 64-bit numbers. The mantissa is 52 bits, which is
roughly equivalent to 16 decimal places (52*log(2)/log(10)). However, due
to rounding errors, usually only 12..14 digits are correct, and the rest is
pretty much random garbage which should be ignored. However, when you
convert the decimal representation back into a <tt>double</tt> for result
processing, an additional small error will occur, because 0.1, 0.01, etc.
cannot be accurately represented in binary. This conversion error is
usually smaller than what that the <tt>double</tt> variable already had
before recording into the file. However, if it is important, you can
eliminate this error by setting the recording precision to 16 digits or
more (but again, be aware that the last digits are garbage). The practical
upper limit is 17 digits, setting it higher doesn't make any difference in
<tt>fprintf()</tt>'s output.


Errors resulting from converting to/from decimal representation can be
eliminated by choosing an output vector/output scalar manager class
which stores <tt>double</tt>s in their native binary form.
The appropriate configuration options are <b><tt>outputvectormanager-class</tt></b>
and <b><tt>outputvectormanager-class</tt></b>. For example,
<tt>cMySQLOutputScalarManager</tt> and <tt>cMySQLOutputScalarManager</tt>
provided in <tt>samples/database</tt> fulfill this requirement.

<p>However, before worrying too much about rounding and conversion errors,
consider the <i>real</i> accuracy of your results:

<p><ul>
  <li> In real life, it is very difficult to measure quantities (weight, distance,
     even time) with more than a few digits of precision. What precision
     are your input data? For example, if you approximate inter-arrival
     time as <i>exponential(0.153)</i> when the mean is really
     <i>0.152601...</i> and the distribution is not even exactly exponential,
     you are already starting out with a bigger error than rounding can cause.

<p>  <li> The simulation model is itself an approximation of real life. How much
     error do the (known and unknown) simplifications cause in the results?
</ul>

<p>

<p><h2><a name="sec:ana-sim:omnetpp-result-file-format"/>12.3 The OMNeT++ Result File Format<a class="headerlink" href="#sec:ana-sim:omnetpp-result-file-format" title="Permalink to this headline"></a></h2>

<p>By default, OMNeT++ saves simulation results into textual, line-oriented files.
The advantage of a text-based, line-oriented format is that it is very
accessible and easy to parse with a wide range of tools and languages, and
still provides enough flexibility to be able to represent the data it
needs to (in contrast to e.g. CSV). This section provides an overview of
these file formats (output vector and output scalar files); the precise
specification is available in the Appendix (<a href="#cha:result-file-formats">[27]</a>).


By default, each file contains data from one run only.

<p>Result files start with a header that contains several attributes of the
simulation run: a reasonably globally unique run ID, the network NED type
name, the experiment-measurement-replication labels, the values of
iteration variables and the repetition counter, the date and time, the host
name, the process id of the simulation, random number seeds, configuration
options, and so on. These data can be useful during result processing, and
increase the reproducibility of the results.

<p>
Vectors are recorded into a separate file for practical reasons: vector
data usually consume several magnitudes more disk space than scalars.

<p><h3><a name="sec:ana-sim:output-vector-files"/>12.3.1 Output Vector Files<a class="headerlink" href="#sec:ana-sim:output-vector-files" title="Permalink to this headline"></a></h3>

<p>All output vectors from a simulation run are recorded into the same file.
The following sections describe the format of the file, and
how to process it.

<p>An example file fragment (without header):

<pre class="filelisting">
...
vector 1   net.host[12]  responseTime  TV
1  12.895  2355.66
1  14.126  4577.66664666
vector 2   net.router[9].ppp[0] queueLength  TV
2  16.960  2
1  23.086  2355.66666666
2  24.026  8
...
</pre>
<p>
There two types of lines: vector declaration lines (beginning with the word
<tt>vector</tt>), and data lines. A <i>vector declaration line</i>
introduces a new output vector, and its columns are: vector Id, module of
creation, name of <tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> object, and multiplicity (usually 1).
Actual data recorded in this vector are on <i>data lines</i> which begin
with the vector Id. Further columns on data lines are the simulation time
and the recorded value.

<p>
Since OMNeT++ 4.0, vector data are recorded into the file clustered by
output vectors, which, combined with index files, allows much more
efficient processing. Using the index file, tools can extract particular
vectors by reading only those parts of the file where the desired data are
located, and do not need to scan through the whole file linearly.

<p>
<h3><a name="sec:ana-sim:scalar-result-files"/>12.3.2 Scalar Result Files<a class="headerlink" href="#sec:ana-sim:scalar-result-files" title="Permalink to this headline"></a></h3>

<p>Fragment of an output scalar file (without header):

<pre class="filelisting">
...
scalar "lan.hostA.mac" "frames sent"  99
scalar "lan.hostA.mac" "frames rcvd"  3088
scalar "lan.hostA.mac" "bytes sent"   64869
scalar "lan.hostA.mac" "bytes rcvd"   3529448
...
</pre>
<p>
Every scalar generates one <tt>scalar</tt> line in the file.

<p>Statistics objects (<tt><a href="../api/classomnetpp_1_1cStatistic.html">cStatistic</a></tt> subclasses such as <tt><a href="../api/classomnetpp_1_1cStdDev.html">cStdDev</a></tt>)
generate several lines: mean, standard deviation, etc.

<p>

<p><h2><a name="sec:ana-sim:sqlite-result-files"/>12.4 SQLite Result Files<a class="headerlink" href="#sec:ana-sim:sqlite-result-files" title="Permalink to this headline"></a></h2>

<p>Starting from version 5.1, OMNeT++ contains experimental support for
saving simulation results into SQLite database files. The perceived advantage
of SQLite is existing support in many existing tools and languages (no need to
write custom parsers), and being able to use the power of the SQL language
for queries. The latter is very useful for processing scalar results, and less
so for vectors and histograms.

<p>To let a simulation record its results in SQLite format, add the following
configuration options to its <tt>omnetpp.ini</tt>:

<pre class="inifile">
outputvectormanager-class="omnetpp::envir::SqliteOutputVectorManager"
outputscalarmanager-class="omnetpp::envir::SqliteOutputScalarManager"
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
Alternatively, to make SQLite the default format, recompile OMNeT++ with
<tt>PREFER_SQLITE_RESULT_FILES=yes</tt> set in <tt>configure.user</tt>.
(Don't forget to also run  <tt>./configure</tt> before <tt>make</tt>.)
</ul>

<p>The SQLite result files will be created with the same names as textual
result files. The two formats also store exactly the same data, only in
a different way (there is one-to-one correspondence between them.) The
Simulation IDE and <tt>scavetool</tt> also understand both formats.

<p><ul class="hint"><b>HINT</b><br>
If you want to get acquainted with the organization of SQLite result
files, exploring one in a graphical tool such as SQLiteBrowser or SQLite
Studio should be a good start.
</ul>

<p>The database schema can be found in Appendix <a href="#cha:result-file-formats">[27]</a>.

<p>

<p><h2><a name="sec:ana-sim:scavetool"/>12.5 Scavetool<a class="headerlink" href="#sec:ana-sim:scavetool" title="Permalink to this headline"></a></h2>
<!--scavetool-->

<p>OMNeT++'s <tt>scavetool</tt> is a command-line program for exploring, filtering
and processing of result files, and exporting the result in formats
digestible by other tools.

<p><h3><a name="sec:ana-sim:scavetool:commands"/>12.5.1 Commands<a class="headerlink" href="#sec:ana-sim:scavetool:commands" title="Permalink to this headline"></a></h3>

<p><tt>scavetool</tt>'s functionality is grouped under five commands:
<tt>query</tt>, <tt>vector</tt>, <tt>scalar</tt>, <tt>index</tt>, and <tt>help</tt>.

<p><ul>

<p><li> <b>query</b>: Query the contents of result files. One can list
    runs, run attributes, result items, unique result names, unique module
    names, unique configuration names, etc. One can filter for result types
    (scalar/vector/histogram), and by run, module name, result name and value,
    using match expressions. There are various options controlling the format
    of the output (group-by-runs; grep-friendly; suppress labels; several
    modes for identifying the run in the output, etc.)

<p><li> <b>vector</b>: Filter and export vector data.  One can filter by run,
    module name and vector name, using match expressions. It is also possible
    to apply processing steps, i.e. a sliding window average or batch average
    filter. The list of available processing filters can be found in the
    help of the tool. Several output formats are available: vector file
    (default), CSV file, GNU Octave text file, MATLAB script.

<p><li> <b>scalar</b>: Filter and export scalar data. One can filter by run,
    module name, scalar name and value, using match expressions. In the output,
    scalars are organized in a table. The table can be organized to contain
    <i>Module</i>, <i>Name</i> and <i>Value</i> columns, or to have each
    scalar in its own column (and data from one run in each row). Other
    groupings are also possible. Several output formats are available: CSV file,
    GNU Octave text file, MATLAB script.

<p><li> <b>index</b>: Generate index files (.vci) for vector files. Note that this
    command is usually not needed, as other scavetool commands automatically create
    vector file indices if they are missing or out of date (unless indexing is
    explicitly disabled.) This command can also be used to rebuild a vector file
    so that data are clustered by vectors for more efficient access.

<p><li> <b>help</b>: Prints help. The synopsys is <tt>scavetool help &lt;topic&gt;</tt>,
    where any command name can be used as topic, plus there are
    additional ones like <tt>patterns</tt> or <tt>filters</tt>. <tt>scavetool
    &lt;command&gt; -h</tt> also works.

<p></ul>

<p>The default command is <tt>query</tt>, so its name may be omitted on the
command line.

<p>
<h3><a name="sec:ana-sim:scavetool:examples"/>12.5.2 Examples<a class="headerlink" href="#sec:ana-sim:scavetool:examples" title="Permalink to this headline"></a></h3>

<p>The following example prints a one-line summary about the contents of
result files in the currect directory:

<pre class="commandline">
$ scavetool *.sca *.vec
runs: 459   scalars: 4120   vectors: 7235   histograms: 916
</pre>
<p>
Listing all results is possible with <tt>-l</tt>:

<pre class="commandline">
$ scavetool -l *.sca *.vec
PureAlohaExperiment-439-20161216-18:56:20-27607:

scalar Aloha.server  duration              26.3156
scalar Aloha.server  collisionLength:mean  0.139814
vector Aloha.host[0] radioState:vector vectorId=2 count=3 mean=0.33 ..
vector Aloha.host[1] radioState:vector vectorId=3 count=9 mean=0.44 ..
vector Aloha.host[2] radioState:vector vectorId=4 count=5 mean=0.44 ..
...
</pre>
<p>
To export all scalars in CSV, use the following command:

<pre class="commandline">
$ scavetool scalar -g module,name -F csv -O x.csv *.sca
</pre>
<p>
The following example writes the window-averaged queuing times stored
in <tt>in.vec</tt> into <tt>out.vec</tt>:

<pre class="commandline">
$ scavetool vector -p "queuing time" -a winavg(10) -O out.vec in.vec
</pre>
<p>
The next example writes the queueing and transmission times of <tt>sink</tt>
modules into CSV files. It generates a separate file for each vector,
named <tt>out-1.csv</tt>, <tt>out-2.csv</tt>, etc.

<pre class="commandline">
$ scavetool vector -p 'module(**.sink) AND ("queueing time" OR "tx time")'
    -O out.csv -F csv in.vec
</pre>
<p>

<p><h2><a name="sec:ana-sim:result-analysis"/>12.6 Result Analysis<a class="headerlink" href="#sec:ana-sim:result-analysis" title="Permalink to this headline"></a></h2>

<p>We recommend the following routes for the analysis of simulation results:

<p><ol>
  <li> Use the <i>Simulation IDE</i> for casual analysis, i.e. browsing data
        and quick plotting.
  <li> Use <i>Python</i> (or R) programs for sophisticated analysis and for
        producing tailored reports.
</ol>

<p>Of courses, many other approaches are also possible, some of which are also
described in later sections. In all cases, <tt>scavetool</tt> can be used to
filter and export simulation results in a format understood by other tools, for
example CSV.

<p>
<h3><a name="sec:ana-sim:analysis-tool"/>12.6.1 The Analysis Tool in the Simulation IDE<a class="headerlink" href="#sec:ana-sim:analysis-tool" title="Permalink to this headline"></a></h3>

<p>The Simulation IDE provides an Analysis Tool for the analysis and visualization
of simulation results. The Analysis Tool lets you load several result files
at once, and presents their contents somewhat like a database. You can
browse the results, select the particular data you are interested in
(scalars, vectors, histograms), apply processing steps, and display them
in charts or plots. Data selection, processing and charting steps
can be freely combined, resulting in a high degree of freedom.
These steps are grouped into and stored as "recipes", which get automatically
re-applied when new result files are added or existing files are
replaced. This automation spares the user lots of repetitive manual work,
without resorting to scripting.

<p>The Analysis Tool is covered in detail in the User Guide.

<p>
<h3><a name="sec:ana-sim:spreadsheet-programs"/>12.6.2 Spreadsheets<a class="headerlink" href="#sec:ana-sim:spreadsheet-programs" title="Permalink to this headline"></a></h3>
<!--Spreadsheets-->

<p>Spreadsheets such as Excel or LibreOffice's Calc, with their charting and
statistical features, offer an obvious alternative to the IDE's Analysis Tool.
Spreadsheets are primarily good for analyzing scalar results, and less so for
vectors and histograms. A commonly available feature called <i>pivot table</i>
can be especially useful.

<p>Spreadsheets cannot open result files directly. An obvious solution is to use
<tt>scavetool</tt> (see <a href="#sec:ana-sim:scavetool">[12.5]</a>) to export data in CSV
(comma-separated vector) format, and open that in the spreadsheet program.
<tt>scavetool</tt> can also help you merge data from several result
files into a single CSV, and to filter the results to reduce the amount
of data to be loaded into the spreadsheet.

<p>One drawback of using spreadsheet programs is the manual work associated
with preparing and reloading data every time simulations are re-run.

<p>
<h3><a name="sec:ana-sim:using-python"/>12.6.3 Using Python for Result Analysis<a class="headerlink" href="#sec:ana-sim:using-python" title="Permalink to this headline"></a></h3>

<p>Python is a popular general-purpose programming language with a large ecosytem.
It is widely used in the open source community and also commercially in a great
number of application areas. Python is also among the most popular languages
for teaching introductory computer science courses at universities.

<p>In the recent years, Python has emerged as great platform for numerical
computing and statistics due to the appearance of powerful extension packages
like NumPy and Pandas. Some of the Python packages useful for our purposes:

<p><ul>
  <li> <i>NumPy</i> and <i>SciPy</i> are numerical and scientific computing
    packages.

<p>  <li> <i>PANDAS</i> is a data analysis package for Python. The design of
    Pandas has been heavily influenced by R's data frames.

<p>  <li> <i>MatPlotlib</i> is a plotting library. MatPlotlib provides a
    &#8220;pylab&#8221; API designed to closely resemble that of MATLAB, thereby making
    it easy to learn for experienced MATLAB users.

<p>  <li> The <i>sqlite3</i> package makes it possible to access SQLite3
    databases from Python. Its significance is that it allows for working
    with OMNeT++ SQLite result files (see <a href="#sec:ana-sim:sqlite-result-files">[12.4]</a>).

<p></ul>

<p>
<h3><a name="sec:ana-sim:alternative-tools"/>12.6.4 Using Other Software<a class="headerlink" href="#sec:ana-sim:alternative-tools" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:ana-sim:gnu-r"/>12.6.4.1 GNU R<a class="headerlink" href="#sec:ana-sim:gnu-r" title="Permalink to this headline"></a></h4>

<p>R is a free software environment for statistical computing and graphics.
R is widely used for statistical software development and data analysis.
The program uses a command line interface, though several graphical user
interfaces are available. It has powerful plotting capabilities,
and it is supported on all major operating systems and platforms.

<p><ul class="hint"><b>HINT</b><br>
An R package for OMNeT++ result processing is available from
<a href="https://github.com/omnetpp/omnetpp-resultfiles/wiki">https://github.com/omnetpp/omnetpp-resultfiles/wiki</a>.
The package supports loading the contents of OMNeT++ result files into R,
organizing the data and creating various plots and charts.
The package is well documented, and the web site offers a Tutorial, a Tips
page, a tutorial for the Scalar Lattice GUI package, and other information.
</ul>

<p>Some other OMNeT++-related packages such as SimProcTC and Syntony also build
on R.

<p><h4><a name="sec:ana-sim:matlab-or-octave"/>12.6.4.2 MATLAB, GNU Octave<a class="headerlink" href="#sec:ana-sim:matlab-or-octave" title="Permalink to this headline"></a></h4>

<p>MATLAB is a commercial numerical computing environment and programming language.
MATLAB allows easy matrix manipulation, plotting of functions and data,
implementation of algorithms, creation of user interfaces, and interfacing
with programs in other languages.

<p>GNU Octave is an MATLAB-like software environment, available on nearly all
platforms. Octave is free software.

<p><h4><a name="sec:ana-sim:gnuplot"/>12.6.4.3 Gnuplot<a class="headerlink" href="#sec:ana-sim:gnuplot" title="Permalink to this headline"></a></h4>

<p>Gnuplot is a simple but popular program for creating two- and three-dimensional
plots of functions and data. The program runs on all major platforms.

<p>Gnuplot has an interactive command interface. For example, given two
data files <tt>foo.csv</tt> and <tt>bar.csv</tt> that contain
two values per line (<i>x</i> <i>y</i>; such files can be exported with
<tt>scavetool</tt> from vector files), you can plot them in the same
graph by typing:

<pre class="commandline">
plot "foo.csv" with lines, "bar.csv" with lines
</pre>
<p>
Several commands are available to adjust the x/y ranges, plotting style, labels,
scaling. The plot can be exported in various image formats.

<p>

<hr class='pgbr'><h1><a name="cha:eventlog"/>13 Eventlog<a class="headerlink" href="#cha:eventlog" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:eventlog:introduction"/>13.1 Introduction<a class="headerlink" href="#sec:eventlog:introduction" title="Permalink to this headline"></a></h2>

<p>The eventlog feature and related tools have been added to OMNeT++ with the aim of
helping the user understand complex simulation models and correctly implement the
desired component behaviors. Using these tools, one can examine details of recorded
history of a simulation, focusing on the behavior instead of the statistical results.

<p>The eventlog file is created automatically during a simulation run upon explicit request
configurable in the ini file. The resulting file can be viewed in the OMNeT++ IDE using
the Sequence Chart and the Eventlog Table or can be processed by the command line Eventlog
Tool. These tools support filtering the collected data to allow you to focus on events
relevant to what you are looking for. They allow examining causality relationships and
provide filtering based on simulation times, event numbers, modules and messages.

<p>The simulation kernel records into the eventlog among others: user level messages,
creation and deletion of modules, gates and connections, scheduling of self messages,
sending of messages to other modules either through gates or directly, and processing of
messages (that is events). Optionally, detailed message data can also be automatically
recorded based on a message filter. The result is an eventlog file which contains detailed
information of the simulation run and later can be used for various purposes.

<p><ul class="note"><b>NOTE</b><br>
    The eventlog file may become quite large for long-running simulations
    (often hundreds of megabytes, but occasionally several gigabytes), especially
    when message detail recording is turned on.
</ul>

<p><h2><a name="sec:eventlog:configuration"/>13.2 Configuration<a class="headerlink" href="#sec:eventlog:configuration" title="Permalink to this headline"></a></h2>

<p>To record an eventlog file during the simulation, insert the following line into
the ini file:

<pre class="inifile">
record-eventlog = true
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    Eventlog recording is turned off by default, because creating the eventlog file
    might significantly decrease the overall simulation performance.
</ul>

<p><h3><a name="sec:eventlog:file-name"/>13.2.1 File Name<a class="headerlink" href="#sec:eventlog:file-name" title="Permalink to this headline"></a></h3>

<p>The simulation kernel will write the eventlog file during the simulation into the file
specified by the following ini file configuration entry (showing the default file name
pattern here):

<pre class="inifile">
eventlog-file = ${resultdir}/${configname}-${runnumber}.elog
</pre>
<p>
<h3><a name="sec:eventlog:recording-intervals"/>13.2.2 Recording Intervals<a class="headerlink" href="#sec:eventlog:recording-intervals" title="Permalink to this headline"></a></h3>

<p>The size of an eventlog file is approximately proportional to the number of
events it contains. To reduce the file size and speed up the simulation, it
might be useful to record only certain events. The
<tt>eventlog-recording-intervals</tt> configuration option instructs the
kernel to record events only in the specified intervals. The syntax is
similar to that of <tt>vector-recording-intervals</tt>.

<p>An example:

<pre class="inifile">
eventlog-recording-intervals = ..10.2, 22.2..100, 233.3..
</pre>
<p>
<h3><a name="sec:eventlog:recording-modules"/>13.2.3 Recording Modules<a class="headerlink" href="#sec:eventlog:recording-modules" title="Permalink to this headline"></a></h3>

<p>Another factor that affects the size of an eventlog file is the number of
modules for which the simulation kernel records events during the
simulation. The <tt>module-eventlog-recording</tt> per-module configuration
option instructs the kernel to record only the events that occurred in the
matching modules. The default is to record events from all modules. This
configuration option only applies to simple modules.

<p>The following example records events from any of the routers whose index is
between 10 and 20, and turns off recording for all other modules.

<pre class="inifile">
**.router[10..20].**.module-eventlog-recording = true
**.module-eventlog-recording = false
</pre>
<p>
<h3><a name="sec:eventlog:recording-messages"/>13.2.4 Recording Message Data<a class="headerlink" href="#sec:eventlog:recording-messages" title="Permalink to this headline"></a></h3>

<p>Since recording message data dramatically increases the size of the
eventlog file and also slows down the simulation, it is turned off by
default, even if writing the eventlog is enabled. To turn on message data
recording, supply a value for the <tt>eventlog-message-detail-pattern</tt>
option in the ini file.

<p>

An example configuration for an IEEE 80211 model that records the <tt>encapsulationMsg</tt> field
and all other fields whose name ends in <tt>Address</tt>, from messages whose class name ends in
<tt>Frame</tt> looks like this:

<pre class="inifile">
eventlog-message-detail-pattern = *Frame:encapsulatedMsg,*Address
</pre>
<p>
An example configuration for a TCP/IP model that records the port and address
fields in all network packets looks like the following:

<pre class="inifile">
eventlog-message-detail-pattern =
 PPPFrame:encapsulatedPacket|IPDatagram:encapsulatedPacket,*Address|TCPSegment:*Port
</pre>
<p>
% <pre class="inifile">
% eventlog-message-detail-pattern = WirelessFrame:declaredOn(WirelessFrame) or bitLength
%</pre>

<p>
<h2><a name="sec:eventlog:eventlog-tool"/>13.3 Eventlog Tool<a class="headerlink" href="#sec:eventlog:eventlog-tool" title="Permalink to this headline"></a></h2>

<p>The Eventlog Tool is a command line tool to process eventlog files. Invoking it without
parameters will display usage information. The following are the most useful commands for users.

<p><h3><a name="sec:eventlog:filter"/>13.3.1 Filter<a class="headerlink" href="#sec:eventlog:filter" title="Permalink to this headline"></a></h3>

<p>The eventlog tool provides off line filtering that is usually applied to the eventlog file
after the simulation has been finished and before actually opening it in the OMNeT++ IDE
or processing it by any other means. Use the filter command and its various options to
specify what should be present in the result file.

<p><h3><a name="sec:eventlog:echo"/>13.3.2 Echo<a class="headerlink" href="#sec:eventlog:echo" title="Permalink to this headline"></a></h3>

<p>Since the eventlog file format is text based and users are encouraged to implement their
own filters, a way is needed to check whether an eventlog file is
correct. The echo command provides a way to check this and help users creating custom
filters. Anything not echoed back by the eventlog tool will not be taken into
consideration by the other tools found in the OMNeT++ IDE.

<p><ul class="note"><b>NOTE</b><br>
    Custom filter tools should filter out whole events only, otherwise the
    consequences are undefined.
</ul>

<hr class='pgbr'><h1><a name="cha:neddoc"/>14 Documenting NED and Messages<a class="headerlink" href="#cha:neddoc" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:neddoc:overview"/>14.1 Overview<a class="headerlink" href="#sec:neddoc:overview" title="Permalink to this headline"></a></h2>

<p>OMNeT++ provides a tool which can generate HTML documentation from NED files
and message definitions. Like Javadoc and Doxygen, the NED documentation tool
makes use of source code comments. The generated HTML documentation
lists all modules, channels, messages, etc., and presents their details including
description, gates, parameters, assignable submodule parameters, and
syntax-highlighted source code. The documentation also includes clickable
network diagrams (exported from the graphical editor) and usage diagrams as
well as inheritance diagrams.

<p>The documentation tool integrates with Doxygen, meaning that it can
hyperlink simple modules and message classes to their C++ implementation
classes in the Doxygen documentation. If the C++ documentation is generated
with some Doxygen features turned on (such as <i>inline-sources</i> and
<i>referenced-by-relation</i>, combined with <i>extract-all</i>,
<i>extract-private</i> and <i>extract-static</i>), the result is an
easily browsable and very informative presentation of the source code.

<p>NED documentation generation is available as part of the OMNeT++ IDE.

<p>
<h2><a name="sec:neddoc:documentation-comments"/>14.2 Documentation Comments<a class="headerlink" href="#sec:neddoc:documentation-comments" title="Permalink to this headline"></a></h2>

<p>Documentation is embedded in normal comments. All <tt>//</tt> comments
that are in the &#8220;right place&#8221; (from the documentation tool's
point of view) will be included in the generated documentation.
  <br><ul><font size=-1>[In contrast, Javadoc and Doxygen use special comments (those
     beginning with <tt>/**</tt>, <tt>///</tt>, <tt>//&lt;</tt> or a similar
     marker) to distinguish documentation from &#8220;normal&#8221; comments in the
     source code. In OMNeT++ there is no need for that: NED and the message
     syntax is so compact that practically all comments one would want to write
     in them can serve documentation purposes.]</font></ul>

<p>Example:

<pre class="ned">
//
// An ad-hoc traffic generator to test the Ethernet models.
//
simple Gen
{
    parameters:
        string destAddress;  // destination MAC address
        int protocolId;      // value for SSAP/DSAP in Ethernet frame
        double waitMean @unit(s); // mean for exponential interarrival times
    gates:
        output out;  // to Ethernet LLC
}
</pre>
<p>
One can also place comments above parameters and gates, which is better
suited for long explanations. Example:

<pre class="ned">
//
// Deletes packets and optionally keeps statistics.
//
simple Sink
{
    parameters:
        // Turns statistics generation on/off. This is a very long
        // comment because it has to be described what statistics
        // are collected.
        bool collectStatistics = default(true);
    gates:
        input in;
}
</pre>
<p>
<h3><a name="sec:neddoc:private-comments"/>14.2.1 Private Comments<a class="headerlink" href="#sec:neddoc:private-comments" title="Permalink to this headline"></a></h3>

<p>Lines that start with <tt>//#</tt> will not appear in the generated
documentation. Such lines can be used to make &#8220;private&#8221; comments like
<tt>FIXME</tt> or <tt>TODO</tt>, or to comment out unused code.

<pre class="ned">
//
// An ad-hoc traffic generator to test the Ethernet models.
//# TODO above description needs to be refined
//
simple Gen
{
    parameters:
        string destAddress;  // destination MAC address
        int protocolId;      // value for SSAP/DSAP in Ethernet frame
        //# double burstiness;  -- not yet supported
        double waitMean @unit(s); // mean for exponential interarrival times
    gates:
        output out;  // to Ethernet LLC
}
</pre>
<p>

<p><h3><a name="sec:neddoc:comment-placement"/>14.2.2 More on Comment Placement<a class="headerlink" href="#sec:neddoc:comment-placement" title="Permalink to this headline"></a></h3>

<p>Comments should be written where the tool will find them.
This is a) immediately above the documented item, or b) after the
documented item, on the same line.

<p>In the former case, make sure there is no blank line left
between the comment and the documented item. Blank lines
detach the comment from the documented item.

<p>Example:
<pre class="ned">
// This is wrong! Because of the blank line, this comment is not
// associated with the following simple module!

simple Gen
{
    ...
}
</pre>

<p>Do not try to comment groups of parameters together. The result
will be awkward.

<p><h2><a name="sec:neddoc:referring-to-other-ned-and-message-types"/>14.3 Referring to Other NED and Message Types<a class="headerlink" href="#sec:neddoc:referring-to-other-ned-and-message-types" title="Permalink to this headline"></a></h2>

<p>One can reference other NED and message types by name in comments. There
are two styles in which references can be written: automatic linking and
tilde linking. The same style must be following throughout the whole
project, and the correct one must be selected in the documentation
generator tool when it is run.

<p><h3><a name="sec:neddoc:automatic-linking"/>14.3.1 Automatic Linking<a class="headerlink" href="#sec:neddoc:automatic-linking" title="Permalink to this headline"></a></h3>

<p>In the automatic linking style, words that match existing NED of message
types are hyperlinked automatically. It is usually enough to write the
simple name of the type (e.g. <tt>TCP</tt>), one does not need to spell out the
fully qualified type (<tt>inet.transport.tcp.TCP</tt>), although that is also
allowed.

<p>Automatic hyperlinking is sometimes overly agressive. For example, when the
words <i>IP address</i> appear in a comment and the project contains an
<tt>IP</tt> module, it will create a hyperlink to the module, which is not
desirable. One can prevent hyperlinking of a word by inserting a
backslash in front it: <tt>\IP address</tt>. The backslash will
not appear in the HTML output. The <tt>&lt;nohtml&gt;</tt> tag will also prevent
hyperlinking words in the enclosed text: <tt>&lt;nohtml&gt;IP address&lt;/nohtml&gt;</tt>.
On the other hand, if a backslash needs to be printed immediately
in front of a word (e.g. output <i>&#8220;use \t to print a Tab&#8221;</i>),
use either two backslashes (<tt>use \\t...</tt>) or the
<tt>&lt;nohtml&gt;</tt> tag (<tt>&lt;nohtml&gt;use \t...&lt;/nohtml&gt;</tt>).
Backslashes in other contexts (i.e. when not in front of a word) do not have
a special meaning, and are preserved in the output.

<p>The detailed rules:

<p><ol>
  <li> Words matching a type name are automatically hyperlinked
  <li> A backslash immediately followed by an identifier (i.e. letter or underscore)
        prevents hyperlinking, and the backslash is removed from the output
  <li> A double backslash followed by an identifier produces a single backslash,
        plus the potentially hyperlinked identifier
  <li> Backslashes in any other contexts are not interpreted, and preserved in the output
  <li> Tildes are not interpreted, and are preserved in the output
  <li> Inside <tt>&lt;nohtml&gt;</tt>, no backslash processing or hyperlinking takes place
</ol>

<p><h3><a name="sec:neddoc:tilde-linking"/>14.3.2 Tilde Linking<a class="headerlink" href="#sec:neddoc:tilde-linking" title="Permalink to this headline"></a></h3>

<p>In the tilde style, only words that are explicitly marked with a tilde are
subject to hyperlinking: <tt>~TCP</tt>,
<tt>~inet.transport.tcp.TCP</tt>.

<p>To produce a literal tilde followed by an identifier in the output (for example,
to output <i>&#8220;the ~TCP() destructor&#8221;</i>), the tilde character
needs to be doubled: <tt>the ~~TCP() destructor</tt>.

<p>The detailed rules:

<p><ol>
  <li> Words matching a type name are <i>not</i> hyperlinked automatically
  <li> A tilde immediately followed by an identifier (i.e. letter or underscore)
        will be hyperlinked, and the tilde is removed from the output. It is
        considered an error if there is no type with that name.
  <li> A double tilde followed by an identifier produces a single tilde plus the identifier
  <li> Tildes in any other contexts are not interpreted, and preserved in the output
  <li> Backslashes are not interpreted, and are preserved in the output
  <li> Inside <tt>&lt;nohtml&gt;</tt>, no tilde processing or hyperlinking takes place
</ol>

<p><h2><a name="sec:neddoc:text-layout-and-formatting"/>14.4 Text Layout and Formatting<a class="headerlink" href="#sec:neddoc:text-layout-and-formatting" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:neddoc:paragraphs-and-lists"/>14.4.1 Paragraphs and Lists<a class="headerlink" href="#sec:neddoc:paragraphs-and-lists" title="Permalink to this headline"></a></h3>

<p>When writing documentation comments longer than a few sentences, one often
needs structuring and formatting facilities. NED provides paragraphs,
bulleted and numbered lists, and basic formatting support. More
sophisticated formatting can be achieved using HTML.

<p>Paragraphs can be created by separating text by blanks lines. Lines
beginning with &#8220;<tt>-</tt>&#8221; will be turned into bulleted lists, and lines
beginning with &#8220;<tt>-#</tt>&#8221; into numbered lists. An example:

<pre class="ned">
//
// Ethernet MAC layer. MAC performs transmission and reception of frames.
//
// Processing of frames received from higher layers:
// - sends out frame to the network
// - no encapsulation of frames -- this is done by higher layers.
// - can send PAUSE message if requested by higher layers (PAUSE protocol,
//   used in switches). PAUSE is not implemented yet.
//
// Supported frame types:
// -# IEEE 802.3
// -# Ethernet-II
//
</pre>
<p>

<p><h3><a name="sec:neddoc:special-tags"/>14.4.2 Special Tags<a class="headerlink" href="#sec:neddoc:special-tags" title="Permalink to this headline"></a></h3>

<p>The documentation tool understands the following tags and will render them accordingly:
<tt>@author</tt>, <tt>@date</tt>, <tt>@todo</tt>, <tt>@bug</tt>, <tt>@see</tt>, <tt>@since</tt>,
<tt>@warning</tt>, <tt>@version</tt>. Example usage:

<pre class="ned">
//
// @author Jack Foo
// @date 2005-02-11
//
</pre>
<p>

<p><h3><a name="sec:neddoc:text-formatting-using-html"/>14.4.3 Text Formatting Using HTML<a class="headerlink" href="#sec:neddoc:text-formatting-using-html" title="Permalink to this headline"></a></h3>

<p>Common HTML tags are understood as formatting commands.
The most useful tags are: <tt>&lt;i&gt;..&lt;/i&gt;</tt> (italic),
<tt>&lt;b&gt;..&lt;/b&gt;</tt> (bold), <tt>&lt;tt&gt;..&lt;/tt&gt;</tt> (typewriter font),
<tt>&lt;sub&gt;..&lt;/sub&gt;</tt> (subscript), <tt>&lt;sup&gt;..&lt;/sup&gt;</tt> (superscript),
<tt>&lt;br&gt;</tt> (line break), <tt>&lt;h3&gt;</tt> (heading),
<tt>&lt;pre&gt;..&lt;/pre&gt;</tt> (preformatted text) and <tt>&lt;a href=..&gt;..&lt;/a&gt;</tt> (link),
as well as a few other tags used for table creation (see below).
For example, <tt>&lt;i&gt;Hello&lt;/i&gt;</tt> will be rendered as &#8220;<i>Hello</i>&#8221;
(using an italic font).

<p>The complete list of HTML tags interpreted by the documentation tool are:
<tt>&lt;a&gt;</tt>, <tt>&lt;b&gt;</tt>, <tt>&lt;body&gt;</tt>, <tt>&lt;br&gt;</tt>, <tt>&lt;center&gt;</tt>,
<tt>&lt;caption&gt;</tt>, <tt>&lt;code&gt;</tt>, <tt>&lt;dd&gt;</tt>, <tt>&lt;dfn&gt;</tt>, <tt>&lt;dl&gt;</tt>,
<tt>&lt;dt&gt;</tt>, <tt>&lt;em&gt;</tt>, <tt>&lt;form&gt;</tt>, <tt>&lt;font&gt;</tt>, <tt>&lt;hr&gt;</tt>,
<tt>&lt;h1&gt;</tt>, <tt>&lt;h2&gt;</tt>, <tt>&lt;h3&gt;</tt>, <tt>&lt;i&gt;</tt>, <tt>&lt;input&gt;</tt>, <tt>&lt;img&gt;</tt>,
<tt>&lt;li&gt;</tt>, <tt>&lt;meta&gt;</tt>, <tt>&lt;multicol&gt;</tt>, <tt>&lt;ol&gt;</tt>, <tt>&lt;p&gt;</tt>, <tt>&lt;small&gt;</tt>,
<tt>&lt;span&gt;</tt>, <tt>&lt;strong&gt;</tt>,
<tt>&lt;sub&gt;</tt>, <tt>&lt;sup&gt;</tt>, <tt>&lt;table&gt;</tt>, <tt>&lt;td&gt;</tt>, <tt>&lt;th&gt;</tt>, <tt>&lt;tr&gt;</tt>,
<tt>&lt;tt&gt;</tt>, <tt>&lt;kbd&gt;</tt>, <tt>&lt;ul&gt;</tt>, <tt>&lt;var&gt;</tt>.

<p>Any tags not in the above list will not be interpreted as formatting commands
but will be printed verbatim -- for example, <tt>&lt;what&gt;bar&lt;/what&gt;</tt>
will be rendered literally as &#8220;&lt;what&gt;bar&lt;/what&gt;&#8221; (unlike HTML where
unknown tags are simply ignored, i.e. HTML would display &#8220;bar&#8221;).

<p>With links to external pages or web sites, its useful to add the
<tt>target="_blank"</tt> attribute to ensure pages come up in a new browser
tab, and not in the current frame. Alternatively, one can use the
<tt>target="_top"</tt> attribute which replaces all frames in the current
browser.

<p>Examples:

<pre class="ned">
//
// For more info on Ethernet and other LAN standards, see the
// &lt;a href="http://www.ieee802.org/" target="_blank"&gt;IEEE 802
// Committee's site&lt;/a&gt;.
//
</pre>
<p>
One can also use the <tt>&lt;a href=..&gt;</tt> tag to create links within the page:

<pre class="ned">
//
// See the &lt;a href="#resources"&gt;resources&lt;/a&gt; in this page.
// ...
// &lt;a name="resources"&gt;&lt;b&gt;Resources&lt;/b&gt;&lt;/a&gt;
// ...
//
</pre>
<p>
One can use the <tt>&lt;pre&gt;..&lt;/pre&gt;</tt> HTML tag to insert source code examples
into the documentation. Line breaks and indentation will be preserved,
but HTML tags continue to be interpreted (they can be turned off with
<tt>&lt;nohtml&gt;</tt>, see later).

<p>Example:

<pre class="ned">
// &lt;pre&gt;
// // my preferred way of indentation in C/C++ is this:
// &lt;b&gt;for&lt;/b&gt; (&lt;b&gt;int&lt;/b&gt; i = 0; i &lt; 10; i++) {
//     printf(&lt;i&gt;"%d\n"&lt;/i&gt;, i);
// }
// &lt;/pre&gt;
</pre>
<p>
will be rendered as

<p><pre class="verbatim">
// my preferred way of indentation in C/C++ is this:
<b>for</b> (<b>int</b> i = 0; i &lt; 10; i++) {
    printf(<i>"%d\n"</i>, i);
}
</pre>

<p>HTML is also the way to create tables. The example below

<pre class="ned">
//
// &lt;table border="1"&gt;
//   &lt;tr&gt;  &lt;th&gt;#&lt;/th&gt; &lt;th&gt;number&lt;/th&gt; &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;1&lt;/td&gt; &lt;td&gt;one&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;2&lt;/td&gt; &lt;td&gt;two&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;3&lt;/td&gt; &lt;td&gt;three&lt;/td&gt;  &lt;/tr&gt;
// &lt;/table&gt;
//
</pre>
<p>
will be rendered approximately as:

<p><table border>
<TR> <TD align=left>

<p><b>#</b> </TD> <TD align=left> <b>number</b> </TD></TR>
<TR> <TD align=left> 1 </TD> <TD align=left> one </TD></TR>
<TR> <TD align=left> 2 </TD> <TD align=left> two </TD></TR>
<TR> <TD align=left> 3 </TD> <TD align=left> three </TD></TR>
</table>

<p>
<h3><a name="sec:neddoc:escaping-html-tags"/>14.4.4 Escaping HTML Tags<a class="headerlink" href="#sec:neddoc:escaping-html-tags" title="Permalink to this headline"></a></h3>

<p>In some cases, one needs to turn off interpreting HTML tags (<tt>&lt;i&gt;</tt>,
<tt>&lt;b&gt;</tt>, etc.) as formatting, and rather include them as literal text in
the generated documentation. This can be achieved by surrounding the text
with the <tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> tag. For example,

<pre class="ned">
// Use the &lt;nohtml&gt;&lt;i&gt;&lt;/nohtml&gt; tag (like &lt;tt&gt;&lt;nohtml&gt;&lt;i&gt;this&lt;/i&gt;&lt;/nohtml&gt;&lt;tt&gt;)
// to write in &lt;i&gt;italic&lt;/i&gt;.
</pre>
<p>
will be rendered as &#8220;Use the &lt;i&gt; tag (like <tt>&lt;i&gt;this&lt;/i&gt;</tt>) to write
in <i>italic</i>.&#8221;

<p><tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> will also prevent <tt>opp_neddoc</tt>
from hyperlinking words that are accidentally the same as an existing
module or message name. Prefixing the word with a backslash will achieve
the same. That is, either of the following will do:

<pre class="ned">
// In &lt;nohtml&gt;IP&lt;/nohtml&gt; networks, routing is...
</pre>
<p>
<pre class="ned">
// In \IP networks, routing is...
</pre>

<p>Both will prevent hyperlinking the word <i>IP</i> in case there is an
<tt>IP</tt> module in the project.

<p>

<p><h2><a name="sec:neddoc:customizing-and-adding-pages"/>14.5 Customizing and Adding Pages<a class="headerlink" href="#sec:neddoc:customizing-and-adding-pages" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:neddoc:adding-custom-title-page"/>14.5.1 Adding a Custom Title Page<a class="headerlink" href="#sec:neddoc:adding-custom-title-page" title="Permalink to this headline"></a></h3>

<p>The title page is the one that appears in the main frame after opening the
documentation in the browser. By default, it contains a boilerplate text
with the title <i>&#8220;OMNeT++ Model Documentation&#8221;</i>. Model authors will
probably want to customize that, and at least change the title be more
specific.

<p>A title page is defined with a <tt>@titlepage</tt> directive. It needs to
appear in a file-level comment.

<p><ul class="note"><b>NOTE</b><br>
A file-level comment is one that appears at the top of a NED file, and is
separated from any other NED content by at least one <i>blank line</i>.
</ul>

<p>While one can place the title page definition into any NED or MSG file, it is
probably a good idea to create a dedicated NED file for it. Lines up to the
next <tt>@page</tt> line or the end of the comment (whichever comes first) are
interpreted as part of the page.

<p>The page should start with a title, as the documentation tool doesn't add
one. Use the <tt>&lt;h1&gt;..&lt;/h1&gt;</tt> HTML tag for that.

<p>Example:

<pre class="ned">
//
// @titlepage
// &lt;h1&gt;Ethernet Model Documentation&lt;/h1&gt;
//
// This documents the Ethernet model created by David Wu and refined by Andras
// Varga at CTIE, Monash University, Melbourne, Australia.
//
</pre>
<p>

<p><h3><a name="sec:neddoc:adding-extra-pages"/>14.5.2 Adding Extra Pages<a class="headerlink" href="#sec:neddoc:adding-extra-pages" title="Permalink to this headline"></a></h3>

<p>One can add new pages to the documentation using the <tt>@page</tt> directive.
<tt>@page</tt> may appear in any file-level comment, and has the following
syntax:

<pre class="ned">
// @page filename.html, Title of the Page
</pre>
<p>
Choose a file name that doesn't collide with other files generated
by the documentation tool. If the file name does not end in <tt>.html</tt>,
it will be appended. The page title will appear at the top of
the page as well as in the page index.

<p>The lines after the <tt>@page</tt> line up to the next <tt>@page</tt> line or the
end of the comment will be used as the page body. One does not need to add
a title because the documentation tool automatically inserts the one
specified in the <tt>@page</tt> directive.

<p>Example:
<pre class="ned">
//
// @page structure.html, Directory Structure
//
// The model core model files and the examples have been placed
// into different directories. The &lt;tt&gt;examples/&lt;/tt&gt; directory...
//
//
// @page examples.html, Examples
// ...
//
</pre>

<p>One can create links to the generated pages using standard HTML,
using the <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag. All HTML files are
placed in a single directory, so one doesn't have to worry about
directories.

<p>Example:
<pre class="ned">
//
// @titlepage
// ...
// The structure of the model is described &lt;a href="structure.html"&gt;here&lt;/a&gt;.
//
</pre>

<p>
<h3><a name="sec:neddoc:externally-created-pages"/>14.5.3 Incorporating Externally Created Pages<a class="headerlink" href="#sec:neddoc:externally-created-pages" title="Permalink to this headline"></a></h3>

<p>The <tt>@externalpage</tt> directive allows one to add externally created
pages into the generated documentation. <tt>@externalpage</tt> may appear
in a file-level comment, and has a similar syntax as <tt>@page</tt>:

<pre class="ned">
// @externalpage filename.html, Title of the Page
</pre>
<p>
The directive causes the page to appear in the page index. However, the
documentation tool does not check if the page exists, and it is the user's
responsibility to copy the file into the directory of the generated
documentation.

<p>External pages can be linked to from other pages using the <tt>&lt;a
href="..."&gt;...&lt;/a&gt;</tt> tag.

<p>
<h2><a name="sec:neddoc:file-inclusion"/>14.6 File Inclusion<a class="headerlink" href="#sec:neddoc:file-inclusion" title="Permalink to this headline"></a></h2>

<p>The <tt>@include</tt> directive allows one to include the content of a file
into a documentation comment. <tt>@include</tt> expects file name or path; if
a relative path is given, it is interpreted as relative to the file that
includes it.

<p>The line of the <tt>@include</tt> directive will be replaced by the
content of the file. The lines of the included file do not need
to start with <tt>//</tt>, but otherwise they are processed in the same way
as the NED comments. They can include other files, but circular
includes are not allowed.

<pre class="ned">
// ...
// @include ../copyright.txt
// ...
</pre>
<p>
<hr class='pgbr'><h1><a name="cha:testing"/>15 Testing<a class="headerlink" href="#cha:testing" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:testing:overview"/>15.1 Overview<a class="headerlink" href="#sec:testing:overview" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:testing:verification-validation"/>15.1.1 Verification, Validation<a class="headerlink" href="#sec:testing:verification-validation" title="Permalink to this headline"></a></h3>

<p>Correctness of the simulation model is a primary concern of the developers
and users of the model, because they want to obtain credible simulation
results. Verification and validation are activities conducted during the
development of a simulation model with the ultimate goal of producing an
accurate and credible model.

<p><ul>
<li> <b>Verification</b> of a model is the process of confirming that it is
    correctly implemented with respect to the conceptual model, that is, it
    matches specifications and assumptions deemed acceptable for the given
    purpose of application. During verification, the model is tested to find
    and fix errors in the implementation of the model.
<li> <b>Validation</b> checks the accuracy of the model's representation of
    the real system. Model validation is defined to mean &#8220;substantiation that
    a computerized model within its domain of applicability possesses a
    satisfactory range of accuracy consistent with the intended application of
    the model&#8221;. A model should be built for a specific purpose or set of
    objectives and its validity determined for that purpose.
</ul>

<p>Of the two, verification is essentially a software engineering issue, so it
can be assisted with tools used for software quality assurance, for example
testing tools. Validation is not a software engineering issue.

<p><h3><a name="sec:testing:unit-testing-regression-testing"/>15.1.2 Unit Testing, Regression Testing<a class="headerlink" href="#sec:testing:unit-testing-regression-testing" title="Permalink to this headline"></a></h3>

<p>As mentioned above, software testing techniques can be of significant help
during model verification. Testing can also help to ensure that
a simulation model that once passed validation and verification will also
remain correct for an extended period.

<p>Software testing is an art on its own, with several techniques and
methodologies. Here we'll only mention two types that are important for us,
regression testing and unit testing.

<p><ul>
<li> <b>Regression testing</b> is a technique that seeks to uncover new
    software bugs, or regressions, in existing areas of a system after changes
    such as enhancements, patches or configuration changes, have been made to
    them.
<li> <b>Unit testing</b> is a method by which individual units of
    source code are tested to determine if they are fit for use. In an
    object-oriented environment, this is usually done at the class level.
</ul>

<p>The two may overlap; for example, unit tests are also useful for discovering
regressions.

<p>One way of performing regression testing on an OMNeT++ simulation model is
to record the log produced during simulation, and compare it to a
pre-recorded log. The drawback is that code refactoring may nontrivially
change the log as well, making it impossible to compare to the pre-recorded
one. Alternatively, one may just compare the result files or only certain
simulation results and be free of the refactoring effects, but then certain
regressions may escape the testing. This type of tradeoff seems to be
typical for regression testing.

<p>Unit testing of simulation models may be done on class level or module
level. There are many open-source unit testing frameworks for C++, for
example CppUnit, Boost Test, Google Test, UnitTest++, just to name a few.
They are well suited for class-level testing. However, they are usually
cumbersome to apply to testing modules due to the peculiarities of the
domain (network simulation) and OMNeT++.

<p>A test in an <i>xUnit</i>-type testing framework (a collective name for
CppUnit-style frameworks) operates with various assertions to test
function return values and object states. This approach is difficult to
apply to the testing of OMNeT++ modules that often operate in a complex
environment (cannot be easily instantiated and operated in isolation),
react to various events (messages, packets, signals, etc.), and have
complex dynamic behavior and substantial internal state.

<p>Later sections will introduce <tt>opp_test</tt>, a tool OMNeT++ provides
for assisting various testing task; and summarize various testing methods
useful for testing simulation models.

<p>
<h2><a name="sec:testing:opptest"/>15.2 The opp_test Tool<a class="headerlink" href="#sec:testing:opptest" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:testing:opptest:introduction"/>15.2.1 Introduction<a class="headerlink" href="#sec:testing:opptest:introduction" title="Permalink to this headline"></a></h3>

<p>This section documents the <tt>opp_test</tt>, a versatile tool that is
helpful for various testing scenarios. <tt>opp_test</tt> can be used for
various types of tests, including unit tests and regression tests. It was
originally written for testing the OMNeT++ simulation kernel, but it is
equally suited for testing functions, classes, modules, and whole
simulations.

<p><tt>opp_test</tt> is built around a simple concept: it lets one define
simulations in a concise way, runs them, and checks that the output (result
files, log, etc.) matches a predefined pattern or patterns. In many cases,
this approach works better than inserting various assertions into the code
(which is still also an option).

<p>Each test is a single file, with the <tt>.test</tt> file extension. All NED
code, C++ code, ini files and other data necessary to run the test case as
well as the PASS criteria are packed together in the test file. Such
self-contained tests are easier to handle, and also encourage authors to
write tests that are compact and to the point.

<p>Let us see a small test file, <tt>cMessage_properties_1.test</tt>:

<pre class="filelisting">
%description:
Test the name and length properties of <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>.

%activity:
<a href="../api/classomnetpp_1_1cPacket.html">cPacket</a> *pk = new <a href="../api/classomnetpp_1_1cPacket.html">cPacket</a>();
pk-&gt;setName("ACK");
pk-&gt;setByteLength(64);
EV &lt;&lt; "name: " &lt;&lt; pk-&gt;getName() &lt;&lt; endl;
EV &lt;&lt; "length: " &lt;&lt; pk-&gt;getByteLength() &lt;&lt; endl;
delete pk;

%contains: stdout
name: ACK
length: 64
</pre>
<p>
What this test says is this: create a simulation with a simple module
that has the above C++ code block as the body of the <tt>activity()</tt> method,
and when run, it should print the text after the <tt>%contains</tt> line.

<p>To run this test, we need a <i>control script</i>, for example
<tt>runtest</tt> from the <tt>omnetpp/test/core</tt> directory. <tt>runtest</tt>
itself relies on the <tt>opp_test</tt> tool.

<p><ul class="note"><b>NOTE</b><br>
The control script is not part of OMNeT++ because it is somewhat specific to
the simulation model or framework being tested, but it is usually trivial
to write. A later section will explain how write the control script.
</ul>

<p>The output will be similar to this one:

<pre class="filelisting">
$ ./runtest cMessage_properties_1.test
opp_test: extracting files from *.test files into work...
Creating Makefile in omnetpp/test/core/work...
cMessage_properties_1/test.cc
Creating executable: out/gcc-debug/work
opp_test: running tests using work.exe...
*** cMessage_properties_1.test: PASS
========================================
PASS: 1   FAIL: 0   UNRESOLVED: 0

Results can be found in work/
</pre>
<p>
This was a passing test. What would constitute a fail?

<p><ul>
<li> crash
<li> simulation runtime error
<li> nonzero exit code (a simulation runtime error is also detected by nonzero exit code)
<li> the output doesn't match the expectation (there are several possibilities
   for expressing what is expected: multiple match criteria, literal string vs regex,
   positive vs negative match, matching against the standard output, standard error
   or any file, etc.)
</ul>

<p>One normally wants to run several tests together. The <tt>runtest</tt> script accepts
several <tt>.test</tt> files on the command line, and when started without
arguments, it defaults to <tt>*.test</tt>, all test files in the current
directory. At the end of the run, the tool prints summary statistics
(number of tests passed, failed, and being unresolved).

<p>An example run from <tt>omnetpp/test/core</tt> (some lines were removed from
the output, and one test was changed to show a failure):

<pre class="filelisting">
$ ./runtest <a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a>-*.test
opp_test: extracting files from *.test files into work...
Creating Makefile in omnetpp/test/core/work...
[...]
Creating executable: out/gcc-debug/work
opp_test: running tests using work...
*** cSimpleModule_activity_1.test: PASS
*** cSimpleModule_activity_2.test: PASS
[...]
*** cSimpleModule_handleMessage_2.test: PASS
*** cSimpleModule_initialize_1.test: PASS
*** cSimpleModule_multistageinit_1.test: PASS
*** cSimpleModule_ownershiptransfer_1.test: PASS
*** cSimpleModule_recordScalar_1.test: PASS
*** cSimpleModule_recordScalar_2.test: FAIL (test-1.sca fails %contains-regex(2) rule)
expected pattern:
&gt;&gt;&gt;&gt;run General-1-.*?
scalar Test 	one 	24.2
scalar Test 	two 	-1.5888&lt;&lt;&lt;&lt;
actual output:
&gt;&gt;&gt;&gt;version 2
run General-1-20141020-11:39:34-1200
attr configname General
attr datetime 20141020-11:39:34
attr experiment General
attr inifile _defaults.ini
[...]
scalar Test 	one 	24.2
scalar Test 	two 	-1.5
&lt;&lt;&lt;&lt;
*** cSimpleModule_recordScalar_3.test: PASS
*** cSimpleModule_scheduleAt_notowner_1.test: PASS
*** cSimpleModule_scheduleAt_notowner_2.test: PASS
[...]
========================================
PASS: 36   FAIL: 1   UNRESOLVED: 0
FAILED tests: cSimpleModule_recordScalar_2.test

Results can be found in work/
</pre>
<p>
Note that code from all tests were linked to form a single executable, which saves
time and disk space compared to per-test executables or libraries.

<p>A test file like the one above is useful for unit testing of classes or functions.
However, as we will see, the test framework provides further facilities that make
it convenient for testing modules and whole simulations as well.


The following sections go into details about the syntax and features of <tt>.test</tt> files,
about writing the control script, and give advice on how to cover several use
cases with the <tt>opp_test</tt> tool.

<p>
<h3><a name="sec:testing:opptest:terminology"/>15.2.2 Terminology<a class="headerlink" href="#sec:testing:opptest:terminology" title="Permalink to this headline"></a></h3>

<p>The next sections will use the following language:

<p><ul>
<li> <i>test file</i>: A file with the <tt>.test</tt> extension that <tt>opp_test</tt> understands.
<li> <i>test tool</i>: The <tt>opp_test</tt> program
<li> <i>control script</i>: A script that relies on <tt>opp_test</tt> to run the tests.
  The control script is not part of OMNeT++ because it usually needs to be somewhat
  specific to the simulation model or framework being tested.
<li> <i>test program</i>: The simulation program whose output is checked by the test.
  It is usually <tt>work/work</tt> (<tt>work/work.exe</tt> on Windows). However, it is
  also possible to let the control script build a dynamic library from the test code, and
  then use e.g. <tt>opp_run</tt> as test program.
<li> <i>test directory</i>: The directory where a <tt>.test</tt> file
  is extracted; usually <tt>work/&lt;testname&gt;/</tt>. It is also set as working
  directory for running the test program.
</ul>

<p>
<h3><a name="sec:testing:opptest:test-file-syntax"/>15.2.3 Test File Syntax<a class="headerlink" href="#sec:testing:opptest:test-file-syntax" title="Permalink to this headline"></a></h3>

<p>Test files are composed of %-directives of the syntax:

<pre class="filelisting">
%&lt;directive&gt;: &lt;value&gt;
&lt;body&gt;
</pre>
<p>
The body extends up to the next directive (the next line starting with %),
or to the end of the file. Some directives require a value, others a body, or both.

<p>Certain directives, e.g. <tt>%contains</tt>, may occur several times in the file.

<p><h3><a name="sec:testing:opptest:test-description"/>15.2.4 Test Description<a class="headerlink" href="#sec:testing:opptest:test-description" title="Permalink to this headline"></a></h3>

<p>Syntax:
<pre class="filelisting">
%description:
&lt;test-description-lines&gt;
</pre>

<p><tt>%description</tt> is customarily written at the top of the <tt>.test</tt>
file, and lets one provide a multi-line comment about the purpose of the
test. It is recommended to invest time into well-written descriptions,
because they make determining the original purpose of a test that has
become broken significantly easier.

<p>
<h3><a name="sec:testing:opptest:test-code-generation"/>15.2.5 Test Code Generation<a class="headerlink" href="#sec:testing:opptest:test-code-generation" title="Permalink to this headline"></a></h3>

<p>This section describes the directives used for creating C++ source and
other files in the test directory.

<p><h4><a name="sec:testing:opptest:activity"/>15.2.5.1 %activity<a class="headerlink" href="#sec:testing:opptest:activity" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%activity:
&lt;body-of-activity()&gt;
</pre>
<p>
<tt>%activity</tt> lets one write test code without much boilerplate. The
directive generates a simple module that contains a single <tt>activity()</tt>
method with the given code as method body.

<p>A NED file containing the simple module's (barebones) declaration, and an
ini file to set up the module as a network are also generated.

<p>
<h4><a name="sec:testing:opptest:module"/>15.2.5.2 %module<a class="headerlink" href="#sec:testing:opptest:module" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%module: &lt;modulename&gt;
&lt;simple-module-C++-definition&gt;
</pre>
<p>
<tt>%module</tt> lets one define a module class and run it as the only module
in the simulation.

<p>A NED file containing the simple module's (barebones) declaration, and an
ini file to set up the module as a network are also generated.

<p>
<h4><a name="sec:testing:opptest:includes-and-global"/>15.2.5.3 %includes, %global<a class="headerlink" href="#sec:testing:opptest:includes-and-global" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%includes:
&lt;#include directives&gt;
</pre>
<p>
<pre class="filelisting">
%global:
&lt;global-code-pasted-before-activity&gt;
</pre>

<p><tt>%includes</tt> and <tt>%global</tt> are helpers for <tt>%activity</tt>
and <tt>%module</tt>, and let one insert additional lines into the
generated C++ code.

<p>Both directives insert the code block above the module C++ declaration. The only
difference is in their relation to the C++ namespace: the body of <tt>%includes</tt>
is inserted above (i.e. outside) the namespace, and the body of <tt>%globals</tt>
is inserted inside the namespace.

<p>
<h4><a name="sec:testing:opptest:default-ini-file"/>15.2.5.4 The Default Ini File<a class="headerlink" href="#sec:testing:opptest:default-ini-file" title="Permalink to this headline"></a></h4>

<p>The following ini file is always generated:

<pre class="inifile">
[General]
network = &lt;network-name&gt;
cmdenv-express-mode = false
</pre>
<p>
The network name in the file is chosen to match the module
generated with <tt>%activity</tt> or <tt>%module</tt>; if they
are absent, it will be <tt>Test</tt>.

<p><h4><a name="sec:testing:opptest:network"/>15.2.5.5 %network<a class="headerlink" href="#sec:testing:opptest:network" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%network: &lt;network-name&gt;
</pre>
<p>
This directive can be used to override the network name in the default ini file.

<p>
<h4><a name="sec:testing:opptest:file-and-inifile"/>15.2.5.6 %file, %inifile<a class="headerlink" href="#sec:testing:opptest:file-and-inifile" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%file: &lt;file-name&gt;
&lt;file-contents&gt;
</pre>
<p>
<pre class="filelisting">
%inifile: [&lt;inifile-name&gt;]
&lt;inifile-contents&gt;
</pre>

<p><tt>%file</tt> saves a file with the given file name and content into the test's
extraction folder in the preparation phase of the test run. It is customarily
used for creating NED files, MSG files, ini files, and extra data files
required by the test. There can be several <tt>%file</tt> sections in the test file.

<p><tt>%inifile</tt> is similar to <tt>%file</tt> in that it also saves a file with the
given file name and content, but it additionally also adds the file to the simulation's
command line, causing the simulation to read it as an (extra) ini file.
There can be several <tt>%inifile</tt> sections in the test file.

<p>The default ini file is always generated.

<p>
<h4><a name="sec:testing:opptest:testname-macro"/>15.2.5.7 The @TESTNAME@ Macro<a class="headerlink" href="#sec:testing:opptest:testname-macro" title="Permalink to this headline"></a></h4>

<p>In test files, the string <tt>@TESTNAME@</tt> will be replaced with the test
case name. Since it is substituted everywhere (C++, NED, msg and ini
files), one can also write things like <tt>@TESTNAME@_function()</tt>, or
<tt>printf("this is @TESTNAME@\n")</tt>.

<p><h4><a name="sec:testing:opptest:avoiding-cpp-name-clashes"/>15.2.5.8 Avoiding C++ Name Clashes<a class="headerlink" href="#sec:testing:opptest:avoiding-cpp-name-clashes" title="Permalink to this headline"></a></h4>

<p>Since all sources are compiled into a single test executable, actions have
to be taken to prevent accidental name clashes between C++ symbols in
different test cases. A good way to ensure this is place all code into
namespaces named after the test cases.

<pre class="filelisting">
namespace @TESTNAME@ {
   ...
};
</pre>
<p>
This is done automatically for the <tt>%activity</tt>, <tt>%module</tt>,
<tt>%global</tt> blocks, but for other files (e.g. source files generated
via <tt>%file</tt>, that needs to be done manually.

<p>
<h3><a name="sec:testing:opptest:pass-criteria"/>15.2.6 PASS Criteria<a class="headerlink" href="#sec:testing:opptest:pass-criteria" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:testing:opptest:contains-and-co"/>15.2.6.1 %contains, %contains-regex, %not-contains, %not-contains-regex<a class="headerlink" href="#sec:testing:opptest:contains-and-co" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%contains: &lt;output-file-to-check&gt;
&lt;multi-line-text&gt;
</pre>
<p>
<pre class="filelisting">
%contains-regex: &lt;output-file-to-check&gt;
&lt;multi-line-regexp&gt;
</pre>

<pre class="filelisting">
%not-contains: &lt;output-file-to-check&gt;
&lt;multi-line-text&gt;
</pre>
<p>
<pre class="filelisting">
%not-contains-regex: &lt;output-file-to-check&gt;
&lt;multi-line-regexp&gt;
</pre>

<p>These directives let one check for the presence (or absence) of certain text in
the output. One can check a file, or the standard output or standard error of
the test program; for the latter two, <tt>stdout</tt> and <tt>stderr</tt> needs to be
specified as file name, respectively. If the file is not found, the test will be marked
as <i>unresolved</i>. There can be several <tt>%contains</tt>-style directives
in the test file.

<p>The text or regular expression can be multi-line. Before match is attempted,
trailing spaces are removed from all lines in both the pattern and the
file contents; leading and trailing blank lines in the patterns are removed;
and any substitutions are performed (see <tt>%subst</tt>). Perl-style regular
expressions are accepted.

<p>To facilitate debugging of tests, the text/regex blocks are saved into
the test directory.

<p>
<h4><a name="sec:testing:opptest:subst"/>15.2.6.2 %subst<a class="headerlink" href="#sec:testing:opptest:subst" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%subst: /&lt;search-regex&gt;/&lt;replacement&gt;/&lt;flags&gt;
</pre>
<p>
It is possible to apply text substitutions to the output before it is
matched against expected output. This is done with <tt>%subst</tt>
directive; there can be more than one <tt>%subst</tt> in a test file. It
takes a Perl-style regular expression to search for, a replacement text,
and flags, in the <i>/search/replace/flags</i> syntax. Flags can be empty
or a combination of the letters <tt>i</tt>, <tt>m</tt>, and <tt>s</tt>, for
case-insensitive, multi-line or single-string match (see the Perl regex
documentation.)

<p><tt>%subst</tt> was primarily invented to deal with differences in printf
output across platforms and compilers: different compilers print infinite
and not-a-number in different ways: <tt>1.#INF</tt>, <tt>inf</tt>, <tt>Inf</tt>,
<tt>-1.#IND</tt>, <tt>nan</tt>, <tt>NaN</tt> etc. With <tt>%subst</tt>, they can be
brought to a common form:

<pre class="filelisting">
%subst: /-?1\.#INF/inf/
%subst: /-?1\.#IND/nan/
%subst: /-?1\.#QNAN/nan/
%subst: /-?NaN/nan/
%subst: /-?nan/nan/
</pre>
<p>
<h4><a name="sec:testing:opptest:exitcode"/>15.2.6.3 %exitcode, %ignore-exitcode<a class="headerlink" href="#sec:testing:opptest:exitcode" title="Permalink to this headline"></a></h4>

<p>Syntax:
<pre class="filelisting">
%exitcode: &lt;one-or-more-numeric-exit-codes&gt;
</pre>

<pre class="filelisting">
%ignore-exitcode: 1
</pre>
<p>
<tt>%exitcode</tt> and <tt>%ignore-exitcode</tt> let one test the exit code of the
test program. The former checks that the exit code is one of the numbers specified in
the directive; the other makes the test framework ignore the exit code.

<p>OMNeT++ simulations exit with zero if the simulation terminated
without an error, and some &gt;0 code if a runtime error occurred. Normally,
a nonzero exit code makes the test fail. However, if the expected outcome
is a runtime error (e.g. for some negative test cases), one can use either
<tt>%exitcode</tt> to express that, or specify <tt>%ignore-exitcode</tt>
and test for the presence of the correct error message in the output.

<p>

<p><h4><a name="sec:testing:opptest:file-exists"/>15.2.6.4 %file-exists, %file-not-exists<a class="headerlink" href="#sec:testing:opptest:file-exists" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%file-exists: &lt;filename&gt;
</pre>
<p>
<pre class="filelisting">
%file-not-exists: &lt;filename&gt;
</pre>

<p>These directives test for the presence or absence of a certain file in
the test directory.

<p><h3><a name="sec:testing:opptest:extra-processing-steps"/>15.2.7 Extra Processing Steps<a class="headerlink" href="#sec:testing:opptest:extra-processing-steps" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:testing:opptest:env-extraargs-testprog"/>15.2.7.1 %env, %extraargs, %testprog<a class="headerlink" href="#sec:testing:opptest:env-extraargs-testprog" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%env: &lt;environment-variable-name&gt;=&lt;value&gt;
</pre>
<p>
<pre class="filelisting">
%extraargs: &lt;argument-list&gt;
</pre>

<pre class="filelisting">
%testprog: &lt;executable&gt;
</pre>
<p>
The <tt>%env</tt> directive lets one set an environment variable that will
be defined when the test program and the potential pre- and post-processing
commands run. There can be multiple <tt>%env</tt> directives in the test
file.

<p><tt>%extraargs</tt> lets one add extra command-line arguments to the
test program (usually the simulation) when it is run.

<p>The <tt>%testprog</tt> directive lets one replace the test program.
<tt>%testprog</tt> also slightly alters the arguments the test program is
run with. Normally, the test program is launched with the following command
line:

<pre class="filelisting">
$ &lt;default-testprog&gt; -u Cmdenv &lt;test-extraargs&gt; &lt;global-extraargs&gt; &lt;inifiles&gt;
</pre>
<p>
When <tt>%testprog</tt> is present, it becomes the following:

<pre class="filelisting">
$ &lt;custom-testprog&gt; &lt;test-extraargs&gt; &lt;global-extraargs&gt;
</pre>
<p>
That is, <tt>-u Cmdenv</tt> and <tt>&lt;inifilenames&gt;</tt> are removed; this allows one
to invoke programs that do not require or understand them, and puts the test author
in complete command of the arguments list.

<p>Note that <tt>%extraargs</tt> and <tt>%testprog</tt> have an equivalent
command-line option in <tt>opp_test</tt>. (In the text above,
<tt>&lt;global-extraargs&gt;</tt> stands for extra args specified to
<tt>opp_test</tt>.)  <tt>%env</tt> doesn't need an option in
<tt>opp_test</tt>, because the test program inherits the environment
variables from <tt>opp_test</tt>, so one can just set them in the control
script, or in the shell one runs the tests from.

<p>
<h4><a name="sec:testing:opptest:prerun-postrun-commands"/>15.2.7.2 %prerun-command, %postrun-command<a class="headerlink" href="#sec:testing:opptest:prerun-postrun-commands" title="Permalink to this headline"></a></h4>

<p>Syntax:

<pre class="filelisting">
%prerun-command: &lt;command&gt;
</pre>
<p>
<pre class="filelisting">
%postrun-command: &lt;command&gt;
</pre>

<p>These directives let one run extra commands before/after running the test
program (i.e. the simulation). There can be multiple pre- and post-run
commands. The post-run command is useful when the test outcome cannot be determined
by simple text matching, but requires statistical evaluation or other processing.

<p>If the command returns a nonzero exit code, the test framework will assume that
it is due to a technical problem (as opposed to test failure), and count the
test as <i>unresolved</i>. To make the test fail, let the command write a
file, and match the file's contents using <tt>%contains</tt> &amp; co.

<p>If the post-processing command is a short script, it is practical
to add it into the <tt>.test</tt> file via the <tt>%file</tt> directive,
and invoke it via its interpreter. For example:

<pre class="filelisting">
%postrun-command: python test.py
%file: test.py
&lt;Python script&gt;
</pre>
<p>
Or:

<pre class="filelisting">
%postrun-command: R CMD BATCH test.R
%file: test.R
&lt;R script&gt;
</pre>
<p>
If the script is very large or shared among several tests, it is more practical
to place it into a separate file. The test command can find the script e.g.
by relative path, or by referring to an environment variable that contains
its location or full path.

<p>
<h3><a name="sec:testing:opptest:unresolved"/>15.2.8 Unresolved<a class="headerlink" href="#sec:testing:opptest:unresolved" title="Permalink to this headline"></a></h3>

<p>A test case is unresolved if the test program cannot be executed at all, the
output cannot be read, or if the test case declares so. The latter is done
by printing <tt>#UNRESOLVED</tt> or <tt>#UNRESOLVED:some-explanation</tt> on the
standard output, at the beginning of the line.

<p>
<h3><a name="sec:testing:opptest:synopsys"/>15.2.9 opp_test Synopsys<a class="headerlink" href="#sec:testing:opptest:synopsys" title="Permalink to this headline"></a></h3>

<p>Little has been said so far what <tt>opp_test</tt> actually does, or how it
is meant to be run. <tt>opp_test</tt> has two modes: file generation and
test running. When running a test suite, <tt>opp_test</tt> is actually run
twice, once in file generation mode, then in test running mode.

<p>File generation mode has the syntax <tt>opp_test gen <i>&lt;options&gt;
&lt;testfiles&gt;</i></tt>. For example:

<pre class="filelisting">
$ opp_test gen *.test
</pre>
<p>
This command will extract C++ and NED files, ini files, etc., from
the <tt>.test</tt> files into separate files. All files will be created
in a work directory (which defaults to <tt>./work/</tt>),
and each test will have its own subdirectory under <tt>./work/</tt>.

<p>The second mode, test running, is invoked as <tt>opp_test run <i>&lt;options&gt;
&lt;testfiles&gt;</i></tt>. For example:

<pre class="filelisting">
$ opp_test run *.test
</pre>
<p>
In this mode, <tt>opp_test</tt> will run the simulations, check the
results, and report the number of passes and failures. The way of invoking
simulations (which executable to run, the list of command-line arguments to
pass, etc.) can be specified to <tt>opp_test</tt> via command-line options.

<p><ul class="note"><b>NOTE</b><br>
Run <tt>opp_test</tt> in your OMNeT++ installation to get the exact list of
command-line options.
</ul>

<p>The simulation needs to have been built from source before <tt>opp_test
run</tt> can be issued. Usually one would employ a command similar to

<pre class="filelisting">
$ cd work; opp_makemake --deep; make
</pre>
<p>
to achieve that.

<p><h3><a name="sec:testing:opptest:writing-control-script"/>15.2.10 Writing the Control Script<a class="headerlink" href="#sec:testing:opptest:writing-control-script" title="Permalink to this headline"></a></h3>

<p>Usually one writes a control script to automate the two invocations of <tt>opp_test</tt>
and the build of the simulation model between them.

<p>A basic variant would look like this:

<pre class="filelisting">
#! /bin/sh
opp_test gen -v *.test || exit 1
(cd work; opp_makemake -f --deep; make) || exit 1
opp_test run -v *.test
</pre>
<p>
For any practical use, the test suite needs to refer to the codebase being
tested. This means that the codebase must be added to the include path,
must be linked with, and the NED files must be added to the NED path. The
first two can be achieved by the appropriate parameterization of
<tt>opp_makemake</tt>; the last one can be done by setting and exporting
the <tt>NEDPATH</tt> environment variable in the control script.

<p>For inspiration, check out <tt>runtest</tt> in the <tt>omnetpp/test/core</tt>
directory, and a similar script used in the INET Framework.

<p><br><br>
<center>
* * *
</center>
<br><br>

<p>Further sections describe how one can implement various types of tests in
OMNeT++.

<p><h2><a name="sec:testing:smoke-tests"/>15.3 Smoke Tests<a class="headerlink" href="#sec:testing:smoke-tests" title="Permalink to this headline"></a></h2>

<p>Smoke tests are a tool for very basic verification and regression testing.
Basically, the simulation is run for a while, and it must not crash or stop
with a runtime error. Naturally, smoke test provide very low confidence in
the model, but in turn they are very easy to implement.

<p>Automation is important. The INET Framework contains a script that runs all
or selected simulations defined in a CSV file (with columns like the working
directory and the command to run), and reports the results. The script can
be easily adapted to other models or model frameworks.

<p>
<h2><a name="sec:testing:fingerprint-tests"/>15.4 Fingerprint Tests<a class="headerlink" href="#sec:testing:fingerprint-tests" title="Permalink to this headline"></a></h2>

<p>Fingerprint tests are a low-cost but effective tool for regression testing
of simulation models. A fingerprint is a hash computed from various properties
of simulation events, messages and statistics. The hash value is continuously
updated as the simulation executes, and thus, the final fingerprint value is
a characteristic of the simulation's trajectory. For regression testing, one
needs to compare the computed fingerprints to that from a reference run --
if they differ, the simulation trajectory has changed. In general, fingerprint
tests are very useful for ensuring that a change (some refactoring, a bugfix,
or a new feature) didn't break the simulation.

<p><h3><a name="sec:testing:fingerprint-computation"/>15.4.1 Fingerprint Computation<a class="headerlink" href="#sec:testing:fingerprint-computation" title="Permalink to this headline"></a></h3>

<p>Technically, providing a <b><tt>fingerprint</tt></b> option in the config file or
on the command line (<tt>-fingerprint=...</tt>) will turn on fingerprint
computation in the OMNeT++ simulation kernel. When the simulation terminates,
OMNeT++ compares the computed fingerprints with the provided ones, and
if they differ, an error is generated.

<p><h4><a name="sec:testing:fingerprint-ingredients"/>15.4.1.1 Ingredients<a class="headerlink" href="#sec:testing:fingerprint-ingredients" title="Permalink to this headline"></a></h4>

<p>The fingerprint computation algorithm allows controlling what is included
in the hash value. Changing the <i>ingredients</i> allows one to make the
fingerprint sensitive for certain changes while keeping it immune to
others.

<p>The ingredients of a fingerprint are usually indicated after a <tt>/</tt> sign
following the hexadecimal hash value. Each ingredient is identified with a
letter. For example, <b>t</b> stands for simulation time. Thus, the following
<tt>omnetpp.ini</tt> line

<pre class="inifile">
fingerprint = 53de-64a7/tplx
</pre>
<p>
means that a fingerprint needs to be computed with the simulation time, the
module full path, received packet's bit length and the extra data included
for each event, and the result should be <tt>53de-64a7</tt>.

<p>The full list of fingerprint ingredients:

<p>
<ul>
  <li><b><b>e</b></b> : event number
  <li><b><b>t</b></b> : simulation time
  <li><b><b>n</b></b> : message/event full name
  <li><b><b>c</b></b> : message/event class name
  <li><b><b>k</b></b> : message kind
  <li><b><b>l</b></b> : message (packet) bit length
  <li><b><b>o</b></b> : message control info class name
  <li><b><b>d</b></b> : message data
  <li><b><b>i</b></b> : module id
  <li><b><b>m</b></b> : module full name (name with index)
  <li><b><b>p</b></b> : module full path (hierarchical name)
  <li><b><b>a</b></b> : module class name
  <li><b><b>r</b></b> : random numbers drawn
  <li><b><b>s</b></b> : scalar results
  <li><b><b>z</b></b> : statistic results (histogram, etc.)
  <li><b><b>v</b></b> : vector results
  <li><b><b>x</b></b> : extra data added programmatically
</ul>

<p>
Ingredients may also be specified with the
<b><tt>fingerprint-ingredients</tt></b> configuration option. However, that is
rarely necessary, because the ingredients list included in the fingerprints
take precedence, and are also more convenient to use.

<p><h4><a name="sec:testing:multiple-fingerprints-alternative-values"/>15.4.1.2 Multiple Fingerprints, Alternative Values<a class="headerlink" href="#sec:testing:multiple-fingerprints-alternative-values" title="Permalink to this headline"></a></h4>

<p>It is possible to specify more than one fingerprint, separated by
<i>commas</i>, each with different ingredients. This will cause OMNeT++ to
compute multiple fingerprints, and all of them must match for the test to
pass. An example:

<pre class="inifile">
fingerprint = 53de-64a7/tplx, 9a3f-7ed2/szv
</pre>
<p>
Occasionally, the same simulation gives a different fingerprint when run on
a different processor architecture or platform. This is due to subtle
differences in floating point arithmetic across platforms.<br><ul><font size=-1>[There
are differences between the floating point operations of AMD and Intel
CPUs. Running under a processor emulator like <tt>valgrind</tt> may also
produce a different fingerprint. This is normal. Hint: see gcc options
<tt>-mfpmath=sse -msse2</tt>.]</font></ul> Acknowledging this fact, OMNeT++ lets one list
several values for a fingerprint, separated by <i>spaces</i>, and will
accept whichever is produced by the simulation. The following example lists
two alternative values for both fingerprints.

<pre class="inifile">
fingerprint = 53de-64a7/tplx 63dc-ff21/tplx, 9a3f-7ed2/szv da39-91fc/szv
</pre>
<p>
Note that fingerprint computation has been changed and significantly
extended in OMNeT++ version 5.0.<br><ul><font size=-1>[The old (OMNeT++ 4.x) fingerprint
was computed from the module ID and simulation time of each event. To
reproduce a 4.x fingerprint on OMNeT++ 5.0 or later, compile OMNeT++ and the
model with <tt>USE_OMNETPP4x_FINGERPRINTS</tt> defined. Simply setting the
ingredients to <b>ti</b> is not enough because of additional, subtle changes
in the simulation kernel.]</font></ul>

<p>
<h4><a name="sec:testing:fingerprint-further-filtering"/>15.4.1.3 Further Filtering<a class="headerlink" href="#sec:testing:fingerprint-further-filtering" title="Permalink to this headline"></a></h4>

<p>It is also possible to filter which modules, statistics, etc. are included
in the fingerprints. The <b><tt>fingerprint-events</tt></b>,
<b><tt>fingerprint-modules</tt></b>, and <b><tt>fingerprint-results</tt></b> options
filter by events, modules, and statistical results, respectively. These
options take wildcard expressions that are matched against the
corresponding object before including its property in the fingerprint.
These filters are mainly useful to limit fingerprint computation to certain
parts of the simulation.

<p><h4><a name="sec:testing:fingerprint-programmatic-access"/>15.4.1.4 Programmatic Access<a class="headerlink" href="#sec:testing:fingerprint-programmatic-access" title="Permalink to this headline"></a></h4>

<p><tt><a href="../api/classomnetpp_1_1cFingerprintCalculator.html">cFingerprintCalculator</a></tt> is the class responsible for fingerprint computation.
The current fingerprint computation object can be retrieved from
<tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>, using the <tt>getFingerprintCalculator()</tt> member function.
This method will return <tt>nullptr</tt> if fingerprint computation is turned
off for the current simulation run.

<p>To contribute data to the fingerprint, <tt><a href="../api/classomnetpp_1_1cFingerprintCalculator.html">cFingerprintCalculator</a></tt> has several
<tt>addExtraData()</tt> methods for various data types (string, <tt>long</tt>,
<tt>double</tt>, byte array, etc.)

<p>An example (note that we check the pointer for <tt>nullptr</tt> to decide
whether a fingerprint is being computed):

<pre class="cpp">
<a href="../api/classomnetpp_1_1cFingerprintCalculator.html">cFingerprintCalculator</a> *fingerprint = getSimulation()-&gt;getFingerprintCalculator();
if (fingerprint) {
    fingerprint-&gt;addExtraData(retryCount);
    fingerprint-&gt;addExtraData(rttEstimate);
}
</pre>
<p>
Data added using <tt>addExtraData()</tt> will only be counted in the
fingerprint if the list of fingerprint ingredients contains <b>x</b>
(otherwise <tt>addExtraData()</tt> does nothing).

<p><h3><a name="sec:testing:creating-fingerprint-tests"/>15.4.2 Fingerprint Tests<a class="headerlink" href="#sec:testing:creating-fingerprint-tests" title="Permalink to this headline"></a></h3>

<p>The INET Framework contains a script for automated fingerprint tests as
well. The script runs all or selected simulations defined in a CSV file
(with columns like the working directory, the command to run, the
simulation time limit, and the expected fingerprints), and reports the
results. The script is extensively used during INET Framework development
to detect regressions, and can be easily adapted to other models or model
frameworks.

<p>Exerpt from a CSV file that prescribes fingerprint tests to run:

<pre class="filelisting">
examples/aodv/, ./run -f omnetpp.ini -c Static,   50s,  4c29-95ef/tplx
examples/aodv/, ./run -f omnetpp.ini -c Dynamic,  60s,  8915-f239/tplx
examples/dhcp/, ./run -f omnetpp.ini -c Wired,    800s, e88f-fee0/tplx
examples/dhcp/, ./run -f omnetpp.ini -c Wireless, 500s, faa5-4111/tplx
</pre>
<p>

<p><h2><a name="sec:testing:unit-tests"/>15.5 Unit Tests<a class="headerlink" href="#sec:testing:unit-tests" title="Permalink to this headline"></a></h2>

<p>If a simulation models contains units of code (classes, functions) smaller
than a module, they are candidates for unit testing. For a network simulation
model, examples of such classes are network addresses, fragmentation reassembly
buffers, queues, various caches and tables, serializers and deserializers,
checksum computation, etc.

<p>Unit tests can be implemented as <tt>.test</tt> files using the <tt>opp_test</tt>
tool (the <tt>%activity</tt> directive is especially useful here), or
with potentially any other C++ unit testing framework.

<p>When using <tt>.test</tt> files, the <i>build</i> part of the control script
needs to be set up so that it adds the tested library's source folder(s)
to the include path, and also links the library to the test code.

<p>

<p><h2><a name="sec:testing:module-tests"/>15.6 Module Tests<a class="headerlink" href="#sec:testing:module-tests" title="Permalink to this headline"></a></h2>

<p>OMNeT++ modules are not as easy to unit test as standalone classes, because
they typically assume a more complex environment, and, especially modules
that implement network protocols, participate in more complex interactions
than the latter.

<p>To test a module in isolation, one needs to place it into a simulation
where the module's normal operation environment (i.e. other modules it
normally communicates with) are replaced by mock objects. Mock objects are
responsible for providing stimuli for the module under test, and (partly)
for checking the response.

<p>Module tests may be implemented in <tt>.test</tt> files using the <tt>opp_test</tt>
tool. A <tt>.test</tt> file allows one to place the test description, the test setup
and the expected output into a single, compact file, while large files or files shared
among several tests may be factored out and only referenced by <tt>.test</tt> files.

<p>
<h2><a name="sec:testing:statistical-tests"/>15.7 Statistical Tests<a class="headerlink" href="#sec:testing:statistical-tests" title="Permalink to this headline"></a></h2>

<p>Statistical tests are those where the test outcome is decided on
some statistical property or properties of the simulation results.

<p>Statistical tests may be useful as validation as well as regression testing.

<p><h3><a name="sec:testing:validation-tests"/>15.7.1 Validation Tests<a class="headerlink" href="#sec:testing:validation-tests" title="Permalink to this headline"></a></h3>

<p>Validation tests aim to verify that simulation results correspond to some
reference values, ideally to those obtained from the real system. In
practice, reference values may come from physical measurements, theoretical
values, or another simulator's results.

<p><h3><a name="sec:testing:statistical-regression-tests"/>15.7.2 Statistical Regression Tests<a class="headerlink" href="#sec:testing:statistical-regression-tests" title="Permalink to this headline"></a></h3>

<p>After a refactoring that changes the simulation trajectory (e.g. after
eliminating or introducing extra events, or changes in RNG usage), there
may be no other way to do regression testing than checking that the model
produces <i>statistically</i> the same results as before.

<p>For statististical regression tests, one needs to perform several
simulation runs with the same configuration but different RNG seeds, and
verify that the results are from the same distributions as before. One can
use <i>Student's t-test</i> (for mean) and the <i>F-test</i> (for
variance) to check that the &#8220;before&#8221; and the &#8220;after&#8221; sets of results
are from the same distribution.

<p><h3><a name="sec:testing:statistical-tests-implementation"/>15.7.3 Implementation<a class="headerlink" href="#sec:testing:statistical-tests-implementation" title="Permalink to this headline"></a></h3>

<p>Statistical software like <i>GNU R</i> is extremely useful for these
tests.

<p>Statistical tests may also be implemented in <tt>.test</tt> files. To let the
tool run several simulations within one test, one may use
<tt>%extraargs</tt> to pass the <tt>-r &lt;runs&gt;</tt> option to Cmdenv;
alternatively, one may use <tt>%testprog</tt> to have the test tool run
<tt>opp_runall</tt> instead of the normal simulation program. For doing the
statistical computations, one may use <tt>%postrun-command</tt> to run an R
script. The R script may rely on the <tt>omnetpp</tt> R package for reading
the result files.

<p>The INET Framework contains statistical tests where one can look for
inspiration.

<p>

<hr class='pgbr'><h1><a name="cha:parallel-exec"/>16 Parallel Distributed Simulation<a class="headerlink" href="#cha:parallel-exec" title="Permalink to this headline"></a></h1>


<h2><a name="sec:parallel-exec:introduction-to-pdes"/>16.1 Introduction to Parallel Discrete Event Simulation<a class="headerlink" href="#sec:parallel-exec:introduction-to-pdes" title="Permalink to this headline"></a></h2>

<p>OMNeT++ supports parallel execution<!--parallel simulation--> of large
simulations. This section provides a brief picture
of the problems and methods of parallel
discrete event simulation (PDES<!--PDES-->). Interested readers are
strongly encouraged to look into the literature.

<p>For parallel execution, the model is to be partitioned into several
LPs (logical processes) that will be simulated independently on
different hosts or processors. Each LP will have its own local
Future Event Set, and thus will maintain its own local simulation
time. The main issue with parallel simulations is keeping LPs
synchronized in order to avoid violating the causality of events.
Without synchronization, a message sent by one LP could arrive in
another LP when the simulation time in the receiving LP has already
passed the timestamp (arrival time) of the message. This would break
causality<!--event!causality--> of events in the receiving LP.

<p>There are two broad categories of parallel simulation algorithms
that differ in the way they handle causality problems outlined
above:

<p><ol>
  <li><b>Conservative algorithms</b><!--parallel simulation!conservative-->
    prevents incausalities from happening. The Null Message Algorithm
    exploits knowledge of the time when LPs send messages to other LPs,
    and uses special <i>null messages</i> to propagate this information
    to other LPs. If an LP knows it won't receive any messages from other
    LPs until <i>t+&Delta; t</i> simulation time, it may advance until
    <i>t+&Delta; t</i> without the need for external synchronization.
    Conservative simulation tends to converge to sequential simulation
    (slowed down by communication between LPs) if there is not
    enough parallelism in the model, or parallelism is not exploited
    by sending a sufficient number of null messages.

<p>  <li><b>Optimistic synchronization</b><!--parallel simulation!optimistic-->
    allows incausalities to occur, but detects and
    repairs them. Repairing involves rollbacks to a previous state,
    sending out anti-messages to cancel messages sent out during the
    period that is being rolled back, etc.  Optimistic synchronization
    is extremely difficult to implement, because it requires periodic
    state saving and the ability to restore previous states. In any
    case, implementing optimistic synchronization in OMNeT++ would
    require -- in addition to a more complicated simulation kernel --
    writing significantly more complex simple<!--module!simple-->
    module code from the user.  Optimistic synchronization may be slow
    in cases of excessive rollbacks.
</ol>

<p>
<h2><a name="sec:parallel-exec:assessing-available-parallelism"/>16.2 Assessing Available Parallelism in a Simulation Model<a class="headerlink" href="#sec:parallel-exec:assessing-available-parallelism" title="Permalink to this headline"></a></h2>

<p>OMNeT++ currently supports conservative synchronization
via the classic Chandy-Misra-Bryant (or null message) algorithm
[<a href="#bib-chandymisra79">chandymisra79</a>].
To assess how efficiently a simulation can be parallelized
with this algorithm, we'll need the following variables:

<p><ul>
  <li><i>P</i> <i>performance</i> represents the number of events processed per
    second (ev/sec).
       <br><ul><font size=-1>[Notations: <i>ev:</i> events, <i>sec:</i> real seconds,
       <i>simsec:</i> simulated seconds]</font></ul>
    <i>P</i> depends on the performance of the hardware and the computation-intensiveness
    of processing an event. <i>P</i> is independent of the size of the model.
    Depending on the nature of the simulation model and the performance of the
    computer, <i>P</i> is usually in the range of 20,000..500,000 ev/sec.
  <li><i>E</i> <i>event density</i> is the number of events that occur per
    simulated second (ev/simsec). <i>E</i> depends on the model only, and not
    where the model is executed. <i>E</i> is determined by the size, the detail level
    and also the nature of the simulated system (e.g. cell-level ATM models
    produce higher <i>E</i> values than call center simulations.)
  <li><i>R</i> <i>relative speed</i> measures the simulation time advancement
    per second (simsec/sec). <i>R</i> strongly depends on both the model and
    on the software/hardware environment where the model executes.
    Note that <i>R = P/E</i>.
  <li><i>L</i> <i>lookahead</i> is measured in simulated seconds (simsec).
    When simulating telecommunication networks and using link delays as
    lookahead, <i>L</i> is typically in the msimsec-<i>&mu;</i>simsec range.
  <li><i>&tau;</i> <i>latency</i> (sec) characterizes the parallel simulation hardware.
    <i>&tau;</i> is the latency of sending a message from one LP to another. <i>&tau;</i>
    can be determined using simple benchmark programs. The authors' measurements
    on a Linux cluster interconnected via a 100Mb Ethernet switch using MPI
    yielded <i>&tau;</i>=22<i>&mu;</i>s which is consistent with measurements reported
    in [<a href="#bib-ongfarrell2000">ongfarrell2000</a>]. Specialized hardware such as
    Quadrics Interconnect [<a href="#bib-quadrics">quadrics</a>] can provide <i>&tau;</i>=5<i>&mu;</i>s or better.
</ul>

<p>In large simulation models, <i>P</i>, <i>E</i> and <i>R</i> usually stay relatively constant
(that is, display little fluctuations in time). They are also intuitive and
easy to measure. The OMNeT++ displays these values on the GUI while the simulation
is running, see Figure <a href="#fig:perfbar-screenshot">below</a>. Cmdenv can also be configured
to display these values.

<p>
  <center>
    <img src="parsim-perfbar-screenshot.png">
    <center><div class="caption"><i>Figure: Performance bar in OMNeT++ showing <i>P</i>, <i>R</i> and <i>E</i></i></div></center>
    <a name="fig:perfbar-screenshot"></a>
  </center>

<p>
After having approximate values of <i>P</i>, <i>E</i>, <i>L</i> and <i>&tau;</i>,
calculate the <i>&lambda;</i> <i>coupling factor</i> as the ratio of <i>LE</i> and <i>&tau; P</i>:

<p><i>&lambda; = (LE) / (&tau; P)</i>

<p>Without going into the details: if the resulting <i>&lambda;</i> value is at
minimum larger than one, but rather in the range 10..100, there is
a good chance that the simulation will perform well when run in
parallel. With <i>&lambda; &lt; 1</i>, poor performance is guaranteed.
For details see the paper [<a href="#bib-ParsimCrit03">ParsimCrit03</a>].

<p>
<h2><a name="sec:parallel-exec:pdes-support-in-omnetpp"/>16.3 Parallel Distributed Simulation Support in OMNeT++<a class="headerlink" href="#sec:parallel-exec:pdes-support-in-omnetpp" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:parallel-exec:overview"/>16.3.1 Overview<a class="headerlink" href="#sec:parallel-exec:overview" title="Permalink to this headline"></a></h3>

<p>This chapter presents the parallel simulation architecture
of OMNeT++. The design allows simulation models to be run
in parallel without code modification -- it only requires configuration.
The implementation relies on the approach of placeholder modules
and proxy gates to instantiate the model on different LPs --
the placeholder approach allows simulation techniques such as
topology discovery and direct message sending to work unmodified with
PDES. The architecture is modular and extensible, so it can
serve as a framework for research on parallel simulation.

<p>The OMNeT++ design places a big emphasis on
<i>separation of models from experiments</i>. The main rationale
is that usually a large number of simulation experiments need to be done
on a single model before a conclusion can be drawn about the real system.
Experiments tend to be ad-hoc and change much faster than simulation
models; thus it is a natural requirement to be able to
carry out experiments without disturbing the simulation model itself.

<p>Following the above principle, OMNeT++ allows simulation models
to be executed in parallel without modification. No special instrumentation
of the source code or the topology description is needed,
as partitioning and other PDES configuration is entirely described
in the configuration files.

<p>OMNeT++ supports the Null Message Algorithm with static
topologies, using link delays as lookahead. The laziness of null message
sending can be tuned. Also supported is the Ideal Simulation Protocol
(ISP) introduced by Bagrodia in 2000 [<a href="#bib-bagrodia00">bagrodia00</a>]. ISP is
a powerful research vehicle to measure the efficiency of
PDES algorithms, both optimistic and conservative;
more precisely, it helps determine the maximum speedup achievable
by any PDES algorithm for a particular model and simulation environment.
In OMNeT++, ISP can be used for benchmarking the performance of the
Null Message Algorithm.
Additionally, models can be executed without any synchronization, which
can be useful for educational purposes (to demonstrate the need for
synchronization) or for simple testing.

<p>For the communication between LPs (logical processes), OMNeT++
primarily uses MPI, the Message Passing Interface standard
[<a href="#bib-mpiforum94">mpiforum94</a>].  An alternative communication mechanism is based on
named pipes, for use on shared memory multiprocessors without the need
to install MPI.  Additionally, a file system based communication mechanism
is also available. It communicates via text files created in a shared
directory, and can be useful for educational purposes (to analyse or
demonstrate messaging in PDES algorithms) or to debug PDES algorithms.
Implementation of a shared memory-based communication mechanism is also planned
for the future, to fully exploit the power of multiprocessors without
the overhead of and the need to install MPI.

<p>Nearly every model can be run in parallel. The constraints are the following:
<ul>
  <li>modules may communicate via sending messages only (no direct method call
        or member access) unless mapped to the same processor
  <li> no global variables
  <li>there are some limitations on direct sending (no sending to a <i>sub</i>module
        of another module, unless mapped to the same processor)
  <li> lookahead must be present in the form of link delays
  <li>currently static topologies are supported (we are working on a
      research project that aims to eliminate this limitation)
</ul>

<p>PDES support in OMNeT++ follows a modular and extensible architecture.
New communication mechanisms can be added by implementing a compact
API (expressed as a C++ class) and registering the implementation --
after that, the new communications mechanism can be selected for use
in the configuration.

<p>New PDES synchronization algorithms can be added in a similar way.
PDES algorithms are also represented by C++ classes that have
to implement a very small API
to integrate with the simulation kernel.
Setting up the model on various LPs as well as relaying
model messages across LPs is already taken care of and
not something the implementation of the synchronization algorithm
needs to worry about (although it can intervene if needed,
because the necessary hooks are provided).

<p>The implementation of the Null Message Algorithm is also
modular in itself in that the lookahead discovery can be plugged
in via a defined API. Currently implemented lookahead
discovery uses link delays, but it is possible to
implement more sophisticated approaches and select them in the
configuration.

<p>

<p><h3><a name="sec:parallel-exec:parallel-simulation-example"/>16.3.2 Parallel Simulation Example<a class="headerlink" href="#sec:parallel-exec:parallel-simulation-example" title="Permalink to this headline"></a></h3>

<p>We will use the Parallel CQN example simulation for demonstrating the
PDES capabilities of OMNeT++.
The model consists of <i>N</i> tandem queues where each tandem consists
of a switch and <i>k</i> single-server queues with exponential service times
(Figure <a href="#fig:cqn-model">below</a>).
The last queues are looped back to their switches. Each switch
randomly chooses the first queue of one of the tandems as destination,
using uniform distribution. The queues and switches are connected
with links that have nonzero propagation delays.
Our OMNeT++ model for CQN wraps tandems into compound modules.

<p>

<p>  <center>
    <img src="parsim-cqn-model.svg">
    <center><div class="caption"><i>Figure: The Closed Queueing Network (CQN) model</i></div></center>
    <a name="fig:cqn-model"></a>
  </center>

<p>
To run the model in parallel, we assign tandems to different LPs
(Figure <a href="#fig:cqn-partitioning">below</a>). Lookahead is provided
by delays on the marked links.

<p>
  <center>
    <img src="parsim-cqn-partitioning.svg">
    <center><div class="caption"><i>Figure: Partitioning the CQN model</i></div></center>
    <a name="fig:cqn-partitioning"></a>
  </center>

<p>
To run the CQN model in parallel, we have to configure it for parallel
execution. In OMNeT++, the configuration is in the
<tt>omnetpp.ini</tt> file. For configuration, first we have to specify
partitioning, that is, assign modules to processors. This is done
by the following lines:

<pre class="inifile">
[General]
*.tandemQueue[0]**.partition-id = 0
*.tandemQueue[1]**.partition-id = 1
*.tandemQueue[2]**.partition-id = 2
</pre>
<p>
The numbers after the equal sign identify the LP.

<p>Then we have to select the communication library and the parallel
simulation algorithm, and enable parallel simulation:

<pre class="inifile">
[General]
parallel-simulation = true
parsim-communications-class = "cMPICommunications"
parsim-synchronization-class = "cNullMessageProtocol"
</pre>
<p>
When the parallel simulation is run, LPs are represented
by multiple running instances of the same program.
When using LAM-MPI [<a href="#bib-lammpi">lammpi</a>], the mpirun program (part of LAM-MPI)
is used to launch the program on the desired processors.
When named pipes or file communications is selected, the opp_prun
OMNeT++ utility can be used to start the processes.
Alternatively, one can run the processes by hand (the -p flag
tells OMNeT++ the index of the given LP and the total number of LPs):

<pre class="commandline">
./cqn -p0,3 &
./cqn -p1,3 &
./cqn -p2,3 &
</pre>
<p>
For PDES, one will usually want to select the command-line user interface,
and redirect the output to files. (OMNeT++ provides the necessary
configuration options.)

<p>The graphical user interface of OMNeT++ can also be used
(as evidenced by Figure <a href="#fig:parsim-screenshot">below</a>),
independently of the selected communication mechanism.
The GUI interface can be useful for educational or demonstration purposes.
OMNeT++ displays debugging output about the Null Message Algorithm,
EITs and EOTs can be inspected, etc.

<p>


<p>
  <center>
    <img src="parsim-screenshot.png">
    <center><div class="caption"><i>Figure: Screenshot of CQN running in three LPs</i></div></center>
    <a name="fig:parsim-screenshot"></a>
  </center>

<p>

<p>
<h3><a name="sec:parallel-exec:placeholder-modules-proxy-gates"/>16.3.3 Placeholder Modules, Proxy Gates<a class="headerlink" href="#sec:parallel-exec:placeholder-modules-proxy-gates" title="Permalink to this headline"></a></h3>

<p>When setting up a model partitioned to several LPs,
OMNeT++ uses placeholder modules and proxy gates.
In the local LP, placeholders represent sibling submodules
that are instantiated on other LPs.
With placeholder modules, every module has all of its siblings
present in the local LP -- either as placeholder or as the &#8220;real thing&#8221;.
Proxy gates take care of forwarding messages to the LP where
the module is instantiated (see Figure <a href="#fig:plach">below</a>).

<p>The main advantage of using placeholders is that algorithms such as
topology discovery embedded in the model can be used with PDES unmodified.
Also, modules can use direct message sending to any sibling module,
including placeholders. This is so because the destination of direct message
sending is an input gate of the destination module -- if the destination
module is a placeholder, the input gate will be a proxy gate which
transparently forwards the messages to the LP where the &#8220;real&#8221; module
was instantiated. A limitation is that the destination of direct message
sending cannot be a <i>submodule</i> of a sibling (which is
probably a bad practice anyway, as it violates encapsulation),
simply because placeholders are empty and so its submodules are
not present in the local LP.

<p>Instantiation of compound modules is slightly more complicated.
Since submodules can be on different LPs, the compound module may
not be &#8220;fully present&#8221; on any given LP, and it may have to be
present on several LPs (wherever it has submodules instantiated).
Thus, compound modules are instantiated wherever they have
at least one submodule instantiated, and are represented by placeholders
everywhere else (Figure <a href="#fig:inst">below</a>).

<p>

<p>  <center>
    <img src="parsim-placeholders.svg">
    <center><div class="caption"><i>Figure: Placeholder modules and proxy gates</i></div></center>
    <a name="fig:plach"></a>
  </center>

<p>

<p>  <center>
    <img src="parsim-placeholders2.svg">
    <center><div class="caption"><i>Figure: Instantiating compound modules</i></div></center>
    <a name="fig:inst"></a>
  </center>

<p>

<p>
<h3><a name="sec:parallel-exec:configuration"/>16.3.4 Configuration<a class="headerlink" href="#sec:parallel-exec:configuration" title="Permalink to this headline"></a></h3>

<p>Parallel simulation configuration is the <tt>[General]</tt> section of <tt>omnetpp.ini</tt>.

<p>The parallel distributed simulation feature can be turned on with the
<b><tt>parallel-simulation</tt></b> boolean option.

<p>The <b><tt>parsim-communications-class</tt></b> selects the class that implements
communication between partitions. The class must implement the
<tt><a href="../api/classomnetpp_1_1cParsimCommunications.html">cParsimCommunications</a></tt> interface.

<p>
The <b><tt>parsim-synchronization-class</tt></b> selects the parallel simulation algorithm.
The class must implement the <tt>cParsimSynchronizer</tt> interface.

<p>
The following two options configure the Null Message Algorithm, so
they are only effective if <tt>cNullMessageProtocol</tt> has been selected
as synchronization class:

<p><ul>
  <li> <b><tt>parsim-nullmessageprotocol-lookahead-class</tt></b>
    selects the lookahead class for the NMA; the class must be subclassed
    from <tt>cNMPLookahead</tt>. The default class is <tt>cLinkDelayLookahead</tt>.

<p>  <li> <b><tt>parsim-nullmessageprotocol-laziness</tt></b> expects a number
    in the <i>(0,1)</i> interval (the default is 0.5), and it ontrols how often
    NMA should send out null messages; the value is understood in proportion
    to the lookahead, e.g. 0.5 means every <i>lookahead/2</i> simsec.
</ul>

<p>The <b><tt>parsim-debug</tt></b> boolean option enables/disables printing
log messages about the parallel simulation algorithm. It is turned on
by default, but for production runs we recommend turning it off.

<p>Other configuration options configure MPI buffer sizes and other details;
see options that begin with <tt>parsim-</tt> in Appendix <a href="#cha:config-options">[26]</a>.

<p>
When you are using cross-mounted home directories (the simulation's
directory is on a disk mounted on all nodes of the cluster),
a useful configuration setting is

<pre class="inifile">
[General]
fname-append-host = true
</pre>
<p>
It will cause the host names to be appended to the names of
all output vector files, so that partitions don't overwrite each other's
output files. (See section <a href="#sec:run-sim:akaroa-using-shared-filesystems">[11.21.3.3]</a>)

<p>

<p>

<p><h3><a name="sec:parallel-exec:design-of-pdes-support"/>16.3.5 Design of PDES Support in OMNeT++<a class="headerlink" href="#sec:parallel-exec:design-of-pdes-support" title="Permalink to this headline"></a></h3>

<p>The design of PDES support in OMNeT++ follows a layered approach,
with a modular and extensible architecture. The overall
architecture is depicted in Figure <a href="#fig:parsim-arch">below</a>.

<p>
  <center>
    <img src="parsim-arch.svg">
    <center><div class="caption"><i>Figure: Architecture of OMNeT++ PDES implementation</i></div></center>
    <a name="fig:parsim-arch"></a>
  </center>

<p>
The parallel simulation subsytem is an optional component
itself, which can be removed from the simulation kernel
if not needed. It consists of three layers, from the bottom up:
Communications Layer, Partitioning Layer and Synchronization Layer.

<p><h4><a name="sec:parallel-exec:communications-layer"/>16.3.5.1 The Communications Layer<a class="headerlink" href="#sec:parallel-exec:communications-layer" title="Permalink to this headline"></a></h4>

<p>The purpose of the Communications Layer is to
provide elementary messaging services between partitions for the
upper layer. The services include send, blocking receive,
nonblocking receive and broadcast. The send/receive operations
work with <i>buffers</i>, which encapsulate packing and unpacking
operations for primitive C++ types. The message class and
other classes in the simulation library can pack and unpack
themselves into such buffers. The Communications layer API
is defined in the <tt><a href="../api/classomnetpp_1_1cParsimCommunications.html">cParsimCommunications</a></tt> interface
(abstract class); specific implementations like the MPI
one (<tt>cMPICommunications</tt>) subclass from this,
and encapsulate MPI send/receive calls. The matching buffer
class <tt>cMPICommBuffer</tt> encapsulates MPI pack/unpack
operations.

<p><h4><a name="sec:parallel-exec:partitioning-layer"/>16.3.5.2 The Partitioning Layer<a class="headerlink" href="#sec:parallel-exec:partitioning-layer" title="Permalink to this headline"></a></h4>

<p>The Partitioning Layer is responsible for instantiating
modules on different LPs according to the partitioning specified
in the configuration, for configuring proxy gates.
During the simulation, this layer also ensures that cross-partition
simulation messages reach their destinations. It intercepts messages
that arrive at proxy gates and transmits them to the destination LP
using the services of the Communications Layer. The receiving LP
unpacks the message and injects it at the gate the proxy gate points at.
The implementation basically encapsulates the
<tt>cParsimSegment</tt>, <tt>cPlaceholderModule</tt>,
<tt>cProxyGate</tt> classes.

<p><h4><a name="sec:parallel-exec:synchronization-layer"/>16.3.5.3 The Synchronization Layer<a class="headerlink" href="#sec:parallel-exec:synchronization-layer" title="Permalink to this headline"></a></h4>

<p>The Synchronization Layer encapsulates the parallel
simulation algorithm. Parallel simulation algorithms are also represented
by classes, subclassed from the <tt>cParsimSynchronizer</tt> abstract class.
The parallel simulation algorithm is invoked on the following hooks:
event scheduling, processing model messages outgoing from the LP,
and messages (model messages or internal messages) arriving
from other LPs. The first hook, event scheduling, is a function
invoked by the simulation kernel to determine the next simulation
event; it also has full access to the future event set (FES<!--FES-->) and
can add/remove events for its own use.
Conservative parallel simulation algorithms will use this hook
to block the simulation if the next event is unsafe, e.g. the
null message algorithm implementation (<tt>cNullMessageProtocol</tt>)
blocks the simulation if an EIT has been reached until a null message
arrives (see [<a href="#bib-bagrodia00">bagrodia00</a>] for terminology); also it uses
this hook to periodically send null messages. The second hook
is invoked when a model message is sent to another LP;
the null message algorithm uses this hook to piggyback null
messages on outgoing model messages. The third hook is invoked
when any message arrives from other LPs, and it allows the
parallel simulation algorithm to process its own internal messages
from other partitions; the null message algorithm processes
incoming null messages here.

<p>The Null Message Protocol implementation itself is modular;
it employs a separate, configurable lookahead discovery object.
Currently only link delay based lookahead discovery has been
implemented, but it is possible to implement more sophisticated
types.

<p>The Ideal Simulation Protocol (ISP; see [<a href="#bib-bagrodia00">bagrodia00</a>])
implementation consists of two parallel simulation
protocol implementations:
the first one is based on the null message algorithm and
additionally records the external events (events received
from other LPs) to a trace file; the second one executes
the simulation using the trace file to find out which
events are safe and which are not.

<p>Note that although we implemented a conservative protocol,
the provided API itself would allow implementing optimistic
protocols, too. The parallel simulation algorithm has
access to the executing simulation model, so it could perform
saving/restoring model state if model objects support this
  <br><ul><font size=-1>[Unfortunately, support for state saving/restoration
  needs to be individually and manually added to each class
  in the simulation, including user-programmed simple modules.]</font></ul>.

<p>We also expect that because of the modularity, extensibility and
clean internal architecture of the parallel simulation subsystem,
the OMNeT++ framework has the potential to become a preferred platform
for PDES research.

<p>
<hr class='pgbr'><h1><a name="cha:plugin-exts"/>17 Customizing and Extending OMNeT++<a class="headerlink" href="#cha:plugin-exts" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:plugin-exts:overview"/>17.1 Overview<a class="headerlink" href="#sec:plugin-exts:overview" title="Permalink to this headline"></a></h2>

<p>OMNeT++ is an open system, and several details of its operation can be
customized and extended by writing C++ code. Some extension interfaces
have already been covered in other chapters:

<p><ul>
   <li> <i>Defining new NED functions</i> was described in
     <a href="#sec:sim-lib:defining-ned-functions">[7.11]</a>
   <li> <i>Defining new result filters and recorders</i> was described
     in <a href="#sec:simple-modules:writing-result-filters">[4.15.6]</a>
</ul>

<p>This chapter will begin by introducing some infrastructure features that
are useful for extensions:

<p><ul>
   <li> <i>Config options</i>. This facility lets other extensions classes
     define their own configuration options.
   <li> <i>Simulation lifecycle listeners</i> allow extensions to get
     notified when a network is set up, simulation is started, paused or resumed,
     the simulation ended successfully or with an error, and so on.
   <li> <tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt> lets extensions schedule actions for certain simulation
     times. This is especially useful for custom event schedulers that we'll
     cover later in this chapter.
</ul>

<p>Then we will continue with the descriptions of the following extension
interfaces:

<p><ul>
   <li> <tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt> lets one add new random number generator algorithms.
   <li> <tt><a href="../api/classomnetpp_1_1cScheduler.html">cScheduler</a></tt> is an interface for event schedulers.
     This extension interface allows for implementing real-time,
     hardware-in-the-loop, distributed and distributed parallel simulation.
   <li> <tt><a href="../api/classomnetpp_1_1cFutureEventSet.html">cFutureEventSet</a></tt>. This extension interface allows one to
     replace the data structure used for storing future events during
     simulation, i.e. the FES. This may make sense for specialized
     workloads.
   <li> <tt><a href="../api/classomnetpp_1_1cFingerprintCalculator.html">cFingerprintCalculator</a></tt>. This extension interface allows one
     to replace or extend the fingerprint computation algorithm.
   <li> <tt><a href="../api/classomnetpp_1_1cIOutputScalarManager.html">cIOutputScalarManager</a></tt>. This extension interface allows
     one to create additional means of saving scalar results, for example
     database or CSV output.
   <li> <tt><a href="../api/classomnetpp_1_1cIOutputVectorManager.html">cIOutputVectorManager</a></tt>. This extension interface allows
     one to create additional means of saving vector results, for example
     database or CSV output.
   <li> <tt><a href="../api/classomnetpp_1_1cIEventlogManager.html">cIEventlogManager</a></tt>. This extension interface allows one
     to customize event log recording.
   <li> <tt><a href="../api/classomnetpp_1_1cISnapshotManager.html">cISnapshotManager</a></tt>. It provides an output stream to which
     snapshots are written.
   <li> <tt><a href="../api/classomnetpp_1_1cConfigurationEx.html">cConfigurationEx</a></tt>. Configuration provider extension.
     This extension interface lets one replace <tt>omnetpp.ini</tt>
     with some other implementation, for example a database.
   <li> <i>User interfaces</i>. When existing runtime user interfaces
     (Cmdenv, Tkenv, Qtenv) don't suffice, one can create a new one,
     reusing the infrastructure provided by the common base of the three.
</ul>

<p>Many extension interfaces follow a common pattern: one needs to implement a
given interface class (e.g. <tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt> for random number generators),
let OMNeT++ know about it by registering the class with the
<tt>Register_Class()</tt> macro, and finally activate it by the appropriate
configuration option (e.g. <tt>rng-class=MyRNG</tt>). The interface classes
(<tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt>, <tt><a href="../api/classomnetpp_1_1cScheduler.html">cScheduler</a></tt>, etc.) are documented in the API
Reference.

<p><ul class="note"><b>NOTE</b><br>
A common error is that OMNeT++ cannot find the class at runtime. When that
happens, make sure the executable actually contains the code of the class.
When linking with a library, over-optimizing linkers (esp. on Unix) tend to
leave out code which seems to be unreferenced by other parts of the
program.
</ul>

<p>The following sections elaborate on the various extension interfaces.

<p>
<h2><a name="sec:plugin-exts:configoption"/>17.2 Adding a New Configuration Option<a class="headerlink" href="#sec:plugin-exts:configoption" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:plugin-exts:configoption:registration"/>17.2.1 Registration<a class="headerlink" href="#sec:plugin-exts:configoption:registration" title="Permalink to this headline"></a></h3>

<p>New configuration options need to be declared with one of the appropriate
registration macros. These macros are:

<pre class="cpp">
Register_GlobalConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_PerRunConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_GlobalConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register_PerRunConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register_PerObjectConfigOption(ID, NAME, KIND, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_PerObjectConfigOptionU(ID, NAME, KIND, UNIT, DEFAULTVALUE, DESCRIPTION)
</pre>
<p>
Config options come in three flavors, as indicated by the macro names:

<p><ul>
  <li> <i>Global</i> options affect all configurations (i.e. they are
      only accepted in the <tt>[General]</tt> section but not in
      <tt>[Config &lt;name&gt;]</tt> sections)
  <li> <i>Per-Run</i> options can be specified in any section
      (i.e. both in <tt>[General]</tt> and in <tt>[Config &lt;name&gt;]</tt> sections).
      They affect the configuration they occur in.
  <li> <i>Per-Object</i> options can be specified in any section
      (i.e. both in <tt>[General]</tt> and in <tt>[Config &lt;name&gt;]</tt> sections).
      They are specific to an object or group of objects. Their names
      must always contain a hyphen (-) character so that they can be
      distinguished from module/channel parameter assignments when they
      occur in ini files.
</ul>

<p>The macro arguments are as follows:
<ul>
  <li> <i>ID</i> is a C++ identifier that becomes the name of a global
        variable, a pointer to a <tt><a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a></tt> object that the
        macro creates. It lets you refer to the configuration option, 
        e.g. when querying its value using <tt><a href="../api/classomnetpp_1_1cConfiguration.html">cConfiguration</a></tt>'s member 
        functions.
  <li> <i>NAME</i> is the name of the option (a string).
  <li> <i>KIND</i> applies to per-object configuration options, and 
        clarifies what kind of objects the option applies to. Its value 
        must be one of: <tt>KIND_COMPONENT</tt> (module or channel),
        <tt>KIND_CHANNEL</tt>, <tt>KIND_MODULE</tt> (simple or compound module),
        <tt>KIND_SIMPLE_MODULE</tt>, <tt>KIND_PARAMETER</tt> (module or channel
        parameter), <tt>KIND_STATISTIC</tt> (statistic declared in NED
        via <b><tt>@statistic</tt></b>), <tt>KIND_SCALAR</tt> (output scalar),
        <tt>KIND_VECTOR</tt> (output vector), <tt>KIND_UNSPECIFIED_TYPE</tt>
        (only used for the <b><tt>typename</tt></b> option), <tt>KIND_OTHER</tt>
        (anything else).
  <li> <i>TYPE</i> is the data type of the config option; it must be one of:
        <tt>CFG_BOOL</tt>, <tt>CFG_INT</tt>, <tt>CFG_DOUBLE</tt>, <tt>CFG_STRING</tt>,
        <tt>CFG_FILENAME</tt>, <tt>CFG_FILENAMES</tt>, <tt>CFG_PATH</tt>, <tt>CFG_CUSTOM</tt>.
        The most significant difference between filesystem-related types
        (filename, filenames, path) and plain strings is that relative
        filenames and paths are automatically converted to absolute
        when the configuration is read, with the base directory being the
        location of the ini file where the configuration entry was read from.
  <li> <i>UNIT</i> is a string that names the measurement unit in which
        the option's value is to be interpreted; it implies type <tt>CFG_DOUBLE</tt>.
  <li> <i>DEFAULTVALUE</i> is the default value in textual form (string);
        this should be <tt>nullptr</tt> if the option has no default value.
  <li> <i>DESCRIPTION</i> is an arbitrarily long string that describes
        the purpose and and operation of the option. It will be used in
        help texts etc.
</ul>

<p>For example, the <tt>debug-on-errors</tt> option is declared in the following way:

<pre class="cpp">
Register_GlobalConfigOption(CFGID_DEBUG_ON_ERRORS, "debug-on-errors",
    CFG_BOOL, "false", "When enabled, runtime errors will cause...");
</pre>
<p>
The macro will register the option, and also declare the
<tt>CFGID_DEBUG_ON_ERRORS</tt> variable as pointer to a
<tt><a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a></tt>. The variable can be used later as a &#8220;handle&#8221; when
reading the option value from the configuration database.

<p><h3><a name="sec:plugin-exts:configoption:reading-values"/>17.2.2 Reading the Value<a class="headerlink" href="#sec:plugin-exts:configoption:reading-values" title="Permalink to this headline"></a></h3>

<p>The configuration is accessible via the <tt>getConfig()</tt> method of <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>.
It returns a pointer to the configuration object (<tt><a href="../api/classomnetpp_1_1cConfiguration.html">cConfiguration</a></tt>):

<pre class="cpp">
<a href="../api/classomnetpp_1_1cConfiguration.html">cConfiguration</a> *config = getEnvir()-&gt;getConfig();
</pre>
<p>
<tt><a href="../api/classomnetpp_1_1cConfiguration.html">cConfiguration</a></tt> provides several methods for querying the configuration.

<p><ul class="note"><b>NOTE</b><br>
The configuration object provides a flattened view of the ini file. Sections
inheriting from each other are merged. Configuration options provided
on the command line in the form <tt>--option=value</tt> are added first to the object.
This ensures that the command line options take precedence over the values specified
in the INI file.
</ul>

<pre class="cpp">
const char *getAsCustom(<a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a> *entry, const char *fallbackValue=nullptr);
bool getAsBool(<a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a> *entry, bool fallbackValue=false);
long getAsInt(<a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a> *entry, long fallbackValue=0);
double getAsDouble(<a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a> *entry, double fallbackValue=0);
std::string getAsString(<a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a> *entry, const char *fallbackValue="");
std::string getAsFilename(<a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a> *entry);
std::vector&lt;std::string&gt; getAsFilenames(<a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a> *entry);
std::string getAsPath(<a href="../api/classomnetpp_1_1cConfigOption.html">cConfigOption</a> *entry);
</pre>
<p>
<i>fallbackValue</i> is returned if the value is not specified in the configuration,
and there is no default value.

<pre class="cpp">
bool debug = getEnvir()-&gt;getConfig()-&gt;getAsBool(CFGID_PARSIM_DEBUG);
</pre>
<p>

<p><h2><a name="sec:plugin-exts:simulation-lifetime-listeners"/>17.3 Simulation Lifetime Listeners<a class="headerlink" href="#sec:plugin-exts:simulation-lifetime-listeners" title="Permalink to this headline"></a></h2>

<p><tt><a href="../api/classomnetpp_1_1cISimulationLifecycleListener.html">cISimulationLifecycleListener</a></tt> is a callback interface for
receiving notifications at various stages of simulations: setting up,
running, tearing down, etc. Extension classes such as custom event
schedulers often need this functionality for performing initalization
and various other tasks.

<p>Listeners of the type <tt><a href="../api/classomnetpp_1_1cISimulationLifecycleListener.html">cISimulationLifecycleListener</a></tt> need to be
added to <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt> with its <tt>addLifecycleListener()</tt> method,
and removed with <tt>removeLifecycleListener()</tt>.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cISimulationLifecycleListener.html">cISimulationLifecycleListener</a> *listener = ...;
getEnvir()-&gt;addLifecycleListener(listener);
// and finally:
getEnvir()-&gt;removeLifecycleListener(listener);
</pre>
<p>
To implement a simulation lifecycle listener, subclass from
<tt><a href="../api/classomnetpp_1_1cISimulationLifecycleListener.html">cISimulationLifecycleListener</a></tt>, and override its
<tt>lifecycleEvent()</tt> method. It has the following signature:

<pre class="cpp">
virtual void lifecycleEvent(SimulationLifecycleEventType eventType, <a href="../api/classomnetpp_1_1cObject.html">cObject</a> *details) = 0;
</pre>
<p>

Event type is one of the following. Their names are fairly self-describing,
but the API documentation contains more precise information.

<p><ul>
  <li> <tt>LF_ON_STARTUP</tt>
  <li> <tt>LF_PRE_NETWORK_SETUP</tt>, <tt>LF_POST_NETWORK_SETUP</tt>
  <li> <tt>LF_PRE_NETWORK_INITIALIZE</tt>, <tt>LF_POST_NETWORK_INITIALIZE</tt>
  <li> <tt>LF_ON_SIMULATION_START</tt>
  <li> <tt>LF_ON_SIMULATION_PAUSE</tt>, <tt>LF_ON_SIMULATION_RESUME</tt>
  <li> <tt>LF_ON_SIMULATION_SUCCESS</tt>, <tt>LF_ON_SIMULATION_ERROR</tt>
  <li> <tt>LF_PRE_NETWORK_FINISH</tt>, <tt>LF_POST_NETWORK_FINISH</tt>
  <li> <tt>LF_ON_RUN_END</tt>
  <li> <tt>LF_PRE_NETWORK_DELETE</tt>, <tt>LF_POST_NETWORK_DELETE</tt>
  <li> <tt>LF_ON_SHUTDOWN</tt>
</ul>

<p>The <i>details</i> argument is currently <tt>nullptr</tt>; further OMNeT++
versions may pass extra information in it. Notifications always refer to
the active simulation in case there're more (see <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>'s
<tt>getActiveSimulation()</tt>).

<p>Simulation lifecycle listeners are mainly intended for use by classes that
extend the simulator's functionality, for example custom event schedulers
and output vector/scalar managers. The lifecycle of such an extension
object is managed by OMNeT++, so one can use their constructor to create and
add the listener object to <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>, and the destructor to remove
and delete it. The code is further simplified if the extension object
itself implements <tt><a href="../api/classomnetpp_1_1cISimulationLifecycleListener.html">cISimulationLifecycleListener</a></tt>:


<pre class="cpp">
class CustomScheduler : public <a href="../api/classomnetpp_1_1cScheduler.html">cScheduler</a>, public <a href="../api/classomnetpp_1_1cISimulationLifecycleListener.html">cISimulationLifecycleListener</a>
{
  public:
    CustomScheduler() { getEnvir()-&gt;addLifecycleListener(this); }
    ~CustomScheduler() { getEnvir()-&gt;removeLifecycleListener(this); }
    //...
};
</pre>
<p>

<p><h2><a name="sec:plugin-exts:cevent"/>17.4 <a href="../api/classomnetpp_1_1cEvent.html">cEvent</a><a class="headerlink" href="#sec:plugin-exts:cevent" title="Permalink to this headline"></a></h2>

<p><tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt> represents an event in the discrete event simulator. When
events are scheduled, they are inserted into the future events set (FES).
During the simulation, events are removed from the FES and executed one by
one in timestamp order. A <tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt> is executed by invoking its
<tt>execute()</tt> member function. <tt>execute()</tt> should be overridden
in subclasses to carry out the actions associated with the event.

<p><ul class="note"><b>NOTE</b><br>
<tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> is also a subclass of <tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt>. Its
<tt>execute()</tt> method calls the <tt>handleMessage()</tt> method of the
message's destination module, or switches to the coroutine of its
<tt>activity()</tt> method.
</ul>

<p><tt>execute()</tt> has the following signature:

<pre class="cpp">
virtual void execute() = 0;
</pre>
<p>
Raw (non-message) event objects are an internal mechanism of the OMNeT++
simulation kernel, and should not used in programming simulation models.
However, they can be very useful when implementing custom event schedulers.
For example, in co-simulation, events that occur in the other simulator may
be represented with a <tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt> in OMNeT++. Simulation time limit
is also implemented with a custom <tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt>.

<p>
<h2><a name="sec:plugin-exts:rng"/>17.5 Defining a New Random Number Generator<a class="headerlink" href="#sec:plugin-exts:rng" title="Permalink to this headline"></a></h2>

<p>This interface lets one add new RNG implementations (see section
<a href="#sec:sim-lib:random-number-generators">[7.3]</a>) to OMNeT++.
The motivation might be achieving integration with external software (for
example something like Akaroa), or exactly replicating the trajectory of a
simulation ported from another simulation framework that uses a different
RNG.

<p>The new RNG C++ class must implement the <tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt> interface,
and can be activated with the <b><tt>rng-class</tt></b> configuration option.

<p>
<h2><a name="sec:plugin-exts:scheduler"/>17.6 Defining a New Event Scheduler<a class="headerlink" href="#sec:plugin-exts:scheduler" title="Permalink to this headline"></a></h2>

<p>This extension interface lets one replace the event scheduler class with a
custom one, which is the key for implementing many features including
cosimulation, real-time simulation, network or device emulation, and
distributed simulation.

<p>The job of the event scheduler is to always return the next event to be
processed by the simulator. The default implementation returns the first
event in the future events list. Other variants:

<p><ul>
<li> For real-time simulation, this scheduler is replaced with one augmented
    with <i>wait</i> calls (e.g. <tt>usleep()</tt>) that synchronize the
    simulation time to the system clock. There are several options on what
    should happen if the simulation time has already fallen behind: one may
    re-adjust the reference time, leave it unchanged in the hope of catching up
    later, or stop with an error message.

<p><li> For emulation, the real-time scheduler is augmented with code that captures
    packets from real network devices, and inserts them into the simulation.
    INET Framework, the main protocol simulation package for OMNeT++, contains
    an emulation scheduler. It uses the <i>pcap</i> library to capture
    packets, and raw sockets to send packets to a real network device.
    Emulation in INET also involves <i>header serializer</i> classes that
    convert between protocol headers and their C++ object representations used
    within the simulation.

<p><li> For parallel simulation (see chapter <a href="#cha:parallel-exec">[16]</a>), the
    scheduler is modified to listen for messages arriving from other logical
    processes (LPs), and inserts them into the simulation. The scheduler also
    blocks the simulation when it is not safe to execute the next event due to
    potential causality violation, until clearance arrives from other LPs to
    continue in the form of a null message.

<p><li> OMNeT++ supports distributed simulation using HLA (IEEE 1516) <br><ul><font size=-1>[The
    source code for the HLA and SystemC integration features are not open
    source, but they are available to researchers on request free of charge.]</font></ul>
    as well. The scheduler plays the role of the HLA Federate Ambassador, is
    responsible for exchanging messages (interactions, change notifications,
    etc.) with other federates, and performs time regulation.

<p><li> OMNeT++ also supports mixing SystemC (IEEE 1666-2005) modules with OMNeT++
    modules in the simulation. When this feature is enabled, there are two
    future event lists in the simulation, OMNeT++'s and SystemC's, and a
    special scheduler takes care that events are consumed from both lists in
    increasing timestamp order. This method of performing mixed simulations is
    orders of magnitude faster and also more flexible than letting the two
    simulators execute in separate processes and communicate over a pipe or
    socket connection.
</ul>

<p>The scheduler C++ class must implement the <tt><a href="../api/classomnetpp_1_1cScheduler.html">cScheduler</a></tt> interface,
and can be activated with the <b><tt>scheduler-class</tt></b> configuration option.

<p>Simulation lifetime listeners and the <tt><a href="../api/classomnetpp_1_1cEvent.html">cEvent</a></tt> class can be extremely
useful when implementing certain types of event schedulers.

<p>To see examples of scheduler classes, check the
<tt><a href="../api/classomnetpp_1_1cSequentialScheduler.html">cSequentialScheduler</a></tt> and <tt><a href="../api/classomnetpp_1_1cRealTimeScheduler.html">cRealTimeScheduler</a></tt> classes in
the simulation kernel, <tt>cSocketRTScheduler</tt> which is part of the
<i>Sockets</i> sample simulation, or <tt>cParsimSynchronizer</tt> and its
subclasses that are part of the parallel simulation support of OMNeT++.

<p>
<h2><a name="sec:plugin-exts:fes"/>17.7 Defining a New FES Data Structure<a class="headerlink" href="#sec:plugin-exts:fes" title="Permalink to this headline"></a></h2>

<p>This extension interface allows one to replace the data structure used for
storing future events during simulation, i.e. the FES. Replacing the FES
may make sense for specialized workloads, or for the purpose of performance
comparison of various FES algorithms. (The default, binary heap based FES
implementation is a good choice for general workloads.)

<p>The FES C++ class must implement the <tt><a href="../api/classomnetpp_1_1cFutureEventSet.html">cFutureEventSet</a></tt> interface,
and can be activated with the <b><tt>futureeventset-class</tt></b> configuration option.

<p>
<h2><a name="sec:plugin-exts:fingerprint"/>17.8 Defining a New Fingerprint Algorithm<a class="headerlink" href="#sec:plugin-exts:fingerprint" title="Permalink to this headline"></a></h2>

<p>This extension interface allows one to replace or extend the fingerprint
computation algorithm (see section <a href="#sec:testing:fingerprint-tests">[15.4]</a>).

<p>
The fingerprint computation class must implement the <tt><a href="../api/classomnetpp_1_1cFingerprintCalculator.html">cFingerprintCalculator</a></tt> interface,
and can be activated with the <b><tt>fingerprintcalculator-class</tt></b> configuration option.

<p>
<h2><a name="sec:plugin-exts:outputscalarmanager"/>17.9 Defining a New Output Scalar Manager<a class="headerlink" href="#sec:plugin-exts:outputscalarmanager" title="Permalink to this headline"></a></h2>

<p>An output scalar manager handles the recording the scalar and histogram
output data. The default output scalar manager is
<tt>cFileOutputScalarManager</tt> that saves data into <tt>.sca</tt> files.
This extension interface allows one to create additional means of saving
scalar and histogram results, for example database or CSV output.

<p>The new class must implement <tt><a href="../api/classomnetpp_1_1cIOutputScalarManager.html">cIOutputScalarManager</a></tt>, and can be
activated with the <b><tt>outputscalarmanager-class</tt></b> configuration
option.

<p>
<h2><a name="sec:plugin-exts:outputvectormanager"/>17.10 Defining a New Output Vector Manager<a class="headerlink" href="#sec:plugin-exts:outputvectormanager" title="Permalink to this headline"></a></h2>

<p>An output vector manager handles the recording output vectors, produced
for example by <tt><a href="../api/classomnetpp_1_1cOutVector.html">cOutVector</a></tt> objects. The default output vector
manager is <tt>cIndexedFileOutputVectorManager</tt> that saves data into
<tt>.vec</tt> files, indexed in separate <tt>.vci</tt> files. This extension
interface allows one to create additional means of saving vector results,
for example database or CSV output.

<p>The new class must implement the <tt><a href="../api/classomnetpp_1_1cIOutputVectorManager.html">cIOutputVectorManager</a></tt> interface,
and can be activated with the <b><tt>outputvectormanager-class</tt></b>
configuration option.

<p>
<h2><a name="sec:plugin-exts:eventlogmanager"/>17.11 Defining a New Eventlog Manager<a class="headerlink" href="#sec:plugin-exts:eventlogmanager" title="Permalink to this headline"></a></h2>

<p>An eventlog manager handles the recording of simulation history into an
event log (see <a href="#cha:eventlog">[13]</a>). The default eventlog manager is
<tt>EventlogFileManager</tt>, which records into file, and also allows for
some filtering. By replacing the default eventlog manager class, one can
introduce additional filtering, record into a different file format or
to different storage (e.g. to a database or a remote vizualizer).

<p>The new class must implement the <tt><a href="../api/classomnetpp_1_1cIEventlogManager.html">cIEventlogManager</a></tt> interface,
and can be activated with the <b><tt>eventlogmanager-class</tt></b> configuration
option.

<p>
<h2><a name="sec:plugin-exts:snapshotmanager"/>17.12 Defining a New Snapshot Manager<a class="headerlink" href="#sec:plugin-exts:snapshotmanager" title="Permalink to this headline"></a></h2>

<p>A snapshot manager provides an output stream to which snapshots are written
(see section <a href="#sec:sim-lib:snapshots">[7.10.5]</a>). The default snapshot manager
is <tt>cFileSnapshotManager</tt>.

<p>The new class must implement the <tt><a href="../api/classomnetpp_1_1cISnapshotManager.html">cISnapshotManager</a></tt> interface, and
can be activated with the <b><tt>snapshotmanager-class</tt></b> configuration
option.

<p>
<h2><a name="sec:plugin-exts:configuration-providers"/>17.13 Defining a New Configuration Provider<a class="headerlink" href="#sec:plugin-exts:configuration-providers" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:plugin-exts:configprovider-overview"/>17.13.1 Overview<a class="headerlink" href="#sec:plugin-exts:configprovider-overview" title="Permalink to this headline"></a></h3>

<p>The configuration provider extension lets one replace ini files
with some other storage implementation, for example a database.
The configuration provider C++ class must implement the
<tt><a href="../api/classomnetpp_1_1cConfigurationEx.html">cConfigurationEx</a></tt> interface, and can be activated with
the <b><tt>configuration-class</tt></b> configuration option.

<p>The <tt><a href="../api/classomnetpp_1_1cConfigurationEx.html">cConfigurationEx</a></tt> interface abstracts the inifile-based
data model to some degree. It assumes that the configuration data
consists of several <i>named configurations</i>. Before every
simulation run, one of the <i>named configurations</i> is
activated, and from then on, all queries into the configuration
operate on the <i>active named configuration</i> only.

<p>It practice, you will probably use the <tt>SectionBasedConfiguration</tt>
class (in <tt>src/envir</tt>) or subclass from it, because it already
implements a lot of functionality that you would otherwise have to.

<p><tt>SectionBasedConfiguration</tt> does not assume ini files or
any other particular storage format; instead, it accepts
an object that implements the <tt><a href="../api/classomnetpp_1_1cConfigurationReader.html">cConfigurationReader</a></tt>
interface to provide the data in raw form to it.
The default implementation of <tt><a href="../api/classomnetpp_1_1cConfigurationReader.html">cConfigurationReader</a></tt> is
<tt>InifileReader</tt>.

<p><h3><a name="sec:plugin-exts:configprovider-startup-sequence"/>17.13.2 The Startup Sequence<a class="headerlink" href="#sec:plugin-exts:configprovider-startup-sequence" title="Permalink to this headline"></a></h3>

<p>From the configuration extension's point of view, the startup sequence
looks like the following (see <tt>src/envir/startup.cc</tt> in the source code):

<p><ol>
  <li> First, ini files specified on the command-line are read into a
     <i>boot-time configuration object</i>. The boot-time configuration
     is always a <tt>SectionBasedConfiguration</tt> with
     <tt>InifileReader</tt>.
  <li> Shared libraries are loaded (see the <tt>-l</tt> command-line option,
     and the <b><tt>load-libs</tt></b> configuration option). This allows
     configuration classes to come from shared libraries.
  <li> The <b><tt>configuration-class</tt></b> configuration option is examined.
     If it is present, a configuration object of the given class
     is instantiated, and replaces the boot-time configuration.
     The new configuration object is initialized from the boot-time
     configuration, so that it can read parameters (e.g. database
     connection parameters, XML file name, etc) from it.
     Then the boot-time configuration object is deallocated.
  <li> The <b><tt>load-libs</tt></b> option from the new configuration object is
     processed.
  <li> Then everything goes on as normally, using the new configuration
     object.
</ol>

<p><h3><a name="sec:plugin-exts:configprovider:custom-class"/>17.13.3 Providing a Custom Configuration Class<a class="headerlink" href="#sec:plugin-exts:configprovider:custom-class" title="Permalink to this headline"></a></h3>

<p>To replace the configuration object with a custom implementation,
one needs to subclass <tt><a href="../api/classomnetpp_1_1cConfigurationEx.html">cConfigurationEx</a></tt>, register the new class,

<pre class="cpp">
#include "cconfiguration.h"

class CustomConfiguration : public <a href="../api/classomnetpp_1_1cConfigurationEx.html">cConfigurationEx</a>
{
   ...
};

Register_Class(CustomConfiguration);
</pre>
<p>
and then activate it in the boot-time configuration:

<pre class="inifile">
[General]
configuration-class = CustomConfiguration
</pre>
<p>

<p><h3><a name="sec:plugin-exts:custom-reader-for-sectionbasedconfiguration"/>17.13.4 Providing a Custom Reader for SectionBasedConfiguration<a class="headerlink" href="#sec:plugin-exts:custom-reader-for-sectionbasedconfiguration" title="Permalink to this headline"></a></h3>

<p>As said already, writing a configuration class from scratch can
be a lot of work, and it may be more practical to reuse
<tt>SectionBasedConfiguration</tt> with a different configuration
reader class. This can be done with <b><tt>sectionbasedconfig-configreader-class</tt></b>
config option, which is interpreted by <tt>SectionBasedConfiguration</tt>.
Specify the following in the boot-time ini file:

<pre class="inifile">
[General]
configuration-class = SectionBasedConfiguration
sectionbasedconfig-configreader-class = &lt;new-reader-class&gt;
</pre>
<p>
The configuration reader class should look like this:

<pre class="cpp">
#include "cconfigreader.h"

class DatabaseConfigurationReader : public <a href="../api/classomnetpp_1_1cConfigurationReader.html">cConfigurationReader</a>
{
   ...
};

Register_Class(DatabaseConfigurationReader);
</pre>
<p>

<p><h2><a name="sec:plugin-exts:user-interface"/>17.14 Implementing a New User Interface<a class="headerlink" href="#sec:plugin-exts:user-interface" title="Permalink to this headline"></a></h2>

<p>It is possible to extend OMNeT++ with a new user interface. The new
user interface will have fully equal rights to Cmdenv, Tkenv and Qtenv;
that is, it can be activated by starting the simulation executable with the
<tt>-u</tt> <i>&lt;name&gt;</i> command-line or the <b><tt>user-interface</tt></b>
configuration option, it can be made the default user interface,
it can define new command-line options and configuration options,
and so on.

<p>User interfaces must implement (i.e. subclass from) <tt><a href="../api/classomnetpp_1_1cRunnableEnvir.html">cRunnableEnvir</a></tt>,
and must be registered to OMNeT++ with the <tt>Register_OmnetApp()</tt> macro.
In practice, you will almost always want to subclass <tt>EnvirBase</tt>
instead of <tt><a href="../api/classomnetpp_1_1cRunnableEnvir.html">cRunnableEnvir</a></tt>, because <tt>EnvirBase</tt> already
implements lots of functionality that otherwise you'd have to.

<p><ul class="note"><b>NOTE</b><br>
If you want something completely different from what <tt>EnvirBase</tt>
provides, such as embedding the simulation kernel into another
application, then you should be reading section <a href="#sec:embedding:embedding">[18.2]</a>,
not this one.
</ul>

<p>An example user interface:

<pre class="cpp">
#include "envirbase.h"

class FooEnv : public EnvirBase
{
    ...
};

Register_OmnetApp("FooEnv", FooEnv, 30, "an experimental user interface");
</pre>
<p>
The <tt>envirbase.h</tt> header comes from the <tt>src/envir</tt> directory,
so it is necessary to add it to the include path (<tt>-I</tt>).

<p>The arguments to <tt>Register_OmnetApp()</tt> include the user interface name
(for use with the <tt>-u</tt> and <b><tt>user-interface</tt></b> options),
the C++ class that implements it, a weight for default user interface selection
(if <tt>-u</tt> is missing, the user interface with the largest weight will be
activated), and a description string (for help and other purposes).

<p>The C++ class should implement all methods left pure virtual in
<tt>EnvirBase</tt>, and possibly others if you want to customize
their behavior. One method that you will surely want to reimplement is
<tt>run()</tt> -- this is where your user interface runs. When this method
exits, the simulation program exits.

<p><ul class="note"><b>NOTE</b><br>
A good starting point for implementing your own user interface is
Cmdenv -- just copy and modify its source code to quickly get going.
</ul>

<p>
<hr class='pgbr'><h1><a name="cha:embedding"/>18 Embedding the Simulation Kernel<a class="headerlink" href="#cha:embedding" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:embedding:architecture"/>18.1 Architecture<a class="headerlink" href="#sec:embedding:architecture" title="Permalink to this headline"></a></h2>

<p>OMNeT++ has a modular architecture. The following diagram illustrates the
high-level architecture of OMNeT++ simulations:

<p>
  <center>
    <img src="embed-architecture.svg">
    <center><div class="caption"><i>Figure: The architecture of OMNeT++ simulations</i></div></center>
  </center>

<p>
The blocks represent the following components:

<p><ul>
  <li> <b>Sim</b> is the simulation kernel and class
    library<!--simulation!kernel-->. Sim is a library linked to
    simulation programs.
  <li> <b>Envir</b> is another library that contains all code
    that is common to all the user interfaces. <tt>main()</tt> also resides
    in the Envir library. Envir presents itself towards Sim and the executing model
    as an instance of the <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt> facade class. Some aspects of the
    Envir library like result recording can be customized<!--customization-->
    using plugin interfaces. Embedding OMNeT++ into applications<!--embedding-->
    usually involves writing a custom <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt> subclass (see sections
    <a href="#sec:plugin-exts:user-interface">[17.14]</a> and <a href="#sec:embedding:embedding">[18.2]</a>.)
  <li> <b>Cmdenv, Tkenv and Qtenv</b> are Envir-based libraries that contain
    specific user interface implementations. A simulation program
    is linked with one or more of them; in the latter case, one of the UI libraries
    is chosen and instantiated either explicitly or automatically when the program starts.
  <li> The <b>Model Component Library</b> includes simple module definitions and
    their C++ implementations, compound module types, channels, networks,
    message types, and everything belonging to models that
    have been linked to the simulation program. A simulation program can
    run any model that contains all of the required linked components.
  <li> The <b>Executing Model</b> is the model that is set up
    for simulation. This model contains objects (modules, channels, and so on) that
    are all instances of the components in the model component library.
</ul>

<p>The arrows in the figure describe how components interact with
each other:

<p><ul>
  <li> <b>Executing Model <i><==></i> Sim</b>. The simulation kernel
    manages the future events and activates modules in the executing model
    as events occur. The modules of the executing model are stored in an
    instance of the class <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>. In turn, the executing model
    calls functions in the simulation kernel and uses classes in the Sim library.
  <li> <b>Sim <i><==></i> Model Component Library</b>. The simulation kernel
    instantiates simple modules and other components when the simulation model
    is set up at the beginning of the simulation run. In addition, it refers
    to the component library when dynamic module creation is used.
    The mechanisms for registering and looking up components in the model
    component library are implemented as part of Sim.
  <li> <b>Executing Model <i><==></i> Envir</b>. The Envir presents itself
    as a facade object towards the executing model. Model code directly accesses Envir
    e.g. for logging (<tt>EV&lt;&lt;</tt>).
  <li> <b>Sim <i><==></i> Envir</b>. Envir is in full command of what
    happens in the simulation program. Envir contains the <tt>main()</tt> function
    where execution begins. Envir determines which models should be set up
    for simulation, and instructs Sim to do so. Envir contains the main
    simulation loop (<i>determine-next-event</i>, <i>execute-event</i>
    sequence) and invokes the simulation kernel for the necessary
    functionality (event scheduling and event execution are implemented in Sim).
    Envir catches and handles errors and exceptions that occur
    in the simulation kernel or in the library classes during execution.
    Envir presents a single facade object toward Sim -- no Envir
    internals are visible to Sim or the executing model.
    During simulation model setup, Envir supplies module parameter values for
    Sim when Sim asks for them. Sim writes output vectors via Envir,
    so one can redefine the output vector storing mechanism by changing Envir.
    Sim and its classes use Envir to print debug information.
  <li> <b>Envir <i><==></i> Cmdenv/Tkenv/Qtenv</b>. Cmdenv, Tkenv and Qtenv
    are concrete user interface implementations. When a simulation program
    is started, the <tt>main()</tt> function (which is part of Envir) determines
    the appropriate user interface class, creates an instance and runs it.
    Sim's or the model's calls on Envir are delegated to the user interface.
</ul>

<p>
<h2><a name="sec:embedding:embedding"/>18.2 Embedding the OMNeT++ Simulation Kernel<a class="headerlink" href="#sec:embedding:embedding" title="Permalink to this headline"></a></h2>

<p>This section discusses the issues of embedding the simulation kernel
or a simulation model into a larger application. We assume that you
do not just want to change one or two aspects of the simulator
(such as , event scheduling or result recording) or create a new user interface
such as Cmdenv or Tkenv -- if so, see chapter <a href="#cha:plugin-exts">[17]</a>.

<p>For the following section, we assume that you will write the embedding
program from scratch, that is, starting from a <tt>main()</tt> function.

<p><h3><a name="sec:embedding:main-function"/>18.2.1 The main() Function<a class="headerlink" href="#sec:embedding:main-function" title="Permalink to this headline"></a></h3>

<p>The minimalistic program described below initializes the simulation library
and runs two simulations. In later sections we will review the details
of the code and discuss how to improve it.

<pre class="cpp">
#include &lt;omnetpp.h&gt;
using namespace omnetpp;

int main(int argc, char *argv[])
{
    // the following line MUST be at the top of main()
    cStaticFlag dummy;

    // initializations
    <a href="../api/classomnetpp_1_1CodeFragments.html">CodeFragments</a>::executeAll(<a href="../api/classomnetpp_1_1CodeFragments.html">CodeFragments</a>::STARTUP);
    <a href="../api/classomnetpp_1_1SimTime.html">SimTime</a>::setScaleExp(-12);

    // load NED files
    <a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>::loadNedSourceFolder("./foodir");
    <a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>::loadNedSourceFolder("./bardir");
    <a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>::doneLoadingNedFiles();

    // run two simulations
    simulate("FooNetwork", 1000);
    simulate("BarNetwork", 2000);

    // deallocate registration lists, loaded NED files, etc.
    CodeFragment::executeAll(CodeFragment::SHUTDOWN);
    return 0;
}
</pre>
<p>
The first few lines of the code initialize the simulation library. The
purpose of <tt>cStaticFlag</tt> is to set a global variable to <tt>true</tt>
for the duration of the <tt>main()</tt> function, to help the simulation
library handle exceptions correctly in extreme cases.
<tt>CodeFragment::executeAll(CodeFragment::STARTUP)</tt> performs various startup
tasks, such as building registration tables out of the <tt>Define_Module()</tt>,
<tt>Register_Class()</tt> and similar entries throughout the code.
<tt><a href="../api/classomnetpp_1_1SimTime.html">SimTime</a>::setScaleExp(-12)</tt> sets the simulation time resolution to
picoseconds; other values can be used as well, but it is mandatory to
choose one.

<p><ul class="note"><b>NOTE</b><br>
The simulation time exponent cannot be changed at a later stage, since it is
a global variable, and the values of the existing <tt>simtime_t</tt> instances
would change.
</ul>

<p>The code then loads the NED files from the <tt>foodir</tt> and
<tt>bardir</tt> subdirectories of the working directory (as if the NED path
was <tt>./foodir;./bardir</tt>), and runs two simulations.

<p>
<h3><a name="sec:embedding:simulate-function"/>18.2.2 The simulate() Function<a class="headerlink" href="#sec:embedding:simulate-function" title="Permalink to this headline"></a></h3>

<p>A minimalistic version of the <tt>simulate()</tt> function is shown below.
In order to shorten the code, the exception handling code has been ommited (<tt>try</tt>/<tt>catch</tt> blocks)
apart from the event loop. However, every line is marked with &#8220;<tt>E!</tt>&#8221; where various
problems with the simulation model can occur and can be thrown as exceptions.

<pre class="cpp">
void simulate(const char *networkName, simtime_t limit)
{
    // look up network type
    <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a> *networkType = <a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a>::find(networkName);
    if (networkType == nullptr) {
        printf("No such network: %s\n", networkName);
        return;
    }

    // create a simulation manager and an environment for the simulation
    <a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a> *env = new CustomSimulationEnv(argc, argv, new EmptyConfig());
    <a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a> *sim = new <a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>("simulation", env);
    <a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>::setActiveSimulation(sim);

    // set up network and prepare for running it
    sim-&gt;setupNetwork(networkType); //E!
    sim-&gt;setSimulationTimeLimit(limit);

    // prepare for running it
    sim-&gt;callInitialize();

    // run the simulation
    bool ok = true;
    try {
        while (true) {
            <a href="../api/classomnetpp_1_1cEvent.html">cEvent</a> *event = sim-&gt;takeNextEvent();
            if (!event)
                break;
            sim-&gt;executeEvent(event);
        }
    }
    catch (<a href="../api/classomnetpp_1_1cTerminationException.html">cTerminationException</a>& e) {
        printf("Finished: %s\n", e.what());
    }
    catch (std::exception& e) {
        ok = false;
        printf("ERROR: %s\n", e.what());
    }

    if (ok)
        sim-&gt;callFinish();  //E!

    sim-&gt;deleteNetwork();  //E!

    <a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>::setActiveSimulation(nullptr);
    delete sim; // deletes env as well
}
</pre>
<p>
The function accepts a network type name (which must be fully qualified
with a package name) and a simulation time limit.

<p>In the first few lines, the code looks up the network among the available
module types, and prints an error message if it is not found.

<p>Then it proceeds to create and activate a simulation manager object
(<tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>). The simulation manager requires another object,
called the environment object. The environment object is used by the
simulation manager to read the configuration. In addition, the simulation
results are also written via the environment object.

<p>The environment object (<tt>CustomSimulationEnv</tt> in the above code) must
be provided by the programmer; this is described in detail in a later section.

<p><ul class="note"><b>NOTE</b><br>
In versions 4.x and earlier, the simulation manager and the
environment object could be accessed as <tt>simulation</tt> and <tt>ev</tt>
(which were global variables in 3.x and macros in 4.x). In 5.x they can be
accessed with the <tt>getSimulation()</tt> and <tt>getEnvir()</tt> functions,
which are basically aliases to <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>::getActiveSimulation()</tt> and
<tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>::getActiveSimulation()-&gt;getEnvir()</tt>.
</ul>

<p>The network is then set up in the simulation manager. The
<tt>sim-&gt;</tt><tt>setupNetwork()</tt> method creates the system module and
recursively all modules and their interconnections; module parameters are
also read from the configuration (where required) and assigned. If there is
an error (for example, module type not found), an exception will be thrown. The
exception object is some kind of <tt>std::exception</tt>, usually a
<tt><a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a></tt>.

<p>If the network setup is successful, <tt>sim-&gt;</tt><tt>callInitialize()</tt> is
invoked next, to run the initialization code of modules and channels in the
network. An exception is thrown if something goes wrong in any of the
<tt>initialize()</tt> methods.

<p>The next lines run the simulation by calling
<tt>sim-&gt;</tt><tt>takeNextEvent()</tt> and <tt>sim-&gt;</tt><tt>executeEvent()</tt>
in a loop. The loop is exited when an exception occurs. The exception
may indicate a runtime error, or a normal termination condition such as
when there are no more events, or the simulation time limit has been
reached. (The latter are represented by <tt><a href="../api/classomnetpp_1_1cTerminationException.html">cTerminationException</a></tt>.)

<p>If the simulation has completed successfully (<tt>ok==true</tt>), the code
goes on to call the <tt>finish()</tt> methods of modules and channels. Then,
regardless whether there was an error, cleanup takes place by calling
<tt>sim-&gt;</tt><tt>deleteNetwork()</tt>.

<p>Finally, the simulation manager object is deallocated, but the active
simulation manager is not allowed to be deleted; therefore it is deactivated
using <tt>setActiveSimulation(nullptr)</tt>.

<p>
<h3><a name="sec:embedding:providing-an-environment-object"/>18.2.3 Providing an Environment Object<a class="headerlink" href="#sec:embedding:providing-an-environment-object" title="Permalink to this headline"></a></h3>

<p>The environment object needs to be subclassed from the <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt> class,
but since it has many pure virtual methods, it is easier
to begin by subclassing <tt><a href="../api/classomnetpp_1_1cNullEnvir.html">cNullEnvir</a></tt>. <tt><a href="../api/classomnetpp_1_1cNullEnvir.html">cNullEnvir</a></tt> defines all
pure virtual methods with either an empty body or with a body that throws
an <tt>"unsupported method called"</tt> exception. You can redefine methods
to be more sophisticated later on, as you progress with the development.

<p>You must redefine the <tt>readParameter()</tt> method. This enables
module parameters to obtain their values. For debugging purposes, you can also
redefine <tt>sputn()</tt> where module log messages are written to.
<tt><a href="../api/classomnetpp_1_1cNullEnvir.html">cNullEnvir</a></tt> only provides one random number generator, so if your
simulation model uses more than one, you also need to redefine the
<tt>getNumRNGs()</tt> and <tt>getRNG(k)</tt> methods. To print or store
simulation records, redefine <tt>recordScalar()</tt>, <tt>recordStatistic()</tt>
and/or the output vector related methods. Other <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt> methods
are invoked from the simulation kernel to inform the environment about
messages being sent, events scheduled and cancelled, modules created, and so on.

<p>The following example shows a minimalistic environment class that is enough
to get started:

<pre class="cpp">
class CustomSimulationEnv : public <a href="../api/classomnetpp_1_1cNullEnvir.html">cNullEnvir</a>
{
  public:
    // constructor
    CustomSimulationEnv(int ac, char **av, <a href="../api/classomnetpp_1_1cConfiguration.html">cConfiguration</a> *c) :
        <a href="../api/classomnetpp_1_1cNullEnvir.html">cNullEnvir</a>(ac, av, c) {}

    // model parameters: accept defaults
    virtual void readParameter(<a href="../api/classomnetpp_1_1cPar.html">cPar</a> *par) {
        if (par-&gt;containsValue())
            par-&gt;acceptDefault();
        else
            throw <a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a>("no value for %s", par-&gt;getFullPath().c_str());
    }

    // send module log messages to stdout
    virtual void sputn(const char *s, int n) {
        (void) ::fwrite(s,1,n,stdout);
    }
};
</pre>
<p>

<p><h3><a name="sec:embedding:providing-a-configuration-object"/>18.2.4 Providing a Configuration Object<a class="headerlink" href="#sec:embedding:providing-a-configuration-object" title="Permalink to this headline"></a></h3>

<p>The configuration object needs to subclass from <tt><a href="../api/classomnetpp_1_1cConfiguration.html">cConfiguration</a></tt>.
<tt><a href="../api/classomnetpp_1_1cConfiguration.html">cConfiguration</a></tt> also has several methods, but the typed ones
(<tt>getAsBool()</tt>, <tt>getAsInt()</tt>, etc.) have default implementations
that delegate to the much fewer string-based methods (<tt>getConfigValue()</tt>, etc.).

<p>It is fairly straightforward to implement a configuration class that
emulates an empty ini file:

<pre class="cpp">
class EmptyConfig : public <a href="../api/classomnetpp_1_1cConfiguration.html">cConfiguration</a>
{
  protected:
    class NullKeyValue : public <a href="../api/classomnetpp_1_1cConfigurationReader_1_1KeyValue.html">KeyValue</a> {
      public:
        virtual const char *getKey() const {return nullptr;}
        virtual const char *getValue() const {return nullptr;}
        virtual const char *getBaseDirectory() const {return nullptr;}
    };
    NullKeyValue nullKeyValue;

  protected:
    virtual const char *substituteVariables(const char *value) {return value;}

  public:
    virtual const char *getConfigValue(const char *key) const
        {return nullptr;}
    virtual const <a href="../api/classomnetpp_1_1cConfigurationReader_1_1KeyValue.html">KeyValue</a>& getConfigEntry(const char *key) const
        {return nullKeyValue;}
    virtual const char *getPerObjectConfigValue(const char *objectFullPath,
        const char *keySuffix) const {return nullptr;}
    virtual const <a href="../api/classomnetpp_1_1cConfigurationReader_1_1KeyValue.html">KeyValue</a>& getPerObjectConfigEntry(const char *objectFullPath,
        const char *keySuffix) const {return nullKeyValue;}
};
</pre>
<p>

<p><h3><a name="sec:embedding:loading-ned-files"/>18.2.5 Loading NED Files<a class="headerlink" href="#sec:embedding:loading-ned-files" title="Permalink to this headline"></a></h3>

<p>NED files can be loaded with any of the following static methods of
<tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>: <tt>loadNedSourceFolder()</tt>, <tt>loadNedFile()</tt>,
and <tt>loadNedText()</tt>. The first method loads an entire subdirectory tree,
the second method loads a single NED file, and the third method takes a literal
string containing NED code and parses it.

<p><ul class="note"><b>NOTE</b><br>
One use of <tt>loadNedText()</tt> is to parse NED sources previously converted
to C++ string constants and linked into the executable. This enables
creating executables that are self-contained, and do not require NED files
to be distributed with them.
</ul>

<p>The above functions can also be mixed, but after the last call,
<tt>doneLoadingNedFiles()</tt> must be invoked (it checks for unresolved
NED types).

<p>Loading NED files has a global effect; therefore they cannot be unloaded.

<p>
<h3><a name="sec:embedding:eliminating-ned-files"/>18.2.6 How to Eliminate NED Files<a class="headerlink" href="#sec:embedding:eliminating-ned-files" title="Permalink to this headline"></a></h3>

<p>It is possible to get rid of NED files altogether. This would also
remove the dependency on the <tt>oppnedxml</tt> library and the code in
<tt>sim/netbuilder</tt>, although at the cost of additional coding.

<p><ul class="note"><b>NOTE</b><br>
When the only purpose is to get rid of NED files as external dependency
of the program, it is simpler to use <tt>loadNedText()</tt> on NED files
converted to C++ string constants instead.
</ul>

<p>The trick is to write <tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt> and <tt><a href="../api/classomnetpp_1_1cChannelType.html">cChannelType</a></tt> objects
for simple module, compound module and channel types, and register them
manually. For example, <tt><a href="../api/classomnetpp_1_1cModuleType.html">cModuleType</a></tt> has pure virtual methods called
<tt>createModuleObject()</tt>, <tt>addParametersAndGatesTo(module)</tt>,
<tt>setupGateVectors(module)</tt>, <tt>buildInside(module)</tt>, which you
need to implement. The body of the <tt>buildInside()</tt> method would
be similar to C++ files generated by <tt>nedtool</tt> of OMNeT++ 3.x.

<p>
<h3><a name="sec:embedding:assigning-module-parameters"/>18.2.7 Assigning Module Parameters<a class="headerlink" href="#sec:embedding:assigning-module-parameters" title="Permalink to this headline"></a></h3>

<p>As already mentioned, modules obtain values for their input parameters
by calling the <tt>readParameter()</tt> method of the environment object
(<tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>).

<p><ul class="note"><b>NOTE</b><br>
<tt>readParameter()</tt> is only called for parameters that have not
been set to a fixed (i.e. non-<tt>default</tt>) value in the NED files.
</ul>

<p>The <tt>readParameter()</tt> method should be written in a manner that enables it to assign
the parameter. When doing so, it can recognize the parameter from its name
(<tt>par-&gt;getName()</tt>), from its full path (<tt>par-&gt;getFullPath()</tt>),
from the owner module's class (<tt>par-&gt;getOwner()-&gt;getClassName()</tt>)
or NED type name (<tt>((<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *)par-&gt;getOwner())-&gt;getNedTypeName()</tt>).
Then it can set the parameter using one of the typed setter methods
(<tt>setBoolValue()</tt>, <tt>setLongValue()</tt>, etc.), or set it
to an expression provided in string form (<tt>parse()</tt> method).
It can also accept the default value if it exists (<tt>acceptDefault()</tt>).

<p>The following code is a straightforward example that answers parameter
value requests from a pre-filled table.

<pre class="cpp">
class CustomSimulationEnv : public <a href="../api/classomnetpp_1_1cNullEnvir.html">cNullEnvir</a>
{
  protected:
    // parameter (fullpath,value) pairs, needs to be pre-filled
    std::map&lt;std::string,std::string&gt; paramValues;
  public:
    ...
    virtual void readParameter(<a href="../api/classomnetpp_1_1cPar.html">cPar</a> *par) {
        if (paramValues.find(par-&gt;getFullPath())!=paramValues.end())
            par-&gt;parse(paramValues[par-&gt;getFullPath()]);
        else if (par-&gt;containsValue())
            par-&gt;acceptDefault();
        else
            throw <a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a>("no value for %s", par-&gt;getFullPath().c_str());
    }
};
</pre>
<p>

<p><h3><a name="sec:embedding:extracting-statistics"/>18.2.8 Extracting Statistics from the Model<a class="headerlink" href="#sec:embedding:extracting-statistics" title="Permalink to this headline"></a></h3>

<p>There are several ways you can extract statistics from the
simulation.

<p><h4><a name="sec:embedding:statistics-via-cpp-calls"/>18.2.8.1 C++ Calls into the Model<a class="headerlink" href="#sec:embedding:statistics-via-cpp-calls" title="Permalink to this headline"></a></h4>

<p>Modules in the simulation are C++ objects. If you add the appropriate
public getter methods to the module classes, you can call them from the
main program to obtain statistics. Modules may be looked up with the
<tt>getModuleByPath()</tt> method of <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>, then cast to the
specific module type via <tt>check_and_cast&lt;&gt;()</tt> so that the getter
methods can be invoked.

<pre class="cpp">
<a href="../api/classomnetpp_1_1cModule.html">cModule</a> *mod = getSimulation()-&gt;getModuleByPath("Network.client[2].app");
WebApp *appMod = check_and_cast&lt;WebApp *&gt;(mod);
int numRequestsSent = appMod-&gt;getNumRequestsSent();
double avgReplyTime = appMod-&gt;getAvgReplyTime();
...
</pre>
<p>
The drawback of this approach is that getters need to be added manually
to all affected module classes, which might not be practical, especially
if modules come from external projects.

<p><h4><a name="sec:embedding:statistics-via-cenvir-callbacks"/>18.2.8.2 <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt> Callbacks<a class="headerlink" href="#sec:embedding:statistics-via-cenvir-callbacks" title="Permalink to this headline"></a></h4>

<p>A more general way is to catch <tt>recordScalar()</tt> method calls in the
simulation model. The <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt>'s <tt>recordScalar()</tt> method
delegates to the similar function in <tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>. You may define the
latter function so that it stores all recorded scalars (for example in an
<tt>std::map</tt>), where the main program can find them later.
Values from output vectors can be captured in a similar manner.

<p>An example implementation:

<pre class="cpp">
class CustomSimulationEnv : public <a href="../api/classomnetpp_1_1cNullEnvir.html">cNullEnvir</a>
{
  private:
    std::map&lt;std::string, double&gt; results;
  public:
    virtual void recordScalar(<a href="../api/classomnetpp_1_1cComponent.html">cComponent</a> *component, const char *name,
                              double value, <a href="../api/classomnetpp_1_1opp__string__map.html">opp_string_map</a> *attributes=nullptr)
    {
       results[component-&gt;getFullPath()+"."+name] = value;
    }

    const std::map&lt;std::string, double&gt;& getResults() {return results;}
};

...

const std::map&lt;std::string, double&gt;& results = env-&gt;getResults();
int numRequestsSent = results["Network.client[2].app.numRequestsSent"];
double avgReplyTime = results["Network.client[2].app.avgReplyTime"];
</pre>
<p>
A drawback of this approach is that compile-time checking of statistics names is lost, but
the advantages are that any simulation model can now be used
without changes, and that capturing additional statistics does not require
code modification in the main program.

<p>
<h3><a name="sec:embedding:simulation-loop"/>18.2.9 The Simulation Loop<a class="headerlink" href="#sec:embedding:simulation-loop" title="Permalink to this headline"></a></h3>

<p>To run the simulation, the <tt>takeNextEvent()</tt> and <tt>executeEvent()</tt>
methods of <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt> must be called in a loop:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a> *sim = getSimulation();
while (sim-&gt;getSimTime() &lt; limit) {
    <a href="../api/classomnetpp_1_1cEvent.html">cEvent</a> *event = sim-&gt;takeNextEvent();
    sim-&gt;executeEvent(event);
}
</pre>
<p>
Depending on the concrete scheduler class, the <tt>takeNextEvent()</tt> 
may return <tt>nullptr</tt> in certain cases. The default
<tt><a href="../api/classomnetpp_1_1cSequentialScheduler.html">cSequentialScheduler</a></tt> never returns <tt>nullptr</tt>.

<p>The execution may terminate in various ways. Runtime errors cause a
<tt><a href="../api/classomnetpp_1_1cRuntimeError.html">cRuntimeError</a></tt> (or other kind of <tt>std::exception</tt>) to be
thrown. <tt><a href="../api/classomnetpp_1_1cTerminationException.html">cTerminationException</a></tt> is thrown on normal termination
conditions, such as when the simulation runs out of events to process.

<p>You may customize the loop to exit on other termination conditions as well,
such as on a simulation time limit (see above), on a CPU time limit, or when
results reach a required accuracy. It is relatively straightforward to
build in progress reporting and interactivity (start/stop).

<p>Animation can be hooked up to the appropriate callback methods of
<tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>: <tt>beginSend()</tt>, <tt>sendHop()</tt>, <tt>endSend()</tt>,
and others.

<p>
<h3><a name="sec:embedding:multiple-coexisting-simulations"/>18.2.10 Multiple, Coexisting Simulations<a class="headerlink" href="#sec:embedding:multiple-coexisting-simulations" title="Permalink to this headline"></a></h3>

<p>It is possible for several instances of <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt> to coexist,
and also to set up and simulate a network in each instance. However, this
requires frequent use of <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a>::setActiveSimulation()</tt>.
Before invoking any <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt> method or module method,
the corresponding <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt> instance needs to be designated
as the active simulation manager.

<p>Every <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt> instance should have its own associated
environment object (<tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt>). Environment objects may not be
shared among several <tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt> instances. The
<tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt>'s destructor also removes the associated
<tt><a href="../api/classomnetpp_1_1cEnvir.html">cEnvir</a></tt> instance.

<p><tt><a href="../api/classomnetpp_1_1cSimulation.html">cSimulation</a></tt> instances may be reused from one simulation to another,
but it is also possible to create a new instance for each simulation run.

<p><ul class="note"><b>NOTE</b><br>
It is not possible to run different simulations concurrently from
different theads, due to the use of global variables which are not easy
to eliminate, such as the active simulation manager pointer and the active
environment object pointer. Static buffers and objects (like string pools)
are also used for efficiency reasons in some places inside the simulation
kernel.
</ul>

<p>
<h3><a name="sec:embedding:installing-a-custom-scheduler"/>18.2.11 Installing a Custom Scheduler<a class="headerlink" href="#sec:embedding:installing-a-custom-scheduler" title="Permalink to this headline"></a></h3>

<p>The default event scheduler is <tt><a href="../api/classomnetpp_1_1cSequentialScheduler.html">cSequentialScheduler</a></tt>. To replace
it with a different scheduler (e.g. <tt><a href="../api/classomnetpp_1_1cRealTimeScheduler.html">cRealTimeScheduler</a></tt> or your
own scheduler class), add a <tt>setScheduler()</tt> call into <tt>main()</tt>:

<pre class="cpp">
<a href="../api/classomnetpp_1_1cScheduler.html">cScheduler</a> *scheduler = new CustomScheduler();
getSimulation()-&gt;setScheduler(scheduler);
</pre>
<p>
It is usually not a good idea to change schedulers in the middle of
a simulation, therefore <tt>setScheduler()</tt> may only be called when
no network is set up.

<p>
<h3><a name="sec:embedding:multi-threaded-programs"/>18.2.12 Multi-Threaded Programs<a class="headerlink" href="#sec:embedding:multi-threaded-programs" title="Permalink to this headline"></a></h3>

<p>The OMNeT++ simulation kernel is not reentrant; therefore it must be protected
against concurrent access.

<p>

<hr class='pgbr'><h1><a name="cha:ned-ref"/>19 Appendix A&#58; NED Reference<a class="headerlink" href="#cha:ned-ref" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:ned-ref:syntax"/>19.1 Syntax<a class="headerlink" href="#sec:ned-ref:syntax" title="Permalink to this headline"></a></h2>

<p><h3><a name="sec:ned-ref:ned-file-name-extension"/>19.1.1 NED File Name Extension<a class="headerlink" href="#sec:ned-ref:ned-file-name-extension" title="Permalink to this headline"></a></h3>

<p>NED files have the <tt>.ned</tt> file name suffix. This is mandatory, and
cannot be overridden.

<p><h3><a name="sec:ned-ref:ned-file-encoding"/>19.1.2 NED File Encoding<a class="headerlink" href="#sec:ned-ref:ned-file-encoding" title="Permalink to this headline"></a></h3>

<p>NED files are ASCII, but non-ASCII characters are permitted in comments
and string literals. This allows for using encodings that are a superset
of ASCII, for example ISO 8859-1 and UTF-8.

<p><ul class="note"><b>NOTE</b><br>
    There is no standard way to specify or determine the encoding of a NED file.
    It is up to the user to configure the desired encoding in text editors
    and other tools that edit or process NED files.
</ul>

<p>String literals (e.g. in parameter values) will be passed to the C++ code
as <tt>const char *</tt> without any conversion; it is up to the simulation model
to interpret them using the desired encoding.

<p>Line ending may be either CR or CRLF, regardless of the platform.

<p>
<h3><a name="sec:ned-ref:reserved-words"/>19.1.3 Reserved Words<a class="headerlink" href="#sec:ned-ref:reserved-words" title="Permalink to this headline"></a></h3>

<p>NED file authors have to take care that no reserved words are used as identifiers.
The reserved words of the NED language are:

<p><tt>allowunconnected bool channel channelinterface connections const
default double extends false for gates if import index inf inout input int like
module moduleinterface nan network output package parameters property simple
sizeof string submodules this true typename types volatile xml xmldoc</tt>

<p>
<h3><a name="sec:ned-ref:identifiers"/>19.1.4 Identifiers<a class="headerlink" href="#sec:ned-ref:identifiers" title="Permalink to this headline"></a></h3>

<p>Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and underscore &#8220;_&#8221;. Identifiers may only begin with a
letter or underscore.

<p>The recommended way to compose identifiers from multiple words is to
capitalize the beginning of each word (<i>camel case</i>).

<p>
<h3><a name="sec:ned-ref:case-sensitivity"/>19.1.5 Case Sensitivity<a class="headerlink" href="#sec:ned-ref:case-sensitivity" title="Permalink to this headline"></a></h3>

<p>Keywords and identifiers in the NED language are case sensitive. For example,
<tt>TCP</tt> and <tt>Tcp</tt> are two different names.

<p>
<h3><a name="sec:ned-ref:literals"/>19.1.6 Literals<a class="headerlink" href="#sec:ned-ref:literals" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:ned-ref:string-literals"/>19.1.6.1 String Literals<a class="headerlink" href="#sec:ned-ref:string-literals" title="Permalink to this headline"></a></h4>

<p>String literals use double quotes. The following C-style backslash escapes
are recognized: <tt>\b</tt>, <tt>\f</tt>,
<tt>\n</tt>, <tt>\r</tt>, <tt>\t</tt>,
<tt>\\</tt>, <tt>\"</tt>, and
<tt>\xhh</tt> where <i>h</i> is a hexadecimal digit.

<p><h4><a name="sec:ned-ref:numeric-constants"/>19.1.6.2 Numeric Constants<a class="headerlink" href="#sec:ned-ref:numeric-constants" title="Permalink to this headline"></a></h4>

<p>Numeric constants are accepted in the usual decimal, hexadecimal (<tt>0x</tt> prefix)
and scientific notations. Octal numbers are not accepted (numbers that start
with the <tt>0</tt> digit are interpreted as decimal.)

<p><b><tt>nan</tt></b>, <b><tt>inf</tt></b> and <tt>-</tt><b><tt>inf</tt></b> mean the floating-point
not-a-number, positive infinity and negative infinity values, respectively.

<p><h4><a name="sec:ned-ref:quantity-constants"/>19.1.6.3 Quantity Constants<a class="headerlink" href="#sec:ned-ref:quantity-constants" title="Permalink to this headline"></a></h4>

<p>A quantity constant has the form <i>(&lt;numeric-constant&gt; &lt;unit&gt;)+</i>, for
example <tt>12.5mW</tt> or <tt>3h 15min 37.2s</tt>. Whitespace is optional in front
of a unit, but must be present after a unit if it is followed by a number.

<p>When multiple measurement units are present, they have to be convertible
into each other (i.e. refer to the same physical quantity).

<p>Section <a href="#sec:ned-ref:units">[19.5.9]</a> lists the units recognized by OMNeT++.
Other units can be used as well; the only downside being that OMNeT++ will
not be able to perform conversions on them.

<p>
<h3><a name="sec:ned-ref:comments"/>19.1.7 Comments<a class="headerlink" href="#sec:ned-ref:comments" title="Permalink to this headline"></a></h3>

<p>Comments can be placed at the end of lines. Comments begin with a double
slash <tt>//</tt>, and continue until the end of the line.

<p>
<h3><a name="sec:ned-ref:grammar"/>19.1.8 Grammar<a class="headerlink" href="#sec:ned-ref:grammar" title="Permalink to this headline"></a></h3>

<p>The grammar of the NED language can be found in Appendix
<a href="#cha:ned-language-grammar">[20]</a>.

<p><h2><a name="sec:ned-ref:built-in-defs"/>19.2 Built-in Definitions<a class="headerlink" href="#sec:ned-ref:built-in-defs" title="Permalink to this headline"></a></h2>

<p>The NED language has the following built-in definitions, all in the <tt>ned</tt>
package: channels <tt>IdealChannel</tt>, <tt>DelayChannel</tt>, and <tt>DatarateChannel</tt>;
module interfaces <tt>IBidirectionalChannel</tt>, and <tt>IUnidirectionalChannel</tt>.
The latter two are reserved for future use.

<p>The bodies of <tt>@statistic</tt> properties have been omitted for brevity from
the following listing.

<p><ul class="note"><b>NOTE</b><br>
One can print the full definitions by running <tt>opp_run -h neddecls</tt>.
</ul>

<pre class="ned">
package ned;
@namespace("");

channel IdealChannel
{
    @class(<a href="../api/classomnetpp_1_1cIdealChannel.html">cIdealChannel</a>);
}

channel DelayChannel
{
    @class(<a href="../api/classomnetpp_1_1cDelayChannel.html">cDelayChannel</a>);
    @signal[messageSent](type=<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>);
    @signal[messageDiscarded](type=<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>);
    @statistic[messages](...);
    @statistic[messagesDiscarded](...);
    bool disabled = default(false);
    double delay = default(0s) @unit(s); // propagation delay
}

channel DatarateChannel
{
    @class(<a href="../api/classomnetpp_1_1cDatarateChannel.html">cDatarateChannel</a>);
    @signal[channelBusy](type=long);
    @signal[messageSent](type=<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>);
    @signal[messageDiscarded](type=<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>);
    @statistic[busy](...);
    @statistic[utilization](...);
    @statistic[packets](...);
    @statistic[packetBytes](...);
    @statistic[packetsDiscarded](...);
    @statistic[throughput](...);
    bool disabled = default(false);
    double delay = default(0s) @unit(s); // propagation delay
    double datarate = default(0bps) @unit(bps); // bits per second; 0=infinite
    double ber = default(0); // bit error rate (BER)
    double per = default(0); // packet error rate (PER)
}

moduleinterface IBidirectionalChannel
{
    gates:
        inout a;
        inout b;
}

moduleinterface IUnidirectionalChannel
{
    gates:
        input i;
        output o;
}
</pre>
<p>

<p>
<h2><a name="sec:ned-ref:packages"/>19.3 Packages<a class="headerlink" href="#sec:ned-ref:packages" title="Permalink to this headline"></a></h2>

<p>NED supports hierarchical namespaces called <i>packages</i>. The model
is similar to Java packages, with minor changes.

<p>
<h3><a name="sec:ned-ref:package-declaration"/>19.3.1 Package Declaration<a class="headerlink" href="#sec:ned-ref:package-declaration" title="Permalink to this headline"></a></h3>

<p>A NED file may contain a package declaration. The package declaration
uses the <b><tt>package</tt></b> keyword, and specifies the package for the
definitions in the NED file. If there is no package declaration, the file's
contents are in the <i>default package</i>.

<p>Component type names must be unique within their package.

<p>
<h3><a name="sec:ned-ref:directory-structure"/>19.3.2 Directory Structure, package.ned<a class="headerlink" href="#sec:ned-ref:directory-structure" title="Permalink to this headline"></a></h3>

<p>Like in Java, the directory of a NED file must match the package
declaration. However, it is possible to omit directories at the top which do
not contain any NED files (like the typical <tt>/org/<i>&lt;projectname&gt;</i></tt>
directories in Java).

<p>The top of a directory tree containing NED files is named a <i>NED source
folder</i>.

<p><ul class="note"><b>NOTE</b><br>
The OMNeT++ runtime recognizes a <tt>NEDPATH</tt> environment variable, which
contains a list of NED source folders, and is similar to the Java <tt>CLASSPATH</tt>
variable. <tt>NEDPATH</tt> also has a command-line option equivalent.
</ul>

<p>The <tt>package.ned</tt> file at the top level of a NED source folder plays a
special role.

<p>If there is no toplevel <tt>package.ned</tt> or it contains no package declaration,
the declared package of a NED file in the folder <tt><i>&lt;srcfolder&gt;</i>/x/y/z</tt>
<i>must</i> be <tt>x.y.z</tt>.
If there is a toplevel <tt>package.ned</tt> and it declares the package as
<tt>a.b</tt>, then any NED file in the folder <tt><i>&lt;srcfolder&gt;</i>/x/y/z</tt>
<i>must</i> have the declared package <tt>a.b.x.y.z</tt>.

<p><ul class="note"><b>NOTE</b><br>
    <tt>package.ned</tt> files are allowed in other folders as well.
    They may contain properties and/or documentation for their package,
    but cannot be used to define the package they are in.
</ul>

<p>

<p>
<h2><a name="sec:ned-ref:components"/>19.4 Components<a class="headerlink" href="#sec:ned-ref:components" title="Permalink to this headline"></a></h2>

<p>Simple modules, compound modules, networks, channels, module interfaces
and channel interfaces are called <i>components</i>.

<p>
<h3><a name="sec:ned-ref:simple-modules"/>19.4.1 Simple Modules<a class="headerlink" href="#sec:ned-ref:simple-modules" title="Permalink to this headline"></a></h3>

<p>Simple module types are declared with the <b><tt>simple</tt></b> keyword;
see the NED Grammar (Appendix <a href="#cha:ned-language-grammar">[20]</a>) for the
syntax.

<p>Simple modules may have properties (<a href="#sec:ned-ref:properties">[19.4.8]</a>),
parameters (<a href="#sec:ned-ref:parameters">[19.4.9]</a>)
and gates (<a href="#sec:ned-ref:gates">[19.4.11]</a>).

<p>A simple module type may not have inner types (<a href="#sec:ned-ref:inner-types">[19.4.15]</a>).

<p>A simple module type may extend another simple module type, and
may implement one or more module interfaces (<a href="#sec:ned-ref:module-interfaces">[19.4.5]</a>).
Inheritance rules are described in section <a href="#sec:ned-ref:inheritance">[19.4.21]</a>,
and interface implementation rules in section <a href="#sec:ned-ref:implementing-an-interface">[19.4.20]</a>.

<p>Every simple module type has an associated C++ class, which must be
subclassed from <tt><a href="../api/classomnetpp_1_1cSimpleModule.html">cSimpleModule</a></tt>. The way of associating the
NED type with the C++ class is described in section
<a href="#sec:ned-ref:resolving-cpp-class">[19.4.7]</a>.

<p>

<p><h3><a name="sec:ned-ref:compound-modules"/>19.4.2 Compound Modules<a class="headerlink" href="#sec:ned-ref:compound-modules" title="Permalink to this headline"></a></h3>

<p>Compound module types are declared with the <b><tt>module</tt></b> keyword;
see the NED Grammar (Appendix <a href="#cha:ned-language-grammar">[20]</a>) for the
syntax.

<p>A compound module may have properties (<a href="#sec:ned-ref:properties">[19.4.8]</a>),
parameters (<a href="#sec:ned-ref:parameters">[19.4.9]</a>),
and gates (<a href="#sec:ned-ref:gates">[19.4.11]</a>); its internal structure is defined by
its submodules (<a href="#sec:ned-ref:submodules">[19.4.12]</a>) and
connections (<a href="#sec:ned-ref:connections">[19.4.13]</a>);
and it may also have inner types (<a href="#sec:ned-ref:inner-types">[19.4.15]</a>)
that can be used for its submodules and connections.

<p>A compound module type may extend another compound module type, and
may implement one or more module interfaces (<a href="#sec:ned-ref:module-interfaces">[19.4.5]</a>).
Inheritance rules are described in section <a href="#sec:ned-ref:inheritance">[19.4.21]</a>,
and interface implementation rules in section <a href="#sec:ned-ref:implementing-an-interface">[19.4.20]</a>.

<p>

<p><h3><a name="sec:ned-ref:networks"/>19.4.3 Networks<a class="headerlink" href="#sec:ned-ref:networks" title="Permalink to this headline"></a></h3>

<p><h4><a name="sec:ned-ref:network-keyword"/>19.4.3.1 The network Keyword<a class="headerlink" href="#sec:ned-ref:network-keyword" title="Permalink to this headline"></a></h4>

<p>A network declared with the <b><tt>network</tt></b> keyword is equivalent to a compound
module (<b><tt>module</tt></b> keyword) with the <b><tt>@isNetwork(true)</tt></b> property.

<p><ul class="note"><b>NOTE</b><br>
    A simple module can only be designated to be a network by spelling out the
    <b><tt>@isNetwork</tt></b> property; the <b><tt>network</tt></b> keyword cannot
    be used for that purpose.
</ul>

<p><h4><a name="sec:ned-ref:isnetwork-property"/>19.4.3.2 The @isNetwork Property<a class="headerlink" href="#sec:ned-ref:isnetwork-property" title="Permalink to this headline"></a></h4>

<p>The <b><tt>@isNetwork</tt></b> property is only recognized for simple modules and
compound modules. The value may be empty, true or false:

<pre class="ned">
@isNetwork;
@isNetwork();
@isNetwork(true);
@isNetwork(false);
</pre>
<p>
The empty value corresponds to <b><tt>@isNetwork(true)</tt></b>.

<p>The <b><tt>@isNetwork</tt></b> property is not inherited; that is, a subclass
of a module with <b><tt>@isNetwork</tt></b> set does not automatically become a network.
The <b><tt>@isNetwork</tt></b> property needs to be explicitly added to the subclass
to make it a network.

<p><ul class="rationale"><b>Rationale</b><br>
    Subclassing may introduce changes to a module that make it unfit to be used
    as a network.
</ul>

<p>

<p><h3><a name="sec:ned-ref:channels"/>19.4.4 Channels<a class="headerlink" href="#sec:ned-ref:channels" title="Permalink to this headline"></a></h3>

<p>Channel types are declared with the <b><tt>channel</tt></b> keyword;
see the NED Grammar (Appendix <a href="#cha:ned-language-grammar">[20]</a>) for the
syntax.

<p>Channel types may have properties (<a href="#sec:ned-ref:properties">[19.4.8]</a>)
and parameters (<a href="#sec:ned-ref:parameters">[19.4.9]</a>).

<p>A channel type may not have inner types (<a href="#sec:ned-ref:inner-types">[19.4.15]</a>).

<p>A channel type may extend another channel type, and
may implement one or more channel interfaces (<a href="#sec:ned-ref:channel-interfaces">[19.4.6]</a>).
Inheritance rules are described in section <a href="#sec:ned-ref:inheritance">[19.4.21]</a>,
and interface implementation rules in section <a href="#sec:ned-ref:implementing-an-interface">[19.4.20]</a>.

<p>Every channel type has an associated C++ class, which must be
subclassed from <tt><a href="../api/classomnetpp_1_1cChannel.html">cChannel</a></tt>. The way of associating the
NED type with the C++ class is described in section
<a href="#sec:ned-ref:resolving-cpp-class">[19.4.7]</a>.

<p>The <tt>@defaultname</tt> property of a channel type determines the default name
of the channel object when used in a connection.

<p>
<h3><a name="sec:ned-ref:module-interfaces"/>19.4.5 Module Interfaces<a class="headerlink" href="#sec:ned-ref:module-interfaces" title="Permalink to this headline"></a></h3>

<p>Module interface types are declared with the <b><tt>moduleinterface</tt></b> keyword;
see the NED Grammar (Appendix <a href="#cha:ned-language-grammar">[20]</a>) for the
syntax.

<p>Module interfaces may have properties (<a href="#sec:ned-ref:properties">[19.4.8]</a>),
parameters (<a href="#sec:ned-ref:parameters">[19.4.9]</a>), and
gates (<a href="#sec:ned-ref:gates">[19.4.11]</a>). However, parameters are not allowed
to have a value assigned, not even a default value.

<p>A module interface type may not have inner types (<a href="#sec:ned-ref:inner-types">[19.4.15]</a>).

<p>A module interface type may extend one or more other module interface types.
Inheritance rules are described in section <a href="#sec:ned-ref:inheritance">[19.4.21]</a>.

<p>

<p><h3><a name="sec:ned-ref:channel-interfaces"/>19.4.6 Channel Interfaces<a class="headerlink" href="#sec:ned-ref:channel-interfaces" title="Permalink to this headline"></a></h3>

<p>Channel interface types are declared with the <b><tt>channelinterface</tt></b> keyword;
see the NED Grammar (Appendix <a href="#cha:ned-language-grammar">[20]</a>) for the
syntax.

<p>Channel interfaces may have properties (<a href="#sec:ned-ref:properties">[19.4.8]</a>) and
parameters (<a href="#sec:ned-ref:parameters">[19.4.9]</a>). However, parameters are not
allowed to have a value assigned, not even a default value.

<p>A channel interface type may not have inner types (<a href="#sec:ned-ref:inner-types">[19.4.15]</a>).

<p>A channel interface type may extend one or more other channel interface types.
Inheritance rules are described in section <a href="#sec:ned-ref:inheritance">[19.4.21]</a>.

<p>

<p><h3><a name="sec:ned-ref:resolving-cpp-class"/>19.4.7 Resolving the C++ Implementation Class<a class="headerlink" href="#sec:ned-ref:resolving-cpp-class" title="Permalink to this headline"></a></h3>

<p>The procedure for determining the C++ implementation class for simple modules
and for channels are identical. It goes as follows (we are going to say
<i>component</i> instead of <i>&#8220;simple module or channel&#8221;</i>):

<p>If the component extends another component and has no <b><tt>@class</tt></b>
property, the C++ implementation class is inherited from the base type.

<p>If the component contains a <b><tt>@class</tt></b> property, the C++ class name
will be composed of the <i>current namespace</i> (see below) and the
value of the <b><tt>@class</tt></b> property. The <b><tt>@class</tt></b> property should
contain a single value.

<p><ul class="note"><b>NOTE</b><br>
    The <b><tt>@class</tt></b> property may itself contain a namespace declaration (ie.
    may contain &#8220;<tt>::</tt>&#8221;).
</ul>

<p>If the component contains no <b><tt>@class</tt></b> property and has no base
class, the C++ class name will be composed of the <i>current namespace</i> and the
unqualified name of the component.

<p><ul class="important"><b>IMPORTANT</b><br>
    Subclassing in NED does not imply subclassing the C++ implementation. If one
    intends to subclass a simple module or channel in NED as well as in C++, the
    <b><tt>@class</tt></b> property needs to be explicitly specified in the derived type,
    otherwise it will continue to use the C++ class from its super type.
</ul>

<p>Compound modules will be instantiated with the built-in <tt><a href="../api/classomnetpp_1_1cModule.html">cModule</a></tt> class,
unless the module contains the <b><tt>@class</tt></b> property. When <b><tt>@class</tt></b> is present,
the resolution rules are the same as with simple modules.

<p>
<h4><a name="ch:ned-ref:current-namespace"/>19.4.7.1 Current Namespace<a class="headerlink" href="#ch:ned-ref:current-namespace" title="Permalink to this headline"></a></h4>

<p>The <i>current namespace</i> is the value of the first <b><tt>@namespace</tt></b>
property found while searching the following order:

<p><ol>
  <li> the current NED file
  <li> the <tt>package.ned</tt> file in the current package or the first ancestor
        package searching upwards
</ol>

<p><ul class="note"><b>NOTE</b><br>
    Note that namespaces coming from multiple <b><tt>@namespace</tt></b> properties
    in different scopes do not nest, but rather, the nearest one wins.
</ul>

<p>The <b><tt>@namespace</tt></b> property should contain a single value.

<p>

<p><h3><a name="sec:ned-ref:properties"/>19.4.8 Properties<a class="headerlink" href="#sec:ned-ref:properties" title="Permalink to this headline"></a></h3>

<p>Properties are a means of adding metadata annotations to NED files, component types,
parameters, gates, submodules, and connections.

<p><h4><a name="sec:ned-ref:identifying-a-property"/>19.4.8.1 Identifying a Property<a class="headerlink" href="#sec:ned-ref:identifying-a-property" title="Permalink to this headline"></a></h4>

<p>Properties are identified by name. It is possible to have several properties
on the same object with the same name, as long as they have unique indices.
An index is an identifier in square brackets after the property name.

<p>The following example shows a property without index, one with the index <tt>index1</tt>,
and a third with the index <tt>index2</tt>.

<pre class="ned">
@prop1();
@prop2[index1]();
@prop3[index2]();
</pre>
<p>

<p><h4><a name="sec:ned-ref:property-value"/>19.4.8.2 Property Value<a class="headerlink" href="#sec:ned-ref:property-value" title="Permalink to this headline"></a></h4>

<p>The value of the property is specified inside parentheses. The property value consists of
<i>key=valuelist</i> pairs, separated by semicolons; <i>valuelist</i> elements
are separated with commas. Example:

<pre class="ned">
@prop(key1=value11,value12,value13;key2=value21,value22)
</pre>
<p>
Keys must be unique.

<p>If the key+equal sign part (<tt>key=</tt>) is missing, the valuelist belongs
to the <i>default key</i>. Examples:

<pre class="ned">
@prop1(value1,value2)
@prop2(value1,value2;key1=value11,value12,value13)
</pre>
<p>
Most of the properties use the default key with one value. Examples:

<pre class="ned">
@namespace(inet);
@class(Foo);
@unit(s);
</pre>
<p>
Property values have a liberal syntax (see Appendix <a href="#cha:ned-language-grammar">[20]</a>).
Values that do not fit the grammar (notably, those containing a comma or
a semicolon) need to be surrounded with double quotes.

<p>When interpreting a property value, one layer of quotes is removed
automatically, that is, <tt>foo</tt> and <tt>"foo"</tt> are the same.
Within quotes, escaping works in the same way as within string literals
(see <a href="#sec:ned-ref:literals">[19.1.6]</a>).

<p>Example:

<pre class="ned">
@prop(marks=the ! mark, "the , mark", "the ; mark", other marks); // 4 items
</pre>
<p>

<p><h4><a name="sec:ned-ref:property-placement"/>19.4.8.3 Placement<a class="headerlink" href="#sec:ned-ref:property-placement" title="Permalink to this headline"></a></h4>

<p>Properties may be added to NED files, component types, parameters,
gates, submodules and connections. For the exact syntax, see
Appendix <a href="#cha:ned-language-grammar">[20]</a>.

<p>When a component type extends another component type(s), properties
are merged. This is described in section <a href="#sec:ned-ref:inheritance">[19.4.21]</a>.

<p>
<h4><a name="sec:ned-ref:property-declarations"/>19.4.8.4 Property Declarations<a class="headerlink" href="#sec:ned-ref:property-declarations" title="Permalink to this headline"></a></h4>

<p>The <b><tt>property</tt></b> keyword is reserved for future use. It is
envisioned that accepted property names and property keys would need
to be pre-declared, so that the NED infrastructure can warn the user
about mistyped or unrecognized names.

<p>
<h3><a name="sec:ned-ref:parameters"/>19.4.9 Parameters<a class="headerlink" href="#sec:ned-ref:parameters" title="Permalink to this headline"></a></h3>

<p>Parameters can be defined and assigned in the <b><tt>parameters</tt></b> section
of component types. In addition, parameters can also be assigned in the
<b><tt>parameters</tt></b> sections of submodule bodies and connection bodies,
but those places do not allow adding new parameters.

<p>The <b><tt>parameters</tt></b> keyword is optional, and can be omitted
without change in the meaning.

<p>The <b><tt>parameters</tt></b> section may also hold pattern assignments
(<a href="#sec:ned-ref:pattern-assignments">[19.4.10]</a>) and properties
(<a href="#sec:ned-ref:properties">[19.4.8]</a>).

<p>A parameter is identified by a name, and has a data type. A parameter
may have value or default value, and may also have properties
(see <a href="#sec:ned-ref:properties">[19.4.8]</a>).

<p>Accepted parameter data types are <b><tt>double</tt></b>, <b><tt>int</tt></b>,
<b><tt>string</tt></b>, <b><tt>bool</tt></b>, and <b><tt>xml</tt></b>. Any
of the above types can be declared <b><tt>volatile</tt></b> as well
(<tt>volatile int</tt>, <tt>volatile string</tt>, etc.)

<p>The presence of a data type keyword determines whether the given line defines
a new parameter or refers to an existing parameter. One can assign a value or
default value to an existing parameter, and/or modify its properties or add
new properties.

<p>Examples:

<pre class="ned">
int a;           // defines new parameter
int b @foo;      // new parameter with property
int c = default(5); // new parameter with default value
int d = 5;       // new parameter with value assigned
int e @foo = 5;  // new parameter with property and value
f = 10;          // assignment to existing (e.g.inherited) parameter
g = default(10); // overrides default value of existing parameter
h;               // legal, but does nothing
i @foo(1);       // adds a property to existing parameter
j @foo(1) = 10;  // adds a property and value to existing parameter
</pre>
<p>
Parameter values are NED expressions. Expressions are described in section
<a href="#sec:ned-ref:expressions">[19.5]</a>.

<p>For <b><tt>volatile</tt></b> parameters, the value expression is evaluated every
time the parameter value is accessed. Non-<b><tt>volatile</tt></b> parameters
are evaluated only once.

<p><ul class="note"><b>NOTE</b><br>
    The <b><tt>const</tt></b> keyword is reserved for future use within expressions
    to define constant subexpressions, i.e. to denote a part within
    an expression that should only be evaluated once. Constant subexpressions
    are not supported yet.
</ul>

<p>The following properties are recognized for parameters: <b><tt>@unit</tt></b>,
<b><tt>@prompt</tt></b>.

<p>
<h4><a name="sec:ned-ref:prompt-property"/>19.4.9.1 The @prompt Property<a class="headerlink" href="#sec:ned-ref:prompt-property" title="Permalink to this headline"></a></h4>

<p>The <b><tt>@prompt</tt></b> property defines a prompt string for the parameter. The
prompt string is used when/if a simulation runtime user interface
interactively prompts the user for the parameter's value.

<p>The <b><tt>@prompt</tt></b> property is expected to contain one string value for the
default key.

<p>
<h4><a name="sec:ned-ref:unit-property"/>19.4.9.2 The @unit Property<a class="headerlink" href="#sec:ned-ref:unit-property" title="Permalink to this headline"></a></h4>

<p>A parameter may have a <b><tt>@unit</tt></b> property to associate it with a measurement
unit. The <b><tt>@unit</tt></b> property should contain one string value for the default
key. Examples:

<pre class="ned">
@unit(s)
@unit(second)
</pre>
<p>
When present, values assigned to the parameter must be in the
same or in a compatible (that is, convertible) unit.
Examples:

<pre class="ned">
  double a @unit(s) = 5s;   // OK
  double a @unit(s) = 10ms; // OK; will be converted to seconds
  double a @unit(s) = 5;    // error: should be 5s
  double a @unit(s) = 5kg;  // error: incompatible unit
</pre>
<p>
<b><tt>@unit</tt></b> behavior for non-numeric parameters (boolean, string, XML)
is unspecified (may be ignored or may be an error).

<p>The <b><tt>@unit</tt></b> property of a parameter may not be modified via inheritance.

<p>Example:
<pre class="ned">
simple A {
    double p @unit(s);
}
simple B extends A {
    p @unit(mW);  // illegal: cannot override @unit
}
</pre>

<p>

<p><h3><a name="sec:ned-ref:pattern-assignments"/>19.4.10 Pattern Assignments<a class="headerlink" href="#sec:ned-ref:pattern-assignments" title="Permalink to this headline"></a></h3>

<p>Pattern assignments allow one to set more than one parameter using
wildcards, and to assign parameters deeper down in a submodule tree.
Pattern assignments may occur in the <b><tt>parameters</tt></b>
section of component types, submodules and connections.

<p>The syntax of a pattern assignment is <i>&lt;pattern&gt; = &lt;value&gt;</i>.

<p>A pattern consists of two or more pattern elements, separated by dots.
The pattern element syntax is defined so that it can accomodate names of
parameters, submodules (optionally with index), gates (optionally with the
<tt>$i</tt>/<tt>$o</tt> suffix and/or index) and connections, and their
wildcard forms. (The default name of connection channel objects is
<b><tt>channel</tt></b>.)

<p>Wildcard forms may use:
<ol>
  <li> Asterisks: They match zero or more characters except dots.
  <li> Numeric ranges, <tt>{</tt><i>&lt;start&gt;</i>..<i>&lt;end&gt;</i><tt>}</tt>
    e.g. <tt>{5..120}</tt> or <tt>{..10}</tt>. They match numbers embedded
    in identifiers, that is, a sequence of decimal digit characters interpreted as a
    nonnegative integer that is within the specified <i>start..end</i>
    range (both limits are inclusive). Both <i>start</i> and <i>end</i>
    are optional.
  <li> Numeric index ranges,<tt>[</tt><i>&lt;start&gt;</i>..<i>&lt;end&gt;</i><tt>]</tt>.
    e.g. <tt>[5..120]</tt> or <tt>[..10]</tt>. They are intended for selecting
    submodule and gate index ranges. They match a nonnegative integer
    enclosed in square brackets that is within the specified
    <i>start..end</i> range (both limits are inclusive).
    Both <i>start</i> and <i>end</i> are optional.
  <li> Double asterisks: They match zero or more characters (including dots),
    and can be used to match more than one parameter path elements.
</ol>

<p>See the NED language grammar (Appendix <a href="#cha:ned-language-grammar">[20]</a>)
for a more formal definition of the pattern syntax.

<p>Examples:
<pre class="ned">
host1.tcp.mss = 512B;
host*.tcp.mss = 512B; // matches host, host1, host2, hostileHost, ...
host{9..11}.tcp.mss = 512B; // matches host9/host10/host11, but nothing else
host[9..11].tcp.mss = 512B; // matches host[9]/host[10]/host[11], but nothing else
**.mss = 512B; // matches foo.mss, host[1].transport.tcp[0].mss, ...
</pre>

<p>

<p><h3><a name="sec:ned-ref:gates"/>19.4.11 Gates<a class="headerlink" href="#sec:ned-ref:gates" title="Permalink to this headline"></a></h3>

<p>Gates can be defined in the <b><tt>gates</tt></b> section of component types.
The size of a gate vector (see below) may be specified at the place of
defining the gate, via inheritance in a derived type, and also in the
<b><tt>gates</tt></b> block of a submodule body. A submodule body does not allow
defining new gates.

<p>A gate is identified by a name, and is characterized by a type
(<b><tt>input</tt></b>, <b><tt>output</tt></b>, <b><tt>inout</tt></b>) and optionally a
vector size. Gates may also have properties (see
<a href="#sec:ned-ref:properties">[19.4.8]</a>).

<p>Gates may be scalar or vector. The vector size is specified with a numeric
expression inside square brackets. The vector size may also be left
unspecified by writing an empty pair of square brackets.

<p>An already specified gate vector size may not be overridden in subclasses or
in a submodule.

<p>The presence of a gate type keyword determines whether the given line defines
a new gate or refers to an existing gate. One can specify the gate vector
size for an existing gate vector, and/or modify its properties, or add new
properties.

<p>Examples:

<pre class="ned">
gates:
  input a;         // defines new gate
  input b @foo;    // new gate with property
  input c[];       // new gate vector with unspecified size
  input d[8];      // new gate vector with size=8
  e[10];           // set gate size for existing (e.g.inherited) gate vector
  f @foo(bar);     // add property to existing gate
  g[10] @foo(bar); // set gate size and add property to existing gate
</pre>
<p>
Gate vector sizes are NED expressions. Expressions are described in section
<a href="#sec:ned-ref:expressions">[19.5]</a>.

<p>See the Connections section (<a href="#sec:ned-ref:connections">[19.4.13]</a>) for more
information on gates.

<p><h4><a name="sec:ned-ref:recognized-gate-properties"/>19.4.11.1 Recognized Gate Properties<a class="headerlink" href="#sec:ned-ref:recognized-gate-properties" title="Permalink to this headline"></a></h4>

<p>The following properties are recognized for gates: <b><tt>@directIn</tt></b>
and <b><tt>@loose</tt></b>. They have the same effect: When either of them is
present on a gate, the gate is not required to be connected in the
connections section of a compound module (see <a href="#sec:ned-ref:connections">[19.4.13]</a>).

<p><b><tt>@directIn</tt></b> should be used when the gate is an <b><tt>input</tt></b> gate that is
intended for being used as a target for the <tt>sendDirect()</tt> method;
<b><tt>@loose</tt></b> should be used in any other case when the gate is not
required to be connected for some reason.

<p><ul class="note"><b>NOTE</b><br>
    The reason <b><tt>@directIn</tt></b> gates are not <i>required</i> to remain
    unconnected is that it is often useful to wrap such modules in a compound
    module, where the compound module also has a <b><tt>@directIn</tt></b> input gate
    that is internally connected to the submodule's corresponding gate.
</ul>

<p>Example:

<pre class="ned">
gates:
    input radioIn @directIn;
</pre>
<p>

<p>
<h3><a name="sec:ned-ref:submodules"/>19.4.12 Submodules<a class="headerlink" href="#sec:ned-ref:submodules" title="Permalink to this headline"></a></h3>

<p>Submodules are defined in the <b><tt>submodules</tt></b> section of the compound
module.

<p>The type of the submodule may be specified statically or parametrically.

<p>Submodules may be scalar or vector. The size of submodule vectors must be
specified as a numeric expression inside square brackets.

<p>Submodules may also be conditional.

<p>A submodule definition may or may not have a body (a curly brace
delimited block). An empty submodule body is equivalent to a
missing one.

<p>Syntax examples:
<pre class="ned">
submodules:
    ip : IP;         // scalar submodule without body
    tcp : TCP {}     // scalar submodule with empty body
    app[10] : App;   // submodule vector
</pre>

<p>
<h4><a name="sec:ned-ref:submodule-type"/>19.4.12.1 Submodule Type<a class="headerlink" href="#sec:ned-ref:submodule-type" title="Permalink to this headline"></a></h4>

<p>The simple or compound module type (<a href="#sec:ned-ref:simple-modules">[19.4.1]</a>,
<a href="#sec:ned-ref:compound-modules">[19.4.2]</a>) that will be instantiated as the
submodule may be specified either statically (with a concrete module type
name) or parametrically.

<p>
<h4><a name="sec:ned-ref:static-submodule-type"/>19.4.12.2 Static Submodule Type<a class="headerlink" href="#sec:ned-ref:static-submodule-type" title="Permalink to this headline"></a></h4>

<p>Submodules with a statically defined type are those that contain a concrete
NED module type name. Example:

<pre class="ned">
tcp : TCP;
</pre>
<p>
See section <a href="#sec:ned-ref:type-name-resolution">[19.4.18]</a> for the type resolution
rules.

<p>
<h4><a name="sec:ned-ref:parametric-submodule-type"/>19.4.12.3 Parametric Submodule Type<a class="headerlink" href="#sec:ned-ref:parametric-submodule-type" title="Permalink to this headline"></a></h4>

<p>Parametric submodule type means that the NED type name is given in a string
expression. The string expression may be specified locally in the submodule
declaration, or elsewhere using typename patterns (see later).

<p>Parametric submodule types are syntactically denoted by the presence of an
expression in a pair of angle brackets and the <b><tt>like</tt></b> keyword
followed by a module interface type <a href="#sec:ned-ref:module-interfaces">[19.4.5]</a>
that a module type must implement in order to be eligible to be chosen.
The angle brackets may be empty, contain a string expression, or contain a
default string expression (<tt>default(...)</tt> syntax).

<p>Examples:

<pre class="ned">
tcp : &lt;tcpType&gt; like ITCP;        // type comes from parent module parameter
tcp : &lt;"TCP_"+suffix&gt; like ITCP;  // expression using parent module parameter

tcp : &lt;&gt; like ITCP;               // type must be specified elsewhere

tcp : &lt;default("TCP")&gt; like ITCP; // type may be specified elsewhere;
                                  // if not, the default is "TCP"
tcp : &lt;default("TCP_"+suffix)&gt; like ITCP;
                                  // type may be specified elsewhere;
                                  // if not, the default is an expression
</pre>
<p>
See the NED Grammar (Appendix <a href="#cha:ned-language-grammar">[20]</a>) for the
formal syntax, and section <a href="#sec:ned-ref:parameteric-type-resolution">[19.4.19]</a>
for the type resolution rules.

<p>
<h4><a name="sec:ned-ref:conditional-submodules"/>19.4.12.4 Conditional Submodules<a class="headerlink" href="#sec:ned-ref:conditional-submodules" title="Permalink to this headline"></a></h4>

<p>Submodules may be made conditional using the <b><tt>if</tt></b> keyword. The
condition expression must evaluate to a boolean; if the result is
<tt>false</tt>, the submodule is not created, and trying to connect its gates
or reference its parameters will be an error.

<p>An example:

<pre class="ned">
submodules:
  tcp : TCP if withTCP { ... }
</pre>
<p>

<p><h4><a name="sec:ned-ref:parameters-gates"/>19.4.12.5 Parameters, Gates<a class="headerlink" href="#sec:ned-ref:parameters-gates" title="Permalink to this headline"></a></h4>

<p>A submodule body may contain parameters (<a href="#sec:ned-ref:parameters">[19.4.9]</a>)
and gates (<a href="#sec:ned-ref:module-interfaces">[19.4.5]</a>).

<p>A submodule body cannot define new parameters or gates. It is only
allowed to assign existing parameters, and to set the vector
size of existing gate vectors.

<p>It is also allowed to add or modify submodule properties and
parameter/gate properties.

<p>

<p><h3><a name="sec:ned-ref:connections"/>19.4.13 Connections<a class="headerlink" href="#sec:ned-ref:connections" title="Permalink to this headline"></a></h3>

<p>Connections are defined in the <b><tt>connections</tt></b> section of the compound module.

<p>Connections may not span multiple hierarchy levels, that is, a connection
may be created between two submodules, a submodule and the compound module,
or between two gates of the compound module.

<p>Normally, all gates must be connected, including submodule gates and the gates
of the compound module. When the <b><tt>allowunconnected</tt></b> modifier is present
after <b><tt>connections</tt></b>, gates will be allowed to be left unconnected.

<p><ul class="note"><b>NOTE</b><br>
    The <b><tt>@directIn</tt></b> and <b><tt>@loose</tt></b> gate properties are alternatives to the
    <tt>connections allowunconnected</tt> syntax; see <a href="#sec:ned-ref:gates">[19.4.11]</a>.
</ul>

<p>Connections may be conditional, and may be created using loops (see
<a href="#sec:ned-ref:connection-groups">[19.4.14]</a>).

<p>
<h4><a name="sec:ned-ref:connection-syntax"/>19.4.13.1 Connection Syntax<a class="headerlink" href="#sec:ned-ref:connection-syntax" title="Permalink to this headline"></a></h4>

<p>The connection syntax uses arrows (<tt>--&gt;</tt>, <tt>&lt;--</tt>) to connect
<b><tt>input</tt></b> and <b><tt>output</tt></b> gates, and double arrows
(<tt>&lt;--&gt;</tt>) to connect <b><tt>inout</tt></b> gates. The latter is
also said to be a bidirectional connection.

<p>Arrows point from the source gate (a submodule output gate or a compound
module input gate) to the destination gate (a submodule input gate or a
compound module output gate). Connections may be written either left to right
or right to left, that is, <tt>a--&gt;b</tt> is equivalent to <tt>b&lt;--a</tt>.

<p>Gates are specified as <i>&lt;modulespec&gt;.&lt;gatespec&gt;</i> (to connect a submodule),
or as <i>&lt;gatespec&gt;</i> (to connect the compound module). <i>&lt;modulespec&gt;</i>
is either a submodule name (for scalar submodules), or a submodule name plus
an index in square brackets (for submodule vectors). For scalar gates,
<i>&lt;gatespec&gt;</i> is the gate name; for gate vectors it is either
the gate name plus a numeric index expression in square brackets,
or <i>&lt;gatename&gt;</i><tt>++</tt>.

<p>The <i>&lt;gatename&gt;</i><tt>++</tt> notation causes the first unconnected gate index
to be used. If all gates of the given gate vector are connected, the behavior
is different for submodules and for the enclosing compound module.
For submodules, the gate vector expands by one. For the compound module,
it is an error to use <tt>++</tt> on a gate vector with no unconnected gates.

<p>Syntax examples:

<pre class="ned">
connections:
   a.out --&gt; b.in;   // unidirectional between two submodules
   c.in[2] &lt;-- in;   // parent-to-child; gate vector with index
   d.g++ &lt;--&gt; e.g++; // bidirectional, auto-expanding gate vectors
</pre>
<p>
<ul class="rationale"><b>Rationale</b><br>
    The reason it is not supported to expand the gate vector of the compound
    module is that the module structure is built in top-down order: new gates
    would be left unconnected on the outside, as there is no way in NED to
    "go back" and connect them afterwards.
</ul>

<p>When the <tt>++</tt> operator is used with <tt>$i</tt> or <tt>$o</tt>
(e.g. <tt>g$i++</tt> or <tt>g$o++</tt>, see later), it will actually add
a gate pair (input+output) to maintain equal gate size for the two
directions.

<p>The syntax to associate a channel (see <a href="#sec:ned-ref:channels">[19.4.4]</a>)
with the connection is to use two arrows with a channel specification
in between (see later). The same syntax is used to add properties such as
<b><tt>@display</tt></b> to the connection.

<p>


<p><h4><a name="sec:ned-ref:inout-gates"/>19.4.13.2 Inout Gates<a class="headerlink" href="#sec:ned-ref:inout-gates" title="Permalink to this headline"></a></h4>

<p>An inout gate is represented as a gate pair: an input gate and an output gate.
The two sub-gates may also be referenced and connected individually, by adding
the <tt>$i</tt> and <tt>$o</tt> suffix to the name of the inout gate.

<p>A bidirectional connection (which uses a double arrow to connect two inout gates),
is also a shorthand for two uni-directional connections; that is,

<pre class="ned">
a.g &lt;--&gt; b.g;
</pre>
<p>
is equivalent to
<pre class="ned">
a.g<i>o --&gt; b.g</i>i;
a.g<i>i &lt;-- b.g</i>o;
</pre>

<p>In inout gate vectors, gates are always in pairs, that is,
<tt>sizeof(g$i)==sizeof(g$o)</tt> always holds. It is maintained even
when <tt>g$i++</tt> or <tt>g$o++</tt> is used: the <tt>++</tt> operator will
add a gate pair, not just an input or an output gate.

<p>
<h4><a name="sec:ned-ref:specifying-channels"/>19.4.13.3 Specifying Channels<a class="headerlink" href="#sec:ned-ref:specifying-channels" title="Permalink to this headline"></a></h4>

<p>A channel specification associates a channel object with the connection.
A channel object is an instance of a channel type (see <a href="#sec:ned-ref:channels">[19.4.4]</a>).

<p><ul class="note"><b>NOTE</b><br>
As bidirectional connections are a shorthand for a pair of uni-directional
connections, they will actually create <i>two</i> channel objects, one
for each direction.
</ul>

<p>The channel type to be instantiated may be implicit, or may be specified
statically or parametrically.

<p>A connection may have a body (a curly brace delimited block) for setting
properties and/or parameters of the channel.

<p>A connection syntax allows one to specify a name for the channel object.
When not specified, the channel name will be taken from the <tt>@defaultname</tt>
property of the channel type; when there is no such property, it will be
<tt>"channel"</tt>. Custom connection names can be useful for easier addressing of
channel objects when assigning parameters using patterns.

<p>See subsequent sections for details.

<p>
<h4><a name="sec:ned-ref:implicit-channel-type"/>19.4.13.4 Implicit Channel Type<a class="headerlink" href="#sec:ned-ref:implicit-channel-type" title="Permalink to this headline"></a></h4>

<p>If the connection syntax does not say anything about the channel type, it
is implicitly determined from the set of connection parameters used.

<p>Syntax examples for connections with implicit channel types:

<pre class="ned">
a.g &lt;--&gt; b.g; // no parameters
a.g &lt;--&gt; {delay = 1ms;} &lt;--&gt; b.g;  // assigns delay
a.g &lt;--&gt; {datarate = 100Mbps; delay = 50ns;} &lt;--&gt; b.g; // assigns delay and datarate
</pre>
<p>
For such connections, the actual NED type to be used will depend on the
parameters set in the connection:

<p><ol>
  <li> When no parameters are set, <tt>ned.IdealChannel</tt> is chosen.
  <li> When only <tt>ned.DelayChannel</tt> parameters are used (<tt>delay</tt>
        and <tt>disabled</tt>), <tt>ned.DelayChannel</tt> is chosen.
  <li> When only <tt>ned.DatarateChannel</tt> parameters are used
        (<tt>datarate</tt>, <tt>delay</tt>, <tt>ber</tt>, <tt>per</tt>, <tt>disabled</tt>),
        the chosen channel type will be <tt>ned.DatarateChannel</tt>.
</ol>

<p>Connections with implicit channel types may not use any other parameter.

<p><h4><a name="sec:ned-ref:static-channel-type"/>19.4.13.5 Static Channel Type<a class="headerlink" href="#sec:ned-ref:static-channel-type" title="Permalink to this headline"></a></h4>

<p>Connections with a statically defined channel type are those that
contain a concrete NED channel type name.

<p>Examples:

<pre class="ned">
a.g &lt;--&gt; FastEthernet &lt;--&gt; b.g;
a.g &lt;--&gt; FastEthernet {per = 1e-6;} &lt;--&gt; b.g;
</pre>
<p>
See section <a href="#sec:ned-ref:type-name-resolution">[19.4.18]</a> for the type resolution
rules.

<p>
<h4><a name="sec:ned-ref:parametric-channel-type"/>19.4.13.6 Parametric Channel Type<a class="headerlink" href="#sec:ned-ref:parametric-channel-type" title="Permalink to this headline"></a></h4>

<p>Parametric channel types are similar to parametric submodule types,
described in section <a href="#sec:ned-ref:submodules">[19.4.12]</a>.

<p>Parametric channel type means that the NED type name is given in a string
expression. The string expression may be specified locally in the connection
declaration, or elsewhere using typename patterns (see later).

<p>Parametric channel types are syntactically denoted by the presence of an
expression in a pair of angle brackets and the <b><tt>like</tt></b> keyword
followed by a channel interface type <a href="#sec:ned-ref:channel-interfaces">[19.4.6]</a>
that a channel type must implement in order to be eligible to be chosen.
The angle brackets may be empty, contain a string expression, or contain a
default string expression (<tt>default(...)</tt> syntax).

<p>Examples:

<pre class="ned">
a.g++ &lt;--&gt; &lt;channelType&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // type comes from parent module parameter
a.g++ &lt;--&gt; &lt;"Ch_"+suffix&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // expression using parent module parameter
a.g++ &lt;--&gt; &lt;&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // type must be specified elsewhere
a.g++ &lt;--&gt; &lt;default("MyChannel")&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // type may be specified elsewhere;
                                  // if not, the default is "MyChannel"
a.g++ &lt;--&gt; &lt;default("Ch_"+suffix)&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // type may be specified elsewhere;
                                  // if not, the default is an expression
</pre>
<p>
See the NED Grammar (Appendix <a href="#cha:ned-language-grammar">[20]</a>) for the
formal syntax, and section <a href="#sec:ned-ref:parameteric-type-resolution">[19.4.19]</a>
for the type resolution rules.

<p>
<h4><a name="sec:ned-ref:channel-parameters-and-properties"/>19.4.13.7 Channel Parameters and Properties<a class="headerlink" href="#sec:ned-ref:channel-parameters-and-properties" title="Permalink to this headline"></a></h4>

<p>A channel definition may or may not have a body (a curly brace
delimited block). An empty channel body (<tt>{ }</tt>) is equivalent
to a missing one.

<p>A channel body may contain parameters (<a href="#sec:ned-ref:parameters">[19.4.9]</a>).

<p>A channel body cannot define new parameters. It is only
allowed to assign existing parameters.

<p>It is also allowed to add or modify properties and parameter properties.

<p>
<h3><a name="sec:ned-ref:connection-groups"/>19.4.14 Conditional and Loop Connections, Connection Groups<a class="headerlink" href="#sec:ned-ref:connection-groups" title="Permalink to this headline"></a></h3>

<p>The connections section may contain any number of connections and
connection groups. A connection group is one or more connections
grouped with curly braces.

<p>Both connections and connection groups may be conditional (<b><tt>if</tt></b>
keyword) or may be multiple (<b><tt>for</tt></b> keyword).

<p>Any number of <b><tt>for</tt></b> and <b><tt>if</tt></b> clauses may be added to
a connection or connection loop; they are interpreted as if they were
nested in the given order. Loop variables of a <b><tt>for</tt></b> may be
referenced from subsequent conditions and loops as well as in module and
gate index expressions in the connections.

<p>See the NED Grammar (<a href="#cha:ned-language-grammar">[20]</a>) for the exact syntax.

<p>Example connections:

<pre class="ned">
a.out --&gt; b.in;
c.out --&gt; d.in if p&gt;0;
e.out[i] --&gt; f[i].in for i=0..sizeof(f)-1, if i%2==0;
</pre>
<p>
Example connection groups:

<pre class="ned">
if p&gt;0 {
    a.out --&gt; b.in;
    a.in &lt;-- b.out;
}
for i=0..sizeof(c)-1, if i%2==0 {
    c[i].out --&gt; out[i];
    c[i].in &lt;-- in[i];
}
for i=0..sizeof(d)-1, for j=0..sizeof(d)-1, if i!=j {
    d[i].out[j] --&gt; d[j].in[i];
}
for i=0..sizeof(e)-1, for j=0..sizeof(e)-1 {
    e[i].out[j] --&gt; e[j].in[i] if i!=j;
}
</pre>
<p>

<p>
<h3><a name="sec:ned-ref:inner-types"/>19.4.15 Inner Types<a class="headerlink" href="#sec:ned-ref:inner-types" title="Permalink to this headline"></a></h3>

<p>Inner types can be defined in the <b><tt>types</tt></b> section of compound
modules, with the same syntax as toplevel (i.e. non-inner) types.

<p>Inner types may not contain further inner types, that is, type nesting
is limited to two levels.

<p>Inner types are only visible inside the enclosing component type
and its subclasses.

<p>

<p><h3><a name="sec:ned-ref:name-uniqueness"/>19.4.16 Name Uniqueness<a class="headerlink" href="#sec:ned-ref:name-uniqueness" title="Permalink to this headline"></a></h3>

<p>Identifier names within a component must be unique. That is, the following
items in a component are considered to be in the same name space and must
not have colliding names:

<p><ul>
  <li> parameters
  <li> gates
  <li> submodules
  <li> inner types
  <li> the above items of super type(s)
</ul>

<p>For example, a gate and a submodule cannot have the same name.

<p>
<h3><a name="sec:ned-ref:param-assignment-order"/>19.4.17 Parameter Assignment Order<a class="headerlink" href="#sec:ned-ref:param-assignment-order" title="Permalink to this headline"></a></h3>

<p>A module or channel parameter may be assigned in <b><tt>parameters</tt></b>
blocks (see <a href="#sec:ned-ref:parameters">[19.4.9]</a>) at various places in NED: in
the module or channel type that defines it; in the type's subclasses; in
the submodule or connection that instantiates the type. The parameter may
also be assigned using pattern assignments (see
<a href="#sec:ned-ref:pattern-assignments">[19.4.10]</a>) in any compound module that uses
the given module or channel type directly or indirectly.

<p>Patterns are matched against the relative path of the parameter, which is
the relative path of its submodule or connection, with a dot and the
parameter name appended. The relative path is composed of a list of
submodule names (name plus index) separated by dots; a connection is
identified by the full name of its source gate plus the name of the channel
object (which is currently always <tt>channel</tt>) separated by a dot.

<p><ul class="note"><b>NOTE</b><br>
As bidirectional connections are a shorthand for two unidirectional
connections, the source gate name is qualified with <tt>$i</tt> or
<tt>$o</tt> in the relative path.
</ul>

<p>Note that the <b><tt>parameters</tt></b> keyword itself is optional,
and is usually not written out in submodules and connections.

<p>This section describes the module and channel parameter assignments procedure.

<p>The general rules are the following:

<p><ol>
  <li> A (non-default) parameter assignment may not be overridden later;
    that is, if there are assignments in multiple places, the assignment
    &#8220;closest&#8221; to the parameter declaration will be effective; others
    will be flagged as errors.
  <li> A default value is only used if a non-default value is not present
    for the given parameter. A non-default value may also come from a source
    external to NED, namely the simulation configuration (<tt>omnetpp.ini</tt>).
  <li> Unlike non-default values, a default value <i>may</i> be overridden;
    that is, if there are default value assignments in multiple places,
    the assignment &#8220;farthest&#8221; from the parameter declaration will win.
  <li> Among pattern assignments within the same <b><tt>parameters</tt></b>
    block, the first match will win. Pattern assignments with default and
    non-default values are considered to be two disjoint sets, only one of
    which are searched at a time.
</ol>

<p>This yields the following conceptual search order for non-default parameter
assignments:

<p><ol>
  <li> First, the NED type that contains the parameter declaration is checked;
  <li> Then its subclasses are checked;
  <li> Then the submodule or connection that instantiates the type is checked;
  <li> Then the compound module that contains the submodule or connection is
    checked for matching pattern assignments;
  <li> Then, assuming the compound module is part of a network, the search
    for matching pattern assignments continues up on the module tree until the root
    (the module that represents the network). At each level (compound module),
    first the specific submodule definition is checked, then the (parent) compound module.
    If a compound module is subclassed before instantiated, the base type is checked
    first.
</ol>

<p>When no (non-default) assignment is found, the same places are searched in the
<i>reverse order</i> for default value assignments. If no default value is
found, an error may be raised or the user may be interactively prompted.

<p>To illustrate the above rules, consider the following example where we
want to assign parameter <i>p</i>:

<pre class="ned">
simple A { double p; }
simple A2 extends A {...}
module B { submodules: a2: A2 {...} }
module B2 extends B {...}
network C { submodules: b2: B2 {...} }
</pre>
<p>
Here, the search order is: <i>A, A2, a2, B, B2, b2, C</i>. NED
conceptually searches the <b><tt>parameters</tt></b> blocks in that order for a
(non-default) value, and then in reverse order for a default value.

<p>The full search order and the form of assignment expected on each level:

<p><ol>
  <li> <tt>A  { p = ...; }</tt>
  <li> <tt>A2 { p = ...; }</tt>
  <li> <tt>a2 { p = ...; }</tt>
  <li> <tt>B  { a2.p = ...; }</tt>
  <li> <tt>B2 { a2.p = ...; }</tt>
  <li> <tt>b2 { a2.p = ...; }</tt>
  <li> <tt>C  { b2.a2.p = ...; }</tt>
  <li> <tt>C  { b2.a2.p = default(...); }</tt>
  <li> <tt>b2 { a2.p = default(...); }</tt>
  <li> <tt>B2 { a2.p = default(...); }</tt>
  <li> <tt>B  { a2.p = default(...); }</tt>
  <li> <tt>a2 { p = default(...); }</tt>
  <li> <tt>A2 { p = default(...); }</tt>
  <li> <tt>A  { p = default(...); }</tt>
</ol>

<p>If only a default value is found or not even that, external configuration
has a say. The configuration may contain an assignment for <tt>C.b2.a2.p</tt>;
it may apply the default if there is one; it may ask the user interactively
to enter a value; or if there is no default, it may raise an error
<i>&#8220;no value for parameter&#8221;</i>.

<p>

<p><h3><a name="sec:ned-ref:type-name-resolution"/>19.4.18 Type Name Resolution<a class="headerlink" href="#sec:ned-ref:type-name-resolution" title="Permalink to this headline"></a></h3>

<p>Names from other NED files can be referred to either by fully qualified
name (&#8220;<tt>inet.networklayer.ip.RoutingTable</tt>&#8221;), or by short name
(&#8220;<tt>RoutingTable</tt>&#8221;) if the name is visible.

<p>Visible names are:

<p><ul>
  <li> inner types of the same type or its super types;
  <li> anything from the same package;
  <li> imported names.
</ul>

<p><h4><a name="sec:ned-ref:imports"/>19.4.18.1 Imports<a class="headerlink" href="#sec:ned-ref:imports" title="Permalink to this headline"></a></h4>

<p>Imports have a similar syntax to Java, but they are more flexible with wildcards.
All of the following are legal:

<pre class="ned">
import inet.networklayer.ipv4.RoutingTable;
import inet.networklayer.ipv4.*;
import inet.networklayer.ipv4.Ro*Ta*;
import inet.*.ipv4.*;
import inet.**.RoutingTable;
</pre>
<p>
One asterisk stands for any character sequence not containing dots; and a
double asterisk stands for any character sequence (which may contain dots).
No other wildcards are recognized.

<p>An import not containing a wildcard must match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

<p>Inner types may not be referenced outside their enclosing types and
their subclasses.

<p><h4><a name="sec:ned-ref:base-types-and-submodules"/>19.4.18.2 Base Types and Submodules<a class="headerlink" href="#sec:ned-ref:base-types-and-submodules" title="Permalink to this headline"></a></h4>

<p>Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.

<p><h4><a name="sec:ned-ref:network-name-in-ini-file"/>19.4.18.3 Network Name in the Ini File<a class="headerlink" href="#sec:ned-ref:network-name-in-ini-file" title="Permalink to this headline"></a></h4>

<p>The network name in the ini file may be given as a fully qualified name
or as a simple (unqualified) name.

<p>Simple (unqualified) names are tried with the same package as the
ini file is in (provided it is in a NED directory).

<p>
<h3><a name="sec:ned-ref:parameteric-type-resolution"/>19.4.19 Resolution of Parametric Types<a class="headerlink" href="#sec:ned-ref:parameteric-type-resolution" title="Permalink to this headline"></a></h3>

<p>This section describes the type resolution for submodules and connections
that are defined using the <b><tt>like</tt></b> keyword.

<p>Type resolution is done in two steps. In the first step, the type name
string expression is found and evaluated. Then in the second step, the
resulting type name string is resolved to an actual NED type.

<p><b>Step 1.</b> The lookup of the type name string expression is similar to
that of a parameter value lookup (<a href="#sec:ned-ref:param-assignment-order">[19.4.17]</a>).

<p>The expression may be specified locally (between the angle brackets), or
using typename pattern assignments in any compound module that
contains the submodule or connection directly or indirectly. A
typename pattern is a pattern that ends in <tt>.typename</tt>.

<p>Patterns are matched against the relative path of the submodule or
connection, with <tt>.typename</tt> appended. The relative path is
composed of a list of submodule names (name plus index) separated
by dots; a connection is identified by the full name of its source
gate plus the name of the channel object (which is currently always
<tt>channel</tt>) separated by a dot.

<p><ul class="note"><b>NOTE</b><br>
As bidirectional connections are a shorthand for two unidirectional
connections, the source gate name is qualified with <tt>$i</tt> or
<tt>$o</tt> in the relative path.
</ul>

<p>An example that uses typename pattern assignment:

<pre class="ned">
module Host {
    submodules:
        tcp: &lt;&gt; like ITCP;;
        ...
    connections:
        tcp.ipOut --&gt; &lt;&gt; like IMyChannel --&gt; ip.tcpIn;
}

network Network {
    parameters:
        host[*].tcp.typename = "TCP_lwIP";
        host[*].tcp.ipOut.channel.typename = "DebugChannel";
    submodules:
        host[10] : Host;
        ...
}
</pre>
<p>
The general rules are the following:

<p><ol>
  <li> A (non-default) parameter assignment may not be overridden later;
    that is, if there are assignments in multiple places, the assignment
    &#8220;closest&#8221; to the submodule or connection definition will be effective;
    others will be flagged as errors.
  <li> A default value is only used if a non-default value is not present.
    A non-default value may also come from a source external to NED, namely
    the simulation configuration (<tt>omnetpp.ini</tt>).
  <li> Unlike non-default values, a default value <i>may</i> be overridden;
    that is, if there are default value assignments in multiple places,
    the assignment &#8220;farthest&#8221; from the submodule or connection definition will win.
  <li> Among pattern assignments within the same <b><tt>parameters</tt></b>
    block, the first match will win. Patterns assignments with default and
    non-default values are considered to be two disjoint sets, only one of
    which are searched at a time.
</ol>

<p>This yields the following conceptual search order for typename assignments:

<p><ol>
   <li> First, the submodule or connection definition is checked (angle brackets);
   <li> Then the compound module that contains the submodule or connection is
     checked for matching pattern assignments;
   <li> Then, assuming the compound module is part of a network, the search
     for matching pattern assignments continues up on the module tree until the root
     (the module that represents the network). At each level (compound module),
     first the specific submodule definition is checked, then the (parent) compound module.
     If a compound module is subclassed before instantiated, the base type is checked
     first.
</ol>

<p>When no (non-default) assignment is found, the same places are searched in the
<i>reverse order</i> for default value assignments. If no default value is
found, an error may be raised or the user may be interactively prompted.

<p>To illustrate the above rules, consider the following example:

<pre class="ned">
module A { submodules: h: &lt;&gt; like IFoo; }
module A2 extends A {...}
module B { submodules: a2: A2 {...} }
module B2 extends B {...}
network C { submodules: b2: B2 {...} }
</pre>
<p>
Here, the search order is: <i>h, A, A2, a2, B, B2, b2, C</i>. NED
conceptually searches the <b><tt>parameters</tt></b> blocks in that order for a
(non-default) value, and then in reverse order for a default value.

<p>The full search order and the form of assignment expected on each level:

<p><ol>
  <li> <tt>h: &lt;...&gt; like IFoo;</tt>
  <li> <tt>A  { h.typename = ...; }</tt>
  <li> <tt>A2 { h.typename = ...; }</tt>
  <li> <tt>a2 { h.typename = ...; }</tt>
  <li> <tt>B  { a2.h.typename = ...; }</tt>
  <li> <tt>B2 { a2.h.typename = ...; }</tt>
  <li> <tt>b2 { a2.h.typename = ...; }</tt>
  <li> <tt>C  { b2.a2.h.typename = ...; }</tt>
  <li> <tt>C  { b2.a2.h.typename = default(...); }</tt>
  <li> <tt>b2 { a2.h.typename = default(...); }</tt>
  <li> <tt>B2 { a2.h.typename = default(...); }</tt>
  <li> <tt>B  { a2.h.typename = default(...); }</tt>
  <li> <tt>a2 { h.typename = default(...); }</tt>
  <li> <tt>A2 { h.typename = default(...); }</tt>
  <li> <tt>A  { h.typename = default(...); }</tt>
  <li> <tt>h: &lt;default(...)&gt; like IFoo;</tt>
</ol>

<p>If only a default value is found or not even that, external configuration
has a say. The configuration may contain an assignment for
<tt>C.b2.a2.h.typename</tt>; it may apply the default value if there is one;
it may ask the user interactively to enter a value; or if there is no
default value, it may raise an error <i>&#8220;cannot determine submodule
type&#8221;</i>.

<p>
<b>Step 2.</b> The type name string is expected to hold the simple name or
fully qualified name of the desired NED type. Resolving the type name
string to an actual NED type differs from normal type name lookups in that
it ignores the imports in the file altogether. Instead, a list of NED types
that have the given simple name or fully qualified name <i>and</i>
implement the given interface is collected. The result must be exactly one
module or channel type.

<p>
<h3><a name="sec:ned-ref:implementing-an-interface"/>19.4.20 Implementing an Interface<a class="headerlink" href="#sec:ned-ref:implementing-an-interface" title="Permalink to this headline"></a></h3>

<p>A module type may implement one or more module interfaces, and a channel type
may implement one or more channel interfaces, using the <b><tt>like</tt></b>
keyword.

<p>The module or channel type is required to have <i>at least</i> those
parameters and gates that the interface has.

<p>Regarding component properties, parameter properties and gate properties
defined in the interface: the module or channel type is required to have at
least the properties of the interface, with at least the same values.
The component may have additional properties, and properties may add more
keys and values.

<p><ul class="note"><b>NOTE</b><br>
  Implementing an interface does not cause the properties, parameters and
  gates to be interited by the module or channel type; they have to be added
  explicitly.
</ul>

<p><ul class="note"><b>NOTE</b><br>
  A module or channel type may have extra properties, parameters and gates
  in addition to those in the interface.
</ul>

<p>

<p><h3><a name="sec:ned-ref:inheritance"/>19.4.21 Inheritance<a class="headerlink" href="#sec:ned-ref:inheritance" title="Permalink to this headline"></a></h3>

<p>Component inheritance is governed by the following rules:

<p><ul>
  <li> A simple module may only extend a simple module.
  <li> A compound module may only extend a compound module or a simple module.
  <li> A channel may only extend a channel.
  <li> A module interface may only extend a module interface (or several module
        interfaces).
  <li> A channel interface may only extend a channel interface (or several
        channel interfaces).
</ul>

<p>A network is a shorthand for a compound module with the <b><tt>@isNetwork</tt></b>
property set, so the same rules apply to it as to compound modules.

<p>Inheritance may:
<ul>
    <li> add new properties, parameters, gates, inner types, submodules,
          connections, as long as names do not conflict with inherited names
    <li> modify inherited properties, and properties of inherited parameters and
          gates
    <li> it may not modify inherited submodules, connections and inner types
</ul>

<p>Other inheritance rules:
<ul>
    <li>  for inner types:
       new inner types can be added, but inherited ones cannot be changed
    <li>  for properties:
       contents will be merged (rules like for display strings: values on
       same key and same position will overwrite old ones)
    <li> for parameters:
       type cannot be redefined;
       value may be redefined in subclasses or at place of usage
    <li>  for gates:
       type cannot be redefined;
       vector size may be specified in subclasses or at place of usage if it was unspecified
    <li>  for gate/parameter properties:
       extra properties can be added;
       existing properties can be overridden/extended as for standalone properties
    <li>  for submodules:
       new submodules may be added, but inherited ones cannot be modified
    <li>  for connections:
       new connections may be added, but inherited ones cannot be modified
</ul>

<p>The following sections will elaborate on the above rules.

<p><h4><a name="sec:ned-ref:property-inheritance"/>19.4.21.1 Property Inheritance<a class="headerlink" href="#sec:ned-ref:property-inheritance" title="Permalink to this headline"></a></h4>

<p>Generally, properties may be modified via inheritance. Inheritance may:

<p><ul>
    <li> add new keys
    <li> add/overwrite values for existing keys
    <li> remove a value from an existing key by using hyphen as a special value
</ul>

<p>
<h4><a name="sec:ned-ref:parameter-inheritance"/>19.4.21.2 Parameter Inheritance<a class="headerlink" href="#sec:ned-ref:parameter-inheritance" title="Permalink to this headline"></a></h4>

<p>Default values for parameters may be overridden in subclasses.

<p><h4><a name="sec:ned-ref:gate-inheritance"/>19.4.21.3 Gate Inheritance<a class="headerlink" href="#sec:ned-ref:gate-inheritance" title="Permalink to this headline"></a></h4>

<p>Gate vector size may not be overridden in subclasses.

<p>
<h3><a name="sec:ned-ref:build-order"/>19.4.22 Network Build Order<a class="headerlink" href="#sec:ned-ref:build-order" title="Permalink to this headline"></a></h3>

<p>When a network is instantiated for simulation, the module tree is built in
a top-down preorder fashion. This means that starting from an empty system
module, all submodules are created, their parameters and vector sizes are
assigned, and they get fully connected before proceeding to go into the
submodules to build their internals.

<p>This implies that inside a compound module definition (including in
submodules and connections), one can refer to the compound module's
parameters and gate sizes, because they are already built at the time of
usage.

<p>The same rules apply to compound or simple modules created dynamically during
runtime.

<p>
<h2><a name="sec:ned-ref:expressions"/>19.5 Expressions<a class="headerlink" href="#sec:ned-ref:expressions" title="Permalink to this headline"></a></h2>

<p>NED language expressions<!--ned!expressions--> have a C-like syntax, with
some variations on operator names (see <tt>^</tt>, <tt>#</tt>, <tt>##</tt>).
Expressions may refer to module parameters, loop variables (inside connection
<b><tt>for</tt></b> loops), gate vector and module vector sizes, and other attributes
of the model. Expressions can use built-in and user-defined functions as well.

<p><ul class="note"><b>NOTE</b><br>
New NED functions can be defined in C++; see section <a href="#sec:sim-lib:defining-ned-functions">[7.11]</a>.
</ul>

<p><h3><a name="sec:ned-ref:constants"/>19.5.1 Constants<a class="headerlink" href="#sec:ned-ref:constants" title="Permalink to this headline"></a></h3>

<p>See section <a href="#sec:ned-ref:literals">[19.1.6]</a>.

<p><h3><a name="sec:ned-ref:operators"/>19.5.2 Operators<a class="headerlink" href="#sec:ned-ref:operators" title="Permalink to this headline"></a></h3>
<!--ned!expressions!operators-->

<p>The following operators are supported (in order of decreasing precedence):

<p><table border>
<TR> <TD align=left>

<p><b>Operator</b>                   </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <tt>-</tt>, <tt>!</tt>, <it>~</it> </TD> <TD align=left> unary minus, negation, bitwise complement </TD></TR>
<TR> <TD align=left> <tt>^</tt>         </TD> <TD align=left> power-of </TD></TR>
<TR> <TD align=left> <tt>*</tt>, <tt>/</tt>, <tt>%</tt>       </TD> <TD align=left> multiply, divide, integer modulo </TD></TR>
<TR> <TD align=left> <tt>+</tt>, <tt>-</tt>                 </TD> <TD align=left> add, subtract, string concatenation </TD></TR>
<TR> <TD align=left> <tt>&lt;&lt;</tt>, <tt>&gt;&gt;</tt>               </TD> <TD align=left> bitwise shift </TD></TR>
<TR> <TD align=left> <tt>&amp;</tt>, <tt>|</tt>, <tt>#</tt>      </TD> <TD align=left> bitwise and, or, xor </TD></TR>
<TR> <TD align=left> <tt>==</tt>                         </TD> <TD align=left> equal </TD></TR>
<TR> <TD align=left> <tt>!=</tt>                         </TD> <TD align=left> not equal </TD></TR>
<TR> <TD align=left> <tt>&gt;</tt>, <tt>&gt;=</tt>                </TD> <TD align=left> greater than, greater than or equal to</TD></TR>
<TR> <TD align=left> <tt>&lt;</tt>, <tt>&lt;=</tt>                </TD> <TD align=left> less than, less than or equal to </TD></TR>
<TR> <TD align=left> <tt>&amp;&amp;</tt>, <tt>||</tt>, <tt>##</tt> </TD> <TD align=left> logical operators and, or, xor </TD></TR>
<TR> <TD align=left> <tt>?:</tt>                         </TD> <TD align=left> the C/C++ &#8220;inline if&#8221; </TD></TR>
</table>

<p><h4><a name="sec:ned-ref:conversions"/>19.5.2.1 Conversions<a class="headerlink" href="#sec:ned-ref:conversions" title="Permalink to this headline"></a></h4>

<p>Values may have the same types as NED parameters: boolean, integer, double, string, or XML element.
An integer or double value may have an associated measurement unit (<tt>s</tt>, <tt>mW</tt>, etc.)

<p>Double-to-integer conversions require explicit cast using the <tt>int()</tt> function,
there is no implicit conversion.

<p>Integer-to-double converson is implicit. However, a runtime error will be raised
if there is precision loss during the conversion, i.e. the integer is so large
that it cannot be precisely represented in a double. That error can be suppressed
by using an explicit cast (<tt>double()</tt>.

<p>There is no implicit conversion between boolean and numeric types, so <tt>0</tt>
is not a synonym for <b><tt>false</tt></b>, and nonzero numbers are not a synonym
for <b><tt>true</tt></b>.

<p>There is also no conversion between string and numeric types, so e.g. <tt>"foo"+5</tt>
is illegal. There are functions for converting a number to string and vice versa.

<p>Bitwise operators expect integer arguments.

<p><ul class="note"><b>NOTE</b><br>
Integers are represented with 64-bit signed integers (<tt>int64_t</tt> in C++).
</ul>

<p>
<h4><a name="sec:ned-ref:unit-handling"/>19.5.2.2 Unit Handling<a class="headerlink" href="#sec:ned-ref:unit-handling" title="Permalink to this headline"></a></h4>

<p>Operations involving numbers with units work in the following way:

<p>Addition, subtraction, and numeric comparisons require their arguments to
have the same unit or compatible units; in the latter case a unit conversion
is performed before the operation. Incompatible units cause an error.

<p>
Modulo, power-of and the bitwise operations require their arguments to be
dimensionless, otherwise the result would depend on the choice of the unit.

<p><ul class="note"><b>NOTE</b><br>
If one needs a floating-point modulo operator that handles units as well,
the <tt>fmod()</tt> function can be used.
</ul>

<p>Multiplying two numbers with units is not supported.

<p>For division, dividing two numbers with units is only supported if the two
units are convertible (i.e. the result will be dimensionless). Dividing
a dimensionless number with a number with unit is not supported.

<p>Operations involving quantities with logarithmic units (dB, dBW, etc.)
are not supported, except for comparisons. (The reason is that such
operations would be easy to misinterpret. For example, it is not obvious
whether <tt>10dB+10dB</tt> (3.16+3.16) should evaluate to 20dB (=10.0)
or to 16.02dB (=2*3.16=6.32), considering that such quantities would
often be hidden behind parameter names where the unit is not obvious.)

<p><h3><a name="sec:ned-ref:referencing-parameters-and-loop-variables"/>19.5.3 Referencing Parameters and Loop Variables<a class="headerlink" href="#sec:ned-ref:referencing-parameters-and-loop-variables" title="Permalink to this headline"></a></h3>

<p>Identifiers in expressions occurring <i>anywhere</i> in component definitions
are interpreted as referring to parameters of the given component. For example,
identifiers inside submodule bodies refer to the parameters of the <i>compound</i>
module.

<p>Expressions may also refer to parameters of submodules defined earlier
in the NED file, using the <tt>submoduleName.paramName</tt> or the
<tt>submoduleName[index].paramName</tt> syntax. To refer to parameters
of the local submodule inside a submodule body, use the
<b><tt>this</tt></b> qualifier: <tt>this.destAddress</tt>.

<p>Exception: if an identifier occurs in a connection <b><tt>for</tt></b> loop and names
a previously defined loop variable, then it is understood as referring to
the loop variable.

<p>
<h3><a name="sec:ned-ref:typename-operator"/>19.5.4 The <b><tt>typename</tt></b> Operator<a class="headerlink" href="#sec:ned-ref:typename-operator" title="Permalink to this headline"></a></h3>

<p>The <b><tt>typename</tt></b> operator returns the NED type name as a string.
If it occurs inside a component definition but outside a submodule or channel
block, it returns the type name of the component being defined. If it occurs
inside a submodule or channel block, it returns the type name of that submodule
or channel.

<p>The <b><tt>typename</tt></b> may also occur in the <b><tt>if</tt></b> condition of a
(scalar) submodule or connection. In such cases, it evaluates to the <i>would-be</i>
type name of the submodule or condition. This allows for conditional
instantiation of parametric-type submodules, controlled from a
<b><tt>typename</tt></b> assignment. (For example, by using the <tt>if typename!=""</tt>
condition, one allows the submodule to be omitted by configuring <tt>typename=""</tt>
for it.

<p><b><tt>typename</tt></b> is not allowed in a submodule vector's <b><tt>if</tt></b> condition.
The reason is that the condition applies to the vector as a whole, while type
is per-element.

<p>
<h3><a name="sec:ned-ref:index-operator"/>19.5.5 The <b><tt>index</tt></b> Operator<a class="headerlink" href="#sec:ned-ref:index-operator" title="Permalink to this headline"></a></h3>

<p>The <b><tt>index</tt></b> operator is only allowed in a vector submodule's body,
and yields the index of the submodule instance.

<p>
<h3><a name="sec:ned-ref:exists-operator"/>19.5.6 The <b><tt>exists()</tt></b> Operator<a class="headerlink" href="#sec:ned-ref:exists-operator" title="Permalink to this headline"></a></h3>

<p>The <b><tt>exists()</tt></b> operator takes one identifier as argument, and it
is only accepted in compound module definitions. The identifier must name
a previously defined submodule, which will typically be a conditional submodule.
The operator returns <b><tt>true</tt></b> if given submodule exists (has been created),
and <b><tt>false</tt></b> otherwise.

<p>
<h3><a name="sec:ned-ref:sizeof-operator"/>19.5.7 The <b><tt>sizeof()</tt></b> Operator<a class="headerlink" href="#sec:ned-ref:sizeof-operator" title="Permalink to this headline"></a></h3>

<p>The <b><tt>sizeof()</tt></b> operator expects one argument, and it is only accepted
in compound module definitions.

<p>The <tt>sizeof(identifier)</tt> syntax occurring <i>anywhere</i> in a compound
module yields the size of the named submodule or gate vector of the
compound module.

<p>Inside submodule bodies, the size of a gate vector of the same submodule
can be referred to with the <b><tt>this</tt></b> qualifier: <tt>sizeof(this.out)</tt>.

<p>To refer to the size of a submodule's gate vector defined earlier in the
NED file, use the <tt>sizeof(submoduleName.gateVectorName)</tt> or
<tt>sizeof(submoduleName[index].gateVectorName)</tt> syntax.

<p>
<h3><a name="sec:ned-ref:functions"/>19.5.8 Functions<a class="headerlink" href="#sec:ned-ref:functions" title="Permalink to this headline"></a></h3>
<!--ned!functions-->

<p>The functions available in NED are listed in Appendix
<a href="#cha:ned-functions">[22]</a>.

<p>Selected functions are documented below.

<p><h4><a name="sec:ned-ref:xmldoc-function"/>19.5.8.1 The <b><tt>xmldoc()</tt></b> Function<a class="headerlink" href="#sec:ned-ref:xmldoc-function" title="Permalink to this headline"></a></h4>

<p>The <b><tt>xmldoc()</tt></b> NED function can be used to assign <b><tt>xml</tt></b> parameters,
that is, point them to XML files or to specific elements inside XML files.

<p><b><tt>xmldoc()</tt></b> accepts a file name as well as an optional second string argument
that contains an XPath-like expression.

<p>
The XPath expression is used to select an element within the document.
If the expression matches several elements, the first element
(in preorder depth-first traversal) will be selected. (This is
unlike XPath, which selects all matching nodes.)

<p>The expression syntax is the following:
<ul>
  <li> An expression consists of <i>path components</i> (or "steps")
        separated by "<tt>/</tt>" or "<tt>//</tt>".
  <li> A path component can be an element tag name, "<tt>*</tt>", "<tt>.</tt>"
        or "<tt>..</tt>".
  <li> "<tt>/</tt>" means child element (just as in <tt>/usr/bin/gcc</tt>);
        "<tt>//</tt>" means an element any number of levels under the current element.
  <li> "<tt>.</tt>", "<tt>..</tt>" and "<tt>*</tt>" mean the current element,
        the parent element, and an element with any tag name, respectively.
  <li> Element tag names and "<tt>*</tt>" can have an optional predicate
        in the form "<tt>[position]</tt>" or "<tt>[@attribute='value']</tt>".
        Positions start from zero.
  <li> Predicates of the form "<tt>[@attribute=<i>$param</i>]</tt>" are also
        accepted, where <tt><i>$param</i></tt> can be one of:
        <tt>$MODULE_FULLPATH</tt>,
        <tt>$MODULE_FULLNAME</tt>,
        <tt>$MODULE_NAME</tt>,
        <tt>$MODULE_INDEX</tt>,
        <tt>$MODULE_ID</tt>,
        <tt>$PARENTMODULE_FULLPATH</tt>,
        <tt>$PARENTMODULE_FULLNAME</tt>,
        <tt>$PARENTMODULE_NAME</tt>,
        <tt>$PARENTMODULE_INDEX</tt>,
        <tt>$PARENTMODULE_ID</tt>,
        <tt>$GRANDPARENTMODULE_FULLPATH</tt>,
        <tt>$GRANDPARENTMODULE_FULLNAME</tt>,
        <tt>$GRANDPARENTMODULE_NAME</tt>,
        <tt>$GRANDPARENTMODULE_INDEX</tt>,
        <tt>$GRANDPARENTMODULE_ID</tt>.
</ul>

<p><h4><a name="sec:ned-ref:xml-function"/>19.5.8.2 The <b><tt>xml()</tt></b> Function<a class="headerlink" href="#sec:ned-ref:xml-function" title="Permalink to this headline"></a></h4>

<p>The <b><tt>xml()</tt></b> NED function can be used to parse a string as an
XML document, and assign the result to an <b><tt>xml</tt></b> parameter.

<p><b><tt>xml()</tt></b> accepts the string to be parsed as well as an optional
second string argument that contains an XPath-like expression.

<p>The XPath expression is used in the same manner as with the
<b><tt>xmldoc()</tt></b> function.

<p>
<h3><a name="sec:ned-ref:units"/>19.5.9 Units of Measurement<a class="headerlink" href="#sec:ned-ref:units" title="Permalink to this headline"></a></h3>

<p>The following measurements units are recognized in constants. Other units can
be used as well, but there are no conversions available for them (i.e.
<tt>parsec</tt> and <tt>kiloparsec</tt> will be treated as two completely unrelated
units.)

<p><table border>
<TR> <TD align=center>
  
<p>  <b>Unit</b> </TD> <TD align=center> <b>Name</b> </TD> <TD align=right> <b>Value</b> </TD></TR>
<TR> <TD align=center>   s </TD> <TD align=center> second </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   d </TD> <TD align=center> day </TD> <TD align=right> 86400s </TD></TR>
<TR> <TD align=center>   h </TD> <TD align=center> hour </TD> <TD align=right> 3600s </TD></TR>
<TR> <TD align=center>   min </TD> <TD align=center> minute </TD> <TD align=right> 60s </TD></TR>
<TR> <TD align=center>   ms </TD> <TD align=center> millisecond </TD> <TD align=right> 0.001s </TD></TR>
<TR> <TD align=center>   us </TD> <TD align=center> microsecond </TD> <TD align=right> 1e-6s </TD></TR>
<TR> <TD align=center>   ns </TD> <TD align=center> nanosecond </TD> <TD align=right> 1e-9s </TD></TR>
<TR> <TD align=center>   ps </TD> <TD align=center> picosecond </TD> <TD align=right> 1e-12s </TD></TR>
<TR> <TD align=center>   fs </TD> <TD align=center> femtosecond </TD> <TD align=right> 1e-15s </TD></TR>
<TR> <TD align=center>   as </TD> <TD align=center> attosecond </TD> <TD align=right> 1e-18s </TD></TR>
<TR> <TD align=center>   bps </TD> <TD align=center> bit/sec </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kbps </TD> <TD align=center> kilobit/sec </TD> <TD align=right> 1000bps </TD></TR>
<TR> <TD align=center>   Mbps </TD> <TD align=center> megabit/sec </TD> <TD align=right> 1e6bps </TD></TR>
<TR> <TD align=center>   Gbps </TD> <TD align=center> gigabit/sec </TD> <TD align=right> 1e9bps </TD></TR>
<TR> <TD align=center>   Tbps </TD> <TD align=center> terabit/sec </TD> <TD align=right> 1e12bps </TD></TR>
<TR> <TD align=center>   B </TD> <TD align=center> byte </TD> <TD align=right> 8b </TD></TR>
<TR> <TD align=center>   KiB </TD> <TD align=center> kibibyte </TD> <TD align=right> 1024B </TD></TR>
<TR> <TD align=center>   MiB </TD> <TD align=center> mebibyte </TD> <TD align=right> 1.04858e6B </TD></TR>
<TR> <TD align=center>   GiB </TD> <TD align=center> gibibyte </TD> <TD align=right> 1.07374e9B </TD></TR>
<TR> <TD align=center>   TiB </TD> <TD align=center> tebibyte </TD> <TD align=right> 1.09951e12B </TD></TR>
<TR> <TD align=center>   kB </TD> <TD align=center> kilobyte </TD> <TD align=right> 1000B </TD></TR>
<TR> <TD align=center>   MB </TD> <TD align=center> megabyte </TD> <TD align=right> 1e6B </TD></TR>
<TR> <TD align=center>   GB </TD> <TD align=center> gigabyte </TD> <TD align=right> 1e9B </TD></TR>
<TR> <TD align=center>   TB </TD> <TD align=center> terabyte </TD> <TD align=right> 1e12B </TD></TR>
<TR> <TD align=center>   b </TD> <TD align=center> bit </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   Kib </TD> <TD align=center> kibibit </TD> <TD align=right> 1024b </TD></TR>
<TR> <TD align=center>   Mib </TD> <TD align=center> mebibit </TD> <TD align=right> 1.04858e6b </TD></TR>
<TR> <TD align=center>   Gib </TD> <TD align=center> gibibit </TD> <TD align=right> 1.07374e9b </TD></TR>
<TR> <TD align=center>   Tib </TD> <TD align=center> tebibit </TD> <TD align=right> 1.09951e12b </TD></TR>
<TR> <TD align=center>   kb </TD> <TD align=center> kilobit </TD> <TD align=right> 1000b </TD></TR>
<TR> <TD align=center>   Mb </TD> <TD align=center> megabit </TD> <TD align=right> 1e6b </TD></TR>
<TR> <TD align=center>   Gb </TD> <TD align=center> gigabit </TD> <TD align=right> 1e9b </TD></TR>
<TR> <TD align=center>   Tb </TD> <TD align=center> terabit </TD> <TD align=right> 1e12b </TD></TR>
<TR> <TD align=center>   rad </TD> <TD align=center> radian </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   deg </TD> <TD align=center> degree </TD> <TD align=right> 0.0174533rad </TD></TR>
<TR> <TD align=center>   m </TD> <TD align=center> meter </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   mm </TD> <TD align=center> millimeter </TD> <TD align=right> 0.001m </TD></TR>
<TR> <TD align=center>   cm </TD> <TD align=center> centimeter </TD> <TD align=right> 0.01m </TD></TR>
<TR> <TD align=center>   km </TD> <TD align=center> kilometer </TD> <TD align=right> 1000m </TD></TR>
<TR> <TD align=center>   W </TD> <TD align=center> watt </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   mW </TD> <TD align=center> milliwatt </TD> <TD align=right> 0.001W </TD></TR>
<TR> <TD align=center>   uW </TD> <TD align=center> microwatt </TD> <TD align=right> 1e-6W </TD></TR>
<TR> <TD align=center>   nW </TD> <TD align=center> nanowatt </TD> <TD align=right> 1e-9W </TD></TR>
<TR> <TD align=center>   pW </TD> <TD align=center> picowatt </TD> <TD align=right> 1e-12W </TD></TR>
<TR> <TD align=center>   fW </TD> <TD align=center> femtowatt </TD> <TD align=right> 1e-15W </TD></TR>
<TR> <TD align=center>   kW </TD> <TD align=center> kilowatt </TD> <TD align=right> 1000W </TD></TR>
<TR> <TD align=center>   MW </TD> <TD align=center> megawatt </TD> <TD align=right> 1e6W </TD></TR>
<TR> <TD align=center>   GW </TD> <TD align=center> gigawatt </TD> <TD align=right> 1e9W </TD></TR>
<TR> <TD align=center>   Hz </TD> <TD align=center> hertz </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kHz </TD> <TD align=center> kilohertz </TD> <TD align=right> 1000Hz </TD></TR>
<TR> <TD align=center>   MHz </TD> <TD align=center> megahertz </TD> <TD align=right> 1e6Hz </TD></TR>
<TR> <TD align=center>   GHz </TD> <TD align=center> gigahertz </TD> <TD align=right> 1e9Hz </TD></TR>
<TR> <TD align=center>   THz </TD> <TD align=center> terahertz </TD> <TD align=right> 1e12Hz </TD></TR>
<TR> <TD align=center>   kg </TD> <TD align=center> kilogram </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   g </TD> <TD align=center> gram </TD> <TD align=right> 0.001kg </TD></TR>
<TR> <TD align=center>   K </TD> <TD align=center> kelvin </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   J </TD> <TD align=center> joule </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kJ </TD> <TD align=center> kilojoule </TD> <TD align=right> 1000J </TD></TR>
<TR> <TD align=center>   MJ </TD> <TD align=center> megajoule </TD> <TD align=right> 1e6J </TD></TR>
<TR> <TD align=center>   V </TD> <TD align=center> volt </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kV </TD> <TD align=center> kilovolt </TD> <TD align=right> 1000V </TD></TR>
<TR> <TD align=center>   mV </TD> <TD align=center> millivolt </TD> <TD align=right> 0.001V </TD></TR>
<TR> <TD align=center>   A </TD> <TD align=center> ampere </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   mA </TD> <TD align=center> milliampere </TD> <TD align=right> 0.001A </TD></TR>
<TR> <TD align=center>   uA </TD> <TD align=center> microampere </TD> <TD align=right> 1e-6A </TD></TR>
<TR> <TD align=center>   Ohm </TD> <TD align=center> ohm </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   mOhm </TD> <TD align=center> milliohm </TD> <TD align=right> 0.001Ohm </TD></TR>
<TR> <TD align=center>   kOhm </TD> <TD align=center> kiloohm </TD> <TD align=right> 1000Ohm </TD></TR>
<TR> <TD align=center>   MOhm </TD> <TD align=center> megaohm </TD> <TD align=right> 1e6Ohm </TD></TR>
<TR> <TD align=center>   mps </TD> <TD align=center> meter/sec </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kmps </TD> <TD align=center> kilometer/sec </TD> <TD align=right> 1000mps </TD></TR>
<TR> <TD align=center>   kmph </TD> <TD align=center> kilometer/hour </TD> <TD align=right> (1/3.6)mps </TD></TR>
<TR> <TD align=center>   C </TD> <TD align=center> coulomb </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   As </TD> <TD align=center> ampere-second </TD> <TD align=right> 1C </TD></TR>
<TR> <TD align=center>   mAs </TD> <TD align=center> milliampere-second </TD> <TD align=right> 0.001C </TD></TR>
<TR> <TD align=center>   Ah </TD> <TD align=center> ampere-hour </TD> <TD align=right> 3600C </TD></TR>
<TR> <TD align=center>   mAh </TD> <TD align=center> milliampere-hour </TD> <TD align=right> 3.6C </TD></TR>
<TR> <TD align=center>   ratio </TD> <TD align=center> ratio </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   pct </TD> <TD align=center> percent </TD> <TD align=right> 0.01ratio </TD></TR>
<TR> <TD align=center>   dBW </TD> <TD align=center> decibel-watt </TD> <TD align=right> 10*log10(W) </TD></TR>
<TR> <TD align=center>   dBm </TD> <TD align=center> decibel-milliwatt </TD> <TD align=right> 10*log10(mW) </TD></TR>
<TR> <TD align=center>   dBmW </TD> <TD align=center> decibel-milliwatt </TD> <TD align=right> 10*log10(mW) </TD></TR>
<TR> <TD align=center>   dBV </TD> <TD align=center> decibel-volt </TD> <TD align=right> 20*log10(V) </TD></TR>
<TR> <TD align=center>   dBmV </TD> <TD align=center> decibel-millivolt </TD> <TD align=right> 20*log10(mV) </TD></TR>
<TR> <TD align=center>   dBA </TD> <TD align=center> decibel-ampere </TD> <TD align=right> 20*log10(A) </TD></TR>
<TR> <TD align=center>   dBmA </TD> <TD align=center> decibel-milliampere </TD> <TD align=right> 20*log10(mA) </TD></TR>
<TR> <TD align=center>   dB </TD> <TD align=center> decibel </TD> <TD align=right> 20*log10(ratio) </TD></TR>
</table>

<p>

<hr class='pgbr'><h1><a name="cha:ned-language-grammar"/>20 Appendix B&#58; NED Language Grammar<a class="headerlink" href="#cha:ned-language-grammar" title="Permalink to this headline"></a></h1>

<p>This appendix contains the grammar for the NED language<!--ned!language-->.

<p>In the NED language, space, horizontal tab and new line characters count
as delimiters, so one or more of them is required between two elements of the
description which would otherwise be unseparable.

<p>'//' (two slashes) may be used to write comments that last to the end of the line.

<p>The language is fully case sensitive.

<p>Notation:
<ul>
  <li> rule syntax is that of <i>bison</i>
  <li> uppercase words are terminals, lowercase words are nonterminals
  <li> <tt>NAME</tt>, <tt>STRINGCONSTANT</tt>, <tt>INTCONSTANT</tt>,
        <tt>REALCONSTANT</tt> represent identifier names and string,
        integer and real number literals (defined as in the C language,
        except that a <tt>0</tt> prefix does not stand for octal notation)
  <li> other terminals represent keywords in all lowercase
</ul>

<p>

<pre class="verbatim">
nedfile
        : definitions
        |
        ;

definitions
        : definitions definition
        | definition
        ;

definition
        : packagedeclaration
        | import
        | propertydecl
        | fileproperty
        | channeldefinition
        | channelinterfacedefinition
        | simplemoduledefinition
        | compoundmoduledefinition
        | networkdefinition
        | moduleinterfacedefinition
        | ';'
        ;

packagedeclaration
        : PACKAGE dottedname ';'
        ;

dottedname
        : dottedname '.' NAME
        | NAME
        ;

import
        : IMPORT importspec ';'
        ;

importspec
        : importspec '.' importname
        | importname
        ;

importname
        : importname NAME
        | importname '*'
        | importname '**'
        | NAME
        | '*'
        | '**'
        ;

propertydecl
        : propertydecl_header opt_inline_properties ';'
        | propertydecl_header '(' opt_propertydecl_keys ')' opt_inline_properties ';'
        ;

propertydecl_header
        : PROPERTY '@' PROPNAME
        | PROPERTY '@' PROPNAME '[' ']'
        ;

opt_propertydecl_keys
        : propertydecl_keys
        |
        ;

propertydecl_keys
        : propertydecl_keys ';' propertydecl_key
        | propertydecl_key
        ;

propertydecl_key
        : property_literal
        ;

fileproperty
        : property_namevalue ';'
        ;

channeldefinition
        : channelheader '{'
            opt_paramblock
          '}'
        ;

channelheader
        : CHANNEL NAME
           opt_inheritance
        ;

opt_inheritance
        :
        | EXTENDS extendsname
        | LIKE likenames
        | EXTENDS extendsname LIKE likenames
        ;

extendsname
        : dottedname
        ;

likenames
        : likenames ',' likename
        | likename
        ;

likename
        : dottedname
        ;

channelinterfacedefinition
        : channelinterfaceheader '{'
            opt_paramblock
          '}'
        ;

channelinterfaceheader
        : CHANNELINTERFACE NAME
           opt_interfaceinheritance
        ;

opt_interfaceinheritance
        : EXTENDS extendsnames
        |
        ;

extendsnames
        : extendsnames ',' extendsname
        | extendsname
        ;

simplemoduledefinition
        : simplemoduleheader '{'
            opt_paramblock
            opt_gateblock
          '}'
        ;

simplemoduleheader
        : SIMPLE NAME
          opt_inheritance
        ;

compoundmoduledefinition
        : compoundmoduleheader '{'
            opt_paramblock
            opt_gateblock
            opt_typeblock
            opt_submodblock
            opt_connblock
          '}'
        ;

compoundmoduleheader
        : MODULE NAME
          opt_inheritance
        ;

networkdefinition
        : networkheader '{'
            opt_paramblock
            opt_gateblock
            opt_typeblock
            opt_submodblock
            opt_connblock
          '}'
        ;

networkheader
        : NETWORK NAME
          opt_inheritance
        ;

moduleinterfacedefinition
        : moduleinterfaceheader '{'
            opt_paramblock
            opt_gateblock
          '}'
        ;

moduleinterfaceheader
        : MODULEINTERFACE NAME
           opt_interfaceinheritance
        ;

opt_paramblock
        : opt_params
        | PARAMETERS ':'
          opt_params
        ;

opt_params
        : params
        |
        ;

params
        : params paramsitem
        | paramsitem
        ;

paramsitem
        : param
        | property
        ;

param
        : param_typenamevalue
        | pattern_value
        ;

param_typenamevalue
        : param_typename opt_inline_properties ';'
        | param_typename opt_inline_properties '=' paramvalue opt_inline_properties ';'
        ;

param_typename
        : opt_volatile paramtype NAME
        | NAME
        ;

pattern_value
        : pattern '=' paramvalue ';'
        ;

paramtype
        : DOUBLE
        | INT
        | STRING
        | BOOL
        | XML
        ;

opt_volatile
        : VOLATILE
        |
        ;

paramvalue
        : expression
        | DEFAULT '(' expression ')'
        | DEFAULT
        | ASK
        ;

opt_inline_properties
        : inline_properties
        |
        ;

inline_properties
        : inline_properties property_namevalue
        | property_namevalue
        ;

pattern
        : pattern2 '.' pattern_elem
        | pattern2 '.' TYPENAME
        ;

pattern2
        : pattern2 '.' pattern_elem
        | pattern_elem
        ;

pattern_elem
        : pattern_name
        | pattern_name '[' pattern_index ']'
        | pattern_name '[' '*' ']'
        | '**'
        ;

pattern_name
        : NAME
        | NAME '$' NAME
        | CHANNEL
        | '{' pattern_index '}'
        | '*'
        | pattern_name NAME
        | pattern_name '{' pattern_index '}'
        | pattern_name '*'
        ;

pattern_index
        : INTCONSTANT
        | INTCONSTANT '..' INTCONSTANT
        | '..' INTCONSTANT
        | INTCONSTANT '..'
        ;

property
        : property_namevalue ';'
        ;

property_namevalue
        : property_name
        | property_name '(' opt_property_keys ')'
        ;

property_name
        : '@' PROPNAME
        | '@' PROPNAME '[' PROPNAME ']'
        ;

opt_property_keys
        : property_keys
        ;

property_keys
        : property_keys ';' property_key
        | property_key
        ;

property_key
        : property_literal '=' property_values
        | property_values
        ;

property_values
        : property_values ',' property_value
        | property_value
        ;

property_value
        : property_literal
        |
        ;

property_literal
        : property_literal CHAR
        | property_literal STRINGCONSTANT
        | CHAR
        | STRINGCONSTANT
        ;

opt_gateblock
        : gateblock
        |
        ;

gateblock
        : GATES ':'
          opt_gates
        ;

opt_gates
        : gates
        |
        ;

gates
        : gates gate
        | gate
        ;

gate
        : gate_typenamesize
          opt_inline_properties ';'
        ;

gate_typenamesize
        : gatetype NAME
        | gatetype NAME '[' ']'
        | gatetype NAME vector
        | NAME
        | NAME '[' ']'
        | NAME vector
        ;

gatetype
        : INPUT
        | OUTPUT
        | INOUT
        ;

opt_typeblock
        : typeblock
        |
        ;

typeblock
        : TYPES ':'
           opt_localtypes
        ;

opt_localtypes
        : localtypes
        |
        ;

localtypes
        : localtypes localtype
        | localtype
        ;

localtype
        : propertydecl
        | channeldefinition
        | channelinterfacedefinition
        | simplemoduledefinition
        | compoundmoduledefinition
        | networkdefinition
        | moduleinterfacedefinition
        | ';'
        ;

opt_submodblock
        : submodblock
        |
        ;

submodblock
        : SUBMODULES ':'
          opt_submodules
        ;

opt_submodules
        : submodules
        |
        ;

submodules
        : submodules submodule
        | submodule
        ;

submodule
        : submoduleheader ';'
        | submoduleheader '{'
          opt_paramblock
          opt_gateblock
          '}' opt_semicolon
        ;

submoduleheader
        : submodulename ':' dottedname opt_condition
        | submodulename ':' likeexpr LIKE dottedname opt_condition
        ;

submodulename
        : NAME
        |  NAME vector
        ;

likeexpr
        : '&lt;' '&gt;'
        | '&lt;' expression '&gt;'
        | '&lt;' DEFAULT '(' expression ')' '&gt;'
        ;

opt_condition
        : condition
        |
        ;

opt_connblock
        : connblock
        |
        ;

connblock
        : CONNECTIONS ALLOWUNCONNECTED ':'
          opt_connections
        | CONNECTIONS ':'
          opt_connections
        ;

opt_connections
        : connections
        |
        ;

connections
        : connections connectionsitem
        | connectionsitem
        ;

connectionsitem
        : connectiongroup
        | connection opt_loops_and_conditions ';'
        ;

connectiongroup
        : opt_loops_and_conditions '{'
          connections '}' opt_semicolon
        ;

opt_loops_and_conditions
        : loops_and_conditions
        |
        ;

loops_and_conditions
        : loops_and_conditions ',' loop_or_condition
        | loop_or_condition
        ;

loop_or_condition
        : loop
        | condition
        ;

loop
        : FOR NAME '=' expression '..' expression
        ;

connection
        : leftgatespec '--&gt;' rightgatespec
        | leftgatespec '--&gt;' channelspec '--&gt;' rightgatespec
        | leftgatespec '&lt;--' rightgatespec
        | leftgatespec '&lt;--' channelspec '&lt;--' rightgatespec
        | leftgatespec '&lt;--&gt;' rightgatespec
        | leftgatespec '&lt;--&gt;' channelspec '&lt;--&gt;' rightgatespec
        ;

leftgatespec
        : leftmod '.' leftgate
        | parentleftgate
        ;

leftmod
        : NAME vector
        | NAME
        ;

leftgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

parentleftgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

rightgatespec
        : rightmod '.' rightgate
        | parentrightgate
        ;

rightmod
        : NAME
        | NAME vector
        ;

rightgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

parentrightgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

opt_subgate
        : '$' NAME
        |
        ;

channelspec
        : channelspec_header
        | channelspec_header '{'
            opt_paramblock
          '}'
        ;

channelspec_header
        : opt_channelname
        | opt_channelname dottedname
        | opt_channelname likeexpr LIKE dottedname
        ;

opt_channelname
        :
        | NAME ':'
        ;

condition
        : IF expression
        ;

vector
        : '[' expression ']'
        ;

expression
        :
          expr
        ;

expr
        : simple_expr
        | '(' expr ')'
        | CONST '(' expr ')'
        | expr '+' expr
        | expr '-' expr
        | expr '*' expr
        | expr '/' expr
        | expr '%' expr
        | expr '^' expr
        | '-' expr
        | expr '==' expr
        | expr '!=' expr
        | expr '&gt;' expr
        | expr '&gt;=' expr
        | expr '&lt;' expr
        | expr '&lt;=' expr
        | expr '&&' expr
        | expr '||' expr
        | expr '##' expr
        | '!' expr
        | expr '&' expr
        | expr '|' expr
        | expr '#' expr
        | '~' expr
        | expr '&lt;&lt;' expr
        | expr '&gt;&gt;' expr
        | expr '?' expr ':' expr
        | INT '(' expr ')'
        | DOUBLE '(' expr ')'
        | STRING '(' expr ')'
        | funcname '(' ')'
        | funcname '(' expr ')'
        | funcname '(' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        ;

simple_expr
        : identifier
        | operator
        | literal
        ;

funcname
        : NAME
        | XMLDOC
        | XML
        ;

identifier
        : NAME
        | THIS '.' NAME
        | NAME '.' NAME
        | NAME '[' expr ']' '.' NAME
        ;

operator
        : INDEX
        | INDEX '(' ')'
        | EXISTS '(' identifier ')'
        | SIZEOF '(' identifier ')'
        | TYPENAME
        ;

literal
        : stringliteral
        | boolliteral
        | numliteral
        ;

stringliteral
        : STRINGCONSTANT
        ;

boolliteral
        : TRUE
        | FALSE
        ;

numliteral
        : INTCONSTANT
        | realconstant_ext
        | quantity
        ;

quantity
        : quantity INTCONSTANT NAME
        | quantity realconstant_ext NAME
        | INTCONSTANT NAME
        | realconstant_ext NAME
        ;

realconstant_ext
        : REALCONSTANT
        | INF
        | NAN
        ;

opt_semicolon
        : ';'
        |
        ;
</pre>

<p>
<hr class='pgbr'><h1><a name="cha:ned-xml-binding"/>21 Appendix C&#58; NED XML Binding<a class="headerlink" href="#cha:ned-xml-binding" title="Permalink to this headline"></a></h1>

<p>This appendix shows the DTD for the XML binding of the NED language and
message definitions.


<pre class="verbatim">
&lt;!ELEMENT files ((ned-file|msg-file)*)&gt;

&lt;!--
  **  NED-2.
  --&gt;

&lt;!ELEMENT ned-file (comment*, (package|import|property-decl|property|
                    simple-module|compound-module|module-interface|
                    channel|channel-interface)*)&gt;
&lt;!ATTLIST ned-file
     filename           CDATA     #REQUIRED
     version            CDATA     "2"&gt;

&lt;!-- comments and whitespace; comments include '//' marks. Note that although
     nearly all elements may contain comment elements, there are places
     (e.g. within expressions) where they are ignored by the implementation.
     Default value is a space or a newline, depending on the context.
 --&gt;
&lt;!ELEMENT comment EMPTY&gt;
&lt;!ATTLIST comment
     locid              NMTOKEN   #REQUIRED
     content            CDATA     #IMPLIED&gt;

&lt;!ELEMENT package (comment*)&gt;
&lt;!ATTLIST package
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT import (comment*)&gt;
&lt;!ATTLIST import
     import-spec        CDATA     #REQUIRED&gt;

&lt;!ELEMENT property-decl (comment*, property-key*, property*)&gt;
&lt;!ATTLIST property-decl
     name               NMTOKEN   #REQUIRED
     is-array           (true|false) "false"&gt;

&lt;!ELEMENT extends (comment*)&gt;
&lt;!ATTLIST extends
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT interface-name (comment*)&gt;
&lt;!ATTLIST interface-name
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT simple-module (comment*, extends?, interface-name*, parameters?, gates?)&gt;
&lt;!ATTLIST simple-module
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT module-interface (comment*, extends*, parameters?, gates?)&gt;
&lt;!ATTLIST module-interface
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT compound-module (comment*, extends?, interface-name*,
                           parameters?, gates?, types?, submodules?, connections?)&gt;
&lt;!ATTLIST compound-module
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT channel-interface (comment*, extends*, parameters?)&gt;
&lt;!ATTLIST channel-interface
     name                NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT channel (comment*, extends?, interface-name*, parameters?)&gt;
&lt;!ATTLIST channel
     name                NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT parameters (comment*, (property|param)*)&gt;
&lt;!ATTLIST parameters
    is-implicit         (true|false)  "false"&gt;

&lt;!ELEMENT param (comment*, expression?, property*)&gt;
&lt;!ATTLIST param
     type               (double|int|string|bool|xml) #IMPLIED
     is-volatile        (true|false)  "false"
     name               CDATA     #REQUIRED
     value              CDATA     #IMPLIED
     is-pattern         (true|false)  "false"
     is-default         (true|false)  "false"&gt;

&lt;!ELEMENT property (comment*, property-key*)&gt;
&lt;!ATTLIST property
     is-implicit        (true|false) "false"
     name               NMTOKEN   #REQUIRED
     index              NMTOKEN   #IMPLIED&gt;

&lt;!ELEMENT property-key (comment*, literal*)&gt;
&lt;!ATTLIST property-key
     name               CDATA     #IMPLIED&gt;

&lt;!ELEMENT gates (comment*, gate*)&gt;

&lt;!ELEMENT gate (comment*, expression?, property*)&gt;
&lt;!ATTLIST gate
     name               NMTOKEN   #REQUIRED
     type               (input|output|inout) #IMPLIED
     is-vector          (true|false) "false"
     vector-size        CDATA     #IMPLIED&gt;

&lt;!ELEMENT types (comment*, (channel|channel-interface|simple-module|
                               compound-module|module-interface)*)&gt;

&lt;!ELEMENT submodules (comment*, submodule*)&gt;

&lt;!ELEMENT submodule (comment*, expression*, condition?, parameters?, gates?)&gt;
&lt;!ATTLIST submodule
     name               NMTOKEN   #REQUIRED
     type               CDATA     #IMPLIED
     like-type          CDATA     #IMPLIED
     like-expr          CDATA     #IMPLIED
     is-default         (true|false) "false"
     vector-size        CDATA     #IMPLIED&gt;

&lt;!ELEMENT connections (comment*, (connection|connection-group)*)&gt;
&lt;!ATTLIST connections
     allow-unconnected (true|false) "false"&gt;

&lt;!ELEMENT connection (comment*, expression*, parameters?, (loop|condition)*)&gt;
&lt;!ATTLIST connection
     src-module          NMTOKEN   #IMPLIED
     src-module-index    CDATA     #IMPLIED
     src-gate            NMTOKEN   #REQUIRED
     src-gate-plusplus  (true|false) "false"
     src-gate-index      CDATA     #IMPLIED
     src-gate-subg       (i|o)     #IMPLIED
     dest-module         NMTOKEN   #IMPLIED
     dest-module-index   CDATA     #IMPLIED
     dest-gate           NMTOKEN   #REQUIRED
     dest-gate-plusplus (true|false) "false"
     dest-gate-index     CDATA     #IMPLIED
     dest-gate-subg      (i|o)     #IMPLIED
     name                NMTOKEN   #IMPLIED
     type                CDATA     #IMPLIED
     like-type           CDATA     #IMPLIED
     like-expr           CDATA     #IMPLIED
     is-default         (true|false) "false"
     is-bidirectional   (true|false) "false"
     is-forward-arrow   (true|false) "true"&gt;

&lt;!ELEMENT connection-group (comment*, (loop|condition)*, connection*)&gt;

&lt;!ELEMENT loop (comment*, expression*)&gt;
&lt;!ATTLIST loop
     param-name          NMTOKEN   #REQUIRED
     from-value          CDATA     #IMPLIED
     to-value            CDATA     #IMPLIED&gt;

&lt;!ELEMENT condition (comment*, expression?)&gt;
&lt;!ATTLIST condition
     condition           CDATA     #IMPLIED&gt;

&lt;!--
  **  Expressions
  --&gt;

&lt;!ELEMENT expression (comment*, (operator|function|ident|literal))&gt;
&lt;!ATTLIST expression
     target              CDATA     #IMPLIED&gt;

&lt;!ELEMENT operator (comment*, (operator|function|ident|literal)+)&gt;
&lt;!ATTLIST operator
     name                CDATA     #REQUIRED&gt;

&lt;!-- functions, "index", "const" and "sizeof" --&gt;
&lt;!ELEMENT function (comment*, (operator|function|ident|literal)*)&gt;
&lt;!ATTLIST function
     name                NMTOKEN   #REQUIRED&gt;

&lt;!-- Ident is either a parameter reference or an argument for the "sizeof"
     operator; its NED source form is one of the following: "name", "module.name",
     "module[n].name". If there is a child, it represents the module index n.
     A reserved module name (with special meaning) is "this".
--&gt;
&lt;!ELEMENT ident (comment*, (operator|function|ident|literal)?)&gt;
&lt;!ATTLIST ident
     module              CDATA     #IMPLIED
     name                NMTOKEN   #REQUIRED&gt;


&lt;!ELEMENT literal (comment*)&gt;
&lt;!-- Note: value is in fact REQUIRED, but empty attr value should
     also be accepted because that represents the "" string literal;
     "spec" is for properties, to store the null value and "-",
     the antivalue. Unit can only be present with "double".
 --&gt;
&lt;!ATTLIST literal
     type  (double|int|string|bool|spec)  #REQUIRED
     unit                CDATA     #IMPLIED
     text                CDATA     #IMPLIED
     value               CDATA     #IMPLIED&gt;

&lt;!--**********************************************************************--&gt;

&lt;!--
**
** OMNeT++/OMNEST Message Definitions (MSG)
**
--&gt;

&lt;!ELEMENT msg-file (comment*, (namespace|property-decl|property|cplusplus|
                    struct-decl|class-decl|message-decl|packet-decl|enum-decl|
                    struct|class|message|packet|enum)*)&gt;

&lt;!ATTLIST msg-file
     filename            CDATA     #IMPLIED
     version             CDATA     "2"&gt;

&lt;!ELEMENT namespace (comment*)&gt;
&lt;!ATTLIST namespace
     name                CDATA     #REQUIRED&gt;  &lt;!-- note: not NMTOKEN because it may contain "::" --&gt;

&lt;!ELEMENT cplusplus (comment*)&gt;
&lt;!ATTLIST cplusplus
     body                CDATA     #REQUIRED&gt;

&lt;!-- C++ type announcements --&gt;

&lt;!ELEMENT struct-decl (comment*)&gt;
&lt;!ATTLIST struct-decl
     name                CDATA     #REQUIRED&gt;

&lt;!ELEMENT class-decl (comment*)&gt;
&lt;!ATTLIST class-decl
     name                CDATA     #REQUIRED
     is-cobject      (true|false)  "false"
     extends-name        CDATA     #IMPLIED&gt;

&lt;!ELEMENT message-decl (comment*)&gt;
&lt;!ATTLIST message-decl
     name                CDATA     #REQUIRED&gt;

&lt;!ELEMENT packet-decl (comment*)&gt;
&lt;!ATTLIST packet-decl
     name                CDATA     #REQUIRED&gt;

&lt;!ELEMENT enum-decl (comment*)&gt;
&lt;!ATTLIST enum-decl
     name                CDATA     #REQUIRED&gt;

&lt;!-- Enums --&gt;

&lt;!ELEMENT enum (comment*, enum-fields?)&gt;
&lt;!ATTLIST enum
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT enum-fields (comment*, enum-field*)&gt;

&lt;!ELEMENT enum-field (comment*)&gt;
&lt;!ATTLIST enum-field
     name                NMTOKEN   #REQUIRED
     value               CDATA     #IMPLIED&gt;

&lt;!-- Message, class, struct --&gt;

&lt;!ELEMENT message (comment*, (property|field)*)&gt;
&lt;!ATTLIST message
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT packet (comment*, (property|field)*)&gt;
&lt;!ATTLIST packet
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT class (comment*, (property|field)*)&gt;
&lt;!ATTLIST class
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT struct (comment*, (property|field)*)&gt;
&lt;!ATTLIST struct
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT field (comment*, property*)&gt;
&lt;!ATTLIST field
     name                NMTOKEN   #REQUIRED
     data-type           CDATA     #IMPLIED
     is-abstract     (true|false)  "false"
     is-readonly     (true|false)  "false"
     is-vector       (true|false)  "false"
     vector-size         CDATA     #IMPLIED
     default-value       CDATA     #IMPLIED&gt;

&lt;!--
  **  'unknown' is used internally to represent elements not in this NED DTD
  --&gt;
&lt;!ELEMENT unknown        ANY&gt;
&lt;!ATTLIST unknown
     element             CDATA     #REQUIRED&gt;
</pre>
<p>

<hr class='pgbr'><h1><a name="cha:ned-functions"/>22 Appendix D&#58; NED Functions<a class="headerlink" href="#cha:ned-functions" title="Permalink to this headline"></a></h1>

<p>The functions that can be used in NED expressions and ini files are the
following. The question mark (as in &#8220;<tt>rng?</tt>&#8221;) marks optional arguments.


<h2><a name="sec:ned-functions:category-conversion"/>22.1 Category "conversion":<a class="headerlink" href="#sec:ned-functions:category-conversion" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>double</b> : <tt>quantity double(any x)</tt> <br>
    Converts x to double, and returns the result. A boolean argument becomes 0 or 1; a string is interpreted as number; an XML argument causes an error. Units are preserved.
<li><b>int</b> : <tt>intquantity int(any x)</tt> <br>
    Converts x to int, and returns the result. A boolean argument becomes 0 or 1; a double is converted using floor(); a string is interpreted as number; an XML argument causes an error. Units are preserved.
<li><b>string</b> : <tt>string string(any x)</tt> <br>
    Converts x to string, and returns the result.

<p></ul>

<p><h2><a name="sec:ned-functions:category-math"/>22.2 Category "math":<a class="headerlink" href="#sec:ned-functions:category-math" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>acos</b> : <tt>double acos(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>asin</b> : <tt>double asin(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>atan</b> : <tt>double atan(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>atan2</b> : <tt>double atan2(double, double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>ceil</b> : <tt>double ceil(double)</tt> <br>
    Rounds down; see standard C function of the same name
<li><b>cos</b> : <tt>double cos(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>exp</b> : <tt>double exp(double)</tt> <br>
    Exponential; see standard C function of the same name
<li><b>fabs</b> : <tt>quantity fabs(quantity x)</tt> <br>
    Returns the absolute value of the quantity.
<li><b>floor</b> : <tt>double floor(double)</tt> <br>
    Rounds up; see standard C function of the same name
<li><b>fmod</b> : <tt>quantity fmod(quantity x, quantity y)</tt> <br>
    Returns the floating-point remainder of x/y; unit conversion takes place if needed.
<li><b>hypot</b> : <tt>double hypot(double, double)</tt> <br>
    Length of the hypotenuse; see standard C function of the same name
<li><b>log</b> : <tt>double log(double)</tt> <br>
    Natural logarithm; see standard C function of the same name
<li><b>log10</b> : <tt>double log10(double)</tt> <br>
    Base-10 logarithm; see standard C function of the same name
<li><b>max</b> : <tt>quantity max(quantity a, quantity b)</tt> <br>
    Returns the greater one of the two quantities; unit conversion takes place if needed.
<li><b>min</b> : <tt>quantity min(quantity a, quantity b)</tt> <br>
    Returns the smaller one of the two quantities; unit conversion takes place if needed.
<li><b>pow</b> : <tt>double pow(double, double)</tt> <br>
    Power; see standard C function of the same name
<li><b>sin</b> : <tt>double sin(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>sqrt</b> : <tt>double sqrt(double)</tt> <br>
    Square root; see standard C function of the same name
<li><b>tan</b> : <tt>double tan(double)</tt> <br>
    Trigonometric function; see standard C function of the same name

<p></ul>

<p><h2><a name="sec:ned-functions:category-misc"/>22.3 Category "misc":<a class="headerlink" href="#sec:ned-functions:category-misc" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>firstAvailable</b> : <tt>string firstAvailable(...)</tt> <br>
    Accepts any number of strings, interprets them as NED type names (qualified or unqualified), and returns the first one that exists and its C++ implementation class is also available. Throws an error if none of the types are available.
<li><b>select</b> : <tt>any select(int index, ...)</tt> <br>
    Returns the &lt;index&gt;th item from the rest of the argument list; numbering starts from 0.
<li><b>simTime</b> : <tt>quantity simTime()</tt> <br>
    Returns the current simulation time.
</ul>

<p><h2><a name="sec:ned-functions:category-ned"/>22.4 Category "ned":<a class="headerlink" href="#sec:ned-functions:category-ned" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>ancestorIndex</b> : <tt>int ancestorIndex(int numLevels)</tt> <br>
    Returns the index of the ancestor module numLevels levels above the module or channel in context.
<li><b>fullName</b> : <tt>string fullName()</tt> <br>
    Returns the full name of the module or channel in context.
<li><b>fullPath</b> : <tt>string fullPath()</tt> <br>
    Returns the full path of the module or channel in context.
<li><b>parentIndex</b> : <tt>int parentIndex()</tt> <br>
    Returns the index of the parent module, which has to be part of module vector.

<p></ul>

<p><h2><a name="sec:ned-functions:category-random-continuous"/>22.5 Category "random/continuous":<a class="headerlink" href="#sec:ned-functions:category-random-continuous" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>beta</b> : <tt>double beta(double alpha1, double alpha2, int rng?)</tt> <br>
    Returns a random number from the Beta distribution
<li><b>cauchy</b> : <tt>quantity cauchy(quantity a, quantity b, int rng?)</tt> <br>
    Returns a random number from the Cauchy distribution
<li><b>chi_square</b> : <tt>double chi_square(int k, int rng?)</tt> <br>
    Returns a random number from the Chi-square distribution
<li><b>erlang_k</b> : <tt>quantity erlang_k(int k, quantity mean, int rng?)</tt> <br>
    Returns a random number from the Erlang distribution
<li><b>exponential</b> : <tt>quantity exponential(quantity mean, int rng?)</tt> <br>
    Returns a random number from the Exponential distribution
<li><b>gamma_d</b> : <tt>quantity gamma_d(double alpha, quantity theta, int rng?)</tt> <br>
    Returns a random number from the Gamma distribution
<li><b>lognormal</b> : <tt>double lognormal(double m, double w, int rng?)</tt> <br>
    Returns a random number from the Lognormal distribution
<li><b>normal</b> : <tt>quantity normal(quantity mean, quantity stddev, int rng?)</tt> <br>
    Returns a random number from the Normal distribution
<li><b>pareto_shifted</b> : <tt>quantity pareto_shifted(double a, quantity b, quantity c, int rng?)</tt> <br>
    Returns a random number from the Pareto-shifted distribution
<li><b>student_t</b> : <tt>double student_t(int i, int rng?)</tt> <br>
    Returns a random number from the Student-t distribution
<li><b>triang</b> : <tt>quantity triang(quantity a, quantity b, quantity c, int rng?)</tt> <br>
    Returns a random number from the Triangular distribution
<li><b>truncnormal</b> : <tt>quantity truncnormal(quantity mean, quantity stddev, int rng?)</tt> <br>
    Returns a random number from the truncated Normal distribution
<li><b>uniform</b> : <tt>quantity uniform(quantity a, quantity b, int rng?)</tt> <br>
    Returns a random number from the Uniform distribution
<li><b>weibull</b> : <tt>quantity weibull(quantity a, quantity b, int rng?)</tt> <br>
    Returns a random number from the Weibull distribution

<p></ul>

<p><h2><a name="sec:ned-functions:category-random-discrete"/>22.6 Category "random/discrete":<a class="headerlink" href="#sec:ned-functions:category-random-discrete" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>bernoulli</b> : <tt>int bernoulli(double p, int rng?)</tt> <br>
    Returns a random number from the Bernoulli distribution
<li><b>binomial</b> : <tt>int binomial(int n, double p, int rng?)</tt> <br>
    Returns a random number from the Binomial distribution
<li><b>geometric</b> : <tt>int geometric(double p, int rng?)</tt> <br>
    Returns a random number from the Geometric distribution
<li><b>intuniform</b> : <tt>int intuniform(intquantity a, intquantity b, int rng?)</tt> <br>
    Returns a random integer uniformly distributed over [a, b]
<li><b>negbinomial</b> : <tt>int negbinomial(int n, double p, int rng?)</tt> <br>
    Returns a random number from the Negbinomial distribution
<li><b>poisson</b> : <tt>int poisson(double lambda, int rng?)</tt> <br>
    Returns a random number from the Poisson distribution

<p></ul>

<p><h2><a name="sec:ned-functions:category-strings"/>22.7 Category "strings":<a class="headerlink" href="#sec:ned-functions:category-strings" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>choose</b> : <tt>string choose(int index, string list)</tt> <br>
    Interprets list as a space-separated list, and returns the item at the given index. Negative and out-of-bounds indices cause an error.
<li><b>contains</b> : <tt>bool contains(string s, string substr)</tt> <br>
    Returns true if string s contains substr as substring
<li><b>endsWith</b> : <tt>bool endsWith(string s, string substr)</tt> <br>
    Returns true if s ends with the substring substr.
<li><b>expand</b> : <tt>string expand(string s)</tt> <br>
    Expands $ variables ($configname, $runnumber, etc.) in the given string, and returns the result.
<li><b>indexOf</b> : <tt>int indexOf(string s, string substr)</tt> <br>
    Returns the position of the first occurrence of substring substr in s, or -1 if s does not contain substr.
<li><b>length</b> : <tt>int length(string s)</tt> <br>
    Returns the length of the string
<li><b>replace</b> : <tt>string replace(string s, string substr, string repl, int startPos?)</tt> <br>
    Replaces all occurrences of substr in s with the string repl. If startPos is given, search begins from position startPos in s.
<li><b>replaceFirst</b> : <tt>string replaceFirst(string s, string substr, string repl, int startPos?)</tt> <br>
    Replaces the first occurrence of substr in s with the string repl. If startPos is given, search begins from position startPos in s.
<li><b>startsWith</b> : <tt>bool startsWith(string s, string substr)</tt> <br>
    Returns true if s begins with the substring substr.
<li><b>substring</b> : <tt>string substring(string s, int pos, int len?)</tt> <br>
    Return the substring of s starting at the given position, either to the end of the string or maximum len characters
<li><b>substringAfter</b> : <tt>string substringAfter(string s, string substr)</tt> <br>
    Returns the substring of s after the first occurrence of substr, or the empty string if s does not contain substr.
<li><b>substringAfterLast</b> : <tt>string substringAfterLast(string s, string substr)</tt> <br>
    Returns the substring of s after the last occurrence of substr, or the empty string if s does not contain substr.
<li><b>substringBefore</b> : <tt>string substringBefore(string s, string substr)</tt> <br>
    Returns the substring of s before the first occurrence of substr, or the empty string if s does not contain substr.
<li><b>substringBeforeLast</b> : <tt>string substringBeforeLast(string s, string substr)</tt> <br>
    Returns the substring of s before the last occurrence of substr, or the empty string if s does not contain substr.
<li><b>tail</b> : <tt>string tail(string s, int len)</tt> <br>
    Returns the last len character of s, or the full s if it is shorter than len characters.
<li><b>toLower</b> : <tt>string toLower(string s)</tt> <br>
    Converts s to all lowercase, and returns the result.
<li><b>toUpper</b> : <tt>string toUpper(string s)</tt> <br>
    Converts s to all uppercase, and returns the result.
<li><b>trim</b> : <tt>string trim(string s)</tt> <br>
    Discards whitespace from the start and end of s, and returns the result.

<p></ul>

<p><h2><a name="sec:ned-functions:category-units"/>22.8 Category "units":<a class="headerlink" href="#sec:ned-functions:category-units" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>convertUnit</b> : <tt>quantity convertUnit(quantity x, string unit)</tt> <br>
    Converts x to the given unit.
<li><b>dropUnit</b> : <tt>double dropUnit(quantity x)</tt> <br>
    Removes the unit of measurement from quantity x.
<li><b>replaceUnit</b> : <tt>quantity replaceUnit(quantity x, string unit)</tt> <br>
    Replaces the unit of x with the given unit.
<li><b>unitOf</b> : <tt>string unitOf(quantity x)</tt> <br>
    Returns the unit of the given quantity.

<p></ul>

<p><h2><a name="sec:ned-functions:category-units-conversion"/>22.9 Category "units/conversion":<a class="headerlink" href="#sec:ned-functions:category-units-conversion" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>A</b> : <tt>quantity A(quantity x)</tt> <br>
    Converts to A (ampere) from a compatible unit or a dimensionless number.
<li><b>Ah</b> : <tt>quantity Ah(quantity x)</tt> <br>
    Converts to Ah (ampere-hour) from a compatible unit or a dimensionless number.
<li><b>As</b> : <tt>quantity As(quantity x)</tt> <br>
    Converts to As (ampere-second) from a compatible unit or a dimensionless number.
<li><b>B</b> : <tt>quantity B(quantity x)</tt> <br>
    Converts to B (byte) from a compatible unit or a dimensionless number.
<li><b>C</b> : <tt>quantity C(quantity x)</tt> <br>
    Converts to C (coulomb) from a compatible unit or a dimensionless number.
<li><b>GB</b> : <tt>quantity GB(quantity x)</tt> <br>
    Converts to GB (gigabyte) from a compatible unit or a dimensionless number.
<li><b>GHz</b> : <tt>quantity GHz(quantity x)</tt> <br>
    Converts to GHz (gigahertz) from a compatible unit or a dimensionless number.
<li><b>etc.</b> 
</ul>

<p>A similar NED function exists for all registered measurement units.
Units are listed in section <a href="#sec:ned-ref:units">[19.5.9]</a>.

<p>
<h2><a name="sec:ned-functions:category-xml"/>22.10 Category "xml":<a class="headerlink" href="#sec:ned-functions:category-xml" title="Permalink to this headline"></a></h2>

<p><ul class="dl">
<li><b>xml</b> : <tt>xml xml(string xmlstring, string xpath?)</tt> <br>
    Parses the given XML string into a <a href="../api/classomnetpp_1_1cXMLElement.html">cXMLElement</a> tree, and returns the root element. When called with two arguments, it returns the first element from the tree that matches the expression given in simplified XPath syntax.
<li><b>xmldoc</b> : <tt>xml xmldoc(string filename, string xpath?)</tt> <br>
    Parses the given XML file into a <a href="../api/classomnetpp_1_1cXMLElement.html">cXMLElement</a> tree, and returns the root element. When called with two arguments, it returns the first element from the tree that matches the expression given in simplified XPath syntax.
</ul>

<hr class='pgbr'><h1><a name="cha:msg-language-grammar"/>23 Appendix E&#58; Message Definitions Grammar<a class="headerlink" href="#cha:msg-language-grammar" title="Permalink to this headline"></a></h1>

<p>This appendix contains the grammar for the message definitions
language.

<p>In the language, space, horizontal tab and new line characters count
as delimiters, so one or more of them is required between two elements of the
description which would otherwise be unseparable.

<p>'//' (two slashes) may be used to write comments that last to the end of the line.

<p>The language is fully case sensitive.

<p>Notation:
<ul>
  <li> rule syntax is that of <i>bison</i>
  <li> uppercase words are terminals, lowercase words are nonterminals
  <li> <tt>NAME</tt>, <tt>CHARCONSTANT</tt>, <tt>STRINGCONSTANT</tt>, <tt>INTCONSTANT</tt>,
        <tt>REALCONSTANT</tt> represent identifier names and string, character,
        integer and real number literals (defined as in the C language)
  <li> other terminals represent keywords in all lowercase
</ul>

<p>Nonterminals ending in <tt>_old</tt> are present so that message files
from OMNeT++ (3.x) can be parsed.


<pre class="verbatim">
msgfile
        : definitions
        ;

definitions
        : definitions definition
        |
        ;

definition
        : namespace_decl
        | fileproperty
        | cplusplus
        | struct_decl
        | class_decl
        | message_decl
        | packet_decl
        | enum_decl
        | enum
        | message
        | packet
        | class
        | struct
        ;

namespace_decl
        : NAMESPACE qname0 ';'

qname0
        : qname0 DOUBLECOLON NAME
        | NAME
        ;

qname
        : DOUBLECOLON qname0
        | qname0
        ;

fileproperty
        : property_namevalue ';'
        ;

cplusplus
        : CPLUSPLUS '{{' ... '}}' opt_semicolon
        ;

struct_decl
        : STRUCT qname ';'
        ;

class_decl
        : CLASS qname ';'
        | CLASS NONCOBJECT qname ';'
        | CLASS qname EXTENDS qname ';'
        ;

message_decl
        : MESSAGE qname ';'
        ;

packet_decl
        : PACKET qname ';'
        ;

enum_decl
        : ENUM qname ';'
        ;

enum
        : ENUM qname '{'
          opt_enumfields '}' opt_semicolon
        ;

opt_enumfields
        : enumfields
        |
        ;

enumfields
        : enumfields enumfield
        | enumfield
        ;

enumfield
        : NAME ';'
        | NAME '=' enumvalue ';'
        ;

message
        : message_header body
        ;

packet
        : packet_header body
        ;

class
        : class_header body
        ;

struct
        : struct_header body
        ;

message_header
        : MESSAGE qname '{'
        | MESSAGE qname EXTENDS qname '{'
        ;

packet_header
        : PACKET qname '{'
        | PACKET qname EXTENDS qname '{'
        ;

class_header
        : CLASS qname '{'
        | CLASS qname EXTENDS qname '{'
        ;

struct_header
        : STRUCT qname '{'
        | STRUCT qname EXTENDS qname '{'
        ;

body
        : opt_fields_and_properties
          '}' opt_semicolon
        ;

opt_fields_and_properties
        : fields_and_properties
        |
        ;

fields_and_properties
        : fields_and_properties field
        | fields_and_properties property
        | field
        | property
        ;

field
        :  fieldtypename opt_fieldvector opt_inline_properties ';'
        |  fieldtypename opt_fieldvector opt_inline_properties '=' fieldvalue opt_inline_properties ';'
        ;

fieldtypename
        : fieldmodifiers fielddatatype NAME
        | fieldmodifiers NAME
        ;

fieldmodifiers
        : ABSTRACT
        | READONLY
        | ABSTRACT READONLY
        | READONLY ABSTRACT
        |
        ;

fielddatatype
        : fieldsimpledatatype
        | fieldsimpledatatype '*'
        ;

fieldsimpledatatype
        : qname
        | CHAR
        | SHORT
        | INT
        | LONG
        | UNSIGNED CHAR
        | UNSIGNED SHORT
        | UNSIGNED INT
        | UNSIGNED LONG
        | DOUBLE
        | STRING
        | BOOL
        ;

opt_fieldvector
        : '[' INTCONSTANT ']'
        | '[' qname ']'
        | '[' ']'
        |
        ;

fieldvalue
        : fieldvalue fieldvalueitem
        | fieldvalueitem
        ;

fieldvalueitem
        : STRINGCONSTANT
        | CHARCONSTANT
        | INTCONSTANT
        | REALCONSTANT
        | TRUE
        | FALSE
        | NAME
        | DOUBLECOLON
        | '?' | ':' | '&&' | '||' | '##' | '==' | '!=' | '&gt;' | '&gt;=' | '&lt;' | '&lt;='
        | '&' | '|' | '#' | '&lt;&lt;' | '&gt;&gt;'
        | '+' | '-' | '*' | '/' | '%' | '^' | '&' | UMIN | '!' | '~'
        | '.' | ',' | '(' | ')' | '[' | ']'
        ;

enumvalue
        : INTCONSTANT
        | '-' INTCONSTANT
        | NAME
        ;

opt_inline_properties
        : inline_properties
        |
        ;

inline_properties
        : inline_properties property_namevalue
        | property_namevalue
        ;

property
        : property_namevalue ';'
        ;

property_namevalue
        : property_name
        | property_name '(' opt_property_keys ')'
        | ENUM '(' NAME ')'
        ;

property_name
        : '@' PROPNAME
        | '@' PROPNAME '[' PROPNAME ']'
        ;

opt_property_keys
        : property_keys
        ;

property_keys
        : property_keys ';' property_key
        | property_key
        ;

property_key
        : property_literal '=' property_values
        | property_values
        ;

property_values
        : property_values ',' property_value
        | property_value
        ;

property_value
        : property_literal
        |
        ;

property_literal
        : property_literal CHAR
        | property_literal STRINGCONSTANT
        | CHAR
        | STRINGCONSTANT
        ;

opt_semicolon : ';' | ;
</pre>

<p>
<hr class='pgbr'><h1><a name="cha:display-strings"/>24 Appendix F&#58; Display String Tags<a class="headerlink" href="#cha:display-strings" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:display-strings:module-and-connection-display-strings"/>24.1 Module and Connection Display String Tags<a class="headerlink" href="#sec:display-strings:module-and-connection-display-strings" title="Permalink to this headline"></a></h2>

<p>Supported module and connection display string tags are listed in the following table.


<table border>
<TR> <TD align=left>

<p><b>Tag[argument index] - name</b> </TD> <TD align=left> <b>Description</b>
</TD></TR>
<TR> <TD align=left>
<b>p</b>[0] - x
</TD> <TD align=left>
X position of the center of the icon/shape; defaults to automatic graph layouting
</TD></TR>
<TR> <TD align=left>
<b>p</b>[1] - y
</TD> <TD align=left>
Y position of the center of the icon/shape; defaults to automatic graph layouting
</TD></TR>
<TR> <TD align=left>
<b>p</b>[2] - arrangement
</TD> <TD align=left>
Arrangement of submodule vectors. Values: row (r), column (c), matrix (m), ring (ri), exact (x)
</TD></TR>
<TR> <TD align=left>
<b>p</b>[3] - arr. par1
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; ncols, ring =&gt; rx, exact =&gt; dx, row =&gt; dx, column =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>p</b>[4] - arr. par2
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; dx, ring =&gt; ry, exact =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>p</b>[5] - arr. par3
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>b</b>[0] - width
</TD> <TD align=left>
Width of object. Default: 40
</TD></TR>
<TR> <TD align=left>
<b>b</b>[1] - height
</TD> <TD align=left>
Height of object. Default: 24
</TD></TR>
<TR> <TD align=left>
<b>b</b>[2] - shape
</TD> <TD align=left>
Shape of object. Values: rectangle (rect), oval (oval). Default: rect
</TD></TR>
<TR> <TD align=left>
<b>b</b>[3] - fill color
</TD> <TD align=left>
Fill color of the object (colorname or #RRGGBB or @HHSSBB). Default: #8080ff
</TD></TR>
<TR> <TD align=left>
<b>b</b>[4] - border color
</TD> <TD align=left>
Border color of the object (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>b</b>[5] - border width
</TD> <TD align=left>
Border width of the object. Default: 2
</TD></TR>
<TR> <TD align=left>
<b>i</b>[0] - icon
</TD> <TD align=left>
An icon representing the object
</TD></TR>
<TR> <TD align=left>
<b>i</b>[1] - icon color
</TD> <TD align=left>
A color to colorize the icon (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>i</b>[2] - icon colorization %
</TD> <TD align=left>
Amount of colorization in percent. Default: 30
</TD></TR>
<TR> <TD align=left>
<b>is</b>[0] - icon size
</TD> <TD align=left>
The size of the image. Values: very small (vs), small (s), normal (n), large (l), very large (vl)
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[0] - overlay icon
</TD> <TD align=left>
An icon added to the upper right corner of the original image
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[1] - overlay icon color
</TD> <TD align=left>
A color to colorize the overlay icon (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[2] - overlay icon colorization %
</TD> <TD align=left>
Amount of colorization in percent. Default: 30
</TD></TR>
<TR> <TD align=left>
<b>r</b>[0] - range
</TD> <TD align=left>
Radius of the range indicator
</TD></TR>
<TR> <TD align=left>
<b>r</b>[1] - range fill color
</TD> <TD align=left>
Fill color of the range indicator (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>r</b>[2] - range border color
</TD> <TD align=left>
Border color of the range indicator (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>r</b>[3] - range border width
</TD> <TD align=left>
Border width of the range indicator. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>q</b>[0] - queue object
</TD> <TD align=left>
Displays the length of the named queue object
</TD></TR>
<TR> <TD align=left>
<b>t</b>[0] - text
</TD> <TD align=left>
Additional text to display
</TD></TR>
<TR> <TD align=left>
<b>t</b>[1] - text position
</TD> <TD align=left>
Position of the text. Values: left (l), right (r), top (t). Default: t
</TD></TR>
<TR> <TD align=left>
<b>t</b>[2] - text color
</TD> <TD align=left>
Color of the displayed text (colorname or #RRGGBB or @HHSSBB). Default: blue
</TD></TR>
<TR> <TD align=left>
<b>tt</b>[0] - tooltip
</TD> <TD align=left>
Tooltip to be displayed over the object
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[0] - bg width
</TD> <TD align=left>
Width of the module background rectangle
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[1] - bg height
</TD> <TD align=left>
Height of the module background rectangle
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[2] - bg fill color
</TD> <TD align=left>
Background fill color (colorname or #RRGGBB or @HHSSBB). Default: grey82
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[3] - bg border color
</TD> <TD align=left>
Border color of the module background rectangle (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[4] - bg border width
</TD> <TD align=left>
Border width of the module background rectangle. Default: 2
</TD></TR>
<TR> <TD align=left>
<b>bgtt</b>[0] - bg tooltip
</TD> <TD align=left>
Tooltip to be displayed over the module's background
</TD></TR>
<TR> <TD align=left>
<b>bgi</b>[0] - bg image
</TD> <TD align=left>
An image to be displayed as a module background
</TD></TR>
<TR> <TD align=left>
<b>bgi</b>[1] - bg image mode
</TD> <TD align=left>
How to arrange the module's background image. Values: fix (f), tile (t), stretch (s), center (c). Default: fixed
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[0] - grid tick distance
</TD> <TD align=left>
Distance between two major ticks measured in units
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[1] - grid minor ticks
</TD> <TD align=left>
Minor ticks per major ticks. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[2] - grid color
</TD> <TD align=left>
Color of the grid lines (colorname or #RRGGBB or @HHSSBB). Default: grey
</TD></TR>
<TR> <TD align=left>
<b>bgu</b>[0] - distance unit
</TD> <TD align=left>
Name of distance unit (default: meter)
</TD></TR>
<TR> <TD align=left>
<b>m</b>[0] - routing constraint
</TD> <TD align=left>
Connection routing constraint. Values: auto (a), south (s), north (n), east (e), west (w), manual (m)
</TD></TR>
<TR> <TD align=left>
<b>m</b>[1] - routing x1
</TD> <TD align=left>
Connection routing source coordinate. When m[0] is 'm', this is the x coordinate of one point of the connection line, in integer percentages of the source rectangle.
</TD></TR>
<TR> <TD align=left>
<b>m</b>[2] - routing y1
</TD> <TD align=left>
Connection routing source coordinate. When m[0] is 'm', this is the y coordinate of one point of the connection line, in integer percentages of the source rectangle.
</TD></TR>
<TR> <TD align=left>
<b>m</b>[3] - routing x2
</TD> <TD align=left>
Connection routing destination coordinate. When m[0] is 'm', this is the x coordinate of another point of the connection line, in integer percentages of the destination rectangle.
</TD></TR>
<TR> <TD align=left>
<b>m</b>[4] - routing y2
</TD> <TD align=left>
Connection routing destination coordinate. When m[0] is 'm', this is the y coordinate of another point of the connection line, in integer percentages of the destination rectangle.
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[0] - line color
</TD> <TD align=left>
Connection color (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[1] - line width
</TD> <TD align=left>
Connection line width. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[2] - line style
</TD> <TD align=left>
Connection line style. Values: solid (s), dotted (d), dashed (da). Default: solid
</TD></TR>
<TR> <TD align=left>
</table>

<p>

<p>
<h2><a name="sec:display-strings:message-display-strings"/>24.2 Message Display String Tags<a class="headerlink" href="#sec:display-strings:message-display-strings" title="Permalink to this headline"></a></h2>

<p>To customize the appearance of messages in the graphical runtime environment,
override the <tt>getDisplayString()</tt> method of <tt><a href="../api/classomnetpp_1_1cMessage.html">cMessage</a></tt> or
<tt><a href="../api/classomnetpp_1_1cPacket.html">cPacket</a></tt> to return a display string.

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>oval</b>
</TD> <TD align=left>
 Ellipse with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=10, <i>height</i>=10</TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>rect</b>
</TD> <TD align=left>
 Rectangle with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=10, <i>height</i>=10</TD></TR>
<TR> <TD align=left> <b>o=</b><i>fillcolor</i>,<i>outlinecolor</i>,<i>borderwidth</i>
</TD> <TD align=left>
 Specifies options for the rectangle or oval.
Colors can be given in HTML format (#rrggbb), in HSB format
(@hhssbb), or as a valid SVG color name.

<p>Defaults: <i>fillcolor</i>=red, <i>outlinecolor</i>=black,
<i>borderwidth</i>=1</TD></TR>
<TR> <TD align=left> <b>i=</b><i>iconname</i>,<i>color</i>,<i>percentage</i>
</TD> <TD align=left>
 Use the named icon. It can be colorized, and percentage
specifies the amount of colorization. If color name is <tt>"kind"</tt>,
a message kind dependent colors is used (like default behaviour).

<p>Defaults: <i>iconname</i>: no default -- if no icon name is present, a small
red solid circle will be used;
<i>color</i>: no coloring; <i>percentage</i>: 30%</TD></TR>
<TR> <TD align=left> <b>tt=</b><i>tooltip-text</i>
</TD> <TD align=left>
 Displays the given text in a tooltip when the user moves
the mouse over the message icon.</TD></TR>
<TR> <TD align=left> 
</table>

<p>

<p>
<hr class='pgbr'><h1><a name="cha:figure-definitions"/>25 Appendix G&#58; Figure Definitions<a class="headerlink" href="#cha:figure-definitions" title="Permalink to this headline"></a></h1>

<p>This appendix provides a reference to defining figures in NED files.

<p><h2><a name="sec:figure-definitions:figure-types"/>25.1 Built-in Figure Types<a class="headerlink" href="#sec:figure-definitions:figure-types" title="Permalink to this headline"></a></h2>

<p>The following table lists the figure types supported by OMNeT++.

<p><table border>
<TR> <TD align=left>

<p><b>@figure type</b> </TD> <TD align=left> <b>C++ class</b>            </TD></TR>
<TR> <TD align=left> <b>line</b>         </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cLineFigure.html">cLineFigure</a></tt>       </TD></TR>
<TR> <TD align=left> <b>arc</b>          </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cArcFigure.html">cArcFigure</a></tt>        </TD></TR>
<TR> <TD align=left> <b>polyline</b>     </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cPolylineFigure.html">cPolylineFigure</a></tt>   </TD></TR>
<TR> <TD align=left> <b>rectangle</b>    </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cRectangleFigure.html">cRectangleFigure</a></tt>  </TD></TR>
<TR> <TD align=left> <b>oval</b>         </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cOvalFigure.html">cOvalFigure</a></tt>       </TD></TR>
<TR> <TD align=left> <b>ring</b>         </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cRingFigure.html">cRingFigure</a></tt>       </TD></TR>
<TR> <TD align=left> <b>pieslice</b>     </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cPieSliceFigure.html">cPieSliceFigure</a></tt>   </TD></TR>
<TR> <TD align=left> <b>polygon</b>      </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cPolygonFigure.html">cPolygonFigure</a></tt>    </TD></TR>
<TR> <TD align=left> <b>path</b>         </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cPathFigure.html">cPathFigure</a></tt>       </TD></TR>
<TR> <TD align=left> <b>text</b>         </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cTextFigure.html">cTextFigure</a></tt>       </TD></TR>
<TR> <TD align=left> <b>label</b>        </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cLabelFigure.html">cLabelFigure</a></tt>      </TD></TR>
<TR> <TD align=left> <b>image</b>        </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cImageFigure.html">cImageFigure</a></tt>      </TD></TR>
<TR> <TD align=left> <b>icon</b>         </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cIconFigure.html">cIconFigure</a></tt>       </TD></TR>
<TR> <TD align=left> <b>pixmap</b>       </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cPixmapFigure.html">cPixmapFigure</a></tt>     </TD></TR>
<TR> <TD align=left> <b>group</b>        </TD> <TD align=left> <tt><a href="../api/classomnetpp_1_1cGroupFigure.html">cGroupFigure</a></tt>      </TD></TR>
</table>

<p>Additional figure types can be defined with the
<tt>custom:<i>&lt;type&gt;</i></tt> syntax; see <i>FigureType</i> below.

<p><h2><a name="sec:figure-definitions:attribute-types"/>25.2 Attribute Types<a class="headerlink" href="#sec:figure-definitions:attribute-types" title="Permalink to this headline"></a></h2>

<p>This section lists what attribute types exist and their value syntaxes.

<p><ul class="dl">

<p><li><b>bool</b> : <br>
<tt>true</tt> or <tt>false</tt>.

<p><li><b>int</b> : <br>
An integer.

<p><li><b>double</b> : <br>
A real number.

<p><li><b>double01</b> : <br>
A real number in the [0,1] interval.

<p><li><b>degrees</b> : <br>
A real number that will be interpreted as degrees.

<p><li><b>string</b> : <br>
A string. It only needs to be enclosed in quotes if it contains comma,
semicolon, unmatched close parenthesis or other character that prevents
it from being parsed properly as a property value.

<p><li><b>Anchor</b> : <br>
<tt>c</tt>, <tt>center</tt>, <tt>n</tt>, <tt>e</tt>, <tt>s</tt>, <tt>w</tt>, <tt>nw</tt>,
<tt>ne</tt>, <tt>se</tt>, <tt>sw</tt>, <tt>start</tt>, <tt>middle</tt>, or <tt>end</tt>.
The last three are only valid for text figures.

<p><li><b>Arrowhead</b> : <br>
<tt>none</tt>, <tt>simple</tt>, <tt>triangle</tt>, or <tt>barbed</tt>.

<p><li><b>CapStyle</b> : <br>
<tt>butt</tt>, <tt>square</tt>, or <tt>round</tt>.

<p><li><b>Color</b> : <br>
A color in HTML format (<i>#rrggbb</i>), a color in
HSB format (<i>@hhssbb</i>), or a valid SVG color name.

<p><li><b>Dimensions</b> : <i>width, height</i> <br>
Size given as width and height.

<p><li><b>FigureType</b> : <br>
One of the built-in figure types (e.g. <tt>line</tt> or <tt>arc</tt>, see
<a href="#sec:figure-definitions:figure-types">[25.1]</a>), or a figure type registered
with <tt>Register_Figure()</tt>.

<p><li><b>FillRule</b> : <br>
<tt>evenodd</tt> or <tt>nonzero</tt>.

<p><li><b>Font</b> : <i>typeface, size, style</i> <br>
All three items are optional. <i>size</i> is the font size in points.
<i>style</i> is space-sparated list of zero or more of the following
words: <tt>normal</tt>, <tt>bold</tt>, <tt>italic</tt>, <tt>underline</tt>.

<p><li><b>ImageName</b> : <br>
The name of an image.

<p><li><b>Interpolation</b> : <br>
<tt>none</tt>, <tt>fast</tt>, or <tt>best</tt>.

<p><li><b>JoinStyle</b> : <br>
<tt>bevel</tt>, <tt>miter</tt>, or <tt>round</tt>.

<p><li><b>LineStyle</b> : <br>
<tt>solid</tt>, <tt>dotted</tt>, or <tt>dashed</tt>.

<p><li><b>Point</b> : <i>x, y</i> <br>
A point with <i>(x,y)</i> coordinates.

<p><li><b>Point2</b> : <i>x1, y1, x2, y2</i> <br>
Two points: <i>(x1,y1)</i> and <i>(x2,y2)</i>.

<p><li><b>PointList</b> : <i>x1, y1, x2, y2, x3, y3...</i> <br>
A list of the <i>(x1,y1)</i>, <i>(x2,y2)</i>, <i>(x3,y3)</i>, etc. points.

<p><li><b>Rectangle</b> : <i>x, y, width, height</i> <br>
A rectangle given with its top-left corner and dimensions.

<p><li><b>TagList</b> : <i>tag1, tag2, tag3...</i> <br>
A list of string tags.

<p><li><b>Tint</b> : <i>Color, double01</i> <br>
Specifies tint color and the amount of tinting for images.

<p><li><b>Transform</b> : <br>
One or more transform steps. A step is one of: <br>
<tt>translate(<i>x</i>, <i>y</i>)</tt>, <br>
<tt>rotate(<i>deg</i>)</tt>, <br>
<tt>rotate(<i>deg</i>, <i>centerx</i>, <i>centery</i>)</tt>, <br>
<tt>scale(<i>s</i>)</tt>, <tt>scale(<i>sx</i>, <i>sy</i>)</tt>, <br>
<tt>scale(<i>s</i>, <i>centerx</i>, <i>centery</i>)</tt>, <br>
<tt>scale(<i>sx</i>, <i>sy</i>, <i>centerx</i>, <i>centery</i>)</tt>, <br>
<tt>skewx(<i>coeff</i>)</tt>, <br>
<tt>skewx(<i>coeff</i>, <i>centery</i>)</tt>, <br>
<tt>skewy(<i>coeff</i>)</tt>, <br>
<tt>skewy(<i>coeff</i>, <i>centerx</i>)</tt>, <br>
<tt>matrix(<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>, <i>t1</i>, <i>t2</i>)</tt>

<p></ul>

<p>

<p><h2><a name="sec:figure-definitions:figure-attributes"/>25.3 Figure Attributes<a class="headerlink" href="#sec:figure-definitions:figure-attributes" title="Permalink to this headline"></a></h2>

<p>This section lists what attributes are accepted by individual figure types.
Types enclosed in parentheses are abstract types which cannot be used
directly; their sole purpose is to provide a base for more specialized
types.

<p>
<ul class="dl">

<p><li><b>(figure)</b> : <br>
    <tt>type</tt>=<i>&lt;FigureType&gt;</i>;
    <tt>visible</tt>=<i>&lt;bool&gt;</i>;
    <tt>tags</tt>=<i>&lt;TagList&gt;</i>;
    <tt>childZ</tt>=<i>&lt;int&gt;</i>;
    <tt>transform</tt>=<i>&lt;Transform&gt;</i>;

<p><li><b>(abstractLine)</b> : figure <br>
    <tt>lineColor</tt>=<i>&lt;Color&gt;</i>;
    <tt>lineStyle</tt>=<i>&lt;LineStyle&gt;</i>;
    <tt>lineWidth</tt>=<i>&lt;double&gt;</i>;
    <tt>lineOpacity</tt>=<i>&lt;double&gt;</i>;
    <tt>capStyle</tt>=<i>&lt;CapStyle&gt;</i>;
    <tt>startArrowhead</tt>=<i>&lt;Arrowhead&gt;</i>;
    <tt>endArrowhead</tt>=<i>&lt;Arrowhead&gt;</i>;
    <tt>zoomLineWidth</tt>=<i>&lt;bool&gt;</i>;

<p><li><b>line</b> : abstractLine <br>
    <tt>points</tt>=<i>&lt;Point2&gt;</i>

<p><li><b>arc</b> : abstractLine <br>
    <tt>bounds</tt>=<i>&lt;Rectangle&gt;</i>
    <tt>pos</tt>=<i>&lt;Point&gt;</i>;
    <tt>size</tt>=<i>&lt;Dimensions&gt;</i>;
    <tt>anchor</tt>=<i>&lt;Anchor&gt;</i>;
    <tt>startAngle</tt>=<i>&lt;degrees&gt;</i>;
    <tt>endAngle</tt>=<i>&lt;degrees&gt;</i>

<p><li><b>polyline</b> : abstractLine <br>
    <tt>points</tt>=<i>&lt;PointList&gt;</i>;
    <tt>smooth</tt>=<i>&lt;bool&gt;</i>;
    <tt>joinstyle</tt>=<i>&lt;JoinStyle&gt;</i>

<p><li><b>(abstractShape)</b> : figure <br>
    <tt>lineColor</tt>=<i>&lt;Color&gt;</i>;
    <tt>fillColor</tt>=<i>&lt;Color&gt;</i>;
    <tt>lineStyle</tt>=<i>&lt;LineStyle&gt;</i>;
    <tt>lineWidth</tt>=<i>&lt;double&gt;</i>;
    <tt>lineOpacity</tt>=<i>&lt;double01&gt;</i>;
    <tt>fillOpacity</tt>=<i>&lt;double01&gt;</i>;
    <tt>zoomLineWidth</tt>=<i>&lt;bool&gt;</i>

<p><li><b>rectangle</b> : abstractShape <br>
    <tt>bounds</tt>=<i>&lt;Rectangle&gt;</i>
    <tt>pos</tt>=<i>&lt;Point&gt;</i>;
    <tt>size</tt>=<i>&lt;Dimensions&gt;</i>;
    <tt>anchor</tt>=<i>&lt;Anchor&gt;</i>;
    <tt>cornerRadius</tt>=<i>&lt;double&gt;|&lt;Dimensions&gt;</i>

<p><li><b>oval</b> : abstractShape <br>
    <tt>bounds</tt>=<i>&lt;Rectangle&gt;</i>
    <tt>pos</tt>=<i>&lt;Point&gt;</i>;
    <tt>size</tt>=<i>&lt;Dimensions&gt;</i>;
    <tt>anchor</tt>=<i>&lt;Anchor&gt;</i>

<p><li><b>ring</b> : abstractShape <br>
    <tt>bounds</tt>=<i>&lt;Rectangle&gt;</i>
    <tt>pos</tt>=<i>&lt;Point&gt;</i>;
    <tt>size</tt>=<i>&lt;Dimensions&gt;</i>;
    <tt>anchor</tt>=<i>&lt;Anchor&gt;</i>;
    <tt>innerSize</tt>=<i>&lt;Dimensions&gt;</i>

<p><li><b>pieslice</b> : abstractShape <br>
    <tt>bounds</tt>=<i>&lt;Rectangle&gt;</i>
    <tt>pos</tt>=<i>&lt;Point&gt;</i>;
    <tt>size</tt>=<i>&lt;Dimensions&gt;</i>;
    <tt>anchor</tt>=<i>&lt;Anchor&gt;</i>;
    <tt>startAngle</tt>=<i>&lt;degrees&gt;</i>;
    <tt>endAngle</tt>=<i>&lt;degrees&gt;</i>

<p><li><b>polygon</b> : abstractShape <br>
    <tt>points</tt>=<i>&lt;PointList&gt;</i>;
    <tt>smooth</tt>=<i>&lt;bool&gt;</i>;
    <tt>joinStyle</tt>=<i>&lt;JoinStyle&gt;</i>;
    <tt>fillRule</tt>=<i>&lt;FillRule&gt;</i>

<p><li><b>path</b> : abstractShape <br>
    <tt>path</tt>=<i>&lt;string&gt;</i>;
    <tt>offset</tt>=<i>&lt;Point&gt;</i>;
    <tt>joinStyle</tt>=<i>&lt;JoinStyle&gt;</i>;
    <tt>capStyle</tt>=<i>&lt;CapStyle&gt;</i>;
    <tt>fillRule</tt>=<i>&lt;FillRule&gt;</i>

<p><li><b>(abstractText)</b> : figure <br>
    <tt>pos</tt>=<i>&lt;Point&gt;</i>;
    <tt>anchor</tt>=<i>&lt;Anchor&gt;</i>
    <tt>text</tt>=<i>&lt;string&gt;</i>;
    <tt>font</tt>=<i>&lt;Font&gt;</i>;
    <tt>opacity</tt>=<i>&lt;double01&gt;</i>;
    <tt>color</tt>=<i>&lt;Color&gt;</i>;

<p><li><b>label</b> : abstractText <br>
    <tt>angle</tt>=<i>&lt;degrees&gt;</i>;

<p><li><b>text</b> : abstractText

<p><li><b>(abstractImage)</b> : figure <br>
    <tt>bounds</tt>=<i>&lt;Rectangle&gt;</i>
    <tt>pos</tt>=<i>&lt;Point&gt;</i>;
    <tt>size</tt>=<i>&lt;Dimensions&gt;</i>;
    <tt>anchor</tt>=<i>&lt;Anchor&gt;</i>;
    <tt>interpolation</tt>=<i>&lt;Interpolation&gt;</i>;
    <tt>opacity</tt>=<i>&lt;double01&gt;</i>;
    <tt>tint</tt>=<i>&lt;Tint&gt;</i>

<p><li><b>image</b> : abstractImage <br>
    <tt>image</tt>=<i>&lt;ImageName&gt;</i>

<p><li><b>icon</b> : abstractImage <br>
    <tt>image</tt>=<i>&lt;ImageName&gt;</i>

<p><li><b>pixmap</b> : abstractImage <br>
    <tt>resolution</tt>=<i>&lt;Dimensions&gt;</i>

<p></ul>

<p>



<p>

<p>

<p>

<p>

<p>

<p>

<p>

<p>

<p>

<p><hr class='pgbr'><h1><a name="cha:config-options"/>26 Appendix H&#58; Configuration Options<a class="headerlink" href="#cha:config-options" title="Permalink to this headline"></a></h1>

<p><h2><a name="sec:config-options:config-options"/>26.1 Configuration Options<a class="headerlink" href="#sec:config-options:config-options" title="Permalink to this headline"></a></h2>


This section lists all configuration options that are available in ini files.
A similar list can be obtained from any simulation executable by running it
with the <tt>-h configdetails</tt> option.

<ul class="dl">
<li><b>**.bin-recording</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-object setting for scalar results.</i><br>
    Whether the bins of the matching histogram object should be recorded,
    provided that recording of the histogram object itself is enabled
    (<tt>**.&lt;scalar-name&gt;.scalar-recording=true</tt>).<br>Usage:
    <tt>&lt;module-full-path&gt;.&lt;scalar-name&gt;.bin-recording=true/false</tt>.
    To control histogram recording from a <tt>@statistic</tt>, use
    <tt>&lt;statistic-name&gt;:histogram</tt> for
    <tt>&lt;scalar-name&gt;</tt>.<br>Example:
    <tt>**.ping.roundTripTime:histogram.bin-recording=false</tt>
<li><b>check-signals</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Controls whether the simulation kernel will validate signals emitted by
    modules and channels against signal declarations
    (<tt>@signal</tt> properties) in NED files. The default setting
    depends on the build type: <tt>true</tt> in DEBUG, and <tt>false</tt> in RELEASE
    mode.
<li><b>cmdenv-autoflush</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Call <tt>fflush(stdout)</tt> after each event banner or status update; affects
    both express and normal mode. Turning on autoflush may have a performance
    penalty, but it can be useful with printf-style debugging for tracking down
    program crashes.
<li><b>cmdenv-config-name</b>  = <i>&lt;string&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies the name of the configuration to be run (for a value <tt>Foo</tt>,
    section <tt>[Config Foo]</tt> will be used from the ini file).
    See also
    <tt>cmdenv-runs-to-execute</tt>. The
    <tt>-c</tt> command line option overrides this setting.
<li><b>cmdenv-event-banner-details</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-simulation-run setting.</i><br>
    When
    <tt>cmdenv-express-mode=false</tt>:
    print extra information after event banners.
<li><b>cmdenv-event-banners</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-simulation-run setting.</i><br>
    When
    <tt>cmdenv-express-mode=false</tt>:
    turns printing event banners on/off.
<li><b>cmdenv-express-mode</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Selects normal (debug/trace) or express mode.
<li><b>cmdenv-extra-stack</b>  = <i>&lt;double&gt;</i>, unit=<tt>B</tt>, default: <tt>8KiB</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies the extra amount of stack that is reserved for each
    <tt>activity()</tt> simple module when the simulation is run under Cmdenv.
<li><b>cmdenv-interactive</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Defines what Cmdenv should do when the model contains unassigned
    parameters. In interactive mode, it asks the user. In non-interactive mode
    (which is more suitable for batch execution), Cmdenv stops with an error.
<li><b>**.cmdenv-log-level</b>  = <i>&lt;string&gt;</i>, default: <tt>TRACE</tt><br>
    <i>Per-object setting for modules.</i><br>
    Specifies the per-component level of detail recorded by log statements,
    output below the specified level is omitted. Available values are (case
    insensitive): <tt>off</tt>, <tt>fatal</tt>, <tt>error</tt>, <tt>warn</tt>, <tt>info</tt>,
    <tt>detail</tt>, <tt>debug</tt> or <tt>trace</tt>. Note that the level of detail is
    also controlled by the globally specified runtime log level and the
    <tt>COMPILETIME_LOGLEVEL</tt> macro that is used to completely remove log
    statements from the executable.
<li><b>cmdenv-log-prefix</b>  = <i>&lt;string&gt;</i>, default: <tt>[%l]	</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Specifies the format string that determines the prefix of each log line.
    The format string may contain format directives in the syntax <tt>%x</tt> (a
    <tt>%</tt> followed by a single format character).  For example <tt>%l</tt>
    stands for log level, and <tt>%J</tt> for source component. See the manual
    for the list of available format characters.
<li><b>cmdenv-output-file</b>  = <i>&lt;filename&gt;</i>, default: <tt>${resultdir}/${configname}-${iterationvarsf}#${repetition}.out</tt><br>
    <i>Per-simulation-run setting.</i><br>
    When
    <tt>cmdenv-record-output=true</tt>:
    file name to redirect standard output to. See also
    <tt>fname-append-host</tt>.
<li><b>cmdenv-performance-display</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-simulation-run setting.</i><br>
    When <tt>cmdenv-express-mode=true</tt>:
    print detailed performance information. Turning it on results in a 3-line
    entry printed on each update, containing ev/sec, simsec/sec, ev/simsec,
    number of messages created/still present/currently scheduled in FES.
<li><b>cmdenv-redirect-output</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Causes Cmdenv to redirect standard output of simulation runs to a file or
    separate files per run. This option can be useful with running simulation
    campaigns (e.g. using opp_runall), and also with parallel simulation. See
    also: <tt>cmdenv-output-file</tt>,
    <tt>fname-append-host</tt>.
<li><b>cmdenv-runs-to-execute</b>  = <i>&lt;string&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies which runs to execute from the selected configuration (see
    <tt>cmdenv-config-name</tt> option). It accepts a
    filter expression of iteration variables such as <tt>$numHosts&gt;10
    &amp;&amp; $iatime==1s</tt>, or
    a comma-separated list of run numbers or run number ranges, e.g.
    <tt>1,3..4,7..9</tt>. If
    the value is missing, Cmdenv executes all runs in the selected
    configuration. The <tt>-r</tt> command line option overrides this
    setting.
<li><b>cmdenv-status-frequency</b>  = <i>&lt;double&gt;</i>, unit=<tt>s</tt>, default: <tt>2s</tt><br>
    <i>Per-simulation-run setting.</i><br>
    When <tt>cmdenv-express-mode=true</tt>:
    print status update every n seconds.
<li><b>cmdenv-stop-batch-on-error</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Decides whether Cmdenv should skip the rest of the runs when an error
    occurs during the execution of one run.
<li><b>configuration-class</b>  = <i>&lt;string&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Part of the Envir plugin mechanism: selects the class from which all
    configuration information will be obtained. This option lets you replace
    omnetpp.ini with some other implementation, e.g. database input. The
    simulation program still has to bootstrap from an omnetpp.ini (which
    contains the configuration-class setting). The class should implement the
    <tt><a href="../api/classomnetpp_1_1cConfigurationEx.html">cConfigurationEx</a></tt> interface.
<li><b>constraint</b>  = <i>&lt;string&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    For scenarios. Contains an expression that iteration variables
    (<tt>${}</tt> syntax) must satisfy for that
    simulation to run. Example: <tt>$i &lt; $j+1</tt>.
<li><b>cpu-time-limit</b>  = <i>&lt;double&gt;</i>, unit=<tt>s</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Stops the simulation when CPU usage has reached the given limit. The
    default is no limit. Note: To reduce per-event overhead, this time limit is
    only checked every N events (by default, N=1024).
<li><b>debug-on-errors</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When set to true, runtime errors will cause the simulation program to break
    into the C++ debugger (if the simulation is running under one, or
    just-in-time debugging is activated). Once in the debugger, you can view
    the stack trace or examine variables.
<li><b>debug-statistics-recording</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Turns on the printing of debugging information related to statistics
    recording (<tt>@statistic</tt> properties)
<li><b>debugger-attach-command</b>  = <i>&lt;string&gt;</i>, default: <tt>nemiver --attach=%u &amp;</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Command line to launch the debugger. It must contain exactly one percent
    sign, as <tt>%u</tt>, which will be replaced by the PID of this process. The
    command must not block (i.e. it should end in <tt>&amp;</tt> on Unix-like
    systems).
<li><b>debugger-attach-on-error</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When set to true, runtime errors and crashes will trigger an external
    debugger to be launched, allowing you to perform just-in-time debugging on
    the simulation process. The debugger command is configurable. Note that
    debugging (i.e. attaching to) a non-child process needs to be explicitly
    enabled on some systems, e.g. Ubuntu.
<li><b>debugger-attach-on-startup</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When set to true, the simulation program will launch an external debugger
    attached to it, allowing you to set breakpoints before proceeding. The
    debugger command is configurable.  Note that debugging (i.e. attaching to)
    a non-child process needs to be explicitly enabled on some systems, e.g.
    Ubuntu.
<li><b>debugger-attach-wait-time</b>  = <i>&lt;double&gt;</i>, unit=<tt>s</tt>, default: <tt>20s</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    An interval to wait after launching the external debugger, to give the
    debugger time to start up and attach to the simulation process.
<li><b>description</b>  = <i>&lt;string&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    Descriptive name for the given simulation configuration. Descriptions get
    displayed in the run selection dialog.
<li><b>eventlog-file</b>  = <i>&lt;filename&gt;</i>, default: <tt>${resultdir}/${configname}-${iterationvarsf}#${repetition}.elog</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Name of the eventlog file to generate.
<li><b>eventlog-message-detail-pattern</b>  = <i>&lt;custom&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    A list of patterns separated by '|' character which will be used to write
    message detail information into the eventlog for each message sent during
    the simulation. The message detail will be presented in the sequence chart
    tool. Each pattern starts with an object pattern optionally followed by ':'
    character and a comma separated list of field patterns. In both patterns
    and/or/not/* and various field match expressions can be used. The object
    pattern matches to class name, the field pattern matches to field name by
    default.<br>
    <tt>EVENTLOG-MESSAGE-DETAIL-PATTERN
    := (
    DETAIL-PATTERN '|' )*
    DETAIL_PATTERN</tt><br>  <tt>DETAIL-PATTERN
    :=
    OBJECT-PATTERN [
    ':' FIELD-PATTERNS
    ]</tt><br>  <tt>OBJECT-PATTERN
    :=
    MATCH-EXPRESSION</tt><br>
    <tt>FIELD-PATTERNS :=
    ( FIELD-PATTERN
    ',' )*
    FIELD_PATTERN</tt><br>  <tt>FIELD-PATTERN
    :=
    MATCH-EXPRESSION</tt><br>Examples:\\  <tt>*</tt>: captures
    all fields of all messages<br>
    <tt>*Frame:*Address,*Id</tt>: captures all fields
    named somethingAddress and somethingId from messages of any class named
    somethingFrame<br>  <tt>MyMessage:declaredOn(MyMessage)</tt>:
    captures instances of MyMessage recording the fields declared on the
    MyMessage class<br>  <tt>*:(not
    declaredOn(<a href="../api/classomnetpp_1_1cMessage.html">cMessage</a>) and not
    declaredOn(<a href="../api/classomnetpp_1_1cNamedObject.html">cNamedObject</a>) and not
    declaredOn(<a href="../api/classomnetpp_1_1cObject.html">cObject</a>))</tt>: records user-defined fields from all
    messages
<li><b>eventlog-recording-intervals</b>  = <i>&lt;custom&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    Simulation time interval(s) when events should be recorded. Syntax:
    <tt>[&lt;from&gt;]..[&lt;to&gt;],...</tt> That is,
    both start and end of an interval are optional, and intervals are separated
    by comma. Example: <tt>..10.2,
    22.2..100,
    233.3..</tt>
<li><b>eventlogmanager-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::envir::EventlogFileManager</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Part of the Envir plugin mechanism: selects the eventlog manager class to
    be used to record data. The class has to implement the
    <tt><a href="../api/classomnetpp_1_1cIEventlogManager.html">cIEventlogManager</a></tt> interface.
<li><b>experiment-label</b>  = <i>&lt;string&gt;</i>, default: <tt>${configname}</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Identifies the simulation experiment (which consists of several,
    potentially repeated measurements). This string gets recorded into result
    files, and may be referred to during result analysis.
<li><b>extends</b>  = <i>&lt;string&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    Name of the configuration this section is based on. Entries from that
    section will be inherited and can be overridden. In other words,
    configuration lookups will fall back to the base section.
<li><b>fingerprint</b>  = <i>&lt;string&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    The expected fingerprints of the simulation. If you need multiple
    fingerprints, separate them with commas. When provided, the fingerprints
    will be calculated from the specified properties of simulation events,
    messages, and statistics during execution, and checked against the provided
    values. Fingerprints are suitable for crude regression tests. As
    fingerprints occasionally differ across platforms, more than one value can
    be specified for a single fingerprint, separated by spaces, and a match
    with any of them will be accepted. To obtain a fingerprint, enter a dummy
    value (such as <tt>0000</tt>), and run the simulation.
<li><b>fingerprint-events</b>  = <i>&lt;string&gt;</i>, default: <tt>*</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Configures the fingerprint calculator to consider only certain events. The
    value is a pattern that will be matched against the event name by default.
    It may also be an expression containing pattern matching characters, field
    access, and logical operators. The default setting is '*' which includes
    all events in the calculated fingerprint. If you configured multiple
    fingerprints, separate filters with commas.
<li><b>fingerprint-ingredients</b>  = <i>&lt;string&gt;</i>, default: <tt>tplx</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Specifies the list of ingredients to be taken into account for fingerprint
    computation. Each character corresponds to one ingredient: 'e' event
    number, 't' simulation time, 'n' message (event) full name, 'c' message
    (event) class name, 'k' message kind, 'l' message bit length, 'o' message
    control info class name, 'd' message data, 'i' module id, 'm' module full
    name, 'p' module full path, 'a' module class name, 'r' random numbers
    drawn, 's' scalar results, 'z' statistic results, 'v' vector results, 'x'
    extra data provided by modules. Note: ingredients specified in an expected
    fingerprint (characters after the '/' in the fingerprint value) take
    precedence over this setting. If you configured multiple fingerprints,
    separate ingredients with commas.
<li><b>fingerprint-modules</b>  = <i>&lt;string&gt;</i>, default: <tt>*</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Configures the fingerprint calculator to consider only certain modules. The
    value is a pattern that will be matched against the module full path by
    default. It may also be an expression containing pattern matching
    characters, field access, and logical operators. The default setting is '*'
    which includes all events in all modules in the calculated fingerprint. If
    you configured multiple fingerprints, separate filters with commas.
<li><b>fingerprint-results</b>  = <i>&lt;string&gt;</i>, default: <tt>*</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Configures the fingerprint calculator to consider only certain results. The
    value is a pattern that will be matched against the result full path by
    default. It may also be an expression containing pattern matching
    characters, field access, and logical operators. The default setting is '*'
    which includes all results in all modules in the calculated fingerprint. If
    you configured multiple fingerprints, separate filters with commas.
<li><b>fingerprintcalculator-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::<a href="../api/classomnetpp_1_1cSingleFingerprintCalculator.html">cSingleFingerprintCalculator</a></tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Part of the Envir plugin mechanism: selects the fingerprint calculator
    class to be used to calculate the simulation fingerprint. The class has to
    implement the <tt><a href="../api/classomnetpp_1_1cFingerprintCalculator.html">cFingerprintCalculator</a></tt> interface.
<li><b>fname-append-host</b>  = <i>&lt;bool&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Turning it on will cause the host name and process Id to be appended to the
    names of output files (e.g. omnetpp.vec, omnetpp.sca). This is especially
    useful with distributed simulation. The default value is true if parallel
    simulation is enabled, false otherwise.
<li><b>futureeventset-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::<a href="../api/classomnetpp_1_1cEventHeap.html">cEventHeap</a></tt><br>
    <i>Per-simulation-run setting.</i><br>
    Part of the Envir plugin mechanism: selects the class for storing the
    future events in the simulation. The class has to implement the
    <tt><a href="../api/classomnetpp_1_1cFutureEventSet.html">cFutureEventSet</a></tt> interface.
<li><b>image-path</b>  = <i>&lt;path&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    A semicolon-separated list of directories that contain module icons and
    other resources. This list with be concatenated with
    <tt>OMNETPP_IMAGE_PATH</tt>.
<li><b>iteration-nesting-order</b>  = <i>&lt;string&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    Specifies the loop nesting order for iteration variables
    (<tt>${}</tt> syntax). The value is a
    comma-separated list of iteration variables; the list may also contain at
    most one asterisk. Variables that are not explicitly listed will be
    inserted at the position of the asterisk, or appended to the list if there
    is no asterisk. The first variable will become the outermost loop, and the
    last one the innermost loop. Example:
    <tt>repetition,numHosts,*,iaTime</tt>.
<li><b>load-libs</b>  = <i>&lt;filenames&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    A space-separated list of dynamic libraries to be loaded on startup. The
    libraries should be given without the <tt>.dll</tt> or
    <tt>.so</tt> suffix -- that will be automatically appended.
<li><b>max-module-nesting</b>  = <i>&lt;int&gt;</i>, default: <tt>50</tt><br>
    <i>Per-simulation-run setting.</i><br>
    The maximum allowed depth of submodule nesting. This is used to catch
    accidental infinite recursions in NED.
<li><b>measurement-label</b>  = <i>&lt;string&gt;</i>, default: <tt>${iterationvars}</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Identifies the measurement within the experiment. This string gets recorded
    into result files, and may be referred to during result analysis.
<li><b>**.module-eventlog-recording</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-object setting for simple modules.</i><br>
    Enables recording events on a per module basis. This is meaningful for
    simple modules only. Usage:
    <tt>&lt;module-full-path&gt;.module-eventlog-recording=true/false</tt>.
    Examples:
    <tt>**.router[10..20].**.module-eventlog-recording
    = true</tt>;
    <tt>**.module-eventlog-recording
    = false</tt>
<li><b>ned-path</b>  = <i>&lt;path&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    A semicolon-separated list of directories. The directories will be regarded
    as roots of the NED package hierarchy, and all NED files will be loaded
    from their subdirectory trees. This option is normally left empty, as the
    OMNeT++ IDE sets the NED path automatically, and for simulations started
    outside the IDE it is more convenient to specify it via a command-line
    option or the NEDPATH environment variable.
<li><b>network</b>  = <i>&lt;string&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    The name of the network to be simulated.  The package name can be omitted
    if the ini file is in the same directory as the NED file that contains the
    network.
<li><b>num-rngs</b>  = <i>&lt;int&gt;</i>, default: <tt>1</tt><br>
    <i>Per-simulation-run setting.</i><br>
    The number of random number generators.
<li><b>output-scalar-db-commit-freq</b>  = <i>&lt;int&gt;</i>, default: <tt>100000</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Used with SqliteOutputScalarManager: COMMIT every n INSERTs.
<li><b>output-scalar-file</b>  = <i>&lt;filename&gt;</i>, default: <tt>${resultdir}/${configname}-${iterationvarsf}#${repetition}.sca</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Name for the output scalar file.
<li><b>output-scalar-file-append</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-simulation-run setting.</i><br>
    What to do when the output scalar file already exists: append to it
    (OMNeT++ 3.x behavior), or delete it and begin a new file (default).
<li><b>output-scalar-precision</b>  = <i>&lt;int&gt;</i>, default: <tt>14</tt><br>
    <i>Per-simulation-run setting.</i><br>
    The number of significant digits for recording data into the output scalar
    file. The maximum value is ~15 (IEEE double precision).
    This has no effect on SQLite recording, as it stores values as 8-byte IEEE
    floating point numbers.
<li><b>output-vector-db-indexing</b>  = <i>&lt;custom&gt;</i>, default: <tt>skip</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Whether and when to add an index to the 'vectordata' table in SQLite output
    vector files. Possible values: skip, ahead, after
<li><b>output-vector-file</b>  = <i>&lt;filename&gt;</i>, default: <tt>${resultdir}/${configname}-${iterationvarsf}#${repetition}.vec</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Name for the output vector file.
<li><b>output-vector-file-append</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-simulation-run setting.</i><br>
    What to do when the output vector file already exists: append to it, or
    delete it and begin a new file (default). Note:
    <tt>cIndexedFileOutputVectorManager</tt> currently does not support
    appending.
<li><b>output-vector-precision</b>  = <i>&lt;int&gt;</i>, default: <tt>14</tt><br>
    <i>Per-simulation-run setting.</i><br>
    The number of significant digits for recording data into the output vector
    file. The maximum value is ~15 (IEEE double precision).
    This setting has no effect on SQLite recording (it stores values as 8-byte
    IEEE floating point numbers), and for the "time" column which is
    represented as fixed-point numbers and always get recorded precisely.
<li><b>output-vectors-memory-limit</b>  = <i>&lt;double&gt;</i>, unit=<tt>B</tt>, default: <tt>16MiB</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Total memory that can be used for buffering output vectors. Larger values
    produce less fragmented vector files (i.e. cause vector data to be grouped
    into larger chunks), and therefore allow more efficient processing later.
    There is also a per-vector limit, see
    <tt>**.vector-buffer</tt>.
<li><b>outputscalarmanager-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::envir::OmnetppOutputScalarManager</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Part of the Envir plugin mechanism: selects the output scalar manager class
    to be used to record data passed to recordScalar(). The class has to
    implement the <tt><a href="../api/classomnetpp_1_1cIOutputScalarManager.html">cIOutputScalarManager</a></tt> interface.
<li><b>outputvectormanager-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::envir::OmnetppOutputVectorManager</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Part of the Envir plugin mechanism: selects the output vector manager class
    to be used to record data from output vectors. The class has to implement
    the <tt><a href="../api/classomnetpp_1_1cIOutputVectorManager.html">cIOutputVectorManager</a></tt> interface.
<li><b>parallel-simulation</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Enables parallel distributed simulation.
<li><b>**.param-record-as-scalar</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-object setting for module/channel parameters.</i><br>
    Applicable to module parameters: specifies whether the module parameter
    should be recorded into the output scalar file. Set it for parameters whose
    value you will need for result analysis.
<li><b>parsim-communications-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::cFileCommunications</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    If <tt>parallel-simulation=true</tt>, it selects the
    class that implements communication between partitions. The class must
    implement the <tt><a href="../api/classomnetpp_1_1cParsimCommunications.html">cParsimCommunications</a></tt> interface.
<li><b>parsim-debug</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    With <tt>parallel-simulation=true</tt>: turns on
    printing of log messages from the parallel simulation code.
<li><b>parsim-filecommunications-prefix</b>  = <i>&lt;string&gt;</i>, default: <tt>comm/</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <tt>cFileCommunications</tt> is selected as parsim communications
    class: specifies the prefix (directory+potential filename prefix) for
    creating the files for cross-partition messages.
<li><b>parsim-filecommunications-preserve-read</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <tt>cFileCommunications</tt> is selected as parsim communications
    class: specifies that consumed files should be moved into another directory
    instead of being deleted.
<li><b>parsim-filecommunications-read-prefix</b>  = <i>&lt;string&gt;</i>, default: <tt>comm/read/</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <tt>cFileCommunications</tt> is selected as parsim communications
    class: specifies the prefix (directory) where files will be moved after
    having been consumed.
<li><b>parsim-idealsimulationprotocol-tablesize</b>  = <i>&lt;int&gt;</i>, default: <tt>100000</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <tt>cIdealSimulationProtocol</tt> is selected as parsim
    synchronization class: specifies the memory buffer size for reading the ISP
    event trace file.
<li><b>parsim-mpicommunications-mpibuffer</b>  = <i>&lt;int&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <tt>cMPICommunications</tt> is selected as parsim communications class:
    specifies the size of the MPI communications buffer. The default is to
    calculate a buffer size based on the number of partitions.
<li><b>parsim-namedpipecommunications-prefix</b>  = <i>&lt;string&gt;</i>, default: <tt>comm/</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <tt>cNamedPipeCommunications</tt> is selected as parsim
    communications class: selects the prefix (directory+potential filename
    prefix) where name pipes are created in the file system.
<li><b>parsim-nullmessageprotocol-laziness</b>  = <i>&lt;double&gt;</i>, default: <tt>0.5</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <tt>cNullMessageProtocol</tt> is selected as parsim synchronization
    class: specifies the laziness of sending null messages. Values in the range
    <tt>[0,1)</tt> are accepted. Laziness=0 causes null messages to
    be sent out immediately as a new EOT is learned, which may result in
    excessive null message traffic.
<li><b>parsim-nullmessageprotocol-lookahead-class</b>  = <i>&lt;string&gt;</i>, default: <tt>cLinkDelayLookahead</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <tt>cNullMessageProtocol</tt> is selected as parsim synchronization
    class: specifies the C++ class that calculates lookahead. The class should
    subclass from <tt>cNMPLookahead</tt>.
<li><b>parsim-synchronization-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::cNullMessageProtocol</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    If <tt>parallel-simulation=true</tt>, it selects the
    parallel simulation algorithm. The class must implement the
    <tt>cParsimSynchronizer</tt> interface.
<li><b>**.partition-id</b>  = <i>&lt;string&gt;</i><br>
    <i>Per-object setting for modules.</i><br>
    With parallel simulation: in which partition the module should be
    instantiated. Specify numeric partition ID, or a comma-separated list of
    partition IDs for compound modules that span across multiple partitions.
    Ranges (<tt>5..9</tt>) and <tt>*</tt> (=all) are accepted too.
<li><b>print-undisposed</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Whether to report objects left (that is, not deallocated by simple module
    destructors) after network cleanup.
<li><b>qtenv-default-config</b>  = <i>&lt;string&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies which config Qtenv should set up automatically on startup. The
    default is to ask the user.
<li><b>qtenv-default-run</b>  = <i>&lt;string&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies which run (of the default config, see
    <tt>qtenv-default-config</tt>) Qtenv should set up
    automatically on startup. A run filter is also accepted. The default is to
    ask the user.
<li><b>qtenv-extra-stack</b>  = <i>&lt;double&gt;</i>, unit=<tt>B</tt>, default: <tt>80KiB</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies the extra amount of stack that is reserved for each
    <tt>activity()</tt> simple module when the simulation is run under Qtenv.
<li><b>real-time-limit</b>  = <i>&lt;double&gt;</i>, unit=<tt>s</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Stops the simulation after the specified amount of time has elapsed. The
    default is no limit. Note: To reduce per-event overhead, this time limit is
    only checked every N events (by default, N=1024).
<li><b>realtimescheduler-scaling</b>  = <i>&lt;double&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When <a href="../api/classomnetpp_1_1cRealTimeScheduler.html">cRealTimeScheduler</a> is selected as scheduler class: ratio of simulation
    time to real time. For example,
    <tt>realtimescheduler-scaling=2</tt> will cause
    simulation time to progress twice as fast as runtime.
<li><b>record-eventlog</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Enables recording an eventlog file, which can be later visualized on a
    sequence chart. See <tt>eventlog-file</tt> option too.
<li><b>repeat</b>  = <i>&lt;int&gt;</i>, default: <tt>1</tt><br>
    <i>Per-simulation-run setting.</i><br>
    For scenarios. Specifies how many replications should be done with the same
    parameters (iteration variables). This is typically used to perform
    multiple runs with different random number seeds. The loop variable is
    available as <tt>${repetition}</tt>. See also:
    <tt>seed-set</tt> key.
<li><b>replication-label</b>  = <i>&lt;string&gt;</i>, default: <tt>#${repetition}</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Identifies one replication of a measurement (see <tt>repeat</tt> and
    <tt>measurement-label</tt> options as well). This string gets
    recorded into result files, and may be referred to during result analysis.
<li><b>result-dir</b>  = <i>&lt;string&gt;</i>, default: <tt>results</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Value for the <tt>${resultdir}</tt> variable,
    which is used as the default directory for result files (output vector
    file, output scalar file, eventlog file, etc.)
<li><b>**.result-recording-modes</b>  = <i>&lt;string&gt;</i>, default: <tt>default</tt><br>
    <i>Per-object setting for statistics (@statistic).</i><br>
    Defines how to calculate results from the matching
    <tt>@statistic</tt>.<br>Usage:
    <tt>&lt;module-full-path&gt;.&lt;statistic-name&gt;.result-recording-modes=&lt;modes&gt;</tt>.
    Special values: <tt>default</tt>, <tt>all</tt>: they select the modes listed in
    the <tt>record</tt> key of <tt>@statistic</tt>; all selects all of
    them, default selects the non-optional ones (i.e. excludes the ones that
    end in a question mark). Example values: <tt>vector</tt>, <tt>count</tt>,
    <tt>last</tt>, <tt>sum</tt>, <tt>mean</tt>, <tt>min</tt>, <tt>max</tt>, <tt>timeavg</tt>,
    <tt>stats</tt>, <tt>histogram</tt>. More than one values are accepted, separated
    by commas. Expressions are allowed. Items prefixed with
    <tt>-</tt> get removed from the list. Example:
    <tt>**.queueLength.result-recording-modes=default,-vector,+timeavg</tt>
<li><b>**.rng-%</b>  = <i>&lt;int&gt;</i><br>
    <i>Per-object setting for modules and channels.</i><br>
    Maps a module-local RNG to one of the global RNGs. Example:
    <tt>**.gen.rng-1=3</tt>
    maps the local RNG 1 of modules matching <tt>**.gen</tt> to the
    global RNG 3. The value may be an expression, with the <tt>index</tt> and
    <tt>ancestorIndex()</tt> operators being potentially very useful. The
    default is one-to-one mapping, i.e. RNG k of all modules refer to the
    global RNG k (<tt>for
    k=0..num-rngs-1</tt>).<br>Usage:
    <tt>&lt;module-full-path&gt;.rng-&lt;local-index&gt;=&lt;global-index&gt;</tt>.
    Examples:
    <tt>**.mac.rng-0=1;
    **.source[*].rng-0=index</tt>
<li><b>rng-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::<a href="../api/classomnetpp_1_1cMersenneTwister.html">cMersenneTwister</a></tt><br>
    <i>Per-simulation-run setting.</i><br>
    The random number generator class to be used. It can be
    <tt><a href="../api/classomnetpp_1_1cMersenneTwister.html">cMersenneTwister</a></tt>, <tt><a href="../api/classomnetpp_1_1cLCG32.html">cLCG32</a></tt>, <tt>cAkaroaRNG</tt>, or you can use
    your own RNG class (it must be subclassed from <tt><a href="../api/classomnetpp_1_1cRNG.html">cRNG</a></tt>).
<li><b>runnumber-width</b>  = <i>&lt;int&gt;</i>, default: <tt>0</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Setting a nonzero value will cause the <tt>$runnumber</tt> variable to get
    padded with leading zeroes to the given length.
<li><b>**.scalar-recording</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-object setting for scalar results.</i><br>
    Whether the matching output scalars and statistic objects should be
    recorded.<br>Usage:
    <tt>&lt;module-full-path&gt;.&lt;scalar-name&gt;.scalar-recording=true/false</tt>.
    To enable/disable individual recording modes for a @statistic (those added
    via the <tt>record=...</tt> key of
    <tt>@statistic</tt> or the
    <tt>**.result-recording-modes=...</tt>
    config option), use <tt>&lt;statistic-name&gt;:&lt;mode&gt;</tt>
    for <tt>&lt;scalar-name&gt;</tt>, and make sure the
    <tt>@statistic</tt> as a whole is not disabled with
    <tt>**.&lt;statistic-name&gt;.statistic-recording=false</tt>.<br>Example:
    <tt>**.ping.roundTripTime:stddev.scalar-recording=false</tt>
<li><b>scheduler-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::<a href="../api/classomnetpp_1_1cSequentialScheduler.html">cSequentialScheduler</a></tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Part of the Envir plugin mechanism: selects the scheduler class. This
    plugin interface allows for implementing real-time, hardware-in-the-loop,
    distributed and distributed parallel simulation. The class has to implement
    the <tt><a href="../api/classomnetpp_1_1cScheduler.html">cScheduler</a></tt> interface.
<li><b>sectionbasedconfig-configreader-class</b>  = <i>&lt;string&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    When
    <tt>configuration-class=SectionBasedConfiguration</tt>:
    selects the configuration reader C++ class, which must subclass from
    <tt><a href="../api/classomnetpp_1_1cConfigurationReader.html">cConfigurationReader</a></tt>.
<li><b>seed-%-lcg32</b>  = <i>&lt;int&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    When <a href="../api/classomnetpp_1_1cLCG32.html">cLCG32</a> is selected as random number generator: seed for the kth RNG.
    (Substitute k for '%' in the key.)
<li><b>seed-%-mt</b>  = <i>&lt;int&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    When Mersenne Twister is selected as random number generator (default):
    seed for RNG number k. (Substitute k for '%' in the key.)
<li><b>seed-%-mt-p%</b>  = <i>&lt;int&gt;</i><br>
    <i>Per-simulation-run setting.</i><br>
    With parallel simulation: When Mersenne Twister is selected as random
    number generator (default): seed for RNG number k in partition number p.
    (Substitute k for the first '%' in the key, and p for the second.)
<li><b>seed-set</b>  = <i>&lt;int&gt;</i>, default: <tt>${runnumber}</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Selects the kth set of automatic random number seeds for the simulation.
    Meaningful values include <tt>${repetition}</tt>
    which is the repeat loop counter (see <tt>repeat</tt> option), and
    <tt>${runnumber}</tt>.
<li><b>sim-time-limit</b>  = <i>&lt;double&gt;</i>, unit=<tt>s</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Stops the simulation when simulation time reaches the given limit. The
    default is no limit.
<li><b>simtime-resolution</b>  = <i>&lt;custom&gt;</i>, default: <tt>ps</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Sets the resolution for the 64-bit fixed-point simulation time
    representation. Accepted values are: second-or-smaller time units (<tt>s</tt>,
    <tt>ms</tt>, <tt>us</tt>, <tt>ns</tt>, <tt>ps</tt>, <tt>fs</tt> or as), power-of-ten
    multiples of such units (e.g. 100ms), and base-10 scale exponents in the
    -18..0 range. The maximum representable simulation time depends on the
    resolution. The default is picosecond resolution, which offers a range of
    ~110 days.
<li><b>simtime-scale</b>  = <i>&lt;int&gt;</i>, default: <tt>-12</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    DEPRECATED in favor of simtime-resolution. Sets the scale exponent, and
    thus the resolution of time for the 64-bit fixed-point simulation time
    representation. Accepted values are -18..0; for example, -6 selects
    microsecond resolution. -12 means picosecond resolution, with a maximum
    simtime of ~110 days.
<li><b>snapshot-file</b>  = <i>&lt;filename&gt;</i>, default: <tt>${resultdir}/${configname}-${iterationvarsf}#${repetition}.sna</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Name of the snapshot file.
<li><b>snapshotmanager-class</b>  = <i>&lt;string&gt;</i>, default: <tt>omnetpp::envir::FileSnapshotManager</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Part of the Envir plugin mechanism: selects the class to handle streams to
    which snapshot() writes its output. The class has to implement the
    <tt><a href="../api/classomnetpp_1_1cISnapshotManager.html">cISnapshotManager</a></tt> interface.
<li><b>**.statistic-recording</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-object setting for statistics (@statistic).</i><br>
    Whether the matching <tt>@statistic</tt> should be recorded. This
    option lets one completely disable all recording from a @statistic.
    Disabling a <tt>@statistic</tt> this way is more efficient than
    specifying
    <tt>**.scalar-recording=false</tt> and
    <tt>**.vector-recording=false</tt>
    together.<br>Usage:
    <tt>&lt;module-full-path&gt;.&lt;statistic-name&gt;.statistic-recording=true/false</tt>.<br>Example:
    <tt>**.ping.roundTripTime.statistic-recording=false</tt>
<li><b>tkenv-default-config</b>  = <i>&lt;string&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies which config Tkenv should set up automatically on startup. The
    default is to ask the user.
<li><b>tkenv-default-run</b>  = <i>&lt;int&gt;</i>, default: <tt>0</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies which run (of the default config, see
    <tt>tkenv-default-config</tt>) Tkenv should set up
    automatically on startup. The default is to ask the user.
<li><b>tkenv-extra-stack</b>  = <i>&lt;double&gt;</i>, unit=<tt>B</tt>, default: <tt>48KiB</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies the extra amount of stack that is reserved for each
    <tt>activity()</tt> simple module when the simulation is run under Tkenv.
<li><b>tkenv-plugin-path</b>  = <i>&lt;path&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies the search path for Tkenv plugins. Tkenv plugins are .tcl files
    that get evaluated on startup.
<li><b>total-stack</b>  = <i>&lt;double&gt;</i>, unit=<tt>B</tt><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Specifies the maximum memory for <tt>activity()</tt> simple module stacks. You
    need to increase this value if you get a "Cannot allocate coroutine stack"
    error.
<li><b>**.typename</b>  = <i>&lt;string&gt;</i><br>
    <i>Per-object setting for modules and channels.</i><br>
    Specifies type for submodules and channels declared with 'like &lt;&gt;'.
<li><b>user-interface</b>  = <i>&lt;string&gt;</i><br>
    <i>Global setting (applies to all simulation runs).</i><br>
    Selects the user interface to be started. Possible values are Cmdenv, Tkenv
    and Qtenv. This option is normally left empty, as it is more convenient to
    specify the user interface via a command-line option or the IDE's Run and
    Debug dialogs. New user interfaces can be defined by subclassing
    <tt><a href="../api/classomnetpp_1_1cRunnableEnvir.html">cRunnableEnvir</a></tt>.
<li><b>**.vector-buffer</b>  = <i>&lt;double&gt;</i>, unit=<tt>B</tt>, default: <tt>1MiB</tt><br>
    <i>Per-object setting for vector results.</i><br>
    For output vectors: the maximum per-vector buffer space used for storing
    values before writing them out as a block into the output vector file.
    There is also a total limit, see
    <tt>output-vectors-memory-limit</tt>.<br>Usage:
    <tt>&lt;module-full-path&gt;.&lt;vector-name&gt;.vector-buffer=&lt;amount&gt;</tt>.
<li><b>**.vector-record-eventnumbers</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-object setting for vector results.</i><br>
    Whether to record event numbers for an output vector. (Values and
    timestamps are always recorded.) Event numbers are needed by the Sequence
    Chart Tool, for example.<br>Usage:
    <tt>&lt;module-full-path&gt;.&lt;vector-name&gt;.vector-record-eventnumbers=true/false</tt>.<br>Example:
    <tt>**.ping.roundTripTime:vector.vector-record-eventnumbers=false</tt>
<li><b>**.vector-recording</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-object setting for vector results.</i><br>
    Whether data written into an output vector should be recorded.<br>Usage:
    <tt>&lt;module-full-path&gt;.&lt;vector-name&gt;.vector-recording=true/false</tt>.
    To control vector recording from a <tt>@statistic</tt>, use
    <tt>&lt;statistic-name&gt;:vector for
    &lt;vector-name&gt;</tt>. Example:
    <tt>**.ping.roundTripTime:vector.vector-recording=false</tt>
<li><b>**.vector-recording-intervals</b>  = <i>&lt;custom&gt;</i><br>
    <i>Per-object setting for vector results.</i><br>
    Allows one to restrict recording of an output vector to one or more
    simulation time intervals. Usage:
    <tt>&lt;module-full-path&gt;.&lt;vector-name&gt;.vector-recording-intervals=&lt;intervals&gt;</tt>.
    The syntax for <tt>&lt;intervals&gt;</tt> is:
    <tt>[&lt;from&gt;]..[&lt;to&gt;],...</tt> That is,
    both start and end of an interval are optional, and intervals are separated
    by comma.<br>Example:
    <tt>**.roundTripTime:vector.vector-recording-intervals=..100,
    200..400,
    900..</tt>
<li><b>warmup-period</b>  = <i>&lt;double&gt;</i>, unit=<tt>s</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Length of the initial warm-up period. When set, results belonging to the
    first x seconds of the simulation will not be recorded into output vectors,
    and will not be counted into output scalars (see option
    <tt>**.result-recording-modes</tt>).
    This option is useful for steady-state simulations. The default is 0s (no
    warmup period). Note that models that compute and record scalar results
    manually (via <tt>recordScalar()</tt>) will not automatically obey this
    setting.
<li><b>warnings</b>  = <i>&lt;bool&gt;</i>, default: <tt>true</tt><br>
    <i>Per-simulation-run setting.</i><br>
    Enables warnings.
<li><b>**.with-akaroa</b>  = <i>&lt;bool&gt;</i>, default: <tt>false</tt><br>
    Per-object setting for vector results.<br>
    Whether the output vector should be under Akaroa control.
 </ul>

<p><h2><a name="sec:config-options:predefined-variables"/>26.2 Predefined Variables<a class="headerlink" href="#sec:config-options:predefined-variables" title="Permalink to this headline"></a></h2>

<p>Predefined variables that can be used in config values:

<p><ul class="dl">
<li><b>${runid}</b>  : <br>
    A reasonably globally unique identifier for the run, produced by
    concatenating the configuration name, run number, date/time, etc.
<li><b>${inifile}</b>  : <br>
    Name of the (primary) inifile
<li><b>${configname}</b>  : <br>
    Name of the active configuration
<li><b>${runnumber}</b>  : <br>
    Sequence number of the current run within all runs in the active
    configuration
<li><b>${network}</b>  : <br>
    Value of the <tt>network</tt> configuration option
<li><b>${experiment}</b>  : <br>
    Value of the <tt>experiment-label</tt> configuration option
<li><b>${measurement}</b>  : <br>
    Value of the <tt>measurement-label</tt> configuration option
<li><b>${replication}</b>  : <br>
    Value of the <tt>replication-label</tt> configuration option
<li><b>${processid}</b>  : <br>
    PID of the simulation process
<li><b>${datetime}</b>  : <br>
    Date and time the simulation run was started
<li><b>${resultdir}</b>  : <br>
    Value of the <tt>result-dir</tt> configuration option
<li><b>${repetition}</b>  : <br>
    The iteration number in <tt>0..N-1</tt>, where
    <tt>N</tt> is the value of the <tt>repeat</tt> configuration option
<li><b>${seedset}</b>  : <br>
    Value of the <tt>seed-set</tt> configuration option
<li><b>${iterationvars}</b>  : <br>
    Concatenation of all user-defined iteration variables in
    <tt>name=value</tt> form
<li><b>${iterationvarsf}</b>  : <br>
    Like ${iterationvars}, but sanitized for use as part of file names
</ul>

<hr class='pgbr'><h1><a name="cha:result-file-formats"/>27 Appendix I&#58; Result File Formats<a class="headerlink" href="#cha:result-file-formats" title="Permalink to this headline"></a></h1>

<p><h2><a name="cha:result-file-formats:opp"/>27.1 Native Result Files<a class="headerlink" href="#cha:result-file-formats:opp" title="Permalink to this headline"></a></h2>

<p>The file format described here applies to <i>both output vector and
output scalar files</i>. Their formats are consistent, only the types of
entries occurring in them are different. This unified format also
means that they can be read with a common routine.

<p>Result files are <i>line oriented</i>. A line consists of one or more
tokens, separated by whitespace. Tokens either do not
contain whitespace, or whitespace is escaped using a backslash, or
are quoted using double quotes. Escaping within quotes using
backslashes is also permitted.

<p>The first token of a line usually identifies the type of the entry. A
notable exception is an output vector data line, which begins with a
numeric identifier of the given output vector.

<p>A line starting with # as the first non-whitespace character denotes
a comment, and is to be ignored during processing.

<p>Result files are written from simulation runs. A simulation run
generates physically contiguous sets of lines into one or more result
files. (That is, lines from different runs do not arbitrarily mix in
the files.)

<p>A run is identified by a unique textual <i>runId</i>, which appears in
all result files written during that run. The runId may appear on the
user interface, so it should be somewhat meaningful to the user.
Nothing should be assumed about the particular format of runId, but it
will be some string concatenated from the simulated network's name, the
time/date, the hostname, and other pieces of data to make it unique.

<p>A simulation run will typically write into two result files (.vec and
.sca). However, when using parallel distributed simulation, the user
will end up with several .vec and .sca files, because different
partitions (a separate process each) will write into different files.
However, all these files will contain the same runId, so it is possible
to relate data that belong together.

<p>Entry types are:

<p><ul>
    <li> <b>version</b>: result file version
    <li> <b>run</b>: simulation run identifier
    <li> <b>attr</b>: run, vector, scalar or statistics object attribute
    <li> <b>param</b>: module parameter
    <li> <b>scalar</b>: scalar data
    <li> <b>vector</b>: vector declaration
    <li> <i>vector-id</i>: vector data
    <li> <b>file</b>: vector file attributes
    <li> <b>statistic</b>: statistics object
    <li> <b>field</b>: field of a statistics object
    <li> <b>bin</b>: histogram bin
</ul>

<p>
<h3><a name="sec:result-file-formats:opp:version"/>27.1.1 Version<a class="headerlink" href="#sec:result-file-formats:opp:version" title="Permalink to this headline"></a></h3>

<p>Specifies the format of the result file. It is written at the beginning of the file.

<p>Syntax:

<p> <b>version</b> <i>versionNumber</i>

<p>The version described in this document is 2. Version 1 files are produced
by OMNeT++ 3.3 or earlier.

<p>
<h3><a name="sec:result-file-formats:opp:run-declaration"/>27.1.2 Run Declaration<a class="headerlink" href="#sec:result-file-formats:opp:run-declaration" title="Permalink to this headline"></a></h3>

<p>Marks the beginning of a new run in the file. Entries after this line
belong to this run.

<p>Syntax:

<p> <b>run</b> <i>runId</i>

<p>Example:

<pre class="filelisting">
run TokenRing1-0-20080514-18:19:44-3248
</pre>
<p>
Typically there will be one run per file, but this is not mandatory.
In cases when there are more than one run in a file and it is not feasible
to keep the entire file in memory during analysis, the offsets of the <i>run</i>
lines may be indexed for more efficient random access.

<p>The <i>run</i> line may be immediately followed by <i>attribute</i> lines.
Attributes may store generic data like the network name, date/time of running
the simulation, configuration options that took effect for the simulation, etc.

<p>Run attribute names used by OMNeT++ include the following:

<p>Generic attribute names:

<p><ul>
    <li> <b>network</b>: name of the network simulated
    <li> <b>datetime</b>: date/time associated with the run
    <li> <b>processid</b>: the PID of the simulation process
    <li> <b>inifile</b>: the main configuration file
    <li> <b>configname</b>: name of the inifile configuration
    <li> <b>seedset</b>: index of the seed-set use for the simulation
</ul>

<p>Attributes associated with parameter studies (iterated runs):

<p><ul>
    <li> <b>runnumber</b>: the run number within the parameter study
    <li> <b>experiment</b>: experiment label
    <li> <b>measurement</b>: measurement label
    <li> <b>replication</b>: replication label
    <li> <b>repetition</b>: the loop counter for repetitions with different seeds
    <li> <b>iterationvars</b>: string containing the values of the iteration variables
    <li> <b>iterationvarsf</b>: like <tt>iterationvars</tt>, but sanitized for use as part of file names
</ul>

<p>An example run header:

<pre class="filelisting">
run TokenRing1-0-20080514-18:19:44-3248
attr configname TokenRing1
attr datetime 20080514-18:19:44
attr experiment TokenRing1
attr inifile omnetpp.ini
attr iterationvars ""
attr measurement ""
attr network TokenRing
attr processid 3248
attr repetition 0
attr replication #0
attr resultdir results
attr runnumber 0
attr seedset 0
</pre>
<p>

<p><h3><a name="sec:result-file-formats:opp:attributes"/>27.1.3 Attributes<a class="headerlink" href="#sec:result-file-formats:opp:attributes" title="Permalink to this headline"></a></h3>

<p>Contains an attribute for the preceding run, vector, scalar or
statistics object. Attributes can be used for saving arbitrary
extra information for objects; processors should ignore unrecognized
attributes.

<p>Syntax:

<p> <b>attr</b> <i>name</i> <i>value</i>

<p>Example:

<pre class="filelisting">
attr network "largeNet"
</pre>
<p>

<p><h3><a name="sec:result-file-formats:opp:module-parameters"/>27.1.4 Module Parameters<a class="headerlink" href="#sec:result-file-formats:opp:module-parameters" title="Permalink to this headline"></a></h3>

<p>Contains a module parameter value for the given run. This is needed so
that module parameters may be included in the analysis (e.g. to
identify the load for a &#8220;throughput vs load&#8221; plot).

<p>It may not be practical to simply store all parameters of all modules in the
result file, because there may be too many. We assume that NED files are
invariant and do not store parameters defined in them. However, we store
parameter assignments that come from <tt>omnetpp.ini</tt>, in their original
wildcard form (i.e. not expanded) to conserve space. Parameter values
entered interactively by the user are also stored.

<p>When the original NED files are present, it should thus be possible to
reconstruct all parameters for the given simulation.

<p>Syntax:

<p> <b>param</b> <i>parameterNamePattern</i> <i>value</i>

<p>Example:

<pre class="filelisting">
param **.gen.sendIaTime  exponential(0.01)
param **.gen.msgLength   10
param **.fifo.bitsPerSec 1000
</pre>
<p>

<p><h3><a name="sec:result-file-formats:opp:scalar-data"/>27.1.5 Scalar Data<a class="headerlink" href="#sec:result-file-formats:opp:scalar-data" title="Permalink to this headline"></a></h3>

<p>Contains an output scalar value.

<p>Syntax:

<p> <b>scalar</b> <i>moduleName</i> <i>scalarName</i> <i>value</i>

<p>Examples:

<pre class="filelisting">
scalar "net.switchA.relay" "processed frames" 100
</pre>
<p>
Scalar lines may be immediately followed by <i>attribute</i> lines.
OMNeT++ uses the following attributes for scalars:

<p><ul>
    <li> <b>title</b>: suggested title on charts
    <li> <b>unit</b>: measurement unit, e.g. <tt>s</tt> for seconds
</ul>

<p>
<h3><a name="sec:result-file-formats:opp:vector-declaration"/>27.1.6 Vector Declaration<a class="headerlink" href="#sec:result-file-formats:opp:vector-declaration" title="Permalink to this headline"></a></h3>

<p>Defines an output vector.

<p>Syntax:

<p> <b>vector</b> <i>vectorId</i> <i>moduleName</i> <i>vectorName</i>

<p> <b>vector</b> <i>vectorId</i> <i>moduleName</i> <i>vectorName</i> <i>columnSpec</i>

<p>Where <i>columnSpec</i> is a string, encoding the meaning and ordering
the columns of data lines. Characters of the string mean:

<p><ul>
  <li> <b>E</b> event number
  <li> <b>T</b> simulation time
  <li> <b>V</b> vector value
</ul>

<p>Common values are <tt>TV</tt> and <tt>ETV</tt>. The default value is <tt>TV</tt>.

<p>Vector lines may be immediately followed by <i>attribute</i> lines.
OMNeT++ uses the following attributes for vectors:

<p><ul>
    <li> <b>title</b>: suggested vector title on charts
    <li> <b>unit</b>: measurement unit, e.g. <tt>s</tt> for seconds
    <li> <b>enum</b>: symbolic names for values of the vector;
          syntax is <tt>"IDLE=0, BUSY=1, OFF=2"</tt>
    <li> <b>type</b>: data type, one of <tt>int</tt>, <tt>double</tt> and <tt>enum</tt>
    <li> <b>interpolationmode</b>: hint for interpolation mode on the
          chart: <tt>none</tt> (=do not connect the dots), <tt>sample-hold</tt>,
          <tt>backward-sample-hold</tt>, <tt>linear</tt>
    <li> <b>min</b>: minimum value
    <li> <b>max</b>: maximum value
</ul>

<p>
<h3><a name="sec:result-file-formats:opp:vector-data"/>27.1.7 Vector Data<a class="headerlink" href="#sec:result-file-formats:opp:vector-data" title="Permalink to this headline"></a></h3>

<p>Adds a value to an output vector. This is the same as in older output
vector files.

<p>Syntax:

<p> <i>vectorId</i> <i>column1</i> <i>column2</i> ...

<p>Simulation times and event numbers <i>within an output vector</i> are
required to be in increasing order.

<p>Performance note: Data lines belonging to the same output vector may be
written out in clusters (of size roughly a multiple of the disk's
physical block size). Then, since an output vector file is typically
not kept in memory during analysis, indexing the start offsets of these
clusters allows one to read the file and seek in it more efficiently.
This does not require any change or extension to the file format.

<p><h3><a name="sec:result-file-formats:opp:index-header"/>27.1.8 Index Header<a class="headerlink" href="#sec:result-file-formats:opp:index-header" title="Permalink to this headline"></a></h3>

<p>The first line of the index file stores the size and modification date
of the vector file. If the attributes of a vector file differ from
the information stored in the index file, then the IDE automatically
rebuilds the index file.

<p>Syntax:

<p> <b>file</b> <i>filesize</i> <i>modificationDate</i>

<p><h3><a name="sec:result-file-formats:opp:index-data"/>27.1.9 Index Data<a class="headerlink" href="#sec:result-file-formats:opp:index-data" title="Permalink to this headline"></a></h3>

<p>Stores the location and statistics of blocks in the vector file.

<p>Syntax:

<p> <i>vectorId offset length firstEventNo lastEventNo
                       firstSimtime lastSimtime count min max sum sqrsum</i>

<p>where

<p><ul>
    <li><i>offset</i>: the start offset of the block
    <li><i>length</i>: the length of the block
    <li><i>firstEventNo</i>, <i>lastEventNo</i>:
        the event number range of the block (optional)
    <li><i>firstSimtime</i>, <i>lastSimtime</i>:
        the simtime range of the block
    <li><i>count, min, max, sum, sqrsum</i>:
        collected statistics of the values in the block

<p></ul>

<p><h3><a name="sec:result-file-formats:opp:statistics-object"/>27.1.10 Statistics Object<a class="headerlink" href="#sec:result-file-formats:opp:statistics-object" title="Permalink to this headline"></a></h3>

<p>Represents a statistics object.

<p>Syntax:

<p> <b>statistic</b> <i>moduleName</i> <i>statisticName</i>

<p>Example:

<pre class="filelisting">
statistic Aloha.server 	"collision multiplicity"
</pre>
<p>
A <i>statistic</i> line may be followed by <i>field</i> and <i>attribute</i> lines,
and a series of <i>bin</i> lines that represent histogram data.

<p>OMNeT++ uses the following attributes:

<p><ul>
    <li> <b>title</b>: suggested title on charts
    <li> <b>unit</b>: measurement unit, e.g. <tt>s</tt> for seconds
    <li> <b>type</b>: type of the collected values: <tt>int</tt> or <tt>double</tt>;
                         the default is <tt>double</tt>
</ul>

<p>A full example with fields, attributes and histogram bins:

<pre class="filelisting">
statistic Aloha.server 	"collision multiplicity"
field count 13908
field mean 6.8510209951107
field stddev 5.2385484477843
field sum 95284
field sqrsum 1034434
field min 2
field max 65
attr type int
attr unit packets
bin	-INF	0
bin	0	0
bin	1	0
bin	2	2254
bin	3	2047
bin	4	1586
bin	5	1428
bin	6	1101
bin	7	952
bin	8	785
...
bin	52	2
</pre>
<p>

<p><h3><a name="sec:result-file-formats:opp:field"/>27.1.11 Field<a class="headerlink" href="#sec:result-file-formats:opp:field" title="Permalink to this headline"></a></h3>

<p>Represents a field in a statistics object.

<p>Syntax:

<p> <b>field</b> <i>fieldName</i> <i>value</i>

<p>Example:

<pre class="filelisting">
field sum 95284
</pre>
<p>
Fields:

<p><ul>
    <li> <b>count</b>: observation count
    <li> <b>mean</b>: mean of the observations
    <li> <b>stddev</b>: standard deviation
    <li> <b>sum</b>: sum of the observations
    <li> <b>sqrsum</b>: sum of the squared observations
    <li> <b>min</b>: minimum of the observations
    <li> <b>max</b>: maximum of the observations
</ul>

<p>For weighted statistics, additionally the following fields may be recorded:

<p><ul>
    <li> <b>weights</b>: sum of the weights
    <li> <b>weightedSum</b>: the weighted sum of the observations
    <li> <b>sqrSumWeights</b>:  sum of the squared weights
    <li> <b>weightedSqrSum</b>: weighted sum of the squared observations
</ul>

<p>
<h3><a name="sec:result-file-formats:opp:histogram-bin"/>27.1.12 Histogram Bin<a class="headerlink" href="#sec:result-file-formats:opp:histogram-bin" title="Permalink to this headline"></a></h3>

<p>Represents a bin in a histogram object.

<p>Syntax:

<p> <b>bin</b> <i>binLowerBound</i> <i>value</i>

<p>Histogram name and module is defined on the <b>statistic</b> line,
which is followed by several <b>bin</b> lines to contain data. Any
non-<b>bin</b> line marks the end of the histogram data.

<p>The <i>binLowerBound</i> column of <b>bin</b> lines represent the
(inclusive) lower bound of the given histogram cell. <b>Bin</b> lines are in
increasing <i>binLowerBound</i> order.

<p>The <i>value</i> column of a <b>bin</b> line represents the observation
count in the given cell: <i>value k</i> is the number of observations
greater or equal to <i>binLowerBound k</i>, but smaller than
<i>binLowerBound k+1</i>. <i>Value</i> is not necessarily an
integer, because the <a href="../api/classomnetpp_1_1cKSplit.html">cKSplit</a> and <a href="../api/classomnetpp_1_1cPSquare.html">cPSquare</a> algorithms produce
non-integer estimates. The first <b>bin</b> line is the underflow
cell, and the last <b>bin</b> line is the overflow cell.

<p>Example:

<pre class="filelisting">
bin -INF  0
bin 0 4
bin 2 6
bin 4 2
bin 6 1
</pre>
<p>

<p><h2><a name="cha:result-file-formats:sqlite"/>27.2 SQLite Result Files<a class="headerlink" href="#cha:result-file-formats:sqlite" title="Permalink to this headline"></a></h2>

<p>The database structure in SQLite result files is created with the
following SQL statements. Scalar and vector files are identical in
structure, they only differ in data.

<pre class="filelisting">
CREATE TABLE run 
( 
    runId       INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, 
    runName     TEXT NOT NULL, 
    simtimeExp  INTEGER NOT NULL 
); 

CREATE TABLE runattr 
( 
    runId       INTEGER NOT NULL REFERENCES run(runId) ON DELETE CASCADE, 
    attrName    TEXT NOT NULL, 
    attrValue   TEXT NOT NULL 
); 

CREATE TABLE runparam 
( 
    runId       INTEGER NOT NULL REFERENCES run(runId) ON DELETE CASCADE, 
    parName     TEXT NOT NULL, 
    parValue    TEXT NOT NULL 
); 

CREATE TABLE scalar 
( 
    scalarId      INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, 
    runId         INTEGER NOT NULL REFERENCES run(runId) ON DELETE CASCADE, 
    moduleName    TEXT NOT NULL, 
    scalarName    TEXT NOT NULL, 
    scalarValue   REAL
); 

CREATE TABLE scalarattr 
( 
    scalarId      INTEGER NOT NULL REFERENCES scalar(scalarId) ON DELETE CASCADE, 
    attrName      TEXT NOT NULL, 
    attrValue     TEXT NOT NULL 
); 

CREATE TABLE statistic 
( 
    statId        INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, 
    runId         INTEGER NOT NULL REFERENCES run(runId) ON DELETE CASCADE, 
    moduleName    TEXT NOT NULL, 
    statName      TEXT NOT NULL, 
    statCount     INTEGER NOT NULL, 
    statMean      REAL, 
    statStddev    REAL, 
    statSum       REAL, 
    statSqrsum    REAL, 
    statMin       REAL, 
    statMax       REAL, 
    statWeights          REAL, 
    statWeightedSum      REAL, 
    statSqrSumWeights    REAL, 
    statWeightedSqrSum   REAL 
); 

CREATE TABLE histattr 
( 
    statId        INTEGER NOT NULL REFERENCES statistic(statId) ON DELETE CASCADE, 
    attrName      TEXT NOT NULL, 
    attrValue     TEXT NOT NULL 
); 

CREATE TABLE histbin 
( 
    statId        INTEGER NOT NULL REFERENCES statistic(statId) ON DELETE CASCADE, 
    baseValue     NUMERIC NOT NULL, 
    cellValue     INTEGER NOT NULL 
); 

CREATE TABLE vector 
( 
    vectorId        INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, 
    runId           INTEGER  NOT NULL REFERENCES run(runId) ON DELETE CASCADE, 
    moduleName      TEXT NOT NULL, 
    vectorName      TEXT NOT NULL, 
    vectorCount     INTEGER,
    vectorMin       REAL, 
    vectorMax       REAL, 
    vectorSum       REAL, 
    vectorSumSqr    REAL, 
    startEventNum   INTEGER, 
    endEventNum     INTEGER, 
    startSimtimeRaw INTEGER, 
    endSimtimeRaw   INTEGER 

); 

CREATE TABLE vectorattr 
( 
    vectorId      INTEGER NOT NULL REFERENCES vector(vectorId) ON DELETE CASCADE, 
    attrName      TEXT NOT NULL, 
    attrValue     TEXT NOT NULL 
); 

CREATE TABLE vectordata 
( 
    vectorId      INTEGER NOT NULL REFERENCES vector(vectorId) ON DELETE CASCADE, 
    eventNumber   INTEGER NOT NULL, 
    simtimeRaw    INTEGER NOT NULL, 
    value         NUMERIC NOT NULL 
); 
</pre>
<p>
Notes:

<p><ol>
  <li> To preserve precision, simulation time is stored in raw form, i.e. 
        the underlying <tt>int64</tt> is stored as an integer. To get the real
        value, they have to be multiplied by 10 to the power of the simtime
        exponent, which is global for the simulation run. The simtime        
        exponent is stored  in the <tt>simtimeExp</tt> column of the <tt>run</tt>
        table.
  <li> Some columns like vector statistics are not marked as <tt>NOT NULL</tt>,
        because of technical reasons: their values are not available at the
        time of the insertion, only at the end of the simulation.
  <li> <tt>REAL</tt> columns are not marked as <tt>NOT NULL</tt>, because
        SQLite stores floating-point NaN values as <tt>NULL</tt>s.
</ol>

<p><ul class="caution"><b>CAUTION</b><br>
SQLite support in OMNeT++ is currently experimental, so the above database
structure may change in future releases.
</ul>

<hr class='pgbr'><h1><a name="cha:eventlog-file-format"/>28 Appendix J&#58; Eventlog File Format<a class="headerlink" href="#cha:eventlog-file-format" title="Permalink to this headline"></a></h1>

<p>This appendix documents the format of the eventlog file. Eventlog
files are written by the simulation (when enabled). Everything
that happens during the simulation is recorded into the file,
  <br><ul><font size=-1>[With certain granularity of course, and subject to
  filters that were active during simulation]</font></ul>
so the file can later be used to reproduce the history of the
simulation on a sequence chart, or in some other form.

<p>The file is a line-oriented text file. Blank lines and lines beginning
with "#" (comments) will be ignored. Other lines begin with an
<i>entry identifier</i> like <tt>E</tt> for <i>Event</i> or
<tt>BS</tt> for <i>BeginSend</i>, followed by <i>attribute-identifier</i>
and <i>value</i> pairs. One exception is debug output
(recorded from <tt>EV&lt;&lt;...</tt> statements), which are represented
by lines that begin with a hyphen, and continue with the actual text.

<p>The grammar of the eventlog file is the following:

<pre class="verbatim">
&lt;file&gt; ::= &lt;line&gt;*
&lt;line&gt; ::= &lt;empty-line&gt; | &lt;user-log-message&gt; | &lt;event-log-entry&gt;
&lt;empty-line&gt; ::= CR LF
&lt;user-log-message&gt; ::= - SPACE &lt;text&gt; CR LF
&lt;event-log-entry&gt; ::= &lt;event-log-entry-type&gt; SPACE &lt;parameters&gt; CR LF
&lt;event-log-entry-type&gt; ::= SB | SE | BU | MB | ME | MC | MD | MR | GC | GD |
                           CC | CD | CS | MS | CE | BS | ES | SD | SH | DM | E
&lt;parameters&gt; ::= (&lt;parameter&gt;)*
&lt;parameter&gt; ::= &lt;name&gt; SPACE &lt;value&gt;
&lt;name&gt; ::= &lt;text&gt;
&lt;value&gt; ::= &lt;boolean&gt; | &lt;integer&gt; | &lt;text&gt; | &lt;quoted-text&gt;
</pre>
<p>
The eventlog file must also fulfill the following requirements:
<ul>
   <li> simulation events are in increasing event number and simulation time order
</ul>

<p>Here is a fragment of an existing eventlog file as an example:

<pre class="filelisting">
E # 14 t 1.018454036455 m 8 ce 9 msg 6
BS id 6 tid 6 c <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> n send/endTx pe 14
ES t 4.840247053855
MS id 8 d t=TRANSMIT,,#808000;i=device/pc_s
MS id 8 d t=,,#808000;i=device/pc_s

E # 15 t 1.025727827674 m 2 ce 13 msg 25
- another frame arrived while receiving -- collision!
CE id 0 pe 12
BS id 0 tid 0 c <a href="../api/classomnetpp_1_1cMessage.html">cMessage</a> n end-reception pe 15
ES t 1.12489449434
BU id 2 txt "Collision! (3 frames)"
DM id 25 pe 15
</pre>
<p>
<h2><a name="sec:eventlog-file-format:entry-types"/>28.1 Supported Entry Types and Their Attributes<a class="headerlink" href="#sec:eventlog-file-format:entry-types" title="Permalink to this headline"></a></h2>

<p>The following entries and attributes are supported in the eventlog file:


<b>SB</b> <i>(SimulationBegin)</i>: mandatory first line of an eventlog file

<p><ul>
  <li> <b>v</b> (<i>version</i>, int): OMNeT++ version, e.g. 0x401 (=1025) is release 4.1
  <li> <b>rid</b> (<i>runId</i>, string): identifies the simulation run
  <li> <b>b</b> (<i>keyframeBlockSize</i>, int): the distance between keyframes in event numbers
</ul>

<p><b>SE</b> <i>(SimulationEnd)</i>: optional last line of an eventlog file

<p><ul>
  <li> <b>e</b> (<i>isError</i>, bool): specifies if the simulation terminated due to an error
  <li> <b>c</b> (<i>resultCode</i>, int): the error code in case of an error, otherwise the normal result code
  <li> <b>m</b> (<i>message</i>, string): human readable description
</ul>

<p><b>BU</b> <i>(Bubble)</i>: display a bubble message

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the module which printed the bubble message
  <li> <b>txt</b> (<i>text</i>, string): displayed message text
</ul>

<p><b>MB</b> <i>(ModuleMethodBegin)</i>: beginning of a call to another module

<p><ul>
  <li> <b>sm</b> (<i>fromModuleId</i>, int): id of the caller module
  <li> <b>tm</b> (<i>toModuleId</i>, int): id of the module being called
  <li> <b>m</b> (<i>method</i>, string): C++ method name
</ul>

<p><b>ME</b> <i>(ModuleMethodEnd)</i>: end of a call to another module

<p><ul>
  <li> no parameters
</ul>

<p><b>MC</b> <i>(ModuleCreated)</i>: creating a module

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the new module
  <li> <b>c</b> (<i>moduleClassName</i>, string): C++ class name of the module
  <li> <b>t</b> (<i>nedTypeName</i>, string): fully qualified NED type name
  <li> <b>pid</b> (<i>parentModuleId</i>, int): id of the parent module
  <li> <b>n</b> (<i>fullName</i>, string): full dotted hierarchical module name
  <li> <b>cm</b> (<i>compoundModule</i>, bool): whether module is a simple or compound module
</ul>

<p><b>MD</b> <i>(ModuleDeleted)</i>: deleting a module

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the module being deleted
</ul>

<p><b>GC</b> <i>(GateCreated)</i>: gate created

<p><ul>
  <li> <b>m</b> (<i>moduleId</i>, int): module in which the gate was created
  <li> <b>g</b> (<i>gateId</i>, int): id of the new gate
  <li> <b>n</b> (<i>name</i>, string): gate name
  <li> <b>i</b> (<i>index</i>, int): gate index if vector, -1 otherwise
  <li> <b>o</b> (<i>isOutput</i>, bool): whether the gate is input or output
</ul>

<p><b>GD</b> <i>(GateDeleted)</i>: gate deleted

<p><ul>
  <li> <b>m</b> (<i>moduleId</i>, int): module in which the gate was created
  <li> <b>g</b> (<i>gateId</i>, int): id of the deleted gate
</ul>

<p><b>CC</b> <i>(ConnectionCreated)</i>: creating a connection

<p><ul>
  <li> <b>sm</b> (<i>sourceModuleId</i>, int): id of the source module identifying the connection
  <li> <b>sg</b> (<i>sourceGateId</i>, int): id of the gate at the source module identifying the connection
  <li> <b>dm</b> (<i>destModuleId</i>, int): id of the destination module
  <li> <b>dg</b> (<i>destGateId</i>, int): id of the gate at the destination module
</ul>

<p><b>CD</b> <i>(ConnectionDeleted)</i>: deleting a connection

<p><ul>
  <li> <b>sm</b> (<i>sourceModuleId</i>, int): id of the source module identifying the connection
  <li> <b>sg</b> (<i>sourceGateId</i>, int): id of the gate at the source module identifying the connection
</ul>

<p><b>CS</b> <i>(ConnectionDisplayStringChanged)</i>: a connection display string change

<p><ul>
  <li> <b>sm</b> (<i>sourceModuleId</i>, int): id of the source module identifying the connection
  <li> <b>sg</b> (<i>sourceGateId</i>, int): id of the gate at the source module identifying the connection
  <li> <b>d</b> (<i>displayString</i>, string): the new display string
</ul>

<p><b>MS</b> <i>(ModuleDisplayStringChanged)</i>: a module display string change

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the module
  <li> <b>d</b> (<i>displayString</i>, string): the new display string
</ul>

<p><b>E</b> <i>(Event)</i>: an event that is processing a message

<p><ul>
  <li> <b>#</b> (<i>eventNumber</i>, eventnumber_t): unique event number
  <li> <b>t</b> (<i>simulationTime</i>, simtime_t): simulation time when the event occurred
  <li> <b>m</b> (<i>moduleId</i>, int): id of the processing module
  <li> <b>ce</b> (<i>causeEventNumber</i>, eventnumber_t): event number from which the message being processed was sent, or -1 if the message was sent from initialize
  <li> <b>msg</b> (<i>messageId</i>, long): lifetime-unique id of the message being processed
  <li> <b>f</b> (<i>fingerprints</i>, string): current simulation fingerprints
</ul>

<p><b>KF</b> <i>(Keyframe)</i>: 

<p><ul>
  <li> <b>p</b> (<i>previousKeyframeFileOffset</i>, int64_t): file offset of the previous keyframe entry
  <li> <b>c</b> (<i>consequenceLookaheadLimits</i>, string): consequence lookahead data
  <li> <b>s</b> (<i>simulationStateEntries</i>, string): simulation state data
</ul>

<p><b>abstract</b> <i>(Message)</i>: base class for entries referring to a message

<p><ul>
  <li> <b>id</b> (<i>messageId</i>, long): lifetime-unique id of the message
  <li> <b>tid</b> (<i>messageTreeId</i>, long): id of the message inherited by dup
  <li> <b>eid</b> (<i>messageEncapsulationId</i>, long): id of the message inherited by encapsulation
  <li> <b>etid</b> (<i>messageEncapsulationTreeId</i>, long): id of the message inherited by both dup and encapsulation
  <li> <b>c</b> (<i>messageClassName</i>, string): C++ class name of the message
  <li> <b>n</b> (<i>messageName</i>, string): message name
  <li> <b>k</b> (<i>messageKind</i>, short): message kind
  <li> <b>p</b> (<i>messagePriority</i>, short): message priority
  <li> <b>l</b> (<i>messageLength</i>, int64_t): message length in bits
  <li> <b>er</b> (<i>hasBitError</i>, bool): true indicates that the message has bit errors
  <li> <b>d</b> (<i>detail</i>, string): detailed information of message content when recording message data is turned on
  <li> <b>pe</b> (<i>previousEventNumber</i>, eventnumber_t): event number from which the message being cloned was sent, or -1 if the message was sent from initialize
</ul>

<p><b>CE</b> <i>(CancelEvent)</i>: canceling an event caused by a self message

<p><ul>
  <li> no parameters
</ul>

<p><b>BS</b> <i>(BeginSend)</i>: beginning to send a message

<p><ul>
  <li> no parameters
</ul>

<p><b>ES</b> <i>(EndSend)</i>: prediction of the arrival of a message

<p><ul>
  <li> <b>t</b> (<i>arrivalTime</i>, simtime_t): when the message will arrive to its destination module
  <li> <b>is</b> (<i>isReceptionStart</i>, bool): true indicates the message arrives with the first bit
</ul>

<p><b>SD</b> <i>(SendDirect)</i>: sending a message directly to a destination gate

<p><ul>
  <li> <b>sm</b> (<i>senderModuleId</i>, int): id of the source module from which the message is being sent
  <li> <b>dm</b> (<i>destModuleId</i>, int): id of the destination module to which the message is being sent
  <li> <b>dg</b> (<i>destGateId</i>, int): id of the gate at the destination module to which the message is being sent
  <li> <b>pd</b> (<i>propagationDelay</i>, simtime_t): propagation delay as the message is propagated through the connection
  <li> <b>td</b> (<i>transmissionDelay</i>, simtime_t): transmission duration as the whole message is sent from the source gate
</ul>

<p><b>SH</b> <i>(SendHop)</i>: sending a message through a connection identified by its source module and gate id

<p><ul>
  <li> <b>sm</b> (<i>senderModuleId</i>, int): id of the source module from which the message is being sent
  <li> <b>sg</b> (<i>senderGateId</i>, int): id of the gate at the source module from which the message is being sent
  <li> <b>pd</b> (<i>propagationDelay</i>, simtime_t): propagation delay as the message is propagated through the connection
  <li> <b>td</b> (<i>transmissionDelay</i>, simtime_t): transmission duration as the whole message is sent from the source gate
  <li> <b>del</b> (<i>discard</i>, bool): whether the channel has discarded the message
</ul>

<p><b>CM</b> <i>(CreateMessage)</i>: creating a message

<p><ul>
  <li> no parameters
</ul>

<p><b>CL</b> <i>(CloneMessage)</i>: cloning a message either via the copy constructor or dup

<p><ul>
  <li> <b>cid</b> (<i>cloneId</i>, long): lifetime-unique id of the clone
</ul>

<p><b>DM</b> <i>(DeleteMessage)</i>: deleting a message

<p><ul>
  <li> no parameters
</ul>


</div>
</body>
</html>

